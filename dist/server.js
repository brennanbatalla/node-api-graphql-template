/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/any-promise/index.js":
/*!*******************************************!*\
  !*** ./node_modules/any-promise/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./register */ "./node_modules/any-promise/register.js")().Promise


/***/ }),

/***/ "./node_modules/any-promise/loader.js":
/*!********************************************!*\
  !*** ./node_modules/any-promise/loader.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";

    // global key for user preferred registration
var REGISTRATION_KEY = '@@any-promise/REGISTRATION',
    // Prior registration (preferred or detected)
    registered = null

/**
 * Registers the given implementation.  An implementation must
 * be registered prior to any call to `require("any-promise")`,
 * typically on application load.
 *
 * If called with no arguments, will return registration in
 * following priority:
 *
 * For Node.js:
 *
 * 1. Previous registration
 * 2. global.Promise if node.js version >= 0.12
 * 3. Auto detected promise based on first sucessful require of
 *    known promise libraries. Note this is a last resort, as the
 *    loaded library is non-deterministic. node.js >= 0.12 will
 *    always use global.Promise over this priority list.
 * 4. Throws error.
 *
 * For Browser:
 *
 * 1. Previous registration
 * 2. window.Promise
 * 3. Throws error.
 *
 * Options:
 *
 * Promise: Desired Promise constructor
 * global: Boolean - Should the registration be cached in a global variable to
 * allow cross dependency/bundle registration?  (default true)
 */
module.exports = function(root, loadImplementation){
  return function register(implementation, opts){
    implementation = implementation || null
    opts = opts || {}
    // global registration unless explicitly  {global: false} in options (default true)
    var registerGlobal = opts.global !== false;

    // load any previous global registration
    if(registered === null && registerGlobal){
      registered = root[REGISTRATION_KEY] || null
    }

    if(registered !== null
        && implementation !== null
        && registered.implementation !== implementation){
      // Throw error if attempting to redefine implementation
      throw new Error('any-promise already defined as "'+registered.implementation+
        '".  You can only register an implementation before the first '+
        ' call to require("any-promise") and an implementation cannot be changed')
    }

    if(registered === null){
      // use provided implementation
      if(implementation !== null && typeof opts.Promise !== 'undefined'){
        registered = {
          Promise: opts.Promise,
          implementation: implementation
        }
      } else {
        // require implementation if implementation is specified but not provided
        registered = loadImplementation(implementation)
      }

      if(registerGlobal){
        // register preference globally in case multiple installations
        root[REGISTRATION_KEY] = registered
      }
    }

    return registered
  }
}


/***/ }),

/***/ "./node_modules/any-promise/register.js":
/*!**********************************************!*\
  !*** ./node_modules/any-promise/register.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./loader */ "./node_modules/any-promise/loader.js")(global, loadImplementation);

/**
 * Node.js version of loadImplementation.
 *
 * Requires the given implementation and returns the registration
 * containing {Promise, implementation}
 *
 * If implementation is undefined or global.Promise, loads it
 * Otherwise uses require
 */
function loadImplementation(implementation){
  var impl = null

  if(shouldPreferGlobalPromise(implementation)){
    // if no implementation or env specified use global.Promise
    impl = {
      Promise: global.Promise,
      implementation: 'global.Promise'
    }
  } else if(implementation){
    // if implementation specified, require it
    var lib = __webpack_require__("./node_modules/any-promise sync recursive")(implementation)
    impl = {
      Promise: lib.Promise || lib,
      implementation: implementation
    }
  } else {
    // try to auto detect implementation. This is non-deterministic
    // and should prefer other branches, but this is our last chance
    // to load something without throwing error
    impl = tryAutoDetect()
  }

  if(impl === null){
    throw new Error('Cannot find any-promise implementation nor'+
      ' global.Promise. You must install polyfill or call'+
      ' require("any-promise/register") with your preferred'+
      ' implementation, e.g. require("any-promise/register/bluebird")'+
      ' on application load prior to any require("any-promise").')
  }

  return impl
}

/**
 * Determines if the global.Promise should be preferred if an implementation
 * has not been registered.
 */
function shouldPreferGlobalPromise(implementation){
  if(implementation){
    return implementation === 'global.Promise'
  } else if(typeof global.Promise !== 'undefined'){
    // Load global promise if implementation not specified
    // Versions < 0.11 did not have global Promise
    // Do not use for version < 0.12 as version 0.11 contained buggy versions
    var version = (/v(\d+)\.(\d+)\.(\d+)/).exec(process.version)
    return !(version && +version[1] == 0 && +version[2] < 12)
  }

  // do not have global.Promise or another implementation was specified
  return false
}

/**
 * Look for common libs as last resort there is no guarantee that
 * this will return a desired implementation or even be deterministic.
 * The priority is also nearly arbitrary. We are only doing this
 * for older versions of Node.js <0.12 that do not have a reasonable
 * global.Promise implementation and we the user has not registered
 * the preference. This preserves the behavior of any-promise <= 0.1
 * and may be deprecated or removed in the future
 */
function tryAutoDetect(){
  var libs = [
      "es6-promise",
      "promise",
      "native-promise-only",
      "bluebird",
      "rsvp",
      "when",
      "q",
      "pinkie",
      "lie",
      "vow"]
  var i = 0, len = libs.length
  for(; i < len; i++){
    try {
      return loadImplementation(libs[i])
    } catch(e){}
  }
  return null
}


/***/ }),

/***/ "./node_modules/any-promise sync recursive":
/*!****************************************!*\
  !*** ./node_modules/any-promise/ sync ***!
  \****************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/any-promise sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/dottie/dottie.js":
/*!***************************************!*\
  !*** ./node_modules/dottie/dottie.js ***!
  \***************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(undefined) {
  var root = this;

  // Weird IE shit, objects do not have hasOwn, but the prototype does...
  var hasOwnProp = Object.prototype.hasOwnProperty;

  var reverseDupArray = function (array) {
    var result = new Array(array.length);
    var index  = array.length;
    var arrayMaxIndex = index - 1;

    while (index--) {
      result[arrayMaxIndex - index] = array[index];
    }

    return result;
  };

  var Dottie = function() {
    var args = Array.prototype.slice.call(arguments);

    if (args.length == 2) {
      return Dottie.find.apply(this, args);
    }
    return Dottie.transform.apply(this, args);
  };

  // Legacy syntax, changed syntax to have get/set be similar in arg order
  Dottie.find = function(path, object) {
    return Dottie.get(object, path);
  };

  // Dottie memoization flag
  Dottie.memoizePath = true;
  var memoized = {};

  // Traverse object according to path, return value if found - Return undefined if destination is unreachable
  Dottie.get = function(object, path, defaultVal) {
    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {
        return defaultVal;
    }

    var names;

    if (typeof path === "string") {
      if (Dottie.memoizePath) {
        if (memoized[path]) {
          names = memoized[path].slice(0);
        } else {
          names = path.split('.').reverse();
          memoized[path] = names.slice(0);
        }
      } else {
        names = path.split('.').reverse();
      }
    } else if (Array.isArray(path)) {
      names = reverseDupArray(path);
    }

    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);

    // Handle cases where accessing a childprop of a null value
    if (object === null && names.length) object = undefined;

    return (object === undefined ? defaultVal : object);
  };

  Dottie.exists = function(object, path) {
    return Dottie.get(object, path) !== undefined;
  };

  // Set nested value
  Dottie.set = function(object, path, value, options) {
    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;

    if (typeof current !== 'object') {
        throw new Error('Parent is not an object.');
    }

    for (var index = 0; index < length; index++) {
      piece = pieces[index];

      // Create namespace (object) where none exists.
      // If `force === true`, bruteforce the path without throwing errors.
      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || (typeof current[piece] !== 'object' && options && options.force === true)) {
        current[piece] = {};
      }

      if (index == (length - 1)) {
        // Set final value
        current[piece] = value;
      } else {
        // We do not overwrite existing path pieces by default
        if (typeof current[piece] !== 'object') {
          throw new Error('Target key "' + piece + '" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');
        }

        // Traverse next in path
        current = current[piece];
      }
    }

    // Is there any case when this is relevant? It's also the last line in the above for-loop
    current[piece] = value;
  };

  // Set default nested value
  Dottie['default'] = function(object, path, value) {
    if (Dottie.get(object, path) === undefined) {
      Dottie.set(object, path, value);
    }
  };

  // Transform unnested object with .-seperated keys into a nested object.
  Dottie.transform = function Dottie$transformfunction(object, options) {
    if (Array.isArray(object)) {
      return object.map(function(o) {
        return Dottie.transform(o, options);
      });
    }

    options = options || {};
    options.delimiter = options.delimiter || '.';

    var pieces
      , piecesLength
      , piece
      , current
      , transformed = {}
      , key
      , keys = Object.keys(object)
      , length = keys.length
      , i;

    for (i = 0; i < length; i++) {
      key = keys[i];

      if (key.indexOf(options.delimiter) !== -1) {
        pieces = key.split(options.delimiter);
        piecesLength = pieces.length;
        current = transformed;

        for (var index = 0; index < piecesLength; index++) {
          piece = pieces[index];
          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {
            current[piece] = {};
          }

          if (index == (piecesLength - 1)) {
            current[piece] = object[key];
          }

          current = current[piece];
          if (current === null) {
            break;
          }
        }
      } else {
        transformed[key] = object[key];
      }
    }

    return transformed;
  };

  Dottie.flatten = function(object, seperator) {
    if (typeof seperator === "undefined") seperator = '.';
    var flattened = {}
      , current
      , nested;

    for (var key in object) {
      if (hasOwnProp.call(object, key)) {
        current = object[key];
        if (Object.prototype.toString.call(current) === "[object Object]") {
          nested = Dottie.flatten(current, seperator);

          for (var _key in nested) {
            flattened[key+seperator+_key] = nested[_key];
          }
        } else {
          flattened[key] = current;
        }
      }
    }

    return flattened;
  };

  Dottie.paths = function(object, prefixes) {
    var paths = [];
    var value;
    var key;

    prefixes = prefixes || [];

    if (typeof object === 'object') {
      for (key in object) {
        value = object[key];

        if (typeof value === 'object' && value !== null) {
          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));
        } else {
          paths.push(prefixes.concat(key).join('.'));
        }
      }
    } else {
      throw new Error('Paths was called with non-object argument.');
    }

    return paths;
  };

  if ( true && module.exports) {
    exports = module.exports = Dottie;
  } else {
    root['Dottie'] = Dottie;
    root['Dot'] = Dottie; //BC

    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Dottie; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "./node_modules/inflection/lib/inflection.js":
/*!***************************************************!*\
  !*** ./node_modules/inflection/lib/inflection.js ***!
  \***************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root, factory ){
  if( true ){
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }else {}
}( this, function (){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    // 'access',
    'accommodation',
    'adulthood',
    'advertising',
    'advice',
    'aggression',
    'aid',
    'air',
    'aircraft',
    'alcohol',
    'anger',
    'applause',
    'arithmetic',
    // 'art',
    'assistance',
    'athletics',
    // 'attention',

    'bacon',
    'baggage',
    // 'ballet',
    // 'beauty',
    'beef',
    // 'beer',
    // 'behavior',
    'biology',
    // 'billiards',
    'blood',
    'botany',
    // 'bowels',
    'bread',
    // 'business',
    'butter',

    'carbon',
    'cardboard',
    'cash',
    'chalk',
    'chaos',
    'chess',
    'crossroads',
    'countryside',

    // 'damage',
    'dancing',
    // 'danger',
    'deer',
    // 'delight',
    // 'dessert',
    'dignity',
    'dirt',
    // 'distribution',
    'dust',

    'economics',
    'education',
    'electricity',
    // 'employment',
    // 'energy',
    'engineering',
    'enjoyment',
    // 'entertainment',
    'envy',
    'equipment',
    'ethics',
    'evidence',
    'evolution',

    // 'failure',
    // 'faith',
    'fame',
    'fiction',
    // 'fish',
    'flour',
    'flu',
    'food',
    // 'freedom',
    // 'fruit',
    'fuel',
    'fun',
    // 'funeral',
    'furniture',

    'gallows',
    'garbage',
    'garlic',
    // 'gas',
    'genetics',
    // 'glass',
    'gold',
    'golf',
    'gossip',
    'grammar',
    // 'grass',
    'gratitude',
    'grief',
    // 'ground',
    'guilt',
    'gymnastics',

    // 'hair',
    'happiness',
    'hardware',
    'harm',
    'hate',
    'hatred',
    'health',
    'heat',
    // 'height',
    'help',
    'homework',
    'honesty',
    'honey',
    'hospitality',
    'housework',
    'humour',
    'hunger',
    'hydrogen',

    'ice',
    'importance',
    'inflation',
    'information',
    // 'injustice',
    'innocence',
    // 'intelligence',
    'iron',
    'irony',

    'jam',
    // 'jealousy',
    // 'jelly',
    'jewelry',
    // 'joy',
    'judo',
    // 'juice',
    // 'justice',

    'karate',
    // 'kindness',
    'knowledge',

    // 'labour',
    'lack',
    // 'land',
    'laughter',
    'lava',
    'leather',
    'leisure',
    'lightning',
    'linguine',
    'linguini',
    'linguistics',
    'literature',
    'litter',
    'livestock',
    'logic',
    'loneliness',
    // 'love',
    'luck',
    'luggage',

    'macaroni',
    'machinery',
    'magic',
    // 'mail',
    'management',
    'mankind',
    'marble',
    'mathematics',
    'mayonnaise',
    'measles',
    // 'meat',
    // 'metal',
    'methane',
    'milk',
    'minus',
    'money',
    // 'moose',
    'mud',
    'music',
    'mumps',

    'nature',
    'news',
    'nitrogen',
    'nonsense',
    'nurture',
    'nutrition',

    'obedience',
    'obesity',
    // 'oil',
    'oxygen',

    // 'paper',
    // 'passion',
    'pasta',
    'patience',
    // 'permission',
    'physics',
    'poetry',
    'pollution',
    'poverty',
    // 'power',
    'pride',
    // 'production',
    // 'progress',
    // 'pronunciation',
    'psychology',
    'publicity',
    'punctuation',

    // 'quality',
    // 'quantity',
    'quartz',

    'racism',
    // 'rain',
    // 'recreation',
    'relaxation',
    'reliability',
    'research',
    'respect',
    'revenge',
    'rice',
    'rubbish',
    'rum',

    'safety',
    // 'salad',
    // 'salt',
    // 'sand',
    // 'satire',
    'scenery',
    'seafood',
    'seaside',
    'series',
    'shame',
    'sheep',
    'shopping',
    // 'silence',
    'sleep',
    // 'slang'
    'smoke',
    'smoking',
    'snow',
    'soap',
    'software',
    'soil',
    // 'sorrow',
    // 'soup',
    'spaghetti',
    // 'speed',
    'species',
    // 'spelling',
    // 'sport',
    'steam',
    // 'strength',
    'stuff',
    'stupidity',
    // 'success',
    // 'sugar',
    'sunshine',
    'symmetry',

    // 'tea',
    'tennis',
    'thirst',
    'thunder',
    'timber',
    // 'time',
    // 'toast',
    // 'tolerance',
    // 'trade',
    'traffic',
    'transportation',
    // 'travel',
    'trust',

    // 'understanding',
    'underwear',
    'unemployment',
    'unity',
    // 'usage',

    'validity',
    'veal',
    'vegetation',
    'vegetarianism',
    'vengeance',
    'violence',
    // 'vision',
    'vitality',

    'warmth',
    // 'water',
    'wealth',
    'weather',
    // 'weight',
    'welfare',
    'wheat',
    // 'whiskey',
    // 'width',
    'wildlife',
    // 'wine',
    'wisdom',
    // 'wood',
    // 'wool',
    // 'work',

    // 'yeast',
    'yoga',

    'zinc',
    'zoology'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */

  var regex = {
    plural : {
      men       : new RegExp( '^(m|wom)en$'                    , 'gi' ),
      people    : new RegExp( '(pe)ople$'                      , 'gi' ),
      children  : new RegExp( '(child)ren$'                    , 'gi' ),
      tia       : new RegExp( '([ti])a$'                       , 'gi' ),
      analyses  : new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ),
      hives     : new RegExp( '(hi|ti)ves$'                    , 'gi' ),
      curves    : new RegExp( '(curve)s$'                      , 'gi' ),
      lrves     : new RegExp( '([lr])ves$'                     , 'gi' ),
      aves      : new RegExp( '([a])ves$'                      , 'gi' ),
      foves     : new RegExp( '([^fo])ves$'                    , 'gi' ),
      movies    : new RegExp( '(m)ovies$'                      , 'gi' ),
      aeiouyies : new RegExp( '([^aeiouy]|qu)ies$'             , 'gi' ),
      series    : new RegExp( '(s)eries$'                      , 'gi' ),
      xes       : new RegExp( '(x|ch|ss|sh)es$'                , 'gi' ),
      mice      : new RegExp( '([m|l])ice$'                    , 'gi' ),
      buses     : new RegExp( '(bus)es$'                       , 'gi' ),
      oes       : new RegExp( '(o)es$'                         , 'gi' ),
      shoes     : new RegExp( '(shoe)s$'                       , 'gi' ),
      crises    : new RegExp( '(cris|ax|test)es$'              , 'gi' ),
      octopi    : new RegExp( '(octop|vir)i$'                  , 'gi' ),
      aliases   : new RegExp( '(alias|canvas|status|campus)es$', 'gi' ),
      summonses : new RegExp( '^(summons)es$'                  , 'gi' ),
      oxen      : new RegExp( '^(ox)en'                        , 'gi' ),
      matrices  : new RegExp( '(matr)ices$'                    , 'gi' ),
      vertices  : new RegExp( '(vert|ind)ices$'                , 'gi' ),
      feet      : new RegExp( '^feet$'                         , 'gi' ),
      teeth     : new RegExp( '^teeth$'                        , 'gi' ),
      geese     : new RegExp( '^geese$'                        , 'gi' ),
      quizzes   : new RegExp( '(quiz)zes$'                     , 'gi' ),
      whereases : new RegExp( '^(whereas)es$'                  , 'gi' ),
      criteria  : new RegExp( '^(criteri)a$'                   , 'gi' ),
      genera    : new RegExp( '^genera$'                       , 'gi' ),
      ss        : new RegExp( 'ss$'                            , 'gi' ),
      s         : new RegExp( 's$'                             , 'gi' )
    },

    singular : {
      man       : new RegExp( '^(m|wom)an$'                  , 'gi' ),
      person    : new RegExp( '(pe)rson$'                    , 'gi' ),
      child     : new RegExp( '(child)$'                     , 'gi' ),
      ox        : new RegExp( '^(ox)$'                       , 'gi' ),
      axis      : new RegExp( '(ax|test)is$'                 , 'gi' ),
      octopus   : new RegExp( '(octop|vir)us$'               , 'gi' ),
      alias     : new RegExp( '(alias|status|canvas|campus)$', 'gi' ),
      summons   : new RegExp( '^(summons)$'                  , 'gi' ),
      bus       : new RegExp( '(bu)s$'                       , 'gi' ),
      buffalo   : new RegExp( '(buffal|tomat|potat)o$'       , 'gi' ),
      tium      : new RegExp( '([ti])um$'                    , 'gi' ),
      sis       : new RegExp( 'sis$'                         , 'gi' ),
      ffe       : new RegExp( '(?:([^f])fe|([lr])f)$'        , 'gi' ),
      hive      : new RegExp( '(hi|ti)ve$'                   , 'gi' ),
      aeiouyy   : new RegExp( '([^aeiouy]|qu)y$'             , 'gi' ),
      x         : new RegExp( '(x|ch|ss|sh)$'                , 'gi' ),
      matrix    : new RegExp( '(matr)ix$'                    , 'gi' ),
      vertex    : new RegExp( '(vert|ind)ex$'                , 'gi' ),
      mouse     : new RegExp( '([m|l])ouse$'                 , 'gi' ),
      foot      : new RegExp( '^foot$'                       , 'gi' ),
      tooth     : new RegExp( '^tooth$'                      , 'gi' ),
      goose     : new RegExp( '^goose$'                      , 'gi' ),
      quiz      : new RegExp( '(quiz)$'                      , 'gi' ),
      whereas   : new RegExp( '^(whereas)$'                  , 'gi' ),
      criterion : new RegExp( '^(criteri)on$'                , 'gi' ),
      genus     : new RegExp( '^genus$'                      , 'gi' ),
      s         : new RegExp( 's$'                           , 'gi' ),
      common    : new RegExp( '$'                            , 'gi' )
    }
  };

  var plural_rules = [

    // do not replace if its already a plural word
    [ regex.plural.men       ],
    [ regex.plural.people    ],
    [ regex.plural.children  ],
    [ regex.plural.tia       ],
    [ regex.plural.analyses  ],
    [ regex.plural.hives     ],
    [ regex.plural.curves    ],
    [ regex.plural.lrves     ],
    [ regex.plural.foves     ],
    [ regex.plural.aeiouyies ],
    [ regex.plural.series    ],
    [ regex.plural.movies    ],
    [ regex.plural.xes       ],
    [ regex.plural.mice      ],
    [ regex.plural.buses     ],
    [ regex.plural.oes       ],
    [ regex.plural.shoes     ],
    [ regex.plural.crises    ],
    [ regex.plural.octopi    ],
    [ regex.plural.aliases   ],
    [ regex.plural.summonses ],
    [ regex.plural.oxen      ],
    [ regex.plural.matrices  ],
    [ regex.plural.feet      ],
    [ regex.plural.teeth     ],
    [ regex.plural.geese     ],
    [ regex.plural.quizzes   ],
    [ regex.plural.whereases ],
    [ regex.plural.criteria  ],
    [ regex.plural.genera    ],

    // original rule
    [ regex.singular.man      , '$1en' ],
    [ regex.singular.person   , '$1ople' ],
    [ regex.singular.child    , '$1ren' ],
    [ regex.singular.ox       , '$1en' ],
    [ regex.singular.axis     , '$1es' ],
    [ regex.singular.octopus  , '$1i' ],
    [ regex.singular.alias    , '$1es' ],
    [ regex.singular.summons  , '$1es' ],
    [ regex.singular.bus      , '$1ses' ],
    [ regex.singular.buffalo  , '$1oes' ],
    [ regex.singular.tium     , '$1a' ],
    [ regex.singular.sis      , 'ses' ],
    [ regex.singular.ffe      , '$1$2ves' ],
    [ regex.singular.hive     , '$1ves' ],
    [ regex.singular.aeiouyy  , '$1ies' ],
    [ regex.singular.matrix   , '$1ices' ],
    [ regex.singular.vertex   , '$1ices' ],
    [ regex.singular.x        , '$1es' ],
    [ regex.singular.mouse    , '$1ice' ],
    [ regex.singular.foot     , 'feet' ],
    [ regex.singular.tooth    , 'teeth' ],
    [ regex.singular.goose    , 'geese' ],
    [ regex.singular.quiz     , '$1zes' ],
    [ regex.singular.whereas  , '$1es' ],
    [ regex.singular.criterion, '$1a' ],
    [ regex.singular.genus    , 'genera' ],

    [ regex.singular.s     , 's' ],
    [ regex.singular.common, 's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ regex.singular.man     ],
    [ regex.singular.person  ],
    [ regex.singular.child   ],
    [ regex.singular.ox      ],
    [ regex.singular.axis    ],
    [ regex.singular.octopus ],
    [ regex.singular.alias   ],
    [ regex.singular.summons ],
    [ regex.singular.bus     ],
    [ regex.singular.buffalo ],
    [ regex.singular.tium    ],
    [ regex.singular.sis     ],
    [ regex.singular.ffe     ],
    [ regex.singular.hive    ],
    [ regex.singular.aeiouyy ],
    [ regex.singular.x       ],
    [ regex.singular.matrix  ],
    [ regex.singular.mouse   ],
    [ regex.singular.foot    ],
    [ regex.singular.tooth   ],
    [ regex.singular.goose   ],
    [ regex.singular.quiz    ],
    [ regex.singular.whereas ],
    [ regex.singular.criterion ],
    [ regex.singular.genus ],

    // original rule
    [ regex.plural.men      , '$1an' ],
    [ regex.plural.people   , '$1rson' ],
    [ regex.plural.children , '$1' ],
    [ regex.plural.genera   , 'genus'],
    [ regex.plural.criteria , '$1on'],
    [ regex.plural.tia      , '$1um' ],
    [ regex.plural.analyses , '$1$2sis' ],
    [ regex.plural.hives    , '$1ve' ],
    [ regex.plural.curves   , '$1' ],
    [ regex.plural.lrves    , '$1f' ],
    [ regex.plural.aves     , '$1ve' ],
    [ regex.plural.foves    , '$1fe' ],
    [ regex.plural.movies   , '$1ovie' ],
    [ regex.plural.aeiouyies, '$1y' ],
    [ regex.plural.series   , '$1eries' ],
    [ regex.plural.xes      , '$1' ],
    [ regex.plural.mice     , '$1ouse' ],
    [ regex.plural.buses    , '$1' ],
    [ regex.plural.oes      , '$1' ],
    [ regex.plural.shoes    , '$1' ],
    [ regex.plural.crises   , '$1is' ],
    [ regex.plural.octopi   , '$1us' ],
    [ regex.plural.aliases  , '$1' ],
    [ regex.plural.summonses, '$1' ],
    [ regex.plural.oxen     , '$1' ],
    [ regex.plural.matrices , '$1ix' ],
    [ regex.plural.vertices , '$1ex' ],
    [ regex.plural.feet     , 'foot' ],
    [ regex.plural.teeth    , 'tooth' ],
    [ regex.plural.geese    , 'goose' ],
    [ regex.plural.quizzes  , '$1' ],
    [ regex.plural.whereases, '$1' ],

    [ regex.plural.ss, 'ss' ],
    [ regex.plural.s , '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function ( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} from_index Starts checking from this position in the Array.(optional)
   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function ( arr, item, from_index, compare_func ){
      if( !from_index ){
        from_index = -1;
      }

      var index = -1;
      var i     = from_index;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },


  /**
   * This function will pluralize or singularlize a String appropriately based on an integer value
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Number} count The number to base pluralization off of.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} English language nouns are returned in the plural or singular form based on the count.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.inflect( 'people' 1 ); // === 'person'
   *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
   *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
   *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
   *     inflection.inflect( 'person', 2 ); // === 'people'
   *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
   *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
   *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
   */
    inflect : function ( str, count, singular, plural ){
      count = parseInt( count, 10 );

      if( isNaN( count )) return str;

      if( count === 0 || count > 1 ){
        return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
      }else{
        return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
      }
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, low_first_letter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = low_first_letter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, all_upper_case ){
      if( all_upper_case && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function ( str, low_first_letter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !low_first_letter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function replaces underscores with dashes in the string.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underscores with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ' );
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function ( str, drop_id_ubar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( inflector.hasOwnProperty( method )){
          str = inflector[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.12.0';

  return inflector;
}));


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/retry-as-promised/index.js":
/*!*************************************************!*\
  !*** ./node_modules/retry-as-promised/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Promise = __webpack_require__(/*! any-promise */ "./node_modules/any-promise/index.js");
var util = __webpack_require__(/*! util */ "util");
var format = util.format;

function TimeoutError(message, err) {
  Error.call(this);
  Error.captureStackTrace(this, TimeoutError);
  this.name = 'TimeoutError';
  this.message = message;
  this.previous = err;
}

util.inherits(TimeoutError, Error);

function matches(match, err) {
  if (match === true) return true;
  if (typeof match === 'function') {
    try {
      if (err instanceof match) return true;
    } catch (_) {
      return !!match(err);
    }
  }
  if (match === err.toString()) return true;
  if (match === err.message) return true;
  return match instanceof RegExp
    && (match.test(err.message) || match.test(err.toString()));
}

module.exports = function retryAsPromised(callback, options) {
  if (!callback || !options) {
    throw new Error(
      'retry-as-promised must be passed a callback and a options set or a number'
    );
  }

  if (typeof options === 'number') {
    options = {
      max: options
    };
  }

  // Super cheap clone
  options = {
    $current: options.$current || 1,
    max: options.max,
    timeout: options.timeout || undefined,
    match: options.match || [],
    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,
    backoffExponent: options.backoffExponent || 1.1,
    report: options.report || function () {},
    name: options.name || callback.name || 'unknown'
  };

  if (!Array.isArray(options.match)) options.match = [options.match];
  options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);

  return new Promise(function(resolve, reject) {
    var timeout, backoffTimeout, lastError;

    if (options.timeout) {
      timeout = setTimeout(function() {
        if (backoffTimeout) clearTimeout(backoffTimeout);
        reject(new TimeoutError(options.name + ' timed out', lastError));
      }, options.timeout);
    }

    Promise.resolve(callback({ current: options.$current }))
      .then(resolve)
      .then(function() {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);
      })
      .catch(function(err) {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);

        lastError = err;
        options.report((err && err.toString()) || err, options);

        // Should not retry if max has been reached
        var shouldRetry = options.$current < options.max;
        if (!shouldRetry) return reject(err);
        shouldRetry = options.match.length === 0 || options.match.some(function (match) {
          return matches(match, err)
        });
        if (!shouldRetry) return reject(err);

        var retryDelay = Math.pow(
          options.backoffBase,
          Math.pow(options.backoffExponent, options.$current - 1)
        );

        // Do some accounting
        options.$current++;
        options.report(format('Retrying %s (%s)', options.name, options.$current), options);

        if (retryDelay) {
          // Use backoff function to ease retry rate
          options.report(format('Delaying retry of %s by %s', options.name, retryDelay), options);
          backoffTimeout = setTimeout(function() {
            retryAsPromised(callback, options)
              .then(resolve)
              .catch(reject);
          }, retryDelay);
        } else {
          retryAsPromised(callback, options)
            .then(resolve)
            .catch(reject);
        }
      });
  });
};

module.exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "lru-cache")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js")
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js"),
  compareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").rcompareIdentifiers,
  parse: __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js"),
  valid: __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js"),
  clean: __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js"),
  inc: __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js"),
  diff: __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js"),
  major: __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js"),
  minor: __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js"),
  patch: __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js"),
  prerelease: __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js"),
  compare: __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js"),
  rcompare: __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js"),
  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js"),
  compareBuild: __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js"),
  sort: __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js"),
  rsort: __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js"),
  gt: __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js"),
  lt: __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js"),
  eq: __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js"),
  neq: __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js"),
  gte: __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js"),
  lte: __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js"),
  cmp: __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js"),
  coerce: __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js"),
  Comparator: __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js"),
  Range: __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js"),
  satisfies: __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js"),
  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js"),
  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js"),
  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js"),
  minVersion: __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js"),
  validRange: __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js"),
  outside: __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js"),
  gtr: __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js"),
  ltr: __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js"),
  intersects: __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js"),
  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js"),
  subset: __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js"),
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js")
const {ANY} = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/sequelize-pool/lib/AggregateError.js":
/*!***********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/AggregateError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregateError = void 0;
class AggregateError extends Error {
    constructor(errors) {
        super();
        this.errors = errors;
        this.name = 'AggregateError';
    }
    toString() {
        const message = `AggregateError of:\n${this.errors
            .map((error) => error === this
            ? '[Circular AggregateError]'
            : error instanceof AggregateError
                ? String(error).replace(/\n$/, '').replace(/^/gm, '  ')
                : String(error).replace(/^/gm, '    ').substring(2))
            .join('\n')}\n`;
        return message;
    }
}
exports.AggregateError = AggregateError;
//# sourceMappingURL=AggregateError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Deferred.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Deferred.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
const TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = resolve;
        });
    }
    registerTimeout(timeoutInMillis, callback) {
        if (this._timeout)
            return;
        this._timeout = setTimeout(() => {
            callback();
            this.reject(new TimeoutError_1.TimeoutError('Operation timeout'));
        }, timeoutInMillis);
    }
    _clearTimeout() {
        if (!this._timeout)
            return;
        clearTimeout(this._timeout);
    }
    resolve(value) {
        this._clearTimeout();
        this._resolve(value);
    }
    reject(error) {
        this._clearTimeout();
        this._reject(error);
    }
    promise() {
        return this._promise;
    }
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Pool.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Pool.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pool = void 0;
const Deferred_1 = __webpack_require__(/*! ./Deferred */ "./node_modules/sequelize-pool/lib/Deferred.js");
const AggregateError_1 = __webpack_require__(/*! ./AggregateError */ "./node_modules/sequelize-pool/lib/AggregateError.js");
class Pool {
    constructor(factory) {
        this.log = false;
        if (!factory.create) {
            throw new Error('create function is required');
        }
        if (!factory.destroy) {
            throw new Error('destroy function is required');
        }
        if (!factory.validate) {
            throw new Error('validate function is required');
        }
        if (typeof factory.min !== 'number' ||
            factory.min < 0 ||
            factory.min !== Math.round(factory.min)) {
            throw new Error('min must be an integer >= 0');
        }
        if (typeof factory.max !== 'number' ||
            factory.max <= 0 ||
            factory.max !== Math.round(factory.max)) {
            throw new Error('max must be an integer > 0');
        }
        if (factory.min > factory.max) {
            throw new Error('max is smaller than min');
        }
        if (factory.maxUses !== undefined &&
            (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {
            throw new Error('maxUses must be an integer >= 0');
        }
        this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;
        this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;
        this.reapIntervalMillis = factory.reapIntervalMillis || 1000;
        this.maxUsesPerResource = factory.maxUses || Infinity;
        this.log = factory.log || false;
        this._factory = factory;
        this._count = 0;
        this._draining = false;
        this._pendingAcquires = [];
        this._inUseObjects = [];
        this._availableObjects = [];
        this._removeIdleScheduled = false;
    }
    get size() {
        return this._count;
    }
    get name() {
        return this._factory.name;
    }
    get available() {
        return this._availableObjects.length;
    }
    get using() {
        return this._inUseObjects.length;
    }
    get waiting() {
        return this._pendingAcquires.length;
    }
    get maxSize() {
        return this._factory.max;
    }
    get minSize() {
        return this._factory.min;
    }
    _log(message, level) {
        if (typeof this.log === 'function') {
            this.log(message, level);
        }
        else if (this.log) {
            console.log(`${level.toUpperCase()} pool ${this.name || ''} - ${message}`);
        }
    }
    _removeIdle() {
        const toRemove = [];
        const now = Date.now();
        let i;
        let available = this._availableObjects.length;
        const maxRemovable = this.size - this.minSize;
        let timeout;
        this._removeIdleScheduled = false;
        for (i = 0; i < available && maxRemovable > toRemove.length; i++) {
            timeout = this._availableObjects[i].timeout;
            if (now >= timeout) {
                this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');
                toRemove.push(this._availableObjects[i].resource);
            }
        }
        toRemove.forEach(this.destroy, this);
        available = this._availableObjects.length;
        if (available > 0) {
            this._log('this._availableObjects.length=' + available, 'verbose');
            this._scheduleRemoveIdle();
        }
        else {
            this._log('removeIdle() all objects removed', 'verbose');
        }
    }
    _scheduleRemoveIdle() {
        if (!this._removeIdleScheduled) {
            this._removeIdleScheduled = true;
            this._removeIdleTimer = setTimeout(() => {
                this._removeIdle();
            }, this.reapIntervalMillis);
        }
    }
    _dispense() {
        let wrappedResource = null;
        const waitingCount = this._pendingAcquires.length;
        this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, 'info');
        if (waitingCount < 1) {
            return;
        }
        while (this._availableObjects.length > 0) {
            this._log('dispense() - reusing obj', 'verbose');
            wrappedResource = this._availableObjects[this._availableObjects.length - 1];
            if (!this._factory.validate(wrappedResource.resource)) {
                this.destroy(wrappedResource.resource);
                continue;
            }
            this._availableObjects.pop();
            this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);
            const deferred = this._pendingAcquires.shift();
            return deferred.resolve(wrappedResource.resource);
        }
        if (this.size < this.maxSize) {
            this._createResource();
        }
    }
    _createResource() {
        this._count += 1;
        this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`, 'verbose');
        this._factory
            .create()
            .then((resource) => {
            const deferred = this._pendingAcquires.shift();
            if (deferred) {
                this._addResourceToInUseObjects(resource, 0);
                deferred.resolve(resource);
            }
            else {
                this._addResourceToAvailableObjects(resource, 0);
            }
        })
            .catch((error) => {
            const deferred = this._pendingAcquires.shift();
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            if (deferred) {
                deferred.reject(error);
            }
            process.nextTick(() => {
                this._dispense();
            });
        });
    }
    _addResourceToAvailableObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
            timeout: Date.now() + this.idleTimeoutMillis,
        };
        this._availableObjects.push(wrappedResource);
        this._dispense();
        this._scheduleRemoveIdle();
    }
    _addResourceToInUseObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
        };
        this._inUseObjects.push(wrappedResource);
    }
    _ensureMinimum() {
        let i, diff;
        if (!this._draining && this.size < this.minSize) {
            diff = this.minSize - this.size;
            for (i = 0; i < diff; i++) {
                this._createResource();
            }
        }
    }
    acquire() {
        if (this._draining) {
            return Promise.reject(new Error('pool is draining and cannot accept work'));
        }
        const deferred = new Deferred_1.Deferred();
        deferred.registerTimeout(this.acquireTimeoutMillis, () => {
            this._pendingAcquires = this._pendingAcquires.filter((pending) => pending !== deferred);
        });
        this._pendingAcquires.push(deferred);
        this._dispense();
        return deferred.promise();
    }
    release(resource) {
        if (this._availableObjects.some((resourceWithTimeout) => resourceWithTimeout.resource === resource)) {
            this._log('release called twice for the same resource: ' + new Error().stack, 'error');
            return;
        }
        const index = this._inUseObjects.findIndex((wrappedResource) => wrappedResource.resource === resource);
        if (index < 0) {
            this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');
            return;
        }
        const wrappedResource = this._inUseObjects[index];
        wrappedResource.useCount += 1;
        if (wrappedResource.useCount >= this.maxUsesPerResource) {
            this._log('release() destroying obj - useCount:' +
                wrappedResource.useCount +
                ' maxUsesPerResource:' +
                this.maxUsesPerResource, 'verbose');
            this.destroy(wrappedResource.resource);
            this._dispense();
        }
        else {
            this._inUseObjects.splice(index, 1);
            this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);
        }
    }
    destroy(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const available = this._availableObjects.length;
            const using = this._inUseObjects.length;
            this._availableObjects = this._availableObjects.filter((object) => object.resource !== resource);
            this._inUseObjects = this._inUseObjects.filter((object) => object.resource !== resource);
            if (available === this._availableObjects.length &&
                using === this._inUseObjects.length) {
                this._ensureMinimum();
                return;
            }
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            try {
                yield this._factory.destroy(resource);
            }
            finally {
                this._ensureMinimum();
            }
        });
    }
    drain() {
        this._log('draining', 'info');
        this._draining = true;
        const check = (callback) => {
            if (this._pendingAcquires.length > 0) {
                this._dispense();
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            if (this._availableObjects.length !== this._count) {
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            callback();
        };
        return new Promise((resolve) => check(resolve));
    }
    destroyAllNow() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log('force destroying all objects', 'info');
            this._removeIdleScheduled = false;
            clearTimeout(this._removeIdleTimer);
            const resources = this._availableObjects.map((resource) => resource.resource);
            const errors = [];
            for (const resource of resources) {
                try {
                    yield this.destroy(resource);
                }
                catch (ex) {
                    this._log('Error destroying resource: ' + ex.stack, 'error');
                    errors.push(ex);
                }
            }
            if (errors.length > 0) {
                throw new AggregateError_1.AggregateError(errors);
            }
        });
    }
}
exports.Pool = Pool;
//# sourceMappingURL=Pool.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/TimeoutError.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/TimeoutError.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = void 0;
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
Object.defineProperty(exports, "TimeoutError", ({ enumerable: true, get: function () { return TimeoutError_1.TimeoutError; } }));
var Pool_1 = __webpack_require__(/*! ./Pool */ "./node_modules/sequelize-pool/lib/Pool.js");
Object.defineProperty(exports, "Pool", ({ enumerable: true, get: function () { return Pool_1.Pool; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferAlias = void 0;
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
/**
 * Pre conform includes, so that "as" value can be inferred from source
 */
function inferAlias(options, source) {
    options = Object.assign({}, options);
    if (!options.include) {
        return options;
    }
    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
        options.include = [options.include];
    }
    else if (!options.include.length) {
        delete options.include;
        return options;
    }
    // convert all included elements to { model: Model } form
    options.include = options.include.map((include) => {
        include = inferAliasForInclude(include, source);
        return include;
    });
    return options;
}
exports.inferAlias = inferAlias;
/**
 * Pre conform include, so that alias ("as") value can be inferred from source class
 */
function inferAliasForInclude(include, source) {
    const hasModelOptionWithoutAsOption = !!(include.model && !include.as);
    const hasIncludeOptions = !!include.include;
    const isConstructorFn = include instanceof Function;
    if (isConstructorFn || hasModelOptionWithoutAsOption) {
        if (isConstructorFn) {
            include = { model: include };
        }
        const targetPrototype = source.prototype || source;
        const relatedClass = include.model;
        const associations = association_service_1.getAssociationsByRelation(targetPrototype, relatedClass);
        if (associations.length > 0) {
            if (associations.length > 1) {
                throw new Error(`Alias cannot be inferred: "${source.name}" has multiple ` +
                    `relations with "${include.model.name}"`);
            }
            include.as = associations[0].getAs();
        }
    }
    if (!isConstructorFn && hasIncludeOptions) {
        include = inferAlias(include, include.model);
    }
    return include;
}
//# sourceMappingURL=alias-inference-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToManyAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToManyAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsToMany;
    }
    getSequelizeOptions(model, sequelize) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        const throughOptions = this.getThroughOptions(sequelize);
        const throughModel = typeof throughOptions === 'object' && typeof throughOptions.model !== "string" ? throughOptions.model : undefined;
        options.through = throughOptions;
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, throughModel, this.options.foreignKey);
        options.otherKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, throughModel, this.options.otherKey);
        return options;
    }
    getThroughOptions(sequelize) {
        const through = this.options.through;
        const throughModel = typeof through === 'object' ? through.model : through;
        const throughOptions = typeof through === 'object' ? Object.assign({}, through) : {};
        if (typeof throughModel === 'function') {
            const throughModelClass = sequelize.model(throughModel());
            if (!throughModelClass.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(throughModelClass, 'Association cannot be resolved.');
            }
            throughOptions.model = throughModelClass;
        }
        else {
            return throughModel;
        }
        return throughOptions;
    }
}
exports.BelongsToManyAssociation = BelongsToManyAssociation;
//# sourceMappingURL=belongs-to-many-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=belongs-to-many-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToMany = void 0;
const belongs_to_many_association_1 = __webpack_require__(/*! ./belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsToMany(associatedClassGetter, throughOrOptions, foreignKey, otherKey) {
    return (target, propertyName) => {
        let options = { foreignKey, otherKey };
        if (typeof throughOrOptions === 'string' ||
            typeof throughOrOptions === 'function') {
            options.through = throughOrOptions;
        }
        else {
            options = Object.assign({}, throughOrOptions);
        }
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_many_association_1.BelongsToManyAssociation(associatedClassGetter, options));
    };
}
exports.BelongsToMany = BelongsToMany;
//# sourceMappingURL=belongs-to-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsTo;
    }
    getSequelizeOptions(model) {
        const associatedClass = this.getAssociatedClass();
        const foreignKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, model, this.options.foreignKey);
        return Object.assign(Object.assign({}, this.options), { foreignKey });
    }
}
exports.BelongsToAssociation = BelongsToAssociation;
//# sourceMappingURL=belongs-to-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsTo = void 0;
const belongs_to_association_1 = __webpack_require__(/*! ./belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsTo(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_association_1.BelongsToAssociation(associatedClassGetter, options));
    };
}
exports.BelongsTo = BelongsTo;
//# sourceMappingURL=belongs-to.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getForeignKeys = exports.addForeignKey = exports.getForeignKeyOptions = void 0;
const FOREIGN_KEYS_KEY = 'sequelize:foreignKeys';
function getForeignKeyOptions(relatedClass, classWithForeignKey, foreignKey) {
    let foreignKeyOptions = {};
    if (typeof foreignKey === 'string') {
        foreignKeyOptions.name = foreignKey;
    }
    else if (foreignKey && typeof foreignKey === 'object') {
        foreignKeyOptions = Object.assign({}, foreignKey);
    }
    if (!foreignKeyOptions.name && classWithForeignKey) {
        const foreignKeys = getForeignKeys(classWithForeignKey.prototype) || [];
        for (const key of foreignKeys) {
            if (key.relatedClassGetter() === relatedClass ||
                relatedClass.prototype instanceof key.relatedClassGetter()) {
                foreignKeyOptions.name = key.foreignKey;
                break;
            }
        }
    }
    if (!foreignKeyOptions.name) {
        throw new Error(`Foreign key for "${relatedClass.name}" is missing ` +
            `on "${classWithForeignKey.name}".`);
    }
    return foreignKeyOptions;
}
exports.getForeignKeyOptions = getForeignKeyOptions;
/**
 * Adds foreign key meta data for specified class
 */
function addForeignKey(target, relatedClassGetter, foreignKey) {
    let foreignKeys = getForeignKeys(target);
    if (!foreignKeys) {
        foreignKeys = [];
    }
    foreignKeys.push({
        relatedClassGetter,
        foreignKey,
    });
    setForeignKeys(target, foreignKeys);
}
exports.addForeignKey = addForeignKey;
/**
 * Returns foreign key meta data from specified class
 */
function getForeignKeys(target) {
    const foreignKeys = Reflect.getMetadata(FOREIGN_KEYS_KEY, target);
    if (foreignKeys) {
        return [...foreignKeys];
    }
}
exports.getForeignKeys = getForeignKeys;
/**
 * Sets foreign key meta data
 */
function setForeignKeys(target, foreignKeys) {
    Reflect.defineMetadata(FOREIGN_KEYS_KEY, foreignKeys, target);
}
//# sourceMappingURL=foreign-key-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForeignKey = void 0;
const foreign_key_service_1 = __webpack_require__(/*! ./foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
function ForeignKey(relatedClassGetter) {
    return (target, propertyName) => {
        foreign_key_service_1.addForeignKey(target, relatedClassGetter, propertyName);
    };
}
exports.ForeignKey = ForeignKey;
//# sourceMappingURL=foreign-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-association.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
class HasAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options, association) {
        super(associatedClassGetter, options);
        this.options = options;
        this.association = association;
    }
    getAssociation() {
        return this.association;
    }
    getSequelizeOptions(model) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, associatedClass, options.foreignKey);
        return options;
    }
}
exports.HasAssociation = HasAssociation;
//# sourceMappingURL=has-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-many.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasMany = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasMany(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasMany));
    };
}
exports.HasMany = HasMany;
//# sourceMappingURL=has-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-one.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasOne = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasOne(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasOne));
    };
}
exports.HasOne = HasOne;
//# sourceMappingURL=has-one.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association-service.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAssociationsByRelation = exports.setAssociations = exports.getAssociations = exports.addAssociation = exports.getPreparedAssociationOptions = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const ASSOCIATIONS_KEY = 'sequelize:associations';
// tslint:disable:max-line-length
function getPreparedAssociationOptions(optionsOrForeignKey) {
    let options = {};
    if (optionsOrForeignKey) {
        if (typeof optionsOrForeignKey === 'string') {
            options.foreignKey = optionsOrForeignKey;
        }
        else {
            options = Object.assign({}, optionsOrForeignKey);
        }
    }
    return options;
}
exports.getPreparedAssociationOptions = getPreparedAssociationOptions;
/**
 * Stores association meta data for specified class
 */
function addAssociation(target, association) {
    let associations = getAssociations(target);
    if (!associations) {
        associations = [];
    }
    associations.push(association);
    setAssociations(target, associations);
}
exports.addAssociation = addAssociation;
/**
 * Returns association meta data from specified class
 */
function getAssociations(target) {
    const associations = Reflect.getMetadata(ASSOCIATIONS_KEY, target);
    if (associations) {
        return [...associations];
    }
}
exports.getAssociations = getAssociations;
function setAssociations(target, associations) {
    Reflect.defineMetadata(ASSOCIATIONS_KEY, associations, target);
}
exports.setAssociations = setAssociations;
function getAssociationsByRelation(target, relatedClass) {
    const associations = getAssociations(target);
    return (associations || []).filter(association => {
        const _relatedClass = association.getAssociatedClass();
        return (_relatedClass.prototype === relatedClass.prototype ||
            relatedClass.prototype instanceof _relatedClass);
    });
}
exports.getAssociationsByRelation = getAssociationsByRelation;
//# sourceMappingURL=association-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Association = void 0;
var Association;
(function (Association) {
    Association["BelongsToMany"] = "belongsToMany";
    Association["BelongsTo"] = "belongsTo";
    Association["HasMany"] = "hasMany";
    Association["HasOne"] = "hasOne";
})(Association = exports.Association || (exports.Association = {}));
//# sourceMappingURL=association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/base-association.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAssociation = void 0;
class BaseAssociation {
    constructor(associatedClassGetter, options) {
        this.associatedClassGetter = associatedClassGetter;
        this.options = options;
    }
    getAssociatedClass() {
        return this.associatedClassGetter();
    }
    getAs() {
        return this.options.as;
    }
}
exports.BaseAssociation = BaseAssociation;
//# sourceMappingURL=base-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=union-association-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/through/through-options.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=through-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkCreate', args);
}
exports.AfterBulkCreate = AfterBulkCreate;
//# sourceMappingURL=after-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkDestroy', args);
}
exports.AfterBulkDestroy = AfterBulkDestroy;
//# sourceMappingURL=after-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkRestore', args);
}
exports.AfterBulkRestore = AfterBulkRestore;
//# sourceMappingURL=after-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkSync', args);
}
exports.AfterBulkSync = AfterBulkSync;
//# sourceMappingURL=after-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkUpdate', args);
}
exports.AfterBulkUpdate = AfterBulkUpdate;
//# sourceMappingURL=after-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkCreate', args);
}
exports.BeforeBulkCreate = BeforeBulkCreate;
//# sourceMappingURL=before-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkDestroy', args);
}
exports.BeforeBulkDestroy = BeforeBulkDestroy;
//# sourceMappingURL=before-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkRestore', args);
}
exports.BeforeBulkRestore = BeforeBulkRestore;
//# sourceMappingURL=before-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkSync', args);
}
exports.BeforeBulkSync = BeforeBulkSync;
//# sourceMappingURL=before-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkUpdate', args);
}
exports.BeforeBulkUpdate = BeforeBulkUpdate;
//# sourceMappingURL=before-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=hook-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setHooks = exports.getHooks = exports.addHook = exports.implementHookDecorator = exports.installHooks = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const HOOKS_KEY = 'sequelize:hooks';
/**
 * Installs hooks on the specified models
 */
function installHooks(models) {
    models.forEach(model => {
        const hooks = getHooks(model);
        if (hooks) {
            hooks.forEach(hook => {
                installHook(model, hook);
            });
        }
    });
}
exports.installHooks = installHooks;
/**
 * Implementation for hook decorator functions. These are polymorphic. When
 * called with a single argument (IHookOptions) they return a decorator
 * factory function. When called with multiple arguments, they add the hook
 * to the models metadata.
 */
function implementHookDecorator(hookType, args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => addHook(target, hookType, propertyName, options);
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        addHook(target, hookType, propertyName);
    }
}
exports.implementHookDecorator = implementHookDecorator;
/**
 * Adds hook meta data for specified model
 * @throws if applied to a non-static method
 * @throws if the hook method name is reserved
 */
function addHook(target, hookType, methodName, options = {}) {
    if (typeof target !== 'function') {
        throw new Error(`Hook method '${methodName}' is not a static method. ` +
            `Only static methods can be used for hooks`);
    }
    // make sure the hook name doesnt conflict with Sequelizes existing methods
    if (methodName === hookType) {
        throw new Error(`Hook method cannot be named '${methodName}'. That name is ` +
            `reserved by Sequelize`);
    }
    const hooks = getHooks(target) || [];
    hooks.push({
        hookType,
        methodName,
        options
    });
    setHooks(target, hooks);
}
exports.addHook = addHook;
/**
 * Install a hook
 */
function installHook(model, hook) {
    if (hook.options && hook.options.name) {
        model.addHook(hook.hookType, hook.options.name, model[hook.methodName]);
        return;
    }
    model.addHook(hook.hookType, model[hook.methodName]);
}
/**
 * Returns hooks meta data from specified class
 */
function getHooks(target) {
    const hooks = Reflect.getMetadata(HOOKS_KEY, target);
    if (hooks) {
        return [...hooks];
    }
}
exports.getHooks = getHooks;
/**
 * Saves hooks meta data for the specified class
 */
function setHooks(target, hooks) {
    Reflect.defineMetadata(HOOKS_KEY, hooks, target);
}
exports.setHooks = setHooks;
//# sourceMappingURL=hooks-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationFailed = void 0;
const hooks_service_1 = __webpack_require__(/*! ./hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function ValidationFailed(...args) {
    return hooks_service_1.implementHookDecorator('validationFailed', args);
}
exports.ValidationFailed = ValidationFailed;
//# sourceMappingURL=validation-failed.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterConnect(...args) {
    return hooks_service_1.implementHookDecorator('afterConnect', args);
}
exports.AfterConnect = AfterConnect;
//# sourceMappingURL=after-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterCreate', args);
}
exports.AfterCreate = AfterCreate;
//# sourceMappingURL=after-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDefine(...args) {
    return hooks_service_1.implementHookDecorator('afterDefine', args);
}
exports.AfterDefine = AfterDefine;
//# sourceMappingURL=after-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterDestroy', args);
}
exports.AfterDestroy = AfterDestroy;
//# sourceMappingURL=after-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterFind(...args) {
    return hooks_service_1.implementHookDecorator('afterFind', args);
}
exports.AfterFind = AfterFind;
//# sourceMappingURL=after-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterInit(...args) {
    return hooks_service_1.implementHookDecorator('afterInit', args);
}
exports.AfterInit = AfterInit;
//# sourceMappingURL=after-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterRestore', args);
}
exports.AfterRestore = AfterRestore;
//# sourceMappingURL=after-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSave(...args) {
    return hooks_service_1.implementHookDecorator('afterSave', args);
}
exports.AfterSave = AfterSave;
//# sourceMappingURL=after-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSync(...args) {
    return hooks_service_1.implementHookDecorator('afterSync', args);
}
exports.AfterSync = AfterSync;
//# sourceMappingURL=after-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterUpdate', args);
}
exports.AfterUpdate = AfterUpdate;
//# sourceMappingURL=after-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpsert(...args) {
    return hooks_service_1.implementHookDecorator('afterUpsert', args);
}
exports.AfterUpsert = AfterUpsert;
//# sourceMappingURL=after-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterValidate(...args) {
    return hooks_service_1.implementHookDecorator('afterValidate', args);
}
exports.AfterValidate = AfterValidate;
//# sourceMappingURL=after-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeConnect(...args) {
    return hooks_service_1.implementHookDecorator('beforeConnect', args);
}
exports.BeforeConnect = BeforeConnect;
//# sourceMappingURL=before-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCount = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCount(...args) {
    return hooks_service_1.implementHookDecorator('beforeCount', args);
}
exports.BeforeCount = BeforeCount;
//# sourceMappingURL=before-count.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeCreate', args);
}
exports.BeforeCreate = BeforeCreate;
//# sourceMappingURL=before-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDefine(...args) {
    return hooks_service_1.implementHookDecorator('beforeDefine', args);
}
exports.BeforeDefine = BeforeDefine;
//# sourceMappingURL=before-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeDestroy', args);
}
exports.BeforeDestroy = BeforeDestroy;
//# sourceMappingURL=before-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterExpandIncludeAll = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterExpandIncludeAll(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterExpandIncludeAll', args);
}
exports.BeforeFindAfterExpandIncludeAll = BeforeFindAfterExpandIncludeAll;
//# sourceMappingURL=before-find-after-expand-include-all.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterOptions = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterOptions(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterOptions', args);
}
exports.BeforeFindAfterOptions = BeforeFindAfterOptions;
//# sourceMappingURL=before-find-after-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFind(...args) {
    return hooks_service_1.implementHookDecorator('beforeFind', args);
}
exports.BeforeFind = BeforeFind;
//# sourceMappingURL=before-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeInit(...args) {
    return hooks_service_1.implementHookDecorator('beforeInit', args);
}
exports.BeforeInit = BeforeInit;
//# sourceMappingURL=before-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeRestore', args);
}
exports.BeforeRestore = BeforeRestore;
//# sourceMappingURL=before-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSave(...args) {
    return hooks_service_1.implementHookDecorator('beforeSave', args);
}
exports.BeforeSave = BeforeSave;
//# sourceMappingURL=before-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeSync', args);
}
exports.BeforeSync = BeforeSync;
//# sourceMappingURL=before-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpdate', args);
}
exports.BeforeUpdate = BeforeUpdate;
//# sourceMappingURL=before-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpsert(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpsert', args);
}
exports.BeforeUpsert = BeforeUpsert;
//# sourceMappingURL=before-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeValidate(...args) {
    return hooks_service_1.implementHookDecorator('beforeValidate', args);
}
exports.BeforeValidate = BeforeValidate;
//# sourceMappingURL=before-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-options */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/foreign-key/foreign-key */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-one */ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-many */ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-action-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/union-association-options */ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/through/through-options */ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-create */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-define */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-find */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-init */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-save */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-update */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-count */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-create */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-define */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-expand-include-all */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-options */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-init */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-save */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-update */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hook-options */ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/validation-failed */ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/allow-null */ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/comment */ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/default */ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/unique */ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/auto-increment */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/primary-key */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/created-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/deleted-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/updated-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column */ "./node_modules/sequelize-typescript/dist/model/column/column.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-count-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-get-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-class-getter */ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table */ "./node_modules/sequelize-typescript/dist/model/table/table.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table-options */ "./node_modules/sequelize-typescript/dist/model/table/table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/create-index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/default-scope */ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-table-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scopes */ "./node_modules/sequelize-typescript/dist/scopes/scopes.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-options */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/validation-only/db-dialect-dummy */ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/repository/repository */ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/contains */ "./node_modules/sequelize-typescript/dist/validation/contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/equals */ "./node_modules/sequelize-typescript/dist/validation/equals.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is */ "./node_modules/sequelize-typescript/dist/validation/is.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-after */ "./node_modules/sequelize-typescript/dist/validation/is-after.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alpha */ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alphanumeric */ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-before */ "./node_modules/sequelize-typescript/dist/validation/is-before.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-credit-card */ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-date */ "./node_modules/sequelize-typescript/dist/validation/is-date.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-decimal */ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-email */ "./node_modules/sequelize-typescript/dist/validation/is-email.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-float */ "./node_modules/sequelize-typescript/dist/validation/is-float.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-in */ "./node_modules/sequelize-typescript/dist/validation/is-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-int */ "./node_modules/sequelize-typescript/dist/validation/is-int.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip */ "./node_modules/sequelize-typescript/dist/validation/is-ip.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v4 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-array */ "./node_modules/sequelize-typescript/dist/validation/is-array.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v6 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-lowercase */ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-null */ "./node_modules/sequelize-typescript/dist/validation/is-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-numeric */ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uppercase */ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-url */ "./node_modules/sequelize-typescript/dist/validation/is-url.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uuid */ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/length */ "./node_modules/sequelize-typescript/dist/validation/length.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/max */ "./node_modules/sequelize-typescript/dist/validation/max.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/min */ "./node_modules/sequelize-typescript/dist/validation/min.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not */ "./node_modules/sequelize-typescript/dist/validation/not.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-contains */ "./node_modules/sequelize-typescript/dist/validation/not-contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-empty */ "./node_modules/sequelize-typescript/dist/validation/not-empty.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-in */ "./node_modules/sequelize-typescript/dist/validation/not-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-null */ "./node_modules/sequelize-typescript/dist/validation/not-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validate */ "./node_modules/sequelize-typescript/dist/validation/validate.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validator */ "./node_modules/sequelize-typescript/dist/validation/validator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/attribute-service.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addAttributeOptions = exports.addAttribute = exports.setAttributes = exports.getAttributes = void 0;
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const ATTRIBUTES_KEY = 'sequelize:attributes';
/**
 * Returns model attributes from class by restoring this
 * information from reflect metadata
 */
function getAttributes(target) {
    const attributes = Reflect.getMetadata(ATTRIBUTES_KEY, target);
    if (attributes) {
        return Object
            .keys(attributes)
            .reduce((copy, key) => {
            copy[key] = Object.assign({}, attributes[key]);
            return copy;
        }, {});
    }
}
exports.getAttributes = getAttributes;
/**
 * Sets attributes
 */
function setAttributes(target, attributes) {
    Reflect.defineMetadata(ATTRIBUTES_KEY, Object.assign({}, attributes), target);
}
exports.setAttributes = setAttributes;
/**
 * Adds model attribute by specified property name and
 * sequelize attribute options and stores this information
 * through reflect metadata
 */
function addAttribute(target, name, options) {
    let attributes = getAttributes(target);
    if (!attributes) {
        attributes = {};
    }
    attributes[name] = Object.assign({}, options);
    setAttributes(target, attributes);
}
exports.addAttribute = addAttribute;
/**
 * Adds attribute options for specific attribute
 */
function addAttributeOptions(target, propertyName, options) {
    const attributes = getAttributes(target);
    if (!attributes || !attributes[propertyName]) {
        throw new Error(`@Column annotation is missing for "${propertyName}" of class "${target.constructor.name}"` +
            ` or annotation order is wrong.`);
    }
    attributes[propertyName] = object_1.deepAssign(attributes[propertyName], options);
    setAttributes(target, attributes);
}
exports.addAttributeOptions = addAttributeOptions;
//# sourceMappingURL=attribute-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllowNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function AllowNull(...args) {
    if (args.length === 1) {
        const allowNull = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, { allowNull });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            allowNull: true
        });
    }
}
exports.AllowNull = AllowNull;
//# sourceMappingURL=allow-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comment = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified comment value for the annotated field
 */
function Comment(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            comment: value
        });
    };
}
exports.Comment = Comment;
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/default.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified default value for the annotated field
 */
function Default(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            defaultValue: value
        });
    };
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unique = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Unique(...args) {
    if (args.length === 1) {
        const [options] = args;
        return (_target, _propertyName) => {
            annotate(_target, _propertyName, options);
        };
    }
    const [target, propertyName] = args;
    annotate(target, propertyName);
}
exports.Unique = Unique;
function annotate(target, propertyName, option = true) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        unique: option,
    });
}
//# sourceMappingURL=unique.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Column = void 0;
const attribute_service_1 = __webpack_require__(/*! ./attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Column(...args) {
    // In case of no specified options, we infer the
    // sequelize data type by the type of the property
    if (args.length >= 2) {
        const target = args[0];
        const propertyName = args[1];
        const propertyDescriptor = args[2];
        annotate(target, propertyName, propertyDescriptor);
        return;
    }
    return (target, propertyName, propertyDescriptor) => {
        annotate(target, propertyName, propertyDescriptor, args[0]);
    };
}
exports.Column = Column;
function annotate(target, propertyName, propertyDescriptor, optionsOrDataType = {}) {
    let options;
    if (data_type_service_1.isDataType(optionsOrDataType)) {
        options = {
            type: optionsOrDataType
        };
    }
    else {
        options = Object.assign({}, optionsOrDataType);
        if (!options.type) {
            options.type = model_service_1.getSequelizeTypeByDesignType(target, propertyName);
        }
    }
    if (propertyDescriptor) {
        if (propertyDescriptor.get) {
            options.get = propertyDescriptor.get;
        }
        if (propertyDescriptor.set) {
            options.set = propertyDescriptor.set;
        }
    }
    attribute_service_1.addAttribute(target, propertyName, options);
}
//# sourceMappingURL=column.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoIncrement = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets auto increment true for annotated field
 */
function AutoIncrement(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        autoIncrement: true
    });
}
exports.AutoIncrement = AutoIncrement;
//# sourceMappingURL=auto-increment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimaryKey = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets primary key option true for annotated property.
 */
function PrimaryKey(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        primaryKey: true
    });
}
exports.PrimaryKey = PrimaryKey;
//# sourceMappingURL=primary-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function CreatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        createdAt: propertyName,
        timestamps: true
    });
}
exports.CreatedAt = CreatedAt;
//# sourceMappingURL=created-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function DeletedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        deletedAt: propertyName,
        timestamps: true,
        paranoid: true
    });
}
exports.DeletedAt = DeletedAt;
//# sourceMappingURL=deleted-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function UpdatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        updatedAt: propertyName,
        timestamps: true
    });
}
exports.UpdatedAt = UpdatedAt;
//# sourceMappingURL=updated-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIndexDecorator = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function createIndexDecorator(options = {}) {
    let indexId;
    return ((...args) => {
        if (args.length >= 2) {
            const [target, propertyName] = args;
            const fieldOptions = { name: propertyName };
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
            return;
        }
        return (target, propertyName) => {
            const fieldOptions = Object.assign({ name: propertyName }, args[0]);
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
        };
    });
}
exports.createIndexDecorator = createIndexDecorator;
//# sourceMappingURL=create-index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-decorator.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.annotateModelWithIndex = exports.Index = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function Index(...args) {
    if (args.length >= 2) {
        const [target, propertyName] = args;
        annotateModelWithIndex(target, propertyName);
        return;
    }
    return (target, propertyName) => {
        annotateModelWithIndex(target, propertyName, args[0]);
    };
}
exports.Index = Index;
function annotateModelWithIndex(target, propertyName, optionsOrName = {}, indexId) {
    let indexOptions;
    let fieldOptions;
    if (typeof optionsOrName === 'string') {
        indexOptions = { name: optionsOrName };
        fieldOptions = { name: propertyName };
    }
    else {
        const { length, order, collate } = optionsOrName, rest = __rest(optionsOrName, ["length", "order", "collate"]);
        indexOptions = rest;
        fieldOptions = {
            name: propertyName,
            length,
            order,
            collate,
        };
    }
    return index_service_1.addFieldToIndex(target, fieldOptions, indexOptions, indexId);
}
exports.annotateModelWithIndex = annotateModelWithIndex;
//# sourceMappingURL=index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-service.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-service.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addFieldToIndex = exports.setIndexes = exports.getIndexes = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const INDEXES_KEY = 'sequelize:indexes';
/**
 * Returns model indexes from class by restoring this
 * information from reflect metadata
 */
function getIndexes(target) {
    const { named = {}, unnamed = [] } = Reflect.getMetadata(INDEXES_KEY, target) || {};
    return { named: Object.assign({}, named), unnamed: [...unnamed] };
}
exports.getIndexes = getIndexes;
/**
 * Sets indexes
 */
function setIndexes(target, indexes) {
    Reflect.defineMetadata(INDEXES_KEY, indexes, target);
}
exports.setIndexes = setIndexes;
/**
 * Adds field to index by sequelize index and index field options,
 * and stores this information through reflect metadata. Returns index ID.
 */
function addFieldToIndex(target, fieldOptions, indexOptions, indexId) {
    const indexes = getIndexes(target);
    const chosenId = typeof indexId !== 'undefined'
        ? indexId
        : indexOptions.name || indexes.unnamed.length;
    const indexStore = typeof chosenId === 'string'
        ? indexes.named
        : indexes.unnamed;
    if (!indexStore[chosenId])
        indexStore[chosenId] = Object.assign({}, indexOptions);
    const index = indexStore[chosenId];
    if (!index.fields)
        index.fields = [];
    index.fields.push(fieldOptions);
    setIndexes(target, indexes);
    return chosenId;
}
exports.addFieldToIndex = addFieldToIndex;
//# sourceMappingURL=index-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-action-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-count-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-get-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/model.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INFER_ALIAS_MAP = exports.Model = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const string_1 = __webpack_require__(/*! ../../shared/string */ "./node_modules/sequelize-typescript/dist/shared/string.js");
const alias_inference_service_1 = __webpack_require__(/*! ../../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
class Model extends sequelize_1.Model {
    constructor(values, options) {
        if (!new.target.isInitialized) {
            throw new model_not_initialized_error_1.ModelNotInitializedError(new.target, `${new.target.name} cannot be instantiated.`);
        }
        super(values, alias_inference_service_1.inferAlias(options, new.target));
    }
    static init(attributes, options) {
        this.isInitialized = true;
        // @ts-ignore
        return super.init(attributes, options);
    }
    /**
     * Adds relation between specified instances and source instance
     */
    $add(propertyKey, instances, options) {
        return this['add' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Sets relation between specified instances and source instance
     * (replaces old relations)
     */
    $set(propertyKey, instances, options) {
        return this['set' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Returns related instance (specified by propertyKey) of source instance
     */
    $get(propertyKey, options) {
        return this['get' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Counts related instances (specified by propertyKey) of source instance
     */
    $count(propertyKey, options) {
        return this['count' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Creates instances and relate them to source instance
     */
    $create(propertyKey, values, options) {
        return this['create' + string_1.capitalize(propertyKey)](values, options);
    }
    /**
     * Checks if specified instances is related to source instance
     */
    $has(propertyKey, instances, options) {
        return this['has' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Removes specified instances from source instance
     */
    $remove(propertyKey, instances, options) {
        return this['remove' + string_1.capitalize(propertyKey)](instances, options);
    }
    reload(options) {
        return super.reload(alias_inference_service_1.inferAlias(options, this));
    }
}
exports.Model = Model;
Model.isInitialized = false;
/**
 * Indicates which static methods of Model has to be proxied,
 * to prepare include option to automatically resolve alias;
 * The index represents the index of the options of the
 * corresponding method parameter
 */
exports.INFER_ALIAS_MAP = {
    bulkBuild: 1,
    build: 1,
    create: 1,
    aggregate: 2,
    all: 0,
    find: 0,
    findAll: 0,
    findAndCount: 0,
    findAndCountAll: 0,
    findById: 1,
    findByPrimary: 1,
    findCreateFind: 0,
    findOne: 0,
    findOrBuild: 0,
    findOrCreate: 0,
    findOrInitialize: 0,
    reload: 0,
};
const staticModelFunctionProperties = object_1.getAllPropertyNames(sequelize_1.Model)
    .filter(key => !isForbiddenMember(key) &&
    isFunctionMember(key, sequelize_1.Model) &&
    !isPrivateMember(key));
function isFunctionMember(propertyKey, target) {
    return typeof target[propertyKey] === 'function';
}
function isForbiddenMember(propertyKey) {
    const FORBIDDEN_KEYS = ['name', 'constructor', 'length', 'prototype', 'caller', 'arguments', 'apply',
        'queryInterface', 'queryGenerator', 'init', 'replaceHookAliases', 'refreshAttributes', 'inspect'];
    return FORBIDDEN_KEYS.indexOf(propertyKey) !== -1;
}
function isPrivateMember(propertyKey) {
    return (propertyKey.charAt(0) === '_');
}
function addThrowNotInitializedProxy() {
    staticModelFunctionProperties
        .forEach(key => {
        const superFn = Model[key];
        Model[key] = function (...args) {
            if (!this.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(this, `Member "${key}" cannot be called.`);
            }
            return superFn.call(this, ...args);
        };
    });
}
function addInferAliasOverrides() {
    Object
        .keys(exports.INFER_ALIAS_MAP)
        .forEach(key => {
        const optionIndex = exports.INFER_ALIAS_MAP[key];
        const superFn = Model[key];
        Model[key] = function (...args) {
            args[optionIndex] = alias_inference_service_1.inferAlias(args[optionIndex], this);
            return superFn.call(this, ...args);
        };
    });
}
addThrowNotInitializedProxy();
addInferAliasOverrides();
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=model-class-getter.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelNotInitializedError = void 0;
class ModelNotInitializedError extends Error {
    constructor(modelClass, additionalMessage) {
        super();
        this.message = `Model not initialized: ${additionalMessage} "${modelClass.name}" ` +
            `needs to be added to a Sequelize instance.`;
    }
}
exports.ModelNotInitializedError = ModelNotInitializedError;
//# sourceMappingURL=model-not-initialized-error.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModelGetter = exports.getSequelizeTypeByDesignType = exports.addOptions = exports.setOptions = exports.getOptions = exports.getModelName = exports.setModelName = void 0;
const model_1 = __webpack_require__(/*! ../model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const MODEL_NAME_KEY = 'sequelize:modelName';
const OPTIONS_KEY = 'sequelize:options';
/**
 * Sets model name from class by storing this
 * information through reflect metadata
 */
function setModelName(target, modelName) {
    Reflect.defineMetadata(MODEL_NAME_KEY, modelName, target);
}
exports.setModelName = setModelName;
/**
 * Returns model name from class by restoring this
 * information from reflect metadata
 */
function getModelName(target) {
    return Reflect.getMetadata(MODEL_NAME_KEY, target);
}
exports.getModelName = getModelName;
/**
 * Returns sequelize define options from class prototype
 * by restoring this information from reflect metadata
 */
function getOptions(target) {
    const options = Reflect.getMetadata(OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
}
exports.getOptions = getOptions;
/**
 * Sets seuqlize define options to class prototype
 */
function setOptions(target, options) {
    Reflect.defineMetadata(OPTIONS_KEY, Object.assign({}, options), target);
}
exports.setOptions = setOptions;
/**
 * Adds options be assigning new options to old one
 */
function addOptions(target, options) {
    let _options = getOptions(target);
    if (!_options) {
        _options = {};
    }
    setOptions(target, Object.assign(Object.assign(Object.assign({}, _options), options), { validate: Object.assign(Object.assign({}, (_options.validate || {})), (options.validate || {})) }));
}
exports.addOptions = addOptions;
/**
 * Maps design types to sequelize data types;
 * @throws if design type cannot be automatically mapped to
 * a sequelize data type
 */
function getSequelizeTypeByDesignType(target, propertyName) {
    const type = Reflect.getMetadata('design:type', target, propertyName);
    const dataType = data_type_service_1.inferDataType(type);
    if (dataType) {
        return dataType;
    }
    throw new Error(`Specified type of property '${propertyName}'
            cannot be automatically resolved to a sequelize data type. Please
            define the data type manually`);
}
exports.getSequelizeTypeByDesignType = getSequelizeTypeByDesignType;
/**
 * Resolves all model getters of specified options object
 * recursively.
 * So that {model: () => Person} will be converted to
 * {model: Person}
 */
function resolveModelGetter(options) {
    const maybeModelGetter = value => typeof value === 'function' && value.length === 0;
    const isModel = value => value && value.prototype && value.prototype instanceof model_1.Model;
    const isOptionObjectOrArray = value => value && typeof value === 'object';
    return Object
        .keys(options)
        .reduce((acc, key) => {
        const value = options[key];
        if (maybeModelGetter(value)) {
            const maybeModel = value();
            if (isModel(maybeModel)) {
                acc[key] = maybeModel;
            }
        }
        else if (isOptionObjectOrArray(value)) {
            acc[key] = resolveModelGetter(value);
        }
        return acc;
    }, Array.isArray(options) ? [...options] : Object.assign({}, options));
}
exports.resolveModelGetter = resolveModelGetter;
//# sourceMappingURL=model-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = void 0;
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Table(arg) {
    if (typeof arg === 'function') {
        annotate(arg);
    }
    else {
        const options = Object.assign({}, arg);
        return (target) => annotate(target, options);
    }
}
exports.Table = Table;
function annotate(target, options = {}) {
    model_service_1.setModelName(target.prototype, options.modelName || target.name);
    model_service_1.addOptions(target.prototype, options);
}
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/default-scope.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultScope = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining default Model scope
 */
function DefaultScope(scopeOrSsopeGetter) {
    return (target) => {
        if (typeof scopeOrSsopeGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, { getDefaultScope: scopeOrSsopeGetter });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, { defaultScope: scopeOrSsopeGetter });
        }
    };
}
exports.DefaultScope = DefaultScope;
//# sourceMappingURL=default-scope.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-options.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-service.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getScopeOptions = exports.addScopeOptions = exports.resolvesDeprecatedScopes = exports.setScopeOptionsGetters = exports.getScopeOptionsGetters = exports.addScopeOptionsGetter = exports.resolveScope = exports.resolveScopes = void 0;
const object_1 = __webpack_require__(/*! ../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const alias_inference_service_1 = __webpack_require__(/*! ../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const SCOPES_KEY = 'sequelize:scopes';
const SCOPES_OPTIONS_KEY = 'sequelize:scopes-options';
/**
 * Resolves scopes and adds them to the specified models
 */
function resolveScopes(models) {
    models.forEach(model => {
        exports.resolvesDeprecatedScopes(model);
        const { getDefaultScope, getScopes } = exports.getScopeOptionsGetters(model.prototype);
        let options = {};
        if (getDefaultScope) {
            options = Object.assign(Object.assign({}, options), { defaultScope: getDefaultScope() });
        }
        if (getScopes) {
            options = Object.assign(Object.assign({}, options), getScopes());
        }
        Object
            .keys(options)
            .forEach(key => exports.resolveScope(key, model, options[key]));
    });
}
exports.resolveScopes = resolveScopes;
const resolveScope = (scopeName, model, options) => {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(options, model);
    }
    model.addScope(scopeName, options, { override: true });
};
exports.resolveScope = resolveScope;
const addScopeOptionsGetter = (target, options) => {
    const currentOptions = exports.getScopeOptionsGetters(target) || {};
    exports.setScopeOptionsGetters(target, Object.assign(Object.assign({}, currentOptions), options));
};
exports.addScopeOptionsGetter = addScopeOptionsGetter;
const getScopeOptionsGetters = (target) => {
    const options = Reflect.getMetadata(SCOPES_OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
    return {};
};
exports.getScopeOptionsGetters = getScopeOptionsGetters;
const setScopeOptionsGetters = (target, options) => {
    Reflect.defineMetadata(SCOPES_OPTIONS_KEY, options, target);
};
exports.setScopeOptionsGetters = setScopeOptionsGetters;
/**
 * @deprecated
 */
const resolvesDeprecatedScopes = (model) => {
    const options = getScopeOptions(model.prototype) || {};
    Object
        .keys(options)
        .forEach(key => resolveDeprecatedScope(key, model, options[key]));
};
exports.resolvesDeprecatedScopes = resolvesDeprecatedScopes;
/**
 * Adds scope option meta data for specified prototype
 * @deprecated
 */
function addScopeOptions(target, options) {
    const _options = getScopeOptions(target) || {};
    setScopeOptions(target, object_1.deepAssign({}, _options, options));
}
exports.addScopeOptions = addScopeOptions;
/**
 * Returns scope option meta data from specified target
 * @deprecated
 */
function getScopeOptions(target) {
    const options = Reflect.getMetadata(SCOPES_KEY, target);
    if (options) {
        return object_1.deepAssign({}, options);
    }
}
exports.getScopeOptions = getScopeOptions;
/**
 * @deprecated
 */
function resolveDeprecatedScope(scopeName, model, options) {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(model_service_1.resolveModelGetter(options), model);
    }
    model.addScope(scopeName, options, { override: true });
}
/**
 * Set scope option meta data for specified prototype
 * @deprecated
 */
function setScopeOptions(target, options) {
    Reflect.defineMetadata(SCOPES_KEY, options, target);
}
//# sourceMappingURL=scope-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scopes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scopes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scopes = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining Model scopes
 */
function Scopes(scopesOrScopesGetter) {
    return (target) => {
        if (typeof scopesOrScopesGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, {
                getScopes: scopesOrScopesGetter,
            });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, scopesOrScopesGetter);
        }
    };
}
exports.Scopes = Scopes;
//# sourceMappingURL=scopes.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferDataType = exports.isDataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
/*
 * Checks if specified value is a sequelize data type (ABSTRACT, STRING...)
 */
function isDataType(value) {
    return typeof value === 'string' ||
        (typeof value === 'function' && value({}) instanceof sequelize_1.DataTypes.ABSTRACT) ||
        value instanceof sequelize_1.DataTypes.ABSTRACT;
}
exports.isDataType = isDataType;
/**
 * Infers sequelize data type by design type
 */
function inferDataType(designType) {
    switch (designType) {
        case String:
            return sequelize_1.DataTypes.STRING;
        case BigInt:
            return sequelize_1.DataTypes.BIGINT;
        case Number:
            return sequelize_1.DataTypes.INTEGER;
        case Boolean:
            return sequelize_1.DataTypes.BOOLEAN;
        case Date:
            return sequelize_1.DataTypes.DATE;
        case Buffer:
            return sequelize_1.DataTypes.BLOB;
        default:
            return void 0;
    }
}
exports.inferDataType = inferDataType;
//# sourceMappingURL=data-type-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
exports.DataType = sequelize_1.DataTypes;
//# sourceMappingURL=data-type.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=repository.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=sequelize-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getModels = exports.prepareArgs = exports.prepareOptions = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const glob = __webpack_require__(/*! glob */ "glob");
const array_1 = __webpack_require__(/*! ../../shared/array */ "./node_modules/sequelize-typescript/dist/shared/array.js");
/**
 * Prepares sequelize config passed to original sequelize constructor
 */
function prepareOptions(options) {
    if (options.validateOnly) {
        return getValidationOnlyOptions(options);
    }
    return Object.assign({}, options);
}
exports.prepareOptions = prepareOptions;
function prepareArgs(...args) {
    const lastArg = args[args.length - 1];
    const options = lastArg && typeof lastArg === 'object'
        ? prepareOptions(lastArg) : undefined;
    if (options) {
        args[args.length - 1] = options;
    }
    return { preparedArgs: args, options };
}
exports.prepareArgs = prepareArgs;
function getValidationOnlyOptions(options) {
    return Object.assign(Object.assign({}, options), { dialect: 'sqlite', dialectModulePath: __dirname + '/../validation-only/db-dialect-dummy' });
}
/**
 * Determines models from value
 */
function getModels(arg, modelMatch) {
    const hasSupportedExtension = path => ['.ts', '.js'].indexOf(path_1.extname(path)) !== -1;
    if (arg && typeof arg[0] === 'string') {
        return arg.reduce((models, dir) => {
            if (!glob.hasMagic(dir) && !hasSupportedExtension(dir))
                dir = path_1.join(dir, '/*');
            const _models = glob
                .sync(dir)
                .filter(isImportable)
                .map(getFullfilepathWithoutExtension)
                .filter(array_1.uniqueFilter)
                .map(fullPath => {
                const module = __webpack_require__("./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive")(fullPath);
                const fileName = path_1.basename(fullPath);
                const matchedMemberKey = Object.keys(module).find(m => modelMatch(fileName, m));
                const matchedMember = matchedMemberKey ? module[matchedMemberKey] : undefined;
                if (!matchedMember && !module.default) {
                    throw new Error(`No default export defined for file "${fileName}" or ` +
                        `export does not satisfy filename.`);
                }
                return matchedMember || module.default;
            });
            models.push(..._models);
            return models;
        }, []);
    }
    return arg;
}
exports.getModels = getModels;
/**
 * Checks if specified filename is importable or not;
 * Which means that, it needs to have a specific file extension
 */
function isImportable(file) {
    const filePart = file.slice(-3);
    return filePart === '.js' || (filePart === '.ts' && file.slice(-5) !== '.d.ts');
}
/**
 * Return the value of the full path with filename, without extension
 */
function getFullfilepathWithoutExtension(file) {
    const parsedFile = path_1.parse(file);
    return path_1.join(parsedFile.dir, parsedFile.name);
}
//# sourceMappingURL=sequelize-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sequelize = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const sequelize_service_1 = __webpack_require__(/*! ./sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js");
const model_service_1 = __webpack_require__(/*! ../../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const scope_service_1 = __webpack_require__(/*! ../../scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
const hooks_service_1 = __webpack_require__(/*! ../../hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
const association_service_1 = __webpack_require__(/*! ../../associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const attribute_service_1 = __webpack_require__(/*! ../../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const index_service_1 = __webpack_require__(/*! ../../model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
class Sequelize extends sequelize_1.Sequelize {
    constructor(...args) {
        const { preparedArgs, options } = sequelize_service_1.prepareArgs(...args);
        super(...preparedArgs);
        if (options) {
            this.repositoryMode = !!options.repositoryMode;
            if (options.models)
                this.addModels(options.models);
            if (options.modelPaths)
                this.addModels(options.modelPaths);
        }
        else {
            this.repositoryMode = false;
        }
    }
    model(model) {
        if (typeof model !== 'string') {
            return super.model(model_service_1.getModelName(model.prototype));
        }
        return super.model(model);
    }
    addModels(arg, modelMatch) {
        const defaultModelMatch = (filename, member) => filename === member;
        const models = sequelize_service_1.getModels(arg, modelMatch || this.options.modelMatch || defaultModelMatch);
        const definedModels = this.defineModels(models);
        this.associateModels(definedModels);
        scope_service_1.resolveScopes(definedModels);
        hooks_service_1.installHooks(definedModels);
    }
    getRepository(modelClass) {
        return this.model(modelClass);
    }
    associateModels(models) {
        models.forEach(model => {
            const associations = association_service_1.getAssociations(model.prototype);
            if (!associations)
                return;
            associations.forEach(association => {
                const options = association.getSequelizeOptions(model, this);
                const associatedClass = this.model(association.getAssociatedClass());
                if (!associatedClass.isInitialized) {
                    throw new model_not_initialized_error_1.ModelNotInitializedError(associatedClass, `Association between ${associatedClass.name} and ${model.name} cannot be resolved.`);
                }
                model[association.getAssociation()](associatedClass, options);
            });
        });
    }
    defineModels(models) {
        return models.map(model => {
            const modelName = model_service_1.getModelName(model.prototype);
            const attributes = attribute_service_1.getAttributes(model.prototype);
            const indexes = index_service_1.getIndexes(model.prototype);
            const modelOptions = model_service_1.getOptions(model.prototype);
            if (!modelOptions)
                throw new Error(`@Table annotation is missing on class "${model['name']}"`);
            const indexArray = Object.keys(indexes.named)
                .map(key => indexes.named[key])
                .concat(indexes.unnamed);
            const initOptions = Object.assign(Object.assign(Object.assign({}, (indexArray.length > 0 && { indexes: indexArray })), modelOptions), { modelName, sequelize: this });
            const definedModel = this.repositoryMode
                ? this.createRepositoryModel(model)
                : model;
            definedModel.init(attributes, initOptions);
            return definedModel;
        });
    }
    createRepositoryModel(modelClass) {
        return class extends modelClass {
        };
    }
}
exports.Sequelize = Sequelize;
//# sourceMappingURL=sequelize.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/ sync ***!
  \**************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Dummy database file, which gets required by sequelize, to
 * make validation of models possible without using the
 * actual ORM or any database connection.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verbose = void 0;
function verbose() {
    return {};
}
exports.verbose = verbose;
//# sourceMappingURL=db-dialect-dummy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueFilter = exports.unique = void 0;
/**
 * Removes duplicates from specified array
 */
function unique(arr) {
    return arr.filter(exports.uniqueFilter);
}
exports.unique = unique;
/**
 * Returns true for items, that only exists once on an array
 */
const uniqueFilter = (item, index, arr) => arr.indexOf(item) === index;
exports.uniqueFilter = uniqueFilter;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/object.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllPropertyNames = exports.cloneRegExp = exports.deepAssign = void 0;
function deepAssign(target, ...sources) {
    sources.forEach(source => {
        Object
            .getOwnPropertyNames(source)
            .forEach(key => assign(key, target, source));
        /* istanbul ignore next */
        if (Object.getOwnPropertySymbols) {
            Object
                .getOwnPropertySymbols(source)
                .forEach(key => assign(key, target, source));
        }
    });
    return target;
    function assign(key, _target, _source) {
        const sourceValue = _source[key];
        if (sourceValue !== void 0) {
            let targetValue = _target[key];
            if (Array.isArray(sourceValue)) {
                if (!Array.isArray(targetValue)) {
                    targetValue = [];
                }
                const length = targetValue.length;
                sourceValue.forEach((_, index) => assign(length + index, targetValue, sourceValue));
            }
            else if (typeof sourceValue === 'object') {
                if (sourceValue instanceof RegExp) {
                    targetValue = cloneRegExp(sourceValue);
                }
                else if (sourceValue instanceof Date) {
                    targetValue = new Date(sourceValue);
                }
                else if (sourceValue === null) {
                    targetValue = null;
                }
                else {
                    if (!targetValue) {
                        targetValue = Object.create(sourceValue.constructor.prototype);
                    }
                    deepAssign(targetValue, sourceValue);
                }
            }
            else {
                targetValue = sourceValue;
            }
            _target[key] = targetValue;
        }
    }
}
exports.deepAssign = deepAssign;
/**
 * I clone the given RegExp object, and ensure that the given flags exist on
 * the clone. The injectFlags parameter is purely additive - it cannot remove
 * flags that already exist on the
 *
 * @param input RegExp - I am the regular expression object being cloned.
 * @param injectFlags String( Optional ) - I am the flags to enforce on the clone.
 * @source https://www.bennadel.com/blog/2664-cloning-regexp-regular-expression-objects-in-javascript.htm
 */
function cloneRegExp(input, injectFlags) {
    const pattern = input.source;
    let flags = "";
    // Make sure the parameter is a defined string - it will make the conditional
    // logic easier to read.
    injectFlags = (injectFlags || "");
    // Test for global.
    if (input.global || (/g/i).test(injectFlags)) {
        flags += "g";
    }
    // Test for ignoreCase.
    if (input.ignoreCase || (/i/i).test(injectFlags)) {
        flags += "i";
    }
    // Test for multiline.
    if (input.multiline || (/m/i).test(injectFlags)) {
        flags += "m";
    }
    // Return a clone with the additive flags.
    return (new RegExp(pattern, flags));
}
exports.cloneRegExp = cloneRegExp;
function getAllPropertyNames(obj) {
    const names = [];
    const exists = {};
    do {
        names.push.apply(names, Object.getOwnPropertyNames(obj));
        obj = Object.getPrototypeOf(obj);
    } while (obj !== Object.prototype);
    return names.filter(name => {
        const isValid = !exists[name] && name !== 'constructor';
        exists[name] = true;
        return isValid;
    });
}
exports.getAllPropertyNames = getAllPropertyNames;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/string.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.capitalize = void 0;
/**
 * Capitalize specified string value
 */
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.substr(1, value.length);
}
exports.capitalize = capitalize;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/contains.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/contains.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Contains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Force specific substrings
 */
function Contains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            contains: value
        }
    });
}
exports.Contains = Contains;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/equals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/equals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Equals = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow a specific value
 */
function Equals(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            equals: value
        }
    });
}
exports.Equals = Equals;
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-after.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-after.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAfter = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings after a specific date
 */
function IsAfter(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAfter: date
        }
    });
}
exports.IsAfter = IsAfter;
//# sourceMappingURL=is-after.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alpha.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlpha = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow letters
 */
function IsAlpha(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlpha: true
        }
    });
}
exports.IsAlpha = IsAlpha;
//# sourceMappingURL=is-alpha.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlphanumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow alphanumeric characters, so "_abc" will fail
 */
function IsAlphanumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlphanumeric: true
        }
    });
}
exports.IsAlphanumeric = IsAlphanumeric;
//# sourceMappingURL=is-alphanumeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-array.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsArray = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow arrays
 */
function IsArray(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isArray: true
        }
    });
}
exports.IsArray = IsArray;
//# sourceMappingURL=is-array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-before.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-before.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsBefore = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings before a specific date
 */
function IsBefore(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isBefore: date
        }
    });
}
exports.IsBefore = IsBefore;
//# sourceMappingURL=is-before.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-credit-card.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsCreditCard = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check for valid credit card numbers
 */
function IsCreditCard(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isCreditCard: true
        }
    });
}
exports.IsCreditCard = IsCreditCard;
//# sourceMappingURL=is-credit-card.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-date.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-date.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings
 */
function IsDate(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDate: true
        }
    });
}
exports.IsDate = IsDate;
//# sourceMappingURL=is-date.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-decimal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDecimal = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for any numbers
 */
function IsDecimal(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDecimal: true
        }
    });
}
exports.IsDecimal = IsDecimal;
//# sourceMappingURL=is-decimal.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-email.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-email.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsEmail = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for email format (foo@bar.com)
 */
function IsEmail(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isEmail: true
        }
    });
}
exports.IsEmail = IsEmail;
//# sourceMappingURL=is-email.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-float.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-float.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsFloat = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid floating point numbers
 */
function IsFloat(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isFloat: true
        }
    });
}
exports.IsFloat = IsFloat;
//# sourceMappingURL=is-float.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-in.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-in.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is one of these
 */
function IsIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIn: arg
        }
    });
}
exports.IsIn = IsIn;
//# sourceMappingURL=is-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-int.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-int.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsInt = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid integers
 */
function IsInt(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isInt: true
        }
    });
}
exports.IsInt = IsInt;
//# sourceMappingURL=is-int.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv4 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1)
 */
function IsIPv4(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv4: true
        }
    });
}
exports.IsIPv4 = IsIPv4;
//# sourceMappingURL=is-ip-v4.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv6 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv6 format
 */
function IsIPv6(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv6: true
        }
    });
}
exports.IsIPv6 = IsIPv6;
//# sourceMappingURL=is-ip-v6.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIP = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1) or IPv6 format
 */
function IsIP(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIP: true
        }
    });
}
exports.IsIP = IsIP;
//# sourceMappingURL=is-ip.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-lowercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsLowercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for lowercase
 */
function IsLowercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isLowercase: true
        }
    });
}
exports.IsLowercase = IsLowercase;
//# sourceMappingURL=is-lowercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-null.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-null.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allows null
 */
function IsNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNull: true
        }
    });
}
exports.IsNull = IsNull;
//# sourceMappingURL=is-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-numeric.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow numbers
 */
function IsNumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNumeric: true
        }
    });
}
exports.IsNumeric = IsNumeric;
//# sourceMappingURL=is-numeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uppercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUppercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for uppercase
 */
function IsUppercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUppercase: true
        }
    });
}
exports.IsUppercase = IsUppercase;
//# sourceMappingURL=is-uppercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUrl = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for url format (http://foo.com)
 */
function IsUrl(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUrl: true
        }
    });
}
exports.IsUrl = IsUrl;
//# sourceMappingURL=is-url.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uuid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUUID = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/*
 * Only allow uuids.
 * Version's regular expressions:
 * https://github.com/chriso/validator.js/blob/b59133b1727b6af355b403a9a97a19226cceb34b/lib/isUUID.js#L14-L19.
 */
function IsUUID(version) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUUID: version
        }
    });
}
exports.IsUUID = IsUUID;
//# sourceMappingURL=is-uuid.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Is = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Is(...args) {
    const options = {};
    const argIsFunction = typeof args[0] === 'function';
    if (argIsFunction || (typeof args[0] === 'string' && typeof args[1] === 'function')) {
        let validator;
        let name;
        if (argIsFunction) {
            validator = args[0];
            name = validator.name;
            if (!name)
                throw new Error(`Passed validator function must have a name`);
        }
        else {
            name = args[0];
            validator = args[1];
        }
        options[`is${name.charAt(0).toUpperCase() + name.substr(1, name.length)}`] = validator;
    }
    else {
        options.is = args[0];
    }
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Is = Is;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/length.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Length = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values with length between min and max
 */
function Length({ msg, min, max }) {
    let options;
    const length = [min || 0, max];
    options = msg ? { args: length, msg: msg } : length;
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            len: options
        }
    });
}
exports.Length = Length;
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/max.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/max.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Max = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values <= limit
 */
function Max(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            max: limit
        }
    });
}
exports.Max = Max;
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/min.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/min.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Min = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values >= limit
 */
function Min(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            min: limit
        }
    });
}
exports.Min = Min;
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-contains.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-contains.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotContains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Don't allow specific substrings
 */
function NotContains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notContains: value
        }
    });
}
exports.NotContains = NotContains;
//# sourceMappingURL=not-contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-empty.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-empty.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotEmpty = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function NotEmpty(...args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: options,
            }
        });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: true
            }
        });
    }
}
exports.NotEmpty = NotEmpty;
//# sourceMappingURL=not-empty.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-in.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-in.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is not one of these
 */
function NotIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notIn: arg
        }
    });
}
exports.NotIn = NotIn;
//# sourceMappingURL=not-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-null.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-null.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Won't allow null
 */
function NotNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notNull: true
        }
    });
}
exports.NotNull = NotNull;
//# sourceMappingURL=not-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Not = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will not allow values, that match the string regex or real regex
 */
function Not(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            not: arg
        }
    });
}
exports.Not = Not;
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets validation options for annotated field
 */
function Validate(options) {
    options = Object.assign({}, options);
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Validate = Validate;
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = void 0;
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const Validator = (target, propertyName, descriptor) => {
    model_service_1.addOptions(target, {
        validate: {
            [propertyName]: descriptor.value
        }
    });
};
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "./node_modules/sequelize/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sequelize/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
  * The entry point.
  *
  * @module Sequelize
  */
module.exports = __webpack_require__(/*! ./lib/sequelize */ "./node_modules/sequelize/lib/sequelize.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/base.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { AssociationError } = __webpack_require__(/*! ./../errors */ "./node_modules/sequelize/lib/errors/index.js");

/**
 * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).
 *
 * * hasOne - adds a foreign key to the target and singular association mixins to the source.
 * * belongsTo - add a foreign key and singular association mixins to the source.
 * * hasMany - adds a foreign key to target and plural association mixins to the source.
 * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.
 *
 * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.
 *
 * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.
 *
 * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.
 *
 * ```js
 * User.hasMany(Picture)
 * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })
 *
 * user.getPictures() // gets you all pictures
 * user.getProfilePicture() // gets you only the profile picture
 *
 * User.findAll({
 *   where: ...,
 *   include: [
 *     { model: Picture }, // load all pictures
 *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture.
 *     // Notice that the spelling must be the exact same as the one in the association
 *   ]
 * })
 * ```
 * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,
 * equivalent to those passed to `sequelize.define`.
 *
 * ```js
 * User.hasMany(Picture, { foreignKey: 'uid' })
 * ```
 *
 * The foreign key column in Picture will now be called `uid` instead of the default `userId`.
 *
 * ```js
 * User.hasMany(Picture, {
 *   foreignKey: {
 *     name: 'uid',
 *     allowNull: false
 *   }
 * })
 * ```
 *
 * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).
 *
 * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:
 *
 * ```js
 * user.getPictures({
 *   where: {
 *     format: 'jpg'
 *   }
 * })
 * ```
 *
 * There are several ways to update and add new associations. Continuing with our example of users and pictures:
 * ```js
 * user.addPicture(p) // Add a single picture
 * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted
 * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations
 * ```
 *
 * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:
 *
 * ```js
 * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture
 * ```
 *
 * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.
 *
 * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.
 */
class Association {
  constructor(source, target, options = {}) {
    /**
     * @type {Model}
     */
    this.source = source;

    /**
     * @type {Model}
     */
    this.target = target;

    this.options = options;
    this.scope = options.scope;
    this.isSelfAssociation = this.source === this.target;
    this.as = options.as;

    /**
     * The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`
     *
     * @type {string}
     */
    this.associationType = '';

    if (source.hasAlias(options.as)) {
      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. ` +
      'Aliased associations must have unique aliases.'
      );
    }
  }

  /**
   * Normalize input
   *
   * @param {Array|string} input it may be array or single obj, instance or primary key
   *
   * @private
   * @returns {Array} built objects
   */
  toInstanceArray(input) {
    if (!Array.isArray(input)) {
      input = [input];
    }

    return input.map(element => {
      if (element instanceof this.target) return element;

      const tmpInstance = {};
      tmpInstance[this.target.primaryKeyAttribute] = element;

      return this.target.build(tmpInstance, { isNewRecord: false });
    });
  }

  [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.as;
  }
}

module.exports = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const AssociationError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").AssociationError;
const EmptyResultError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").EmptyResultError;
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * Many-to-many association with a join table.
 *
 * When the join table has additional attributes, these can be passed in the options object:
 *
 * ```js
 * UserProject = sequelize.define('user_project', {
 *   role: Sequelize.STRING
 * });
 * User.belongsToMany(Project, { through: UserProject });
 * Project.belongsToMany(User, { through: UserProject });
 * // through is required!
 *
 * user.addProject(project, { through: { role: 'manager' }});
 * ```
 *
 * All methods allow you to pass either a persisted instance, its primary key, or a mixture:
 *
 * ```js
 * const project = await Project.create({ id: 11 });
 * await user.addProjects([project, 12]);
 * ```
 *
 * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:
 *
 * ```js
 * p1.UserProjects = {
 *   started: true
 * }
 * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.
 * ```
 *
 * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.
 * ```js
 * const projects = await user.getProjects();
 * const p1 = projects[0];
 * p1.UserProjects.started // Is this project started yet?
 * })
 * ```
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.
 *
 * @see {@link Model.belongsToMany}
 */
class BelongsToMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {
      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);
    }

    if (!this.options.through.model) {
      this.options.through = {
        model: options.through
      };
    }

    this.associationType = 'BelongsToMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.through = { ...this.options.through };
    this.isMultiAssociation = true;
    this.doubleLinked = false;

    if (!this.as && this.isSelfAssociation) {
      throw new AssociationError('\'as\' must be defined for many-to-many self-associations');
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    this.combinedTableName = Utils.combineTableNames(
      this.source.tableName,
      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName
    );

    /*
    * If self association, this is the target association - Unless we find a pairing association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    /*
    * Find paired association (if exists)
    */
    _.each(this.target.associations, association => {
      if (association.associationType !== 'BelongsToMany') return;
      if (association.target !== this.source) return;

      if (this.options.through.model === association.options.through.model) {
        this.paired = association;
        association.paired = this;
      }
    });

    /*
    * Default/generated source/target keys
    */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    if (this.options.targetKey) {
      this.targetKey = this.options.targetKey;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    } else {
      this.targetKeyDefault = true;
      this.targetKey = this.target.primaryKeyAttribute;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    }

    this._createForeignAndOtherKeys();

    if (typeof this.through.model === 'string') {
      if (!this.sequelize.isDefined(this.through.model)) {
        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {
          tableName: this.through.model,
          indexes: [], //we don't want indexes here (as referenced in #2416)
          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)
          validate: {} // Don't propagate model-level validations
        }));
      } else {
        this.through.model = this.sequelize.model(this.through.model);
      }
    }

    Object.assign(this.options, _.pick(this.through.model.options, [
      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'
    ]));

    if (this.paired) {
      let needInjectPaired = false;

      if (this.targetKeyDefault) {
        this.targetKey = this.paired.sourceKey;
        this.targetKeyField = this.paired.sourceKeyField;
        this._createForeignAndOtherKeys();
      }
      if (this.paired.targetKeyDefault) {
        // in this case paired.otherKey depends on paired.targetKey,
        // so cleanup previously wrong generated otherKey
        if (this.paired.targetKey !== this.sourceKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.targetKey = this.sourceKey;
          this.paired.targetKeyField = this.sourceKeyField;
          this.paired._createForeignAndOtherKeys();
          needInjectPaired = true;
        }
      }

      if (this.otherKeyDefault) {
        this.otherKey = this.paired.foreignKey;
      }
      if (this.paired.otherKeyDefault) {
        // If paired otherKey was inferred we should make sure to clean it up
        // before adding a new one that matches the foreignKey
        if (this.paired.otherKey !== this.foreignKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.otherKey = this.foreignKey;
          needInjectPaired = true;
        }
      }

      if (needInjectPaired) {
        this.paired._injectAttributes();
      }
    }

    if (this.through) {
      this.throughModel = this.through.model;
    }

    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;

    this.associationAccessor = this.as;

    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  _createForeignAndOtherKeys() {
    /*
    * Default/generated foreign/other keys
    */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else {
      this.foreignKeyAttribute = {};
      this.foreignKey = this.options.foreignKey || Utils.camelize(
        [
          this.source.options.name.singular,
          this.sourceKey
        ].join('_')
      );
    }

    if (_.isObject(this.options.otherKey)) {
      this.otherKeyAttribute = this.options.otherKey;
      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;
    } else {
      if (!this.options.otherKey) {
        this.otherKeyDefault = true;
      }

      this.otherKeyAttribute = {};
      this.otherKey = this.options.otherKey || Utils.camelize(
        [
          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,
          this.targetKey
        ].join('_')
      );
    }
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    this.identifier = this.foreignKey;
    this.foreignIdentifier = this.otherKey;

    // remove any PKs previously defined by sequelize
    // but ignore any keys that are part of this association (#5865)
    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {
      if (attribute.primaryKey === true && attribute._autoGenerated === true) {
        if (attributeName === this.foreignKey || attributeName === this.otherKey) {
          // this key is still needed as it's part of the association
          // so just set primaryKey to false
          attribute.primaryKey = false;
        }
        else {
          delete this.through.model.rawAttributes[attributeName];
        }
        this.primaryKeyDeleted = true;
      }
    });

    const sourceKey = this.source.rawAttributes[this.sourceKey];
    const sourceKeyType = sourceKey.type;
    const sourceKeyField = this.sourceKeyField;
    const targetKey = this.target.rawAttributes[this.targetKey];
    const targetKeyType = targetKey.type;
    const targetKeyField = this.targetKeyField;
    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };
    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };

    if (this.primaryKeyDeleted === true) {
      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;
    } else if (this.through.unique !== false) {
      let uniqueKey;
      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {
        uniqueKey = this.options.uniqueKey;
      } else {
        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');
      }
      targetAttribute.unique = sourceAttribute.unique = uniqueKey;
    }

    if (!this.through.model.rawAttributes[this.foreignKey]) {
      this.through.model.rawAttributes[this.foreignKey] = {
        _autoGenerated: true
      };
    }

    if (!this.through.model.rawAttributes[this.otherKey]) {
      this.through.model.rawAttributes[this.otherKey] = {
        _autoGenerated: true
      };
    }

    if (this.options.constraints !== false) {
      sourceAttribute.references = {
        model: this.source.getTableName(),
        key: sourceKeyField
      };
      // For the source attribute the passed option is the priority
      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;
      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;

      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';
      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';

      targetAttribute.references = {
        model: this.target.getTableName(),
        key: targetKeyField
      };
      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)
      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;
      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;

      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';
      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';
    }

    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);
    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);

    this.through.model.refreshAttributes();

    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;

    if (this.paired && !this.paired.foreignIdentifierField) {
      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;
    }

    this.toSource = new BelongsTo(this.through.model, this.source, {
      foreignKey: this.foreignKey
    });
    this.manyFromSource = new HasMany(this.source, this.through.model, {
      foreignKey: this.foreignKey
    });
    this.oneFromSource = new HasOne(this.source, this.through.model, {
      foreignKey: this.foreignKey,
      sourceKey: this.sourceKey,
      as: this.through.model.name
    });

    this.toTarget = new BelongsTo(this.through.model, this.target, {
      foreignKey: this.otherKey
    });
    this.manyFromTarget = new HasMany(this.target, this.through.model, {
      foreignKey: this.otherKey
    });
    this.oneFromTarget = new HasOne(this.target, this.through.model, {
      foreignKey: this.otherKey,
      sourceKey: this.targetKey,
      as: this.through.model.name
    });

    if (this.paired && this.paired.otherKeyDefault) {
      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {
        foreignKey: this.paired.otherKey
      });

      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {
        foreignKey: this.paired.otherKey,
        sourceKey: this.paired.targetKey,
        as: this.paired.through.model.name
      });
    }

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @see
   * {@link Model} for a full explanation of options
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   * @param {object} [options.through.where] An optional where clause applied to through model (join table)
   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instance, options) {
    options = Utils.cloneDeep(options) || {};

    const through = this.through;
    let scopeWhere;
    let throughWhere;

    if (this.scope) {
      scopeWhere = { ...this.scope };
    }

    options.where = {
      [Op.and]: [
        scopeWhere,
        options.where
      ]
    };

    if (Object(through.model) === through.model) {
      throughWhere = {};
      throughWhere[this.foreignKey] = instance.get(this.sourceKey);

      if (through.scope) {
        Object.assign(throughWhere, through.scope);
      }

      //If a user pass a where on the options through options, make an "and" with the current throughWhere
      if (options.through && options.through.where) {
        throughWhere = {
          [Op.and]: [throughWhere, options.through.where]
        };
      }

      options.include = options.include || [];
      options.include.push({
        association: this.oneFromTarget,
        attributes: options.joinTableAttributes,
        required: true,
        paranoid: _.get(options.through, 'paranoid', true),
        where: throughWhere
      });
    }

    let model = this.target;
    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        model = model.unscoped();
      } else {
        model = model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      model = model.schema(options.schema, options.schemaDelimiter);
    }

    return model.findAll(options);
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    const sequelize = this.target.sequelize;

    options = Utils.cloneDeep(options);
    options.attributes = [
      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']
    ];
    options.joinTableAttributes = [];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated
   *
   * @param {Model} sourceInstance source instance to check for an association with
   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise<boolean>}
   */
  async has(sourceInstance, instances, options) {
    if (!Array.isArray(instances)) {
      instances = [instances];
    }

    options = {
      raw: true,
      ...options,
      scope: false,
      attributes: [this.targetKey],
      joinTableAttributes: []
    };

    const instancePrimaryKeys = instances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.targetKey]: instance
      };
    });

    options.where = {
      [Op.and]: [
        { [Op.or]: instancePrimaryKeys },
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return _.differenceWith(instancePrimaryKeys, associatedObjects,
      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;
  }

  /**
   * Set the associated models by passing an array of instances or their primary keys.
   * Everything that it not in the passed array will be un-associated.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`
   * @param {object} [options.validate] Run validation for the join model
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async set(sourceInstance, newAssociatedObjects, options) {
    options = options || {};

    const sourceKey = this.sourceKey;
    const targetKey = this.targetKey;
    const identifier = this.identifier;
    const foreignIdentifier = this.foreignIdentifier;

    if (newAssociatedObjects === null) {
      newAssociatedObjects = [];
    } else {
      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);
    }
    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      ...this.through.scope
    };

    const updateAssociations = currentRows => {
      const obsoleteAssociations = [];
      const promises = [];
      const defaultAttributes = options.through || {};

      const unassociatedObjects = newAssociatedObjects.filter(obj =>
        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))
      );

      for (const currentRow of currentRows) {
        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));

        if (!newObj) {
          obsoleteAssociations.push(currentRow);
        } else {
          let throughAttributes = newObj[this.through.model.name];
          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
          if (throughAttributes instanceof this.through.model) {
            throughAttributes = {};
          }

          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).length) {
            promises.push(
              this.through.model.update(attributes, Object.assign(options, {
                where: {
                  [identifier]: sourceInstance.get(sourceKey),
                  [foreignIdentifier]: newObj.get(targetKey)
                }
              }
              ))
            );
          }
        }
      }

      if (obsoleteAssociations.length > 0) {
        promises.push(
          this.through.model.destroy({
            ...options,
            where: {
              [identifier]: sourceInstance.get(sourceKey),
              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),
              ...this.through.scope
            }
          })
        );
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          return {
            ...defaultAttributes,
            ...unassociatedObject[this.through.model.name],
            [identifier]: sourceInstance.get(sourceKey),
            [foreignIdentifier]: unassociatedObject.get(targetKey),
            ...this.through.scope
          };
        });

        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });
      return await updateAssociations(currentRows);
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations([]);
      throw error;
    }
  }

  /**
   * Associate one or several rows with source instance. It will not un-associate any already associated instance
   * that may be missing from `newInstances`.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`
   * @param {object} [options.validate] Run validation for the join model.
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, newInstances, options) {
    // If newInstances is null or undefined, no-op
    if (!newInstances) return Promise.resolve();

    options = { ...options };

    const association = this;
    const sourceKey = association.sourceKey;
    const targetKey = association.targetKey;
    const identifier = association.identifier;
    const foreignIdentifier = association.foreignIdentifier;
    const defaultAttributes = options.through || {};

    newInstances = association.toInstanceArray(newInstances);

    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),
      ...association.through.scope
    };

    const updateAssociations = currentRows => {
      const promises = [];
      const unassociatedObjects = [];
      const changedAssociations = [];
      for (const obj of newInstances) {
        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));

        if (!existingAssociation) {
          unassociatedObjects.push(obj);
        } else {
          const throughAttributes = obj[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {
            changedAssociations.push(obj);
          }
        }
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          const throughAttributes = unassociatedObject[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          attributes[identifier] = sourceInstance.get(sourceKey);
          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);

          Object.assign(attributes, association.through.scope);

          return attributes;
        });

        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      for (const assoc of changedAssociations) {
        let throughAttributes = assoc[association.through.model.name];
        const attributes = { ...defaultAttributes, ...throughAttributes };
        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
        if (throughAttributes instanceof association.through.model) {
          throughAttributes = {};
        }

        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {
          [identifier]: sourceInstance.get(sourceKey),
          [foreignIdentifier]: assoc.get(targetKey)
        } })));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });
      const [associations] = await updateAssociations(currentRows);
      return associations;
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations();
      throw error;
    }
  }

  /**
   * Un-associate one or more instance(s).
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `through.destroy`
   *
   * @returns {Promise}
   */
  remove(sourceInstance, oldAssociatedObjects, options) {
    const association = this;

    options = options || {};

    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);

    const where = {
      [association.identifier]: sourceInstance.get(association.sourceKey),
      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))
    };

    return association.through.model.destroy({ ...options, where });
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model
   * @param {object} [options] Options passed to create and add
   * @param {object} [options.through] Additional attributes for the join table
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options) {
    const association = this;

    options = options || {};
    values = values || {};

    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (association.scope) {
      Object.assign(values, association.scope);
      if (options.fields) {
        options.fields = options.fields.concat(Object.keys(association.scope));
      }
    }

    // Create the related model instance
    const newAssociatedObject = await association.target.create(values, options);

    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));
    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsToMany;
module.exports.BelongsToMany = BelongsToMany;
module.exports.default = BelongsToMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.
 *
 * @see {@link Model.belongsTo}
 */
class BelongsTo extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'BelongsTo';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.as,
          this.target.primaryKeyAttribute
        ].join('_')
      );
    }

    this.identifier = this.foreignKey;
    if (this.source.rawAttributes[this.identifier]) {
      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;
    }

    if (
      this.options.targetKey
      && !this.target.rawAttributes[this.options.targetKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.targetKey}" passed as targetKey, define this attribute on model "${this.target.name}" first`);
    }

    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;
    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;
    this.targetIdentifier = this.targetKey;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the source table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);
    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);

    this.source.refreshAttributes();

    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.
   * @param {string}         [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};
    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.targetKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))
      };
    } else {
      if (this.targetKeyIsPrimary && !options.where) {
        return Target.findByPk(instance.get(this.foreignKey), options);
      }
      where[this.targetKey] = instance.get(this.foreignKey);
      options.limit = null;
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.foreignKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.targetKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options={}] options passed to `this.save`
   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.
   *
   *  @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options = {}) {
    let value = associatedInstance;

    if (associatedInstance instanceof this.target) {
      value = associatedInstance[this.targetKey];
    }

    sourceInstance.set(this.foreignKey, value);

    if (options.save === false) return;

    options = {
      fields: [this.foreignKey],
      allowNull: [this.foreignKey],
      association: true,
      ...options
    };

    // passes the changed field to save, so only that field get updated.
    return await sourceInstance.save(options);
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options={}] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create}  for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    const newAssociatedObject = await this.target.create(values, options);
    await sourceInstance[this.accessors.set](newAssociatedObject, options);

    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsTo;
module.exports.BelongsTo = BelongsTo;
module.exports.default = BelongsTo;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-many.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-many.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-many association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.
 * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.
 *
 * @see {@link Model.hasMany}
 */
class HasMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.isMultiAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.options.through) {
      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');
    }

    /*
    * If self association, this is the target association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    /*
     * Foreign key setup
     */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.source.options.name.singular,
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    /*
     * Source key setup
     */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;

    if (this.source.rawAttributes[this.sourceKey]) {
      this.sourceKeyAttribute = this.sourceKey;
      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    } else {
      this.sourceKeyAttribute = this.source.primaryKeyAttribute;
      this.sourceKeyField = this.source.primaryKeyField;
    }

    // Get singular and plural names
    // try to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.associationAccessor = this.as;
    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m
    const constraintOptions = { ...this.options };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();
    this.source.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findAll}  for a full explanation of options
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instances, options = {}) {
    const where = {};

    let Model = this.target;
    let instance;
    let values;

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    options = { ...options };

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    if (instances) {
      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));

      if (options.limit && instances.length > 1) {
        options.groupedLimit = {
          limit: options.limit,
          on: this, // association
          values
        };

        delete options.limit;
      } else {
        where[this.foreignKey] = {
          [Op.in]: values
        };
        delete options.groupedLimit;
      }
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Model = Model.unscoped();
      } else {
        Model = Model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Model = Model.schema(options.schema, options.schemaDelimiter);
    }

    const results = await Model.findAll(options);
    if (instance) return results;

    const result = {};
    for (const _instance of instances) {
      result[_instance.get(this.sourceKey, { raw: true })] = [];
    }

    for (const _instance of results) {
      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);
    }

    return result;
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model}        instance the source instance
   * @param {object}         [options] find & count options
   * @param {object}         [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    options = Utils.cloneDeep(options);

    options.attributes = [
      [
        this.sequelize.fn(
          'COUNT',
          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)
        ),
        'count'
      ]
    ];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more rows are associated with `this`.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise}
   */
  async has(sourceInstance, targetInstances, options) {
    const where = {};

    if (!Array.isArray(targetInstances)) {
      targetInstances = [targetInstances];
    }

    options = {
      ...options,
      scope: false,
      attributes: [this.target.primaryKeyAttribute],
      raw: true
    };

    where[Op.or] = targetInstances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.target.primaryKeyAttribute]: instance
      };
    });

    options.where = {
      [Op.and]: [
        where,
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return associatedObjects.length === targetInstances.length;
  }

  /**
   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.
   * @param {object} [options] Options passed to `target.findAll` and `update`.
   * @param {object} [options.validate] Run validation for the join model
   *
   * @returns {Promise}
   */
  async set(sourceInstance, targetInstances, options) {
    if (targetInstances === null) {
      targetInstances = [];
    } else {
      targetInstances = this.toInstanceArray(targetInstances);
    }

    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });
    const promises = [];
    const obsoleteAssociations = oldAssociations.filter(old =>
      !targetInstances.find(obj =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    const unassociatedObjects = targetInstances.filter(obj =>
      !oldAssociations.find(old =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    let updateWhere;
    let update;

    if (obsoleteAssociations.length > 0) {
      update = {};
      update[this.foreignKey] = null;

      updateWhere = {
        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>
          associatedObject[this.target.primaryKeyAttribute]
        )
      };


      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    if (unassociatedObjects.length > 0) {
      updateWhere = {};

      update = {};
      update[this.foreignKey] = sourceInstance.get(this.sourceKey);

      Object.assign(update, this.scope);
      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>
        unassociatedObject[this.target.primaryKeyAttribute]
      );

      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    await Promise.all(promises);

    return sourceInstance;
  }

  /**
   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,
   * or a mixed array of Model / string / numbers to associate multiple rows.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `target.update`.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, targetInstances, options = {}) {
    if (!targetInstances) return Promise.resolve();


    targetInstances = this.toInstanceArray(targetInstances);

    const update = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      ...this.scope
    };

    const where = {
      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>
        unassociatedObject.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return sourceInstance;
  }

  /**
   * Un-associate one or several target rows.
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `target.update`
   *
   * @returns {Promise}
   */
  async remove(sourceInstance, targetInstances, options = {}) {
    const update = {
      [this.foreignKey]: null
    };

    targetInstances = this.toInstanceArray(targetInstances);

    const where = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>
        targetInstance.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return this;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model instance
   * @param {object} [options] Options passed to `target.create`
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options = {}) {
    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (values === undefined) {
      values = {};
    }

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) options.fields.push(attribute);
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKey);
    if (options.fields) options.fields.push(this.foreignKey);
    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = HasMany;
module.exports.HasMany = HasMany;
module.exports.default = HasMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-one.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-one.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.
 * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.
 *
 * @see {@link Model.hasOne}
 */
class HasOne extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasOne';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          Utils.singularize(this.options.as || this.source.name),
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (
      this.options.sourceKey
      && !this.source.rawAttributes[this.options.sourceKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.sourceKey}" passed as sourceKey, define this attribute on model "${this.source.name}" first`);
    }

    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the target table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};

    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.foreignKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.sourceKey))
      };
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey);
    }

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.sourceKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.foreignKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options] Options passed to getAssociation and `target.save`
   *
   * @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options) {
    options = { ...options, scope: false };

    const oldInstance = await sourceInstance[this.accessors.get](options);
    // TODO Use equals method once #5605 is resolved
    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>
      oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)
    );

    if (oldInstance && !alreadyAssociated) {
      oldInstance[this.foreignKey] = null;

      await oldInstance.save({
        ...options,
        fields: [this.foreignKey],
        allowNull: [this.foreignKey],
        association: true
      });
    }
    if (associatedInstance && !alreadyAssociated) {
      if (!(associatedInstance instanceof this.target)) {
        const tmpInstance = {};
        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;
        associatedInstance = this.target.build(tmpInstance, {
          isNewRecord: false
        });
      }

      Object.assign(associatedInstance, this.scope);
      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));

      return associatedInstance.save(options);
    }

    return null;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create} for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) {
          options.fields.push(attribute);
        }
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);
    if (options.fields) {
      options.fields.push(this.foreignKey);
    }

    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = HasOne;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function checkNamingCollision(association) {
  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {
    throw new Error(
      `Naming collision between attribute '${association.as}'` +
      ` and association '${association.as}' on model ${association.source.name}` +
      '. To remedy this, change either foreignKey or as in your association definition'
    );
  }
}
exports.checkNamingCollision = checkNamingCollision;

function addForeignKeyConstraints(newAttribute, source, target, options, key) {
  // FK constraints are opt-in: users must either set `foreignKeyConstraints`
  // on the association, or request an `onDelete` or `onUpdate` behavior

  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {
    // Find primary keys: composite keys not supported with this approach
    const primaryKeys = Object.keys(source.primaryKeys)
      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);

    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {
      newAttribute.references = {
        model: source.getTableName(),
        key: key || primaryKeys[0]
      };

      newAttribute.onDelete = options.onDelete;
      newAttribute.onUpdate = options.onUpdate;
    }
  }
}
exports.addForeignKeyConstraints = addForeignKeyConstraints;

/**
 * Mixin (inject) association methods to model prototype
 *
 * @private
 *
 * @param {object} association instance
 * @param {object} obj Model prototype
 * @param {Array} methods Method names to inject
 * @param {object} aliases Mapping between model and association method names
 *
 */
function mixinMethods(association, obj, methods, aliases) {
  aliases = aliases || {};

  for (const method of methods) {
    // don't override custom methods
    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {
      const realMethod = aliases[method] || method;

      obj[association.accessors[method]] = function() {
        return association[realMethod](this, ...Array.from(arguments));
      };
    }
  }
}
exports.mixinMethods = mixinMethods;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");

Association.BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
Association.HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
Association.HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
Association.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");

module.exports = Association;
module.exports.default = Association;
module.exports.Association = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/mixin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");

function isModel(model, sequelize) {
  return model
    && model.prototype
    && model.prototype instanceof sequelize.Sequelize.Model;
}

const Mixin = {
  hasMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    Object.assign(options, _.omit(source.options, ['hooks']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);
    }

    // the id is in the foreign table or in a connecting table
    const association = new HasMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);
    }

    return association;
  },

  belongsToMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;
    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;
    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);
    }
    // the id is in the foreign table or in a connecting table
    const association = new BelongsToMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);
    }

    return association;
  },

  getAssociations(target) {
    return Object.values(this.associations).filter(association => association.target.name === target.name);
  },

  getAssociationForAlias(target, alias) {
    // Two associations cannot have the same alias, so we can use find instead of filter
    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;
  }
};

// The logic for hasOne and belongsTo is exactly the same
function singleLinked(Type) {
  return function(target, options = {}) {
    // eslint-disable-next-line no-invalid-this
    const source = this;
    if (!isModel(target, source.sequelize)) {
      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);
    }


    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    if (options.useHooks) {
      source.runHooks('beforeAssociate', { source, target, type: Type }, options);
    }
    // the id is in the foreign table
    const association = new Type(source, target, Object.assign(options, source.options));
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);
    }

    return association;
  };
}

Mixin.hasOne = singleLinked(HasOne);
Mixin.belongsTo = singleLinked(BelongsTo);

module.exports = Mixin;
module.exports.Mixin = Mixin;
module.exports.default = Mixin;


/***/ }),

/***/ "./node_modules/sequelize/lib/data-types.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/data-types.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const moment = __webpack_require__(/*! moment */ "moment");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const warnings = {};
const { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js");
const { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js");

class ABSTRACT {
  toString(options) {
    return this.toSql(options);
  }
  toSql() {
    return this.key;
  }
  stringify(value, options) {
    if (this._stringify) {
      return this._stringify(value, options);
    }
    return value;
  }
  bindParam(value, options) {
    if (this._bindParam) {
      return this._bindParam(value, options);
    }
    return options.bindParam(this.stringify(value, options));
  }
  static toString() {
    return this.name;
  }
  static warn(link, text) {
    if (!warnings[text]) {
      warnings[text] = true;
      logger.warn(`${text} \n>> Check: ${link}`);
    }
  }
  static extend(oldType) {
    return new this(oldType.options);
  }
}

ABSTRACT.prototype.dialectTypes = '';

/**
 * STRING A variable length string
 */
class STRING extends ABSTRACT {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super();
    const options = typeof length === 'object' && length || { length, binary };
    this.options = options;
    this._binary = options.binary;
    this._length = options.length || 255;
  }
  toSql() {
    return joinSQLFragments([
      `VARCHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
  validate(value) {
    if (Object.prototype.toString.call(value) !== '[object String]') {
      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {
        return true;
      }
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }

  get BINARY() {
    this._binary = true;
    this.options.binary = true;
    return this;
  }

  static get BINARY() {
    return new this().BINARY;
  }
}

/**
 * CHAR A fixed length string
 */
class CHAR extends STRING {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super(typeof length === 'object' && length || { length, binary });
  }
  toSql() {
    return joinSQLFragments([
      `CHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
}

/**
 * Unlimited length TEXT column
 */
class TEXT extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYTEXT';
      case 'medium':
        return 'MEDIUMTEXT';
      case 'long':
        return 'LONGTEXT';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * An unlimited length case-insensitive text column.
 * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).
 * Only available in Postgres and SQLite.
 *
 */
class CITEXT extends ABSTRACT {
  toSql() {
    return 'CITEXT';
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * Base number type which is used to build other types
 */
class NUMBER extends ABSTRACT {
  /**
   * @param {object} options type options
   * @param {string|number} [options.length] length of type, like `INT(4)`
   * @param {boolean} [options.zerofill] Is zero filled?
   * @param {boolean} [options.unsigned] Is unsigned?
   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`
   * @param {string|number} [options.precision] defines precision for decimal type
   * @param {string|number} [options.scale] defines scale for decimal type
   */
  constructor(options = {}) {
    super();
    if (typeof options === 'number') {
      options = {
        length: options
      };
    }
    this.options = options;
    this._length = options.length;
    this._zerofill = options.zerofill;
    this._decimals = options.decimals;
    this._precision = options.precision;
    this._scale = options.scale;
    this._unsigned = options.unsigned;
  }
  toSql() {
    let result = this.key;
    if (this._length) {
      result += `(${this._length}`;
      if (typeof this._decimals === 'number') {
        result += `,${this._decimals}`;
      }
      result += ')';
    }
    if (this._unsigned) {
      result += ' UNSIGNED';
    }
    if (this._zerofill) {
      result += ' ZEROFILL';
    }
    return result;
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
  _stringify(number) {
    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {
      return number;
    }
    if (typeof number.toString === 'function') {
      return number.toString();
    }
    return number;
  }

  get UNSIGNED() {
    this._unsigned = true;
    this.options.unsigned = true;
    return this;
  }

  get ZEROFILL() {
    this._zerofill = true;
    this.options.zerofill = true;
    return this;
  }

  static get UNSIGNED() {
    return new this().UNSIGNED;
  }

  static get ZEROFILL() {
    return new this().ZEROFILL;
  }
}

/**
 * A 32 bit integer
 */
class INTEGER extends NUMBER {
  validate(value) {
    if (!Validator.isInt(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
}

/**
 * A 8 bit integer
 */
class TINYINT extends INTEGER {
}

/**
 * A 16 bit integer
 */
class SMALLINT extends INTEGER {
}

/**
 * A 24 bit integer
 */
class MEDIUMINT extends INTEGER {
}

/**
 * A 64 bit integer
 */
class BIGINT extends INTEGER {
}

/**
 * Floating point number (4-byte precision).
 */
class FLOAT extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `FLOAT(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));
    }
    return true;
  }
}

/**
 * Floating point number (4-byte precision).
 */
class REAL extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `REAL(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Floating point number (8-byte precision).
 */
class DOUBLE extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`
   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Decimal type, variable precision, take length as specified by user
 */
class DECIMAL extends NUMBER {
  /**
   * @param {string|number} [precision] defines precision
   * @param {string|number} [scale] defines scale
   */
  constructor(precision, scale) {
    super(typeof precision === 'object' && precision || { precision, scale });
  }
  toSql() {
    if (this._precision || this._scale) {
      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;
    }
    return 'DECIMAL';
  }
  validate(value) {
    if (!Validator.isDecimal(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));
    }
    return true;
  }
}

// TODO: Create intermediate class
const protoExtensions = {
  escape: false,
  _value(value) {
    if (isNaN(value)) {
      return 'NaN';
    }
    if (!isFinite(value)) {
      const sign = value < 0 ? '-' : '';
      return `${sign}Infinity`;
    }

    return value;
  },
  _stringify(value) {
    return `'${this._value(value)}'`;
  },
  _bindParam(value, options) {
    return options.bindParam(this._value(value));
  }
};

for (const floating of [FLOAT, DOUBLE, REAL]) {
  Object.assign(floating.prototype, protoExtensions);
}

/**
 * A boolean / tinyint column, depending on dialect
 */
class BOOLEAN extends ABSTRACT {
  toSql() {
    return 'TINYINT(1)';
  }
  validate(value) {
    if (!Validator.isBoolean(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));
    }
    return true;
  }
  _sanitize(value) {
    if (value !== null && value !== undefined) {
      if (Buffer.isBuffer(value) && value.length === 1) {
        // Bit fields are returned as buffers
        value = value[0];
      }
      const type = typeof value;
      if (type === 'string') {
        // Only take action on valid boolean strings.
        return value === 'true' ? true : value === 'false' ? false : value;
      }
      if (type === 'number') {
        // Only take action on valid boolean integers.
        return value === 1 ? true : value === 0 ? false : value;
      }
    }
    return value;
  }
}


BOOLEAN.parse = BOOLEAN.prototype._sanitize;

/**
 * A time column
 *
 */
class TIME extends ABSTRACT {
  toSql() {
    return 'TIME';
  }
}

/**
 * Date column with timezone, default is UTC
 */
class DATE extends ABSTRACT {
  /**
   * @param {string|number} [length] precision to allow storing milliseconds
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    return 'DATETIME';
  }
  validate(value) {
    if (!Validator.isDate(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));
    }
    return true;
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {
      return new Date(value);
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value &&
      (value === originalValue ||
        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
  _applyTimezone(date, options) {
    if (options.timezone) {
      if (momentTz.tz.zone(options.timezone)) {
        return momentTz(date).tz(options.timezone);
      }
      return date = moment(date).utcOffset(options.timezone);
    }
    return momentTz(date);
  }
  _stringify(date, options) {
    date = this._applyTimezone(date, options);
    // Z here means current timezone, _not_ UTC
    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');
  }
}

/**
 * A date only column (no timestamp)
 */
class DATEONLY extends ABSTRACT {
  toSql() {
    return 'DATE';
  }
  _stringify(date) {
    return moment(date).format('YYYY-MM-DD');
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !!value) {
      return moment(value).format('YYYY-MM-DD');
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value && originalValue === value) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
}

/**
 * A key / value store column. Only available in Postgres.
 */
class HSTORE extends ABSTRACT {
  validate(value) {
    if (!_.isPlainObject(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));
    }
    return true;
  }
}

/**
 * A JSON string column. Available in MySQL, Postgres and SQLite
 */
class JSONTYPE extends ABSTRACT {
  validate() {
    return true;
  }
  _stringify(value) {
    return JSON.stringify(value);
  }
}

/**
 * A binary storage JSON column. Only available in Postgres.
 */
class JSONB extends JSONTYPE {
}

/**
 * A default value of the current timestamp
 */
class NOW extends ABSTRACT {
}

/**
 * Binary storage
 */
class BLOB extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYBLOB';
      case 'medium':
        return 'MEDIUMBLOB';
      case 'long':
        return 'LONGBLOB';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));
    }
    return true;
  }
  _stringify(value) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    const hex = value.toString('hex');
    return this._hexify(hex);
  }
  _hexify(hex) {
    return `X'${hex}'`;
  }
  _bindParam(value, options) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    return options.bindParam(value);
  }
}


BLOB.prototype.escape = false;

/**
 * Range types are data types representing a range of values of some element type (called the range's subtype).
 * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details
 */
class RANGE extends ABSTRACT {
  /**
   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)
   */
  constructor(subtype) {
    super();
    const options = _.isPlainObject(subtype) ? subtype : { subtype };
    if (!options.subtype)
      options.subtype = new INTEGER();
    if (typeof options.subtype === 'function') {
      options.subtype = new options.subtype();
    }
    this._subtype = options.subtype.key;
    this.options = options;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));
    }
    if (value.length !== 2) {
      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');
    }
    return true;
  }
}

/**
 * A column storing a unique universal identifier.
 * Use with `UUIDV1` or `UUIDV4` for default values.
 */
class UUID extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v1 standard
 */
class UUIDV1 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v4 standard
 */
class UUIDV4 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));
    }
    return true;
  }
}

/**
 * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.
 *
 * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments
 * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.
 * Return type is mostly useful for setups that rely on types like GraphQL.
 *
 * @example <caption>Checking password length before hashing it</caption>
 * sequelize.define('user', {
 *   password_hash: DataTypes.STRING,
 *   password: {
 *     type: DataTypes.VIRTUAL,
 *     set: function (val) {
 *        // Remember to set the data value, otherwise it won't be validated
 *        this.setDataValue('password', val);
 *        this.setDataValue('password_hash', this.salt + val);
 *      },
 *      validate: {
 *         isLongEnough: function (val) {
 *           if (val.length < 7) {
 *             throw new Error("Please choose a longer password")
 *          }
 *       }
 *     }
 *   }
 * })
 *
 * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.
 *
 * @example <caption>Virtual with dependency fields</caption>
 * {
 *   active: {
 *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),
 *     get: function() {
 *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)
 *     }
 *   }
 * }
 *
 */
class VIRTUAL extends ABSTRACT {
  /**
   * @param {ABSTRACT} [ReturnType] return type for virtual type
   * @param {Array} [fields] array of fields this virtual type is dependent on
   */
  constructor(ReturnType, fields) {
    super();
    if (typeof ReturnType === 'function')
      ReturnType = new ReturnType();
    this.returnType = ReturnType;
    this.fields = fields;
  }
}

/**
 * An enumeration, Postgres Only
 *
 * @example
 * DataTypes.ENUM('value', 'another value')
 * DataTypes.ENUM(['value', 'another value'])
 * DataTypes.ENUM({
 *   values: ['value', 'another value']
 * })
 */
class ENUM extends ABSTRACT {
  /**
   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values
   */
  constructor(...args) {
    super();
    const value = args[0];
    const options = typeof value === 'object' && !Array.isArray(value) && value || {
      values: args.reduce((result, element) => {
        return result.concat(Array.isArray(element) ? element : [element]);
      }, [])
    };
    this.values = options.values;
    this.options = options;
  }
  validate(value) {
    if (!this.values.includes(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));
    }
    return true;
  }
}

/**
 * An array of `type`. Only available in Postgres.
 *
 * @example
 * DataTypes.ARRAY(DataTypes.DECIMAL)
 */
class ARRAY extends ABSTRACT {
  /**
   * @param {ABSTRACT} type type of array values
   */
  constructor(type) {
    super();
    const options = _.isPlainObject(type) ? type : { type };
    this.options = options;
    this.type = typeof options.type === 'function' ? new options.type() : options.type;
  }
  toSql() {
    return `${this.type.toSql()}[]`;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));
    }
    return true;
  }
  static is(obj, type) {
    return obj instanceof ARRAY && obj.type instanceof type;
  }
}

/**
 * A column storing Geometry information.
 * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.
 *
 * GeoJSON is accepted as input and returned as output.
 *
 * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.
 * In MySQL it is parsed using the function `GeomFromText`.
 *
 * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:
 *
 * @example <caption>Defining a Geometry type attribute</caption>
 * DataTypes.GEOMETRY
 * DataTypes.GEOMETRY('POINT')
 * DataTypes.GEOMETRY('POINT', 4326)
 *
 * @example <caption>Create a new point</caption>
 * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};
 *
 * User.create({username: 'username', geometry: point });
 *
 * @example <caption>Create a new linestring</caption>
 * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };
 *
 * User.create({username: 'username', geometry: line });
 *
 * @example <caption>Create a new polygon</caption>
 * const polygon = { type: 'Polygon', coordinates: [
 *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
 *                   [100.0, 1.0], [100.0, 0.0] ]
 *                 ]};
 *
 * User.create({username: 'username', geometry: polygon });
 *
 * @example <caption>Create a new point with a custom SRID</caption>
 * const point = {
 *   type: 'Point',
 *   coordinates: [39.807222,-76.984722],
 *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }
 * };
 *
 * User.create({username: 'username', geometry: point })
 *
 *
 * @see {@link DataTypes.GEOGRAPHY}
 */
class GEOMETRY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geometry data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}

GEOMETRY.prototype.escape = false;

/**
 * A geography datatype represents two dimensional spacial objects in an elliptic coord system.
 *
 * __The difference from geometry and geography type:__
 *
 * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.
 * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),
 * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.
 *
 * __What is best to use? It depends:__
 *
 * When choosing between the geometry and geography type for data storage, you should consider what youll be using it for.
 * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.
 * Although the new geography data type can cover the globe, the geometry type is far from obsolete.
 * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools
 *
 * @example <caption>Defining a Geography type attribute</caption>
 * DataTypes.GEOGRAPHY
 * DataTypes.GEOGRAPHY('POINT')
 * DataTypes.GEOGRAPHY('POINT', 4326)
 */
class GEOGRAPHY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geography data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}


GEOGRAPHY.prototype.escape = false;

/**
 * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.
 *
 * Only available for Postgres
 */
class CIDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIPRange(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));
    }
    return true;
  }
}

/**
 * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes
 *
 * Only available for Postgres
 */
class INET extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIP(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));
    }
    return true;
  }
}

/**
 * The MACADDR type stores MAC addresses. Takes 6 bytes
 *
 * Only available for Postgres
 *
 */
class MACADDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));
    }
    return true;
  }
}

/**
 * The TSVECTOR type stores text search vectors.
 *
 * Only available for Postgres
 *
 */
class TSVECTOR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:
 * ```js
 * sequelize.define('model', {
 *   column: DataTypes.INTEGER
 * })
 * ```
 * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean
 * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.
 *
 * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`
 *
 * Some data types have special properties that can be accessed in order to change the data type.
 * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.
 * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.
 *
 * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`
 * * The `CHAR` and `STRING` types expose the `BINARY` property
 *
 * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for
 * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: DataTypes.UUIDV1,
 *     primaryKey: true
 *   }
 * })
 * ```
 * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished
 * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value
 * from a function.
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: function() {
 *       return generateMyId()
 *     },
 *     primaryKey: true
 *   }
 * })
 * ```
 */
const DataTypes = module.exports = {
  ABSTRACT,
  STRING,
  CHAR,
  TEXT,
  NUMBER,
  TINYINT,
  SMALLINT,
  MEDIUMINT,
  INTEGER,
  BIGINT,
  FLOAT,
  TIME,
  DATE,
  DATEONLY,
  BOOLEAN,
  NOW,
  BLOB,
  DECIMAL,
  NUMERIC: DECIMAL,
  UUID,
  UUIDV1,
  UUIDV4,
  HSTORE,
  JSON: JSONTYPE,
  JSONB,
  VIRTUAL,
  ARRAY,
  ENUM,
  RANGE,
  REAL,
  'DOUBLE PRECISION': DOUBLE,
  DOUBLE,
  GEOMETRY,
  GEOGRAPHY,
  CIDR,
  INET,
  MACADDR,
  CITEXT,
  TSVECTOR
};

_.each(DataTypes, (dataType, name) => {
  // guard for aliases
  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {
    dataType.types = {};
    dataType.key = dataType.prototype.key = name;
  }
});

const dialectMap = {};
dialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ "./node_modules/sequelize/lib/dialects/postgres/data-types.js")(DataTypes);
dialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ "./node_modules/sequelize/lib/dialects/mysql/data-types.js")(DataTypes);
dialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js")(DataTypes);
dialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js")(DataTypes);
dialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ "./node_modules/sequelize/lib/dialects/mssql/data-types.js")(DataTypes);

const dialectList = Object.values(dialectMap);

for (const dataTypes of dialectList) {
  _.each(dataTypes, (DataType, key) => {
    if (!DataType.key) {
      DataType.key = DataType.prototype.key = key;
    }
  });
}

// Wrap all data types to not require `new`
for (const dataTypes of [DataTypes, ...dialectList]) {
  _.each(dataTypes, (DataType, key) => {
    dataTypes[key] = classToInvokable(DataType);
  });
}

Object.assign(DataTypes, dialectMap);


/***/ }),

/***/ "./node_modules/sequelize/lib/deferrable.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/deferrable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { classToInvokable } = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");

class ABSTRACT {
  static toString(...args) {
    return new this().toString(...args);
  }

  toString(...args) {
    return this.toSql(...args);
  }

  toSql() {
    throw new Error('toSql implementation missing');
  }
}

class INITIALLY_DEFERRED extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY DEFERRED';
  }
}

class INITIALLY_IMMEDIATE extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY IMMEDIATE';
  }
}

class NOT extends ABSTRACT {
  toSql() {
    return 'NOT DEFERRABLE';
  }
}

class SET_DEFERRED extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setDeferredQuery(this.constraints);
  }
}

class SET_IMMEDIATE extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setImmediateQuery(this.constraints);
  }
}

/**
 * A collection of properties related to deferrable constraints. It can be used to
 * make foreign key constraints deferrable and to set the constraints within a
 * transaction. This is only supported in PostgreSQL.
 *
 * The foreign keys can be configured like this. It will create a foreign key
 * that will check the constraints immediately when the data was inserted.
 *
 * ```js
 * sequelize.define('Model', {
 *   foreign_id: {
 *     type: Sequelize.INTEGER,
 *     references: {
 *       model: OtherModel,
 *       key: 'id',
 *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE
 *     }
 *   }
 * });
 * ```
 *
 * The constraints can be configured in a transaction like this. It will
 * trigger a query once the transaction has been started and set the constraints
 * to be checked at the very end of the transaction.
 *
 * ```js
 * sequelize.transaction({
 *   deferrable: Sequelize.Deferrable.SET_DEFERRED
 * });
 * ```
 *
 * @property INITIALLY_DEFERRED    Use when declaring a constraint. Allow and enable by default this constraint's checks to be deferred at the end of transactions.
 * @property INITIALLY_IMMEDIATE   Use when declaring a constraint. Allow the constraint's checks to be deferred at the end of transactions.
 * @property NOT                   Use when declaring a constraint. Set the constraint to not deferred. This is the default in PostgreSQL and makes it impossible to dynamically defer the constraints within a transaction.
 * @property SET_DEFERRED          Use when declaring a transaction. Defer the deferrable checks involved in this transaction at commit.
 * @property SET_IMMEDIATE         Use when declaring a transaction. Execute the deferrable checks involved in this transaction immediately.
 */

const Deferrable = {
  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),
  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),
  NOT: classToInvokable(NOT),
  SET_DEFERRED: classToInvokable(SET_DEFERRED),
  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)
};

module.exports = Deferrable;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ "./node_modules/sequelize-pool/lib/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const errors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const debug = logger.debugContext('pool');

/**
 * Abstract Connection Manager
 *
 * Connection manager which handles pooling & replication.
 * Uses sequelize-pool for pooling
 *
 * @private
 */
class ConnectionManager {
  constructor(dialect, sequelize) {
    const config = _.cloneDeep(sequelize.config);

    this.sequelize = sequelize;
    this.config = config;
    this.dialect = dialect;
    this.versionPromise = null;
    this.dialectName = this.sequelize.options.dialect;

    if (config.pool === false) {
      throw new Error('Support for pool:false was removed in v4.0');
    }

    config.pool = _.defaults(config.pool || {}, {
      max: 5,
      min: 0,
      idle: 10000,
      acquire: 60000,
      evict: 1000,
      validate: this._validate.bind(this)
    });

    this.initPools();
  }

  refreshTypeParser(dataTypes) {
    _.each(dataTypes, dataType => {
      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {
        if (dataType.types[this.dialectName]) {
          this._refreshTypeParser(dataType);
        } else {
          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);
        }
      }
    });
  }

  /**
   * Try to load dialect module from various configured options.
   * Priority goes like dialectModulePath > dialectModule > require(default)
   *
   * @param {string} moduleName Name of dialect module to lookup
   *
   * @private
   * @returns {object}
   */
  _loadDialectModule(moduleName) {
    try {
      if (this.sequelize.config.dialectModulePath) {
        return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(this.sequelize.config.dialectModulePath);
      }
      if (this.sequelize.config.dialectModule) {
        return this.sequelize.config.dialectModule;
      }
      return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(moduleName);

    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        if (this.sequelize.config.dialectModulePath) {
          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);
        }
        throw new Error(`Please install ${moduleName} package manually`);
      }

      throw err;
    }
  }

  /**
   * Handler which executes on process exit or connection manager shutdown
   *
   * @private
   * @returns {Promise}
   */
  async _onProcessExit() {
    if (!this.pool) {
      return;
    }

    await this.pool.drain();
    debug('connection drain due to process exit');

    return await this.pool.destroyAllNow();
  }

  /**
   * Drain the pool and close it permanently
   *
   * @returns {Promise}
   */
  async close() {
    // Mark close of pool
    this.getConnection = async function getConnection() {
      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');
    };

    return await this._onProcessExit();
  }

  /**
   * Initialize connection pool. By default pool autostart is set to false, so no connection will be
   * be created unless `pool.acquire` is called.
   */
  initPools() {
    const config = this.config;

    if (!config.replication) {
      this.pool = new Pool({
        name: 'sequelize',
        create: () => this._connect(config),
        destroy: async connection => {
          const result = await this._disconnect(connection);
          debug('connection destroy');
          return result;
        },
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      });

      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);

      return;
    }

    if (!Array.isArray(config.replication.read)) {
      config.replication.read = [config.replication.read];
    }

    // Map main connection config
    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));

    // Apply defaults to each read config
    config.replication.read = config.replication.read.map(readConfig =>
      _.defaults(readConfig, _.omit(this.config, 'replication'))
    );

    // custom pooling for replication (original author @janmeier)
    let reads = 0;
    this.pool = {
      release: client => {
        if (client.queryType === 'read') {
          this.pool.read.release(client);
        } else {
          this.pool.write.release(client);
        }
      },
      acquire: (queryType, useMaster) => {
        useMaster = useMaster === undefined ? false : useMaster;
        if (queryType === 'SELECT' && !useMaster) {
          return this.pool.read.acquire();
        }
        return this.pool.write.acquire();
      },
      destroy: connection => {
        this.pool[connection.queryType].destroy(connection);
        debug('connection destroy');
      },
      destroyAllNow: async () => {
        await Promise.all([
          this.pool.read.destroyAllNow(),
          this.pool.write.destroyAllNow()
        ]);

        debug('all connections destroyed');
      },
      drain: async () => Promise.all([
        this.pool.write.drain(),
        this.pool.read.drain()
      ]),
      read: new Pool({
        name: 'sequelize:read',
        create: async () => {
          // round robin config
          const nextRead = reads++ % config.replication.read.length;
          const connection = await this._connect(config.replication.read[nextRead]);
          connection.queryType = 'read';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      }),
      write: new Pool({
        name: 'sequelize:write',
        create: async () => {
          const connection = await this._connect(config.replication.write);
          connection.queryType = 'write';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      })
    };

    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);
  }

  /**
   * Get connection from pool. It sets database version if it's not already set.
   * Call pool.acquire to get a connection
   *
   * @param {object}   [options]                 Pool options
   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`
   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from
   *
   * @returns {Promise<Connection>}
   */
  async getConnection(options) {
    options = options || {};

    if (this.sequelize.options.databaseVersion === 0) {
      if (!this.versionPromise) {
        this.versionPromise = (async () => {
          try {
            const connection = await this._connect(this.config.replication.write || this.config);
            const _options = {};

            _options.transaction = { connection }; // Cheat .query to use our private connection
            _options.logging = () => {};
            _options.logging.__testLoggingFn = true;

            //connection might have set databaseVersion value at initialization,
            //avoiding a useless round trip
            if (this.sequelize.options.databaseVersion === 0) {
              const version = await this.sequelize.databaseVersion(_options);
              const parsedVersion = _.get(semver.coerce(version), 'version') || version;
              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)
                ? parsedVersion
                : this.dialect.defaultVersion;
            }

            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {
              deprecations.unsupportedEngine();
              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);
            }

            this.versionPromise = null;
            return await this._disconnect(connection);
          } catch (err) {
            this.versionPromise = null;
            throw err;
          }
        })();
      }
      await this.versionPromise;
    }

    let result;

    try {
      result = await this.pool.acquire(options.type, options.useMaster);
    } catch (error) {
      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);
      throw error;
    }

    debug('connection acquired');

    return result;
  }

  /**
   * Release a pooled connection so it can be utilized by other connection requests
   *
   * @param {Connection} connection
   *
   * @returns {Promise}
   */
  async releaseConnection(connection) {
    this.pool.release(connection);
    debug('connection released');
  }

  /**
   * Call dialect library to get connection
   *
   * @param {*} config Connection config
   * @private
   * @returns {Promise<Connection>}
   */
  async _connect(config) {
    await this.sequelize.runHooks('beforeConnect', config);
    const connection = await this.dialect.connectionManager.connect(config);
    await this.sequelize.runHooks('afterConnect', connection, config);
    return connection;
  }

  /**
   * Call dialect library to disconnect a connection
   *
   * @param {Connection} connection
   * @private
   * @returns {Promise}
   */
  async _disconnect(connection) {
    await this.sequelize.runHooks('beforeDisconnect', connection);
    await this.dialect.connectionManager.disconnect(connection);
    return this.sequelize.runHooks('afterDisconnect', connection);
  }

  /**
   * Determine if a connection is still valid or not
   *
   * @param {Connection} connection
   *
   * @returns {boolean}
   */
  _validate(connection) {
    if (!this.dialect.connectionManager.validate) {
      return true;
    }

    return this.dialect.connectionManager.validate(connection);
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class AbstractDialect {}

AbstractDialect.prototype.supports = {
  'DEFAULT': true,
  'DEFAULT VALUES': false,
  'VALUES ()': false,
  'LIMIT ON UPDATE': false,
  'ORDER NULLS': false,
  'UNION': true,
  'UNION ALL': true,
  'RIGHT JOIN': true,

  /* does the dialect support returning values for inserted/updated fields */
  returnValues: false,

  /* features specific to autoIncrement values */
  autoIncrement: {
    /* does the dialect require modification of insert queries when inserting auto increment fields */
    identityInsert: false,

    /* does the dialect support inserting default/null values for autoincrement fields */
    defaultValue: true,

    /* does the dialect support updating autoincrement fields */
    update: true
  },
  /* Do we need to say DEFAULT for bulk insert */
  bulkDefault: false,
  schemas: false,
  transactions: true,
  settingIsolationLevelDuringTransaction: true,
  transactionOptions: {
    type: false
  },
  migrations: true,
  upserts: true,
  inserts: {
    ignoreDuplicates: '', /* dialect specific words for INSERT IGNORE or DO NOTHING */
    updateOnDuplicate: false, /* whether dialect supports ON DUPLICATE KEY UPDATE */
    onConflictDoNothing: '' /* dialect specific words for ON CONFLICT DO NOTHING */
  },
  constraints: {
    restrict: true,
    addConstraint: true,
    dropConstraint: true,
    unique: true,
    default: false,
    check: true,
    foreignKey: true,
    primaryKey: true
  },
  index: {
    collate: true,
    length: false,
    parser: false,
    concurrently: false,
    type: false,
    using: true,
    functionBased: false,
    operator: false
  },
  joinTableDependent: true,
  groupedLimit: true,
  indexViaAlter: false,
  JSON: false,
  deferrableConstraints: false
};

module.exports = AbstractDialect;
module.exports.AbstractDialect = AbstractDialect;
module.exports.default = AbstractDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Model = __webpack_require__(/*! ../../model */ "./node_modules/sequelize/lib/model.js");
const Association = __webpack_require__(/*! ../../associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const HasMany = __webpack_require__(/*! ../../associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const sequelizeError = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const IndexHints = __webpack_require__(/*! ../../index-hints */ "./node_modules/sequelize/lib/index-hints.js");

const QuoteHelper = __webpack_require__(/*! ./query-generator/helpers/quote */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js");

/**
 * Abstract Query Generator
 *
 * @private
 */
class QueryGenerator {
  constructor(options) {
    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');
    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');

    this.sequelize = options.sequelize;
    this.options = options.sequelize.options;

    // dialect name
    this.dialect = options._dialect.name;
    this._dialect = options._dialect;
  }

  extractTableDetails(tableName, options) {
    options = options || {};
    tableName = tableName || {};
    return {
      schema: tableName.schema || options.schema || 'public',
      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
      delimiter: tableName.delimiter || options.delimiter || '.'
    };
  }

  addSchema(param) {
    if (!param._schema) return param.tableName || param;
    const self = this;
    return {
      tableName: param.tableName || param,
      table: param.tableName || param,
      name: param.name || param,
      schema: param._schema,
      delimiter: param._schemaDelimiter || '.',
      toString() {
        return self.quoteTable(this);
      }
    };
  }

  dropSchema(tableName, options) {
    return this.dropTableQuery(tableName, options);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `DESCRIBE ${table};`;
  }

  dropTableQuery(tableName) {
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;
  }

  renameTableQuery(before, after) {
    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;
  }

  /**
   * Returns an insert into command
   *
   * @param {string} table
   * @param {object} valueHash       attribute value pairs
   * @param {object} modelAttributes
   * @param {object} [options]
   *
   * @private
   */
  insertQuery(table, valueHash, modelAttributes, options) {
    options = options || {};
    _.defaults(options, this.options);

    const modelAttributeMap = {};
    const bind = [];
    const fields = [];
    const returningModelAttributes = [];
    const values = [];
    const quotedTable = this.quoteTable(table);
    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;
    let query;
    let valueQuery = '';
    let emptyQuery = '';
    let outputFragment = '';
    let returningFragment = '';
    let identityWrapperRequired = false;
    let tmpTable = ''; //tmpTable declaration for trigger

    if (modelAttributes) {
      _.each(modelAttributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    if (this._dialect.supports['DEFAULT VALUES']) {
      emptyQuery += ' DEFAULT VALUES';
    } else if (this._dialect.supports['VALUES ()']) {
      emptyQuery += ' VALUES ()';
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(modelAttributes, options);

      returningModelAttributes.push(...returnValues.returnFields);
      returningFragment = returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';
    }

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    if (this._dialect.supports.EXCEPTION && options.exception) {
      // Not currently supported with bind parameters (requires output of multiple queries)
      options.bindParam = false;
    }

    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
    for (const key in valueHash) {
      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {
        const value = valueHash[key];
        fields.push(this.quoteIdentifier(key));

        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {
          if (!this._dialect.supports.autoIncrement.defaultValue) {
            fields.splice(-1, 1);
          } else if (this._dialect.supports.DEFAULT) {
            values.push('DEFAULT');
          } else {
            values.push(this.escape(null));
          }
        } else {
          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
            identityWrapperRequired = true;
          }

          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));
          } else {
            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));
          }
        }
      }
    }

    let onDuplicateKeyUpdate = '';

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else {
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const replacements = {
      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',
      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',
      attributes: fields.join(','),
      output: outputFragment,
      values: values.join(','),
      tmpTable
    };

    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;
    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;

    // Mostly for internal use, so we expect the user to know what he's doing!
    // pg_temp functions are private per connection, so we never risk this function interfering with another one.
    if (this._dialect.supports.EXCEPTION && options.exception) {
      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';

      if (returningModelAttributes.length === 0) {
        returningModelAttributes.push('*');
      }

      const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;
      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;

      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';
      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;
    } else {
      valueQuery += returningFragment;
      emptyQuery += returningFragment;
    }

    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;
    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;
    }

    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }

    return result;
  }

  /**
   * Returns an insert into command for multiple values.
   *
   * @param {string} tableName
   * @param {object} fieldValueHashes
   * @param {object} options
   * @param {object} fieldMappedAttributes
   *
   * @private
   */
  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
    options = options || {};
    fieldMappedAttributes = fieldMappedAttributes || {};

    const tuples = [];
    const serials = {};
    const allAttributes = [];
    let onDuplicateKeyUpdate = '';

    for (const fieldValueHash of fieldValueHashes) {
      _.forOwn(fieldValueHash, (value, key) => {
        if (!allAttributes.includes(key)) {
          allAttributes.push(key);
        }
        if (
          fieldMappedAttributes[key]
          && fieldMappedAttributes[key].autoIncrement === true
        ) {
          serials[key] = true;
        }
      });
    }

    for (const fieldValueHash of fieldValueHashes) {
      const values = allAttributes.map(key => {
        if (
          this._dialect.supports.bulkDefault
          && serials[key] === true
        ) {
          return fieldValueHash[key] || 'DEFAULT';
        }

        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });
      });

      tuples.push(`(${values.join(',')})`);
    }

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else { // mysql / maria
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';
    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';
    let returning = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);

      returning += returnValues.returningFragment;
    }

    return Utils.joinSQLFragments([
      'INSERT',
      ignoreDuplicates,
      'INTO',
      this.quoteTable(tableName),
      `(${attributes})`,
      'VALUES',
      tuples.join(','),
      onDuplicateKeyUpdate,
      onConflictDoNothing,
      returning,
      ';'
    ]);
  }

  /**
   * Returns an update query
   *
   * @param {string} tableName
   * @param {object} attrValueHash
   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} options
   * @param {object} attributes
   *
   * @private
   */
  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const values = [];
    const bind = [];
    const modelAttributeMap = {};
    let outputFragment = '';
    let tmpTable = ''; // tmpTable declaration for trigger
    let suffix = '';

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;

    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {
      if (this.dialect !== 'mssql') {
        suffix = ` LIMIT ${this.escape(options.limit)} `;
      }
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      suffix += returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';

      // ensure that the return output is properly mapped to model fields.
      if (!this._dialect.supports.returnValues.output && options.returning) {
        options.mapToModel = true;
      }
    }

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      if (modelAttributeMap && modelAttributeMap[key] &&
        modelAttributeMap[key].autoIncrement === true &&
        !this._dialect.supports.autoIncrement.update) {
        // not allowed to update identity column
        continue;
      }

      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    const whereOptions = { ...options, bindParam };

    if (values.length === 0) {
      return '';
    }

    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();
    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }
    return result;
  }

  /**
   * Returns an update query using arithmetic operator
   *
   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')
   * @param {string} tableName                   Name of the table
   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs
   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs
   * @param {object} options
   *
   * @private
   */
  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = options || {};
    _.defaults(options, { returning: true });

    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);

    let outputFragment = '';
    let returningFragment = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(null, options);

      outputFragment = returnValues.outputFragment;
      returningFragment = returnValues.returningFragment;
    }

    const updateSetSqlFragments = [];
    for (const field in incrementAmountsByField) {
      const incrementAmount = incrementAmountsByField[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedAmount = this.escape(incrementAmount);
      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);
    }
    for (const field in extraAttributesToBeUpdated) {
      const newValue = extraAttributesToBeUpdated[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedValue = this.escape(newValue);
      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);
    }

    return Utils.joinSQLFragments([
      'UPDATE',
      this.quoteTable(tableName),
      'SET',
      updateSetSqlFragments.join(','),
      outputFragment,
      this.whereQuery(where),
      returningFragment
    ]);
  }

  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
        - using
        - operator
        - concurrently: Pass CONCURRENT so other operations run while the index is created
      - rawTablename, the name of the table, without schema. Used to create the name of the index
   @private
  */
  addIndexQuery(tableName, attributes, options, rawTablename) {
    options = options || {};

    if (!Array.isArray(attributes)) {
      options = attributes;
      attributes = undefined;
    } else {
      options.fields = attributes;
    }

    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && typeof options.prefix === 'string') {
      options.prefix = options.prefix.replace(/\./g, '_');
      options.prefix = options.prefix.replace(/("|')/g, '');
    }

    const fieldsSql = options.fields.map(field => {
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (typeof field === 'string') {
        field = {
          name: field
        };
      }
      let result = '';

      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${util.inspect(field)}`);
      }

      result += this.quoteIdentifier(field.name);

      if (this._dialect.supports.index.collate && field.collate) {
        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;
      }

      if (this._dialect.supports.index.operator) {
        const operator = field.operator || options.operator;
        if (operator) {
          result += ` ${operator}`;
        }
      }

      if (this._dialect.supports.index.length && field.length) {
        result += `(${field.length})`;
      }

      if (field.order) {
        result += ` ${field.order}`;
      }

      return result;
    });

    if (!options.name) {
      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)
      // All calls that go through sequelize should already have a name
      options = Utils.nameIndex(options, options.prefix);
    }

    options = Model._conformIndex(options);

    if (!this._dialect.supports.index.type) {
      delete options.type;
    }

    if (options.where) {
      options.where = this.whereQuery(options.where);
    }

    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;
    let ind;
    if (this._dialect.supports.indexViaAlter) {
      ind = [
        'ALTER TABLE',
        tableName,
        concurrently,
        'ADD'
      ];
    } else {
      ind = ['CREATE'];
    }

    ind = ind.concat(
      options.unique ? 'UNIQUE' : '',
      options.type, 'INDEX',
      !this._dialect.supports.indexViaAlter ? concurrently : undefined,
      this.quoteIdentifiers(options.name),
      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',
      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,
      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',
      `(${fieldsSql.join(', ')})`,
      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,
      this._dialect.supports.index.where && options.where ? options.where : undefined
    );

    return _.compact(ind).join(' ');
  }

  addConstraintQuery(tableName, options) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'ADD',
      this.getConstraintSnippet(tableName, options || {}),
      ';'
    ]);
  }

  getConstraintSnippet(tableName, options) {
    let constraintSnippet, constraintName;

    const fieldsSql = options.fields.map(field => {
      if (typeof field === 'string') {
        return this.quoteIdentifier(field);
      }
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${field}`);
      }

      return this.quoteIdentifier(field.name);
    });

    const fieldsSqlQuotedString = fieldsSql.join(', ');
    const fieldsSqlString = fieldsSql.join('_');

    switch (options.type.toUpperCase()) {
      case 'UNIQUE':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);
        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;
        break;
      case 'CHECK':
        options.where = this.whereItemsQuery(options.where);
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);
        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;
        break;
      case 'DEFAULT':
        if (options.defaultValue === undefined) {
          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');
        }

        if (this._dialect.name !== 'mssql') {
          throw new Error('Default constraints are supported only for MSSQL dialect.');
        }

        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);
        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;
        break;
      case 'PRIMARY KEY':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);
        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;
        break;
      case 'FOREIGN KEY':
        const references = options.references;
        if (!references || !references.table || !(references.field || references.fields)) {
          throw new Error('references object with table and field must be specified');
        }
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);
        const quotedReferences =
          typeof references.field !== 'undefined'
            ? this.quoteIdentifier(references.field)
            : references.fields.map(f => this.quoteIdentifier(f)).join(', ');
        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;
        constraintSnippet = `CONSTRAINT ${constraintName} `;
        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;
        if (options.onUpdate) {
          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;
        }
        if (options.onDelete) {
          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;
        }
        break;
      default: throw new Error(`${options.type} is invalid.`);
    }

    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {
      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;
    }

    return constraintSnippet;
  }

  removeConstraintQuery(tableName, constraintName) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'DROP CONSTRAINT',
      this.quoteIdentifiers(constraintName)
    ]);
  }

  /*
    Quote an object based on its type. This is a more general version of quoteIdentifiers
    Strings: should proxy to quoteIdentifiers
    Arrays:
      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]
        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an
        association object, or the name of an association.
      * Zero or more models can be included in the array and are used to trace a path through the tree of
        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL
        and quotes it.
      * If a single string is appended to end of array, it is quoted.
        If two strings appended, the 1st string is quoted, the 2nd string unquoted.
    Objects:
      * If raw is set, that value should be returned verbatim, without quoting
      * If fn is set, the string should start with the value of fn, starting paren, followed by
        the values of cols (which is assumed to be an array), quoted and joined with ', ',
        unless they are themselves objects
      * If direction is set, should be prepended

    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could
    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)
   @private
  */
  quote(collection, parent, connector) {
    // init
    const validOrderOptions = [
      'ASC',
      'DESC',
      'ASC NULLS LAST',
      'DESC NULLS LAST',
      'ASC NULLS FIRST',
      'DESC NULLS FIRST',
      'NULLS FIRST',
      'NULLS LAST'
    ];

    // default
    connector = connector || '.';

    // just quote as identifiers if string
    if (typeof collection === 'string') {
      return this.quoteIdentifiers(collection);
    }
    if (Array.isArray(collection)) {
      // iterate through the collection and mutate objects into associations
      collection.forEach((item, index) => {
        const previous = collection[index - 1];
        let previousAssociation;
        let previousModel;

        // set the previous as the parent when previous is undefined or the target of the association
        if (!previous && parent !== undefined) {
          previousModel = parent;
        } else if (previous && previous instanceof Association) {
          previousAssociation = previous;
          previousModel = previous.target;
        }

        // if the previous item is a model, then attempt getting an association
        if (previousModel && previousModel.prototype instanceof Model) {
          let model;
          let as;

          if (typeof item === 'function' && item.prototype instanceof Model) {
            // set
            model = item;
          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {
            // set
            model = item.model;
            as = item.as;
          }

          if (model) {
            // set the as to either the through name or the model name
            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {
              // get from previous association
              item = new Association(previousModel, model, {
                as: model.name
              });
            } else {
              // get association from previous model
              item = previousModel.getAssociationForAlias(model, as);

              // attempt to use the model name if the item is still null
              if (!item) {
                item = previousModel.getAssociationForAlias(model, model.name);
              }
            }

            // make sure we have an association
            if (!(item instanceof Association)) {
              throw new Error(util.format('Unable to find a valid association for model, \'%s\'', model.name));
            }
          }
        }

        if (typeof item === 'string') {
          // get order index
          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());

          // see if this is an order
          if (index > 0 && orderIndex !== -1) {
            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);
          } else if (previousModel && previousModel.prototype instanceof Model) {
            // only go down this path if we have preivous model and check only once
            if (previousModel.associations !== undefined && previousModel.associations[item]) {
              // convert the item to an association
              item = previousModel.associations[item];
            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {
              // convert the item attribute from its alias
              item = previousModel.rawAttributes[item].field;
            } else if (
              item.includes('.')
              && previousModel.rawAttributes !== undefined
            ) {
              const itemSplit = item.split('.');

              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {
                // just quote identifiers for now
                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);

                // get path
                const path = itemSplit.slice(1);

                // extract path
                item = this.jsonPathExtractionQuery(identifier, path);

                // literal because we don't want to append the model name when string
                item = this.sequelize.literal(item);
              }
            }
          }
        }

        collection[index] = item;
      }, this);

      // loop through array, adding table names of models to quoted
      const collectionLength = collection.length;
      const tableNames = [];
      let item;
      let i = 0;

      for (i = 0; i < collectionLength - 1; i++) {
        item = collection[i];
        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {
          break;
        } else if (item instanceof Association) {
          tableNames[i] = item.as;
        }
      }

      // start building sql
      let sql = '';

      if (i > 0) {
        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;
      } else if (typeof collection[0] === 'string' && parent) {
        sql += `${this.quoteIdentifier(parent.name)}.`;
      }

      // loop through everything past i and append to the sql
      collection.slice(i).forEach(collectionItem => {
        sql += this.quote(collectionItem, parent, connector);
      }, this);

      return sql;
    }
    if (collection._modelAttribute) {
      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;
    }
    if (collection instanceof Utils.SequelizeMethod) {
      return this.handleSequelizeMethod(collection);
    }
    if (_.isPlainObject(collection) && collection.raw) {
      // simple objects with raw is no longer supported
      throw new Error('The `{raw: "..."}` syntax is no longer supported.  Use `sequelize.literal` instead.');
    }
    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);
  }

  /**
   * Split a list of identifiers by "." and quote each part
   *
   * @param {string} identifier
   * @param {boolean} force
   *
   * @returns {string}
   */
  quoteIdentifier(identifier, force) {
    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {
      force,
      quoteIdentifiers: this.options.quoteIdentifiers
    });
  }

  quoteIdentifiers(identifiers) {
    if (identifiers.includes('.')) {
      identifiers = identifiers.split('.');

      const head = identifiers.slice(0, identifiers.length - 1).join('->');
      const tail = identifiers[identifiers.length - 1];

      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;
    }

    return this.quoteIdentifier(identifiers);
  }

  quoteAttribute(attribute, model) {
    if (model && attribute in model.rawAttributes) {
      return this.quoteIdentifier(attribute);
    }
    return this.quoteIdentifiers(attribute);
  }

  /**
   * Quote table name with optional alias and schema attribution
   *
   * @param {string|object}  param table string or object
   * @param {string|boolean} alias alias name
   *
   * @returns {string}
   */
  quoteTable(param, alias) {
    let table = '';

    if (alias === true) {
      alias = param.as || param.name || param;
    }

    if (_.isObject(param)) {
      if (this._dialect.supports.schemas) {
        if (param.schema) {
          table += `${this.quoteIdentifier(param.schema)}.`;
        }

        table += this.quoteIdentifier(param.tableName);
      } else {
        if (param.schema) {
          table += param.schema + (param.delimiter || '.');
        }

        table += param.tableName;
        table = this.quoteIdentifier(table);
      }
    } else {
      table = this.quoteIdentifier(param);
    }

    if (alias) {
      table += ` AS ${this.quoteIdentifier(alias)}`;
    }

    return table;
  }

  /*
    Escape a value (e.g. a string, number or date)
    @private
  */
  escape(value, field, options) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(value);
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.stringify) {
          // Users shouldn't have to worry about these args - just give them a function that takes a single arg
          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);

          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });

          if (field.type.escape === false) {
            // The data-type already did the required escaping
            return value;
          }
        }
      }
    }
    return SqlString.escape(value, this.options.timezone, this.dialect);
  }

  bindParam(bind) {
    return value => {
      bind.push(value);
      return `$${bind.length}`;
    };
  }

  /*
    Returns a bind parameter representation of a value (e.g. a string, number or date)
    @private
  */
  format(value, field, options, bindParam) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.bindParam) {
          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });
        }
      }
    }

    return bindParam(value);
  }

  /*
    Validate a value against a field specification
    @private
  */
  validate(value, field, options) {
    if (this.typeValidation && field.type.validate && value) {
      try {
        if (options.isList && Array.isArray(value)) {
          for (const item of value) {
            field.type.validate(item, options);
          }
        } else {
          field.type.validate(value, options);
        }
      } catch (error) {
        if (error instanceof sequelizeError.ValidationError) {
          error.errors.push(new sequelizeError.ValidationErrorItem(
            error.message,
            'Validation error',
            field.fieldName,
            value,
            null,
            `${field.type.key} validator`
          ));
        }

        throw error;
      }
    }
  }

  isIdentifierQuoted(identifier) {
    return QuoteHelper.isIdentifierQuoted(identifier);
  }

  /**
   * Generates an SQL query that extract JSON property of given path.
   *
   * @param   {string}               column  The JSON column
   * @param   {string|Array<string>} [path]  The path to extract (optional)
   * @returns {string}                       The generated sql query
   * @private
   */
  jsonPathExtractionQuery(column, path) {
    let paths = _.toPath(path);
    let pathStr;
    const quotedColumn = this.isIdentifierQuoted(column)
      ? column
      : this.quoteIdentifier(column);

    switch (this.dialect) {
      case 'mysql':
      case 'mariadb':
      case 'sqlite':
        /**
         * Non digit sub paths need to be quoted as ECMAScript identifiers
         * https://bugs.mysql.com/bug.php?id=81896
         */
        if (this.dialect === 'mysql') {
          paths = paths.map(subPath => {
            return /\D/.test(subPath)
              ? Utils.addTicks(subPath, '"')
              : subPath;
          });
        }

        pathStr = this.escape(['$']
          .concat(paths)
          .join('.')
          .replace(/\.(\d+)(?:(?=\.)|$)/g, (__, digit) => `[${digit}]`));

        if (this.dialect === 'sqlite') {
          return `json_extract(${quotedColumn},${pathStr})`;
        }

        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;

      case 'postgres':
        pathStr = this.escape(`{${paths.join(',')}}`);
        return `(${quotedColumn}#>>${pathStr})`;

      default:
        throw new Error(`Unsupported ${this.dialect} for JSON operations`);
    }
  }

  /*
    Returns a query for selecting elements in the table <tableName>.
    Options:
      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
      - order -> e.g. 'id DESC'
      - group
      - limit -> The maximum count you want to get.
      - offset -> An offset value to start from. Only useable with limit!
   @private
  */
  selectQuery(tableName, options, model) {
    options = options || {};
    const limit = options.limit;
    const mainQueryItems = [];
    const subQueryItems = [];
    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;
    const attributes = {
      main: options.attributes && options.attributes.slice(),
      subQuery: null
    };
    const mainTable = {
      name: tableName,
      quotedName: null,
      as: null,
      model
    };
    const topLevelInfo = {
      names: mainTable,
      options,
      subQuery
    };
    let mainJoinQueries = [];
    let subJoinQueries = [];
    let query;

    // Aliases can be passed through subqueries and we don't want to reset them
    if (this.options.minifyAliases && !options.aliasesMapping) {
      options.aliasesMapping = new Map();
      options.aliasesByTable = {};
      options.includeAliases = new Map();
    }

    // resolve table name options
    if (options.tableAs) {
      mainTable.as = this.quoteIdentifier(options.tableAs);
    } else if (!Array.isArray(mainTable.name) && mainTable.model) {
      mainTable.as = this.quoteIdentifier(mainTable.model.name);
    }

    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {
      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);
    }).join(', ');

    if (subQuery && attributes.main) {
      for (const keyAtt of mainTable.model.primaryKeyAttributes) {
        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field
        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {
          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);
        }
      }
    }

    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);
    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);

    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery
    if (subQuery || options.groupedLimit) {
      // We need primary keys
      attributes.subQuery = attributes.main;
      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];
    }

    if (options.include) {
      for (const include of options.include) {
        if (include.separate) {
          continue;
        }
        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);

        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

        if (joinQueries.attributes.main.length > 0) {
          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));
        }
        if (joinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));
        }
      }
    }

    if (subQuery) {
      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));
      subQueryItems.push(subJoinQueries.join(''));
    } else {
      if (options.groupedLimit) {
        if (!mainTable.as) {
          mainTable.as = mainTable.quotedName;
        }
        const where = { ...options.where };
        let groupedLimitOrder,
          whereKey,
          include,
          groupedTableName = mainTable.as;

        if (typeof options.groupedLimit.on === 'string') {
          whereKey = options.groupedLimit.on;
        } else if (options.groupedLimit.on instanceof HasMany) {
          whereKey = options.groupedLimit.on.foreignKeyField;
        }

        if (options.groupedLimit.on instanceof BelongsToMany) {
          // BTM includes needs to join the through table on to check ID
          groupedTableName = options.groupedLimit.on.manyFromSource.as;
          const groupedLimitOptions = Model._validateIncludedElements({
            include: [{
              association: options.groupedLimit.on.manyFromSource,
              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot
              required: true,
              where: {
                [Op.placeholder]: true,
                ...options.groupedLimit.through && options.groupedLimit.through.where
              }
            }],
            model
          });

          // Make sure attributes from the join table are mapped back to models
          options.hasJoin = true;
          options.hasMultiAssociation = true;
          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);
          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
          include = groupedLimitOptions.include;

          if (Array.isArray(options.order)) {
            // We need to make sure the order by attributes are available to the parent query
            options.order.forEach((order, i) => {
              if (Array.isArray(order)) {
                order = order[0];
              }

              let alias = `subquery_order_${i}`;
              options.attributes.push([order, alias]);

              // We don't want to prepend model name when we alias the attributes, so quote them here
              alias = this.sequelize.literal(this.quote(alias));

              if (Array.isArray(options.order[i])) {
                options.order[i][0] = alias;
              } else {
                options.order[i] = alias;
              }
            });
            groupedLimitOrder = options.order;
          }
        } else {
          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed
          groupedLimitOrder = options.order;
          delete options.order;
          where[Op.placeholder] = true;
        }

        // Caching the base query and splicing the where part into it is consistently > twice
        // as fast than generating from scratch each time for values.length >= 5
        const baseQuery = `SELECT * FROM (${this.selectQuery(
          tableName,
          {
            attributes: options.attributes,
            offset: options.offset,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            aliasesMapping: options.aliasesMapping,
            aliasesByTable: options.aliasesByTable,
            where,
            include,
            model
          },
          model
        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias
        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });
        const splicePos = baseQuery.indexOf(placeHolder);

        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${
          options.groupedLimit.values.map(value => {
            let groupWhere;
            if (whereKey) {
              groupWhere = {
                [whereKey]: value
              };
            }
            if (include) {
              groupWhere = {
                [options.groupedLimit.on.foreignIdentifierField]: value
              };
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
          }).join(
            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '
          )
        })`, mainTable.as));
      } else {
        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));
      }

      mainQueryItems.push(mainJoinQueries.join(''));
    }

    // Add WHERE to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {
      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);
      if (options.where) {
        if (subQuery) {
          subQueryItems.push(` WHERE ${options.where}`);
        } else {
          mainQueryItems.push(` WHERE ${options.where}`);
          // Walk the main query to update all selects
          mainQueryItems.forEach((value, key) => {
            if (value.startsWith('SELECT')) {
              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);
            }
          });
        }
      }
    }

    // Add GROUP BY to sub or main query
    if (options.group) {
      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);

      if (subQuery && options.group) {
        subQueryItems.push(` GROUP BY ${options.group}`);
      } else if (options.group) {
        mainQueryItems.push(` GROUP BY ${options.group}`);
      }
    }

    // Add HAVING to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'having')) {
      options.having = this.getWhereConditions(options.having, tableName, model, options, false);
      if (options.having) {
        if (subQuery) {
          subQueryItems.push(` HAVING ${options.having}`);
        } else {
          mainQueryItems.push(` HAVING ${options.having}`);
        }
      }
    }

    // Add ORDER to sub or main query
    if (options.order) {
      const orders = this.getQueryOrders(options, model, subQuery);
      if (orders.mainQueryOrder.length) {
        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);
      }
      if (orders.subQueryOrder.length) {
        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);
      }
    }

    // Add LIMIT, OFFSET to sub or main query
    const limitOrder = this.addLimitAndOffset(options, mainTable.model);
    if (limitOrder && !options.groupedLimit) {
      if (subQuery) {
        subQueryItems.push(limitOrder);
      } else {
        mainQueryItems.push(limitOrder);
      }
    }

    if (subQuery) {
      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });
      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;
    } else {
      query = mainQueryItems.join('');
    }

    if (options.lock && this._dialect.supports.lock) {
      let lock = options.lock;
      if (typeof options.lock === 'object') {
        lock = options.lock.level;
      }
      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {
        query += ` FOR ${lock}`;
      } else if (lock === 'SHARE') {
        query += ` ${this._dialect.supports.forShare}`;
      } else {
        query += ' FOR UPDATE';
      }
      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {
        query += ` OF ${this.quoteTable(options.lock.of.name)}`;
      }
      if (this._dialect.supports.skipLocked && options.skipLocked) {
        query += ' SKIP LOCKED';
      }
    }

    return `${query};`;
  }

  aliasGrouping(field, model, tableName, options) {
    const src = Array.isArray(field) ? field[0] : field;

    return this.quote(this._getAliasForField(tableName, src, options) || src, model);
  }

  escapeAttributes(attributes, options, mainTableAs) {
    return attributes && attributes.map(attr => {
      let addTable = true;

      if (attr instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(attr);
      }
      if (Array.isArray(attr)) {
        if (attr.length !== 2) {
          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);
        }
        attr = attr.slice();

        if (attr[0] instanceof Utils.SequelizeMethod) {
          attr[0] = this.handleSequelizeMethod(attr[0]);
          addTable = false;
        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {
          attr[0] = this.quoteIdentifier(attr[0]);
        } else {
          deprecations.noRawAttributes();
        }
        let alias = attr[1];

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, mainTableAs, options);
        }

        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');
      } else {
        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('"')
          ? this.quoteAttribute(attr, options.model)
          : this.escape(attr);
      }
      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {
        attr = `${mainTableAs}.${attr}`;
      }

      return attr;
    });
  }

  generateInclude(include, parentTableName, topLevelInfo) {
    const joinQueries = {
      mainQuery: [],
      subQuery: []
    };
    const mainChildIncludes = [];
    const subChildIncludes = [];
    let requiredMismatch = false;
    const includeAs = {
      internalAs: include.as,
      externalAs: include.as
    };
    const attributes = {
      main: [],
      subQuery: []
    };
    let joinQuery;

    topLevelInfo.options.keysEscaped = true;

    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {
      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;
      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;
    }

    // includeIgnoreAttributes is used by aggregate functions
    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      include.model._expandAttributes(include);
      Utils.mapFinderOptions(include, include.model);

      const includeAttributes = include.attributes.map(attr => {
        let attrAs = attr;
        let verbatim = false;

        if (Array.isArray(attr) && attr.length === 2) {
          if (attr[0] instanceof Utils.SequelizeMethod && (
            attr[0] instanceof Utils.Literal ||
            attr[0] instanceof Utils.Cast ||
            attr[0] instanceof Utils.Fn
          )) {
            verbatim = true;
          }

          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);

          attrAs = attr[1];
          attr = attr[0];
        }
        if (attr instanceof Utils.Literal) {
          return attr.val; // We trust the user to rename the field correctly
        }
        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {
          throw new Error(
            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +
            'This means the attribute will not be added to the returned instance'
          );
        }

        let prefix;
        if (verbatim === true) {
          prefix = attr;
        } else if (/#>>|->>/.test(attr)) {
          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\(|\)/g, '')})`;
        } else if (/json_extract\(/.test(attr)) {
          prefix = attr.replace(/json_extract\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);
        } else {
          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;
        }
        let alias = `${includeAs.externalAs}.${attrAs}`;

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);
        }

        return Utils.joinSQLFragments([
          prefix,
          'AS',
          this.quoteIdentifier(alias, true)
        ]);
      });
      if (include.subQuery && topLevelInfo.subQuery) {
        for (const attr of includeAttributes) {
          attributes.subQuery.push(attr);
        }
      } else {
        for (const attr of includeAttributes) {
          attributes.main.push(attr);
        }
      }
    }

    //through
    if (include.through) {
      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);
    } else {
      this._generateSubQueryFilter(include, includeAs, topLevelInfo);
      joinQuery = this.generateJoin(include, topLevelInfo);
    }

    // handle possible new attributes created in join
    if (joinQuery.attributes.main.length > 0) {
      attributes.main = attributes.main.concat(joinQuery.attributes.main);
    }

    if (joinQuery.attributes.subQuery.length > 0) {
      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);
    }

    if (include.include) {
      for (const childInclude of include.include) {
        if (childInclude.separate || childInclude._pseudo) {
          continue;
        }

        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);

        if (include.required === false && childInclude.required === true) {
          requiredMismatch = true;
        }
        // if the child is a sub query we just give it to the
        if (childInclude.subQuery && topLevelInfo.subQuery) {
          subChildIncludes.push(childJoinQueries.subQuery);
        }
        if (childJoinQueries.mainQuery) {
          mainChildIncludes.push(childJoinQueries.mainQuery);
        }
        if (childJoinQueries.attributes.main.length > 0) {
          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);
        }
        if (childJoinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);
        }
      }
    }

    if (include.subQuery && topLevelInfo.subQuery) {
      if (requiredMismatch && subChildIncludes.length > 0) {
        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (subChildIncludes.length > 0) {
          joinQueries.subQuery.push(subChildIncludes.join(''));
        }
      }
      joinQueries.mainQuery.push(mainChildIncludes.join(''));
    } else {
      if (requiredMismatch && mainChildIncludes.length > 0) {
        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (mainChildIncludes.length > 0) {
          joinQueries.mainQuery.push(mainChildIncludes.join(''));
        }
      }
      joinQueries.subQuery.push(subChildIncludes.join(''));
    }

    return {
      mainQuery: joinQueries.mainQuery.join(''),
      subQuery: joinQueries.subQuery.join(''),
      attributes
    };
  }

  _getMinifiedAlias(alias, tableName, options) {
    // We do not want to re-alias in case of a subquery
    if (options.aliasesByTable[`${tableName}${alias}`]) {
      return options.aliasesByTable[`${tableName}${alias}`];
    }

    // Do not alias custom suquery_orders
    if (alias.match(/subquery_order_[0-9]/)) {
      return alias;
    }

    const minifiedAlias = `_${options.aliasesMapping.size}`;

    options.aliasesMapping.set(minifiedAlias, alias);
    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;

    return minifiedAlias;
  }

  _getAliasForField(tableName, field, options) {
    if (this.options.minifyAliases) {
      if (options.aliasesByTable[`${tableName}${field}`]) {
        return options.aliasesByTable[`${tableName}${field}`];
      }
    }
    return null;
  }

  generateJoin(include, topLevelInfo) {
    const association = include.association;
    const parent = include.parent;
    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    let $parent;
    let joinWhere;
    /* Attributes for the left side */
    const left = association.source;
    const attrLeft = association instanceof BelongsTo ?
      association.identifier :
      association.sourceKeyAttribute || left.primaryKeyAttribute;
    const fieldLeft = association instanceof BelongsTo ?
      association.identifierField :
      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;
    let asLeft;
    /* Attributes for the right side */
    const right = include.model;
    const tableRight = right.getTableName();
    const fieldRight = association instanceof BelongsTo ?
      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :
      association.identifierField;
    let asRight = include.as;

    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {
      if (asLeft) {
        asLeft = `${$parent.as}->${asLeft}`;
      } else {
        asLeft = $parent.as;
      }
    }

    if (!asLeft) asLeft = parent.as || parent.model.name;
    else asRight = `${asLeft}->${asRight}`;

    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;
    const subqueryAttributes = [];

    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {
      if (parentIsTop) {
        // The main model attributes is not aliased to a prefix
        const tableName = this.quoteTable(parent.as || parent.model.name);

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;

        if (topLevelInfo.subQuery) {
          subqueryAttributes.push(`${tableName}.${this.quoteIdentifier(fieldLeft)}`);
        }
      } else {
        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);
      }
    }

    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;

    if (include.on) {
      joinOn = this.whereItemsQuery(include.on, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
    }

    if (include.where) {
      joinWhere = this.whereItemsQuery(include.where, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
      if (joinWhere) {
        if (include.or) {
          joinOn += ` OR ${joinWhere}`;
        } else {
          joinOn += ` AND ${joinWhere}`;
        }
      }
    }

    if (this.options.minifyAliases && asRight.length > 63) {
      const alias = `%${topLevelInfo.options.includeAliases.size}`;

      topLevelInfo.options.includeAliases.set(alias, asRight);
    }

    return {
      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',
      body: this.quoteTable(tableRight, asRight),
      condition: joinOn,
      attributes: {
        main: [],
        subQuery: subqueryAttributes
      }
    };
  }

  /**
   * Returns the SQL fragments to handle returning the attributes from an insert/update query.
   *
   * @param  {object} modelAttributes An object with the model attributes.
   * @param  {object} options         An object with options.
   *
   * @private
   */
  generateReturnValues(modelAttributes, options) {
    const returnFields = [];
    const returnTypes = [];
    let outputFragment = '';
    let returningFragment = '';
    let tmpTable = '';

    if (Array.isArray(options.returning)) {
      returnFields.push(...options.returning.map(field => this.quoteIdentifier(field)));
    } else if (modelAttributes) {
      _.each(modelAttributes, attribute => {
        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {
          returnFields.push(this.quoteIdentifier(attribute.field));
          returnTypes.push(attribute.type);
        }
      });
    }

    if (_.isEmpty(returnFields)) {
      returnFields.push('*');
    }

    if (this._dialect.supports.returnValues.returning) {
      returningFragment = ` RETURNING ${returnFields.join(',')}`;
    } else if (this._dialect.supports.returnValues.output) {
      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(',')}`;

      //To capture output rows when there is a trigger on MSSQL DB
      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);

        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;
        outputFragment += ' INTO @tmp';
        returningFragment = '; SELECT * FROM @tmp';
      }
    }

    return { outputFragment, returnFields, returningFragment, tmpTable };
  }

  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {
    const through = include.through;
    const throughTable = through.model.getTableName();
    const throughAs = `${includeAs.internalAs}->${through.as}`;
    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;
    const throughAttributes = through.attributes.map(attr => {
      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;

      if (this.options.minifyAliases) {
        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);
      }

      return Utils.joinSQLFragments([
        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,
        'AS',
        this.quoteIdentifier(alias)
      ]);
    });
    const association = include.association;
    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    const tableSource = parentTableName;
    const identSource = association.identifierField;
    const tableTarget = includeAs.internalAs;
    const identTarget = association.foreignIdentifierField;
    const attrTarget = association.targetKeyField;

    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';
    let joinBody;
    let joinCondition;
    const attributes = {
      main: [],
      subQuery: []
    };
    let attrSource = association.sourceKey;
    let sourceJoinOn;
    let targetJoinOn;
    let throughWhere;
    let targetWhere;

    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)
      for (const attr of throughAttributes) {
        attributes.main.push(attr);
      }
    }

    // Figure out if we need to use field or attribute
    if (!topLevelInfo.subQuery) {
      attrSource = association.sourceKeyField;
    }
    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {
      attrSource = association.sourceKeyField;
    }

    // Filter statement for left side of through
    // Used by both join and subquery where
    // If parent include was in a subquery need to join on the aliased attribute
    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;

      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;
    } else {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;

      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;
    }
    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;

    // Filter statement for right side of through
    // Used by both join and subquery where
    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;
    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;

    if (through.where) {
      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);
    }

    if (this._dialect.supports.joinTableDependent) {
      // Generate a wrapped join so that the through table join can be dependent on the target join
      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;
      if (throughWhere) {
        joinBody += ` AND ${throughWhere}`;
      }
      joinBody += ')';
      joinCondition = sourceJoinOn;
    } else {
      // Generate join SQL for left side of through
      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;
      joinCondition = targetJoinOn;
      if (throughWhere) {
        joinCondition += ` AND ${throughWhere}`;
      }
    }

    if (include.where || include.through.where) {
      if (include.where) {
        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);
        if (targetWhere) {
          joinCondition += ` AND ${targetWhere}`;
        }
      }
    }

    this._generateSubQueryFilter(include, includeAs, topLevelInfo);

    return {
      join: joinType,
      body: joinBody,
      condition: joinCondition,
      attributes
    };
  }

  /*
   * Generates subQueryFilter - a select nested in the where clause of the subQuery.
   * For a given include a query is generated that contains all the way from the subQuery
   * table to the include table plus everything that's in required transitive closure of the
   * given include.
   */
  _generateSubQueryFilter(include, includeAs, topLevelInfo) {
    if (!topLevelInfo.subQuery || !include.subQueryFilter) {
      return;
    }

    if (!topLevelInfo.options.where) {
      topLevelInfo.options.where = {};
    }
    let parent = include;
    let child = include;
    let nestedIncludes = this._getRequiredClosure(include).include;
    let query;

    while ((parent = parent.parent)) { // eslint-disable-line
      if (parent.parent && !parent.required) {
        return; // only generate subQueryFilter if all the parents of this include are required
      }

      if (parent.subQueryFilter) {
        // the include is already handled as this parent has the include on its required closure
        // skip to prevent duplicate subQueryFilter
        return;
      }

      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];
      child = parent;
    }

    const topInclude = nestedIncludes[0];
    const topParent = topInclude.parent;
    const topAssociation = topInclude.association;
    topInclude.association = undefined;

    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
      query = this.selectQuery(topInclude.through.model.getTableName(), {
        attributes: [topInclude.through.model.primaryKeyField],
        include: Model._validateIncludedElements({
          model: topInclude.through.model,
          include: [{
            association: topAssociation.toTarget,
            required: true,
            where: topInclude.where,
            include: topInclude.include
          }]
        }).include,
        model: topInclude.through.model,
        where: {
          [Op.and]: [
            this.sequelize.literal([
              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,
              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`
            ].join(' = ')),
            topInclude.through.where
          ]
        },
        limit: 1,
        includeIgnoreAttributes: false
      }, topInclude.through.model);
    } else {
      const isBelongsTo = topAssociation.associationType === 'BelongsTo';
      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;
      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;

      const join = [
        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,
        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`
      ].join(' = ');

      query = this.selectQuery(topInclude.model.getTableName(), {
        attributes: [targetField],
        include: Model._validateIncludedElements(topInclude).include,
        model: topInclude.model,
        where: {
          [Op.and]: [
            topInclude.where,
            { [Op.join]: this.sequelize.literal(join) }
          ]
        },
        limit: 1,
        tableAs: topInclude.as,
        includeIgnoreAttributes: false
      }, topInclude.model);
    }

    if (!topLevelInfo.options.where[Op.and]) {
      topLevelInfo.options.where[Op.and] = [];
    }

    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([
      '(',
      query.replace(/;$/, ''),
      ')',
      'IS NOT NULL'
    ].join(' '));
  }

  /*
   * For a given include hierarchy creates a copy of it where only the required includes
   * are preserved.
   */
  _getRequiredClosure(include) {
    const copy = { ...include, attributes: [], include: [] };

    if (Array.isArray(include.include)) {
      copy.include = include.include
        .filter(i => i.required)
        .map(inc => this._getRequiredClosure(inc));
    }

    return copy;
  }

  getQueryOrders(options, model, subQuery) {
    const mainQueryOrder = [];
    const subQueryOrder = [];

    if (Array.isArray(options.order)) {
      for (let order of options.order) {

        // wrap if not array
        if (!Array.isArray(order)) {
          order = [order];
        }

        if (
          subQuery
          && Array.isArray(order)
          && order[0]
          && !(order[0] instanceof Association)
          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)
          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)
          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])
        ) {
          subQueryOrder.push(this.quote(order, model, '->'));
        }

        if (subQuery) {
          // Handle case where sub-query renames attribute we want to order by,
          // see https://github.com/sequelize/sequelize/issues/8739
          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);
          if (subQueryAttribute) {
            const modelName = this.quoteIdentifier(model.name);

            order[0] = new Utils.Col(this._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);
          }
        }

        mainQueryOrder.push(this.quote(order, model, '->'));
      }
    } else if (options.order instanceof Utils.SequelizeMethod) {
      const sql = this.quote(options.order, model, '->');
      if (subQuery) {
        subQueryOrder.push(sql);
      }
      mainQueryOrder.push(sql);
    } else {
      throw new Error('Order must be type of array or instance of a valid sequelize method.');
    }

    return { mainQueryOrder, subQueryOrder };
  }

  _throwOnEmptyAttributes(attributes, extraInfo = {}) {
    if (attributes.length > 0) return;
    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';
    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';
    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;
    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;

    if (mainTableAs) {
      fragment += ` AS ${mainTableAs}`;
    }

    if (options.indexHints && this._dialect.supports.indexHints) {
      for (const hint of options.indexHints) {
        if (IndexHints[hint.type]) {
          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;
        }
      }
    }

    return fragment;
  }

  /**
   * Returns an SQL fragment for adding result constraints.
   *
   * @param  {object} options An object with selectQuery options.
   * @returns {string}         The generated sql query.
   * @private
   */
  addLimitAndOffset(options) {
    let fragment = '';

    /* eslint-disable */
    if (options.offset != null && options.limit == null) {
      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;
    } else if (options.limit != null) {
      if (options.offset != null) {
        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);
      } else {
        fragment += ' LIMIT ' + this.escape(options.limit);
      }
    }
    /* eslint-enable */

    return fragment;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    let result;

    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {
      smth.comparator = this.OperatorMap[smth.comparator];
    }

    if (smth instanceof Utils.Where) {
      let value = smth.logic;
      let key;

      if (smth.attribute instanceof Utils.SequelizeMethod) {
        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
      } else {
        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;
      }

      if (value && value instanceof Utils.SequelizeMethod) {
        value = this.getWhereConditions(value, tableName, factory, options, prepend);

        if (value === 'NULL') {
          if (smth.comparator === '=') {
            smth.comparator = 'IS';
          }
          if (smth.comparator === '!=') {
            smth.comparator = 'IS NOT';
          }
        }

        return [key, value].join(` ${smth.comparator} `);
      }
      if (_.isPlainObject(value)) {
        return this.whereItemQuery(smth.attribute, value, {
          model: factory
        });
      }
      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {
        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;
      } else if (typeof value === 'boolean') {
        value = this.booleanValue(value);
      } else {
        value = this.escape(value);
      }

      if (value === 'NULL') {
        if (smth.comparator === '=') {
          smth.comparator = 'IS';
        }
        if (smth.comparator === '!=') {
          smth.comparator = 'IS NOT';
        }
      }

      return [key, value].join(` ${smth.comparator} `);
    }
    if (smth instanceof Utils.Literal) {
      return smth.val;
    }
    if (smth instanceof Utils.Cast) {
      if (smth.val instanceof Utils.SequelizeMethod) {
        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
      } else if (_.isPlainObject(smth.val)) {
        result = this.whereItemsQuery(smth.val);
      } else {
        result = this.escape(smth.val);
      }

      return `CAST(${result} AS ${smth.type.toUpperCase()})`;
    }
    if (smth instanceof Utils.Fn) {
      return `${smth.fn}(${
        smth.args.map(arg => {
          if (arg instanceof Utils.SequelizeMethod) {
            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);
          }
          if (_.isPlainObject(arg)) {
            return this.whereItemsQuery(arg);
          }
          return this.escape(typeof arg === 'string' ? arg.replace('$', '$$$') : arg);
        }).join(', ')
      })`;
    }
    if (smth instanceof Utils.Col) {
      if (Array.isArray(smth.col) && !factory) {
        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');
      }
      if (smth.col.startsWith('*')) {
        return '*';
      }
      return this.quote(smth.col, factory);
    }
    return smth.toString(this, factory);
  }

  whereQuery(where, options) {
    const query = this.whereItemsQuery(where, options);
    if (query && query.length) {
      return `WHERE ${query}`;
    }
    return '';
  }

  whereItemsQuery(where, options, binding) {
    if (
      where === null ||
      where === undefined ||
      Utils.getComplexSize(where) === 0
    ) {
      // NO OP
      return '';
    }

    if (typeof where === 'string') {
      throw new Error('Support for `{where: \'raw query\'}` has been removed.');
    }

    const items = [];

    binding = binding || 'AND';
    if (binding[0] !== ' ') binding = ` ${binding} `;

    if (_.isPlainObject(where)) {
      Utils.getComplexKeys(where).forEach(prop => {
        const item = where[prop];
        items.push(this.whereItemQuery(prop, item, options));
      });
    } else {
      items.push(this.whereItemQuery(undefined, where, options));
    }

    return items.length && items.filter(item => item && item.length).join(binding) || '';
  }

  whereItemQuery(key, value, options = {}) {
    if (value === undefined) {
      throw new Error(`WHERE parameter "${key}" has invalid "undefined" value`);
    }

    if (typeof key === 'string' && key.includes('.') && options.model) {
      const keyParts = key.split('.');
      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {
        const tmp = {};
        const field = options.model.rawAttributes[keyParts[0]];
        _.set(tmp, keyParts.slice(1), value);
        return this.whereItemQuery(field.field || keyParts[0], tmp, { field, ...options });
      }
    }

    const field = this._findField(key, options);
    const fieldType = field && field.type || options.type;

    const isPlainObject = _.isPlainObject(value);
    const isArray = !isPlainObject && Array.isArray(value);
    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;
    if (isPlainObject) {
      value = this._replaceAliases(value);
    }
    const valueKeys = isPlainObject && Utils.getComplexKeys(value);

    if (key === undefined) {
      if (typeof value === 'string') {
        return value;
      }

      if (isPlainObject && valueKeys.length === 1) {
        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);
      }
    }

    if (value === null) {
      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);
    }

    if (!value) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {
      return this.handleSequelizeMethod(value);
    }

    // Convert where: [] to Op.and if possible, else treat as literal/replacements
    if (key === undefined && isArray) {
      if (Utils.canTreatArrayAsAnd(value)) {
        key = Op.and;
      } else {
        throw new Error('Support for literal replacements in the `where` object has been removed.');
      }
    }

    if (key === Op.or || key === Op.and || key === Op.not) {
      return this._whereGroupBind(key, value, options);
    }


    if (value[Op.or]) {
      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);
    }

    if (value[Op.and]) {
      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);
    }

    if (isArray && fieldType instanceof DataTypes.ARRAY) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {
      return this._whereJSON(key, value, options);
    }
    // If multiple keys we combine the different logic conditions
    if (isPlainObject && valueKeys.length > 1) {
      return this._whereBind(this.OperatorMap[Op.and], key, value, options);
    }

    if (isArray) {
      return this._whereParseSingleValueObject(key, field, Op.in, value, options);
    }
    if (isPlainObject) {
      if (this.OperatorMap[valueKeys[0]]) {
        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);
      }
      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);
    }

    if (key === Op.placeholder) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
  }

  _findField(key, options) {
    if (options.field) {
      return options.field;
    }

    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {
      return options.model.rawAttributes[key];
    }

    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {
      return options.model.fieldRawAttributesMap[key];
    }
  }

  // OR/AND/NOT grouping logic
  _whereGroupBind(key, value, options) {
    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];
    const outerBinding = key === Op.not ? 'NOT ' : '';

    if (Array.isArray(value)) {
      value = value.map(item => {
        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);
        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {
          itemQuery = `(${itemQuery})`;
        }
        return itemQuery;
      }).filter(item => item && item.length);

      value = value.length && value.join(binding);
    } else {
      value = this.whereItemsQuery(value, options, binding);
    }
    // Op.or: [] should return no data.
    // Op.not of no restriction should also return no data
    if ((key === Op.or || key === Op.not) && !value) {
      return '0 = 1';
    }

    return value ? `${outerBinding}(${value})` : undefined;
  }

  _whereBind(binding, key, value, options) {
    if (_.isPlainObject(value)) {
      value = Utils.getComplexKeys(value).map(prop => {
        const item = value[prop];
        return this.whereItemQuery(key, { [prop]: item }, options);
      });
    } else {
      value = value.map(item => this.whereItemQuery(key, item, options));
    }

    value = value.filter(item => item && item.length);

    return value.length ? `(${value.join(binding)})` : undefined;
  }

  _whereJSON(key, value, options) {
    const items = [];
    let baseKey = this.quoteIdentifier(key);
    if (options.prefix) {
      if (options.prefix instanceof Utils.Literal) {
        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;
      } else {
        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;
      }
    }

    Utils.getOperators(value).forEach(op => {
      const where = {
        [op]: value[op]
      };
      items.push(this.whereItemQuery(key, where, { ...options, json: false }));
    });

    _.forOwn(value, (item, prop) => {
      this._traverseJSON(items, baseKey, prop, item, [prop]);
    });

    const result = items.join(this.OperatorMap[Op.and]);
    return items.length > 1 ? `(${result})` : result;
  }

  _traverseJSON(items, baseKey, prop, item, path) {
    let cast;

    if (path[path.length - 1].includes('::')) {
      const tmp = path[path.length - 1].split('::');
      cast = tmp[1];
      path[path.length - 1] = tmp[0];
    }

    const pathKey = this.jsonPathExtractionQuery(baseKey, path);

    if (_.isPlainObject(item)) {
      Utils.getOperators(item).forEach(op => {
        const value = this._toJSONValue(item[op]);
        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));
      });
      _.forOwn(item, (value, itemProp) => {
        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));
      });

      return;
    }

    item = this._toJSONValue(item);
    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));
  }

  _toJSONValue(value) {
    return value;
  }

  _castKey(key, value, cast, json) {
    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);
    if (cast) {
      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));
    }

    return new Utils.Literal(key);
  }

  _getJsonCast(value) {
    if (typeof value === 'number') {
      return 'double precision';
    }
    if (value instanceof Date) {
      return 'timestamptz';
    }
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    return;
  }

  _joinKeyValue(key, value, comparator, prefix) {
    if (!key) {
      return value;
    }
    if (comparator === undefined) {
      throw new Error(`${key} and ${value} has no comparator`);
    }
    key = this._getSafeKey(key, prefix);
    return [key, value].join(` ${comparator} `);
  }

  _getSafeKey(key, prefix) {
    if (key instanceof Utils.SequelizeMethod) {
      key = this.handleSequelizeMethod(key);
      return this._prefixKey(this.handleSequelizeMethod(key), prefix);
    }

    if (Utils.isColString(key)) {
      key = key.substr(1, key.length - 2).split('.');

      if (key.length > 2) {
        key = [
          // join the tables by -> to match out internal namings
          key.slice(0, -1).join('->'),
          key[key.length - 1]
        ];
      }

      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');
    }

    return this._prefixKey(this.quoteIdentifier(key), prefix);
  }

  _prefixKey(key, prefix) {
    if (prefix) {
      if (prefix instanceof Utils.Literal) {
        return [this.handleSequelizeMethod(prefix), key].join('.');
      }

      return [this.quoteTable(prefix), key].join('.');
    }

    return key;
  }

  _whereParseSingleValueObject(key, field, prop, value, options) {
    if (prop === Op.not) {
      if (Array.isArray(value)) {
        prop = Op.notIn;
      } else if (value !== null && value !== true && value !== false) {
        prop = Op.ne;
      }
    }

    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];

    switch (prop) {
      case Op.in:
      case Op.notIn:
        if (value instanceof Utils.Literal) {
          return this._joinKeyValue(key, value.val, comparator, options.prefix);
        }

        if (value.length) {
          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);
        }

        if (comparator === this.OperatorMap[Op.in]) {
          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);
        }

        return '';
      case Op.any:
      case Op.all:
        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;
        if (value[Op.values]) {
          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);
        }

        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);
      case Op.between:
      case Op.notBetween:
        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);
      case Op.raw:
        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');
      case Op.col:
        comparator = this.OperatorMap[Op.eq];
        value = value.split('.');

        if (value.length > 2) {
          value = [
            // join the tables by -> to match out internal namings
            value.slice(0, -1).join('->'),
            value[value.length - 1]
          ];
        }

        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);
      case Op.startsWith:
      case Op.endsWith:
      case Op.substring:
        comparator = this.OperatorMap[Op.like];

        if (value instanceof Utils.Literal) {
          value = value.val;
        }

        let pattern = `${value}%`;

        if (prop === Op.endsWith) pattern = `%${value}`;
        if (prop === Op.substring) pattern = `%${value}%`;

        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);
    }

    const escapeOptions = {
      acceptStrings: comparator.includes(this.OperatorMap[Op.like])
    };

    if (_.isPlainObject(value)) {
      if (value[Op.col]) {
        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);
      }
      if (value[Op.any]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);
      }
      if (value[Op.all]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);
      }
    }

    if (value === null && comparator === this.OperatorMap[Op.eq]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);
    }
    if (value === null && comparator === this.OperatorMap[Op.ne]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);
    }

    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);
  }

  /*
    Takes something and transforms it into values of a where condition.
   @private
  */
  getWhereConditions(smth, tableName, factory, options, prepend) {
    const where = {};

    if (Array.isArray(tableName)) {
      tableName = tableName[0];
      if (Array.isArray(tableName)) {
        tableName = tableName[1];
      }
    }

    options = options || {};

    if (prepend === undefined) {
      prepend = true;
    }

    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls
      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }
    if (_.isPlainObject(smth)) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName,
        type: options.type
      });
    }
    if (typeof smth === 'number') {
      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];

      if (primaryKeys.length > 0) {
        // Since we're just a number, assume only the first key
        primaryKeys = primaryKeys[0];
      } else {
        primaryKeys = 'id';
      }

      where[primaryKeys] = smth;

      return this.whereItemsQuery(where, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (typeof smth === 'string') {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (Buffer.isBuffer(smth)) {
      return this.escape(smth);
    }
    if (Array.isArray(smth)) {
      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';
      if (Utils.canTreatArrayAsAnd(smth)) {
        const _smth = { [Op.and]: smth };
        return this.getWhereConditions(_smth, tableName, factory, options, prepend);
      }
      throw new Error('Support for literal replacements in the `where` object has been removed.');
    }
    if (smth === null) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }

    return '1=1';
  }

  // A recursive parser for nested where conditions
  parseConditionObject(conditions, path) {
    path = path || [];
    return _.reduce(conditions, (result, value, key) => {
      if (_.isObject(value)) {
        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects
      }
      result.push({ path: path.concat(key), value });
      return result;
    }, []);
  }

  booleanValue(value) {
    return value;
  }
}

Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js"));
Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js"));

module.exports = QueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Quote helpers implement quote ability for all dialects.
 * These are basic block of query building
 *
 * Its better to implement all dialect implementation together here. Which will allow
 * even abstract generator to use them by just specifying dialect type.
 *
 * Defining these helpers in each query dialect will leave
 * code in dual dependency of abstract <-> specific dialect
 */



const Utils = __webpack_require__(/*! ../../../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * list of reserved words in PostgreSQL 10
 * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html
 *
 * @private
 */
const postgresReservedWords = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');

/**
 *
 * @param {string}  dialect         Dialect name
 * @param {string}  identifier      Identifier to quote
 * @param {object}  [options]
 * @param {boolean} [options.force=false]
 * @param {boolean} [options.quoteIdentifiers=true]
 *
 * @returns {string}
 * @private
 */
function quoteIdentifier(dialect, identifier, options) {
  if (identifier === '*') return identifier;

  options = Utils.defaults(options || {}, {
    force: false,
    quoteIdentifiers: true
  });

  switch (dialect) {
    case 'sqlite':
    case 'mariadb':
    case 'mysql':
      return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');

    case 'postgres':
      const rawIdentifier = Utils.removeTicks(identifier, '"');

      if (
        options.force !== true &&
        options.quoteIdentifiers === false &&
        !identifier.includes('.') &&
        !identifier.includes('->') &&
        !postgresReservedWords.includes(rawIdentifier.toLowerCase())
      ) {
        // In Postgres, if tables or attributes are created double-quoted,
        // they are also case sensitive. If they contain any uppercase
        // characters, they must always be double-quoted. This makes it
        // impossible to write queries in portable SQL if tables are created in
        // this way. Hence, we strip quotes if we don't want case sensitivity.
        return rawIdentifier;
      }
      return Utils.addTicks(rawIdentifier, '"');
    case 'mssql':
      return `[${identifier.replace(/[[\]']+/g, '')}]`;

    default:
      throw new Error(`Dialect "${dialect}" is not supported`);
  }
}
module.exports.quoteIdentifier = quoteIdentifier;

/**
 * Test if a give string is already quoted
 *
 * @param {string} identifier
 *
 * @returns {boolean}
 * @private
 */
function isIdentifierQuoted(identifier) {
  return /^\s*(?:([`"'])(?:(?!\1).|\1{2})*\1\.?)+\s*$/i.test(identifier);
}
module.exports.isIdentifierQuoted = isIdentifierQuoted;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Op = __webpack_require__(/*! ../../../operators */ "./node_modules/sequelize/lib/operators.js");
const Utils = __webpack_require__(/*! ../../../utils */ "./node_modules/sequelize/lib/utils.js");

const OperatorHelpers = {
  OperatorMap: {
    [Op.eq]: '=',
    [Op.ne]: '!=',
    [Op.gte]: '>=',
    [Op.gt]: '>',
    [Op.lte]: '<=',
    [Op.lt]: '<',
    [Op.not]: 'IS NOT',
    [Op.is]: 'IS',
    [Op.in]: 'IN',
    [Op.notIn]: 'NOT IN',
    [Op.like]: 'LIKE',
    [Op.notLike]: 'NOT LIKE',
    [Op.iLike]: 'ILIKE',
    [Op.notILike]: 'NOT ILIKE',
    [Op.startsWith]: 'LIKE',
    [Op.endsWith]: 'LIKE',
    [Op.substring]: 'LIKE',
    [Op.regexp]: '~',
    [Op.notRegexp]: '!~',
    [Op.iRegexp]: '~*',
    [Op.notIRegexp]: '!~*',
    [Op.between]: 'BETWEEN',
    [Op.notBetween]: 'NOT BETWEEN',
    [Op.overlap]: '&&',
    [Op.contains]: '@>',
    [Op.contained]: '<@',
    [Op.adjacent]: '-|-',
    [Op.strictLeft]: '<<',
    [Op.strictRight]: '>>',
    [Op.noExtendRight]: '&<',
    [Op.noExtendLeft]: '&>',
    [Op.any]: 'ANY',
    [Op.all]: 'ALL',
    [Op.and]: ' AND ',
    [Op.or]: ' OR ',
    [Op.col]: 'COL',
    [Op.placeholder]: '$$PLACEHOLDER$$',
    [Op.match]: '@@'
  },

  OperatorsAliasMap: {},

  setOperatorsAliases(aliases) {
    if (!aliases || _.isEmpty(aliases)) {
      this.OperatorsAliasMap = false;
    } else {
      this.OperatorsAliasMap = { ...aliases };
    }
  },

  _replaceAliases(orig) {
    const obj = {};
    if (!this.OperatorsAliasMap) {
      return orig;
    }

    Utils.getOperators(orig).forEach(op => {
      const item = orig[op];
      if (_.isPlainObject(item)) {
        obj[op] = this._replaceAliases(item);
      } else {
        obj[op] = item;
      }
    });

    _.forOwn(orig, (item, prop) => {
      prop = this.OperatorsAliasMap[prop] || prop;
      if (_.isPlainObject(item)) {
        item = this._replaceAliases(item);
      }
      obj[prop] = item;
    });
    return obj;
  }
};

module.exports = OperatorHelpers;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const TransactionQueries = {
  /**
   * Returns a query that sets the transaction isolation level.
   *
   * @param  {string} value   The isolation level.
   * @param  {object} options An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  setIsolationLevelQuery(value, options) {
    if (options.parent) {
      return;
    }

    return `SET TRANSACTION ISOLATION LEVEL ${value};`;
  },

  generateTransactionId() {
    return uuidv4();
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'START TRANSACTION;';
  },

  deferConstraintsQuery() {},

  setConstraintQuery() {},
  setDeferredQuery() {},
  setImmediateQuery() {},

  /**
   * Returns a query that commits a transaction.
   *
   * @param  {Transaction} transaction An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT;';
  },

  /**
   * Returns a query that rollbacks a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'ROLLBACK;';
  }
};

module.exports = TransactionQueries;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk to all databases
 */
class QueryInterface {
  constructor(sequelize, queryGenerator) {
    this.sequelize = sequelize;
    this.queryGenerator = queryGenerator;
  }

  /**
   * Create a database
   *
   * @param {string} database  Database name to create
   * @param {object} [options] Query options
   * @param {string} [options.charset] Database default character set, MYSQL only
   * @param {string} [options.collate] Database default collation
   * @param {string} [options.encoding] Database default character set, PostgreSQL only
   * @param {string} [options.ctype] Database character classification, PostgreSQL only
   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only
   *
   * @returns {Promise}
   */
  async createDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.createDatabaseQuery(database, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a database
   *
   * @param {string} database  Database name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.dropDatabaseQuery(database);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Create a schema
   *
   * @param {string} schema    Schema name to create
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.createSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a schema
   *
   * @param {string} schema    Schema name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.dropSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    options = options || {};

    if (!this.queryGenerator._dialect.supports.schemas) {
      return this.sequelize.drop(options);
    }
    const schemas = await this.showAllSchemas(options);
    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));
  }

  /**
   * Show all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise<Array>}
   */
  async showAllSchemas(options) {
    options = {
      ...options,
      raw: true,
      type: this.sequelize.QueryTypes.SELECT
    };

    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);

    const schemaNames = await this.sequelize.query(showSchemasSql, options);

    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));
  }

  /**
   * Return database version
   *
   * @param {object}    [options]      Query options
   * @param {QueryType} [options.type] Query type
   *
   * @returns {Promise}
   * @private
   */
  async databaseVersion(options) {
    return await this.sequelize.query(
      this.queryGenerator.versionQuery(),
      { ...options, type: QueryTypes.VERSION }
    );
  }

  /**
   * Create a table with given set of attributes
   *
   * ```js
   * queryInterface.createTable(
   *   'nameOfTheNewTable',
   *   {
   *     id: {
   *       type: Sequelize.INTEGER,
   *       primaryKey: true,
   *       autoIncrement: true
   *     },
   *     createdAt: {
   *       type: Sequelize.DATE
   *     },
   *     updatedAt: {
   *       type: Sequelize.DATE
   *     },
   *     attr1: Sequelize.STRING,
   *     attr2: Sequelize.INTEGER,
   *     attr3: {
   *       type: Sequelize.BOOLEAN,
   *       defaultValue: false,
   *       allowNull: false
   *     },
   *     //foreign key usage
   *     attr4: {
   *       type: Sequelize.INTEGER,
   *       references: {
   *         model: 'another_table_name',
   *         key: 'id'
   *       },
   *       onUpdate: 'cascade',
   *       onDelete: 'cascade'
   *     }
   *   },
   *   {
   *     engine: 'MYISAM',    // default: 'InnoDB'
   *     charset: 'latin1',   // default: null
   *     schema: 'public',    // default: public, PostgreSQL only.
   *     comment: 'my table', // comment for table
   *     collate: 'latin1_danish_ci' // collation, MYSQL only
   *   }
   * )
   * ```
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of table attributes to create
   * @param {object} [options] create table and query options
   * @param {Model}  [model] model class
   *
   * @returns {Promise}
   */
  async createTable(tableName, attributes, options, model) {
    let sql = '';

    options = { ...options };

    if (options && options.uniqueKeys) {
      _.forOwn(options.uniqueKeys, uniqueKey => {
        if (uniqueKey.customIndex === undefined) {
          uniqueKey.customIndex = true;
        }
      });
    }

    if (model) {
      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;
    }

    attributes = _.mapValues(
      attributes,
      attribute => this.sequelize.normalizeAttribute(attribute)
    );

    // Postgres requires special SQL commands for ENUM/ENUM[]
    await this.ensureEnums(tableName, attributes, options, model);

    if (
      !tableName.schema &&
      (options.schema || !!model && model._schema)
    ) {
      tableName = this.queryGenerator.addSchema({
        tableName,
        _schema: !!model && model._schema || options.schema
      });
    }

    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });
    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);

    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a table from database
   *
   * @param {string} tableName Table name to drop
   * @param {object} options   Query options
   *
   * @returns {Promise}
   */
  async dropTable(tableName, options) {
    // if we're forcing we should be cascading unless explicitly stated otherwise
    options = { ...options };
    options.cascade = options.cascade || options.force || false;

    const sql = this.queryGenerator.dropTableQuery(tableName, options);

    await this.sequelize.query(sql, options);
  }

  async _dropAllTables(tableNames, skip, options) {
    for (const tableName of tableNames) {
      // if tableName is not in the Array of tables names then don't drop it
      if (!skip.includes(tableName.tableName || tableName)) {
        await this.dropTable(tableName, { ...options, cascade: true } );
      }
    }
  }

  /**
   * Drop all tables from database
   *
   * @param {object} [options] query options
   * @param {Array}  [options.skip] List of table to skip
   *
   * @returns {Promise}
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);

    for (const tableName of tableNames) {
      let normalizedTableName = tableName;
      if (_.isObject(tableName)) {
        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;
      }

      for (const foreignKey of foreignKeys[normalizedTableName]) {
        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));
      }
    }
    await this._dropAllTables(tableNames, skip, options);
  }

  /**
   * Rename a table
   *
   * @param {string} before    Current name of table
   * @param {string} after     New name from table
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async renameTable(before, after, options) {
    options = options || {};
    const sql = this.queryGenerator.renameTableQuery(before, after);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Get all tables in current database
   *
   * @param {object}    [options] Query options
   * @param {boolean}   [options.raw=true] Run query in raw mode
   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showAllTables(options) {
    options = {
      ...options,
      raw: true,
      type: QueryTypes.SHOWTABLES
    };

    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);
    const tableNames = await this.sequelize.query(showTablesSql, options);
    return _.flatten(tableNames);
  }

  /**
   * Describe a table structure
   *
   * This method returns an array of hashes containing information about all attributes in the table.
   *
   * ```js
   * {
   *    name: {
   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!
   *      allowNull:    true,
   *      defaultValue: null
   *    },
   *    isBetaMember: {
   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!
   *      allowNull:    false,
   *      defaultValue: false
   *    }
   * }
   * ```
   *
   * @param {string} tableName table name
   * @param {object} [options] Query options
   *
   * @returns {Promise<object>}
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }

  /**
   * Add a new column to a table
   *
   * ```js
   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {
   *    after: 'columnB' // after option is only supported by MySQL
   * });
   * ```
   *
   * @param {string} table     Table to add column to
   * @param {string} key       Column name
   * @param {object} attribute Attribute definition
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async addColumn(table, key, attribute, options) {
    if (!table || !key || !attribute) {
      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');
    }

    options = options || {};
    attribute = this.sequelize.normalizeAttribute(attribute);
    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);
  }

  /**
   * Remove a column from a table
   *
   * @param {string} tableName      Table to remove column from
   * @param {string} attributeName  Column name to remove
   * @param {object} [options]      Query options
   */
  async removeColumn(tableName, attributeName, options) {
    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);
  }

  normalizeAttribute(dataTypeOrOptions) {
    let attribute;
    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {
      attribute = { type: dataTypeOrOptions, allowNull: true };
    } else {
      attribute = dataTypeOrOptions;
    }

    return this.sequelize.normalizeAttribute(attribute);
  }

  /**
   * Change a column definition
   *
   * @param {string} tableName          Table name to change from
   * @param {string} attributeName      Column name
   * @param {object} dataTypeOrOptions  Attribute definition for new column
   * @param {object} [options]          Query options
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const query = this.queryGenerator.attributesToSQL({
      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)
    }, {
      context: 'changeColumn',
      table: tableName
    });
    const sql = this.queryGenerator.changeColumnQuery(tableName, query);

    return this.sequelize.query(sql, options);
  }

  /**
   * Rejects if the table doesn't have the specified column, otherwise returns the column description.
   *
   * @param {string} tableName
   * @param {string} columnName
   * @param {object} options
   * @private
   */
  async assertTableHasColumn(tableName, columnName, options) {
    const description = await this.describeTable(tableName, options);
    if (description[columnName]) {
      return description;
    }
    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);
  }

  /**
   * Rename a column
   *
   * @param {string} tableName        Table name whose column to rename
   * @param {string} attrNameBefore   Current column name
   * @param {string} attrNameAfter    New column name
   * @param {object} [options]        Query option
   *
   * @returns {Promise}
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];

    const _options = {};

    _options[attrNameAfter] = {
      attribute: attrNameAfter,
      type: data.type,
      allowNull: data.allowNull,
      defaultValue: data.defaultValue
    };

    // fix: a not-null column cannot have null as default value
    if (data.defaultValue === null && !data.allowNull) {
      delete _options[attrNameAfter].defaultValue;
    }

    const sql = this.queryGenerator.renameColumnQuery(
      tableName,
      attrNameBefore,
      this.queryGenerator.attributesToSQL(_options)
    );
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add an index to a column
   *
   * @param {string|object}  tableName Table name to add index on, can be a object with schema
   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on
   * @param {object}  options          indexes options
   * @param {Array}   options.fields   List of attributes to add index on
   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created
   * @param {boolean} [options.unique] Create a unique index
   * @param {string}  [options.using]  Useful for GIN indexes
   * @param {string}  [options.operator] Index operator
   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL
   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>
   * @param {object}  [options.where]  Where condition on index, for partial indexes
   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity
   *
   * @returns {Promise}
   */
  async addIndex(tableName, attributes, options, rawTablename) {
    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)
    if (!Array.isArray(attributes)) {
      rawTablename = options;
      options = attributes;
      attributes = options.fields;
    }

    if (!rawTablename) {
      // Map for backwards compat
      rawTablename = tableName;
    }

    options = Utils.cloneDeep(options);
    options.fields = attributes;
    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);
    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });
  }

  /**
   * Show indexes on a table
   *
   * @param {string} tableName table name
   * @param {object} [options]   Query options
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showIndex(tableName, options) {
    const sql = this.queryGenerator.showIndexesQuery(tableName, options);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });
  }


  /**
   * Returns all foreign key constraints of requested tables
   *
   * @param {string[]} tableNames table names
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async getForeignKeysForTables(tableNames, options) {
    if (tableNames.length === 0) {
      return {};
    }

    options = { ...options, type: QueryTypes.FOREIGNKEYS };

    const results = await Promise.all(tableNames.map(tableName =>
      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));

    const result = {};

    tableNames.forEach((tableName, i) => {
      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      result[tableName] = Array.isArray(results[i])
        ? results[i].map(r => r.constraint_name)
        : [results[i] && results[i].constraint_name];

      result[tableName] = result[tableName].filter(_.identity);
    });

    return result;
  }

  /**
   * Get foreign key references details for the table
   *
   * Those details contains constraintSchema, constraintName, constraintCatalog
   * tableCatalog, tableSchema, tableName, columnName,
   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.
   * Remind: constraint informations won't return if it's sqlite.
   *
   * @param {string} tableName table name
   * @param {object} [options]  Query options
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };
    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);
    return this.sequelize.query(query, queryOptions);
  }

  /**
   * Remove an already existing index from a table
   *
   * @param {string} tableName                    Table name to drop index from
   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index
   * @param {object} [options]                    Query options
   *
   * @returns {Promise}
   */
  async removeIndex(tableName, indexNameOrAttributes, options) {
    options = options || {};
    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add a constraint to a table
   *
   * Available constraints:
   * - UNIQUE
   * - DEFAULT (MSSQL only)
   * - CHECK (MySQL - Ignored by the database engine )
   * - FOREIGN KEY
   * - PRIMARY KEY
   *
   * @example <caption>UNIQUE</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['email'],
   *   type: 'unique',
   *   name: 'custom_unique_constraint_name'
   * });
   *
   * @example <caption>CHECK</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['roles'],
   *   type: 'check',
   *   where: {
   *      roles: ['user', 'admin', 'moderator', 'guest']
   *   }
   * });
   *
   * @example <caption>Default - MSSQL only</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['roles'],
   *    type: 'default',
   *    defaultValue: 'guest'
   * });
   *
   * @example <caption>Primary Key</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['username'],
   *    type: 'primary key',
   *    name: 'custom_primary_constraint_name'
   * });
   *
   * @example <caption>Foreign Key</caption>
   * queryInterface.addConstraint('Posts', {
   *   fields: ['username'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     field: 'target_column_name'
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @example <caption>Composite Foreign Key</caption>
   * queryInterface.addConstraint('TableName', {
   *   fields: ['source_column_name', 'other_source_column_name'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     fields: ['target_column_name', 'other_target_column_name']
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @param {string} tableName                   Table name where you want to add a constraint
   * @param {object} options                     An object to define the constraint name, type etc
   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)
   * @param {Array}  options.fields              Array of column names to apply the constraint over
   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names
   * @param {string} [options.defaultValue]      The value for the default constraint
   * @param {object} [options.where]             Where clause/expression for the CHECK constraint
   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint
   * @param {string} [options.references.table]  Target table name
   * @param {string} [options.references.field]  Target column name
   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.
   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only
   *
   * @returns {Promise}
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.addConstraintQuery(tableName, options);
    return await this.sequelize.query(sql, options);
  }

  async showConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });
  }

  /**
   * Remove a constraint from a table
   *
   * @param {string} tableName       Table name to drop constraint from
   * @param {string} constraintName  Constraint name
   * @param {object} options         Query options
   */
  async removeConstraint(tableName, constraintName, options) {
    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);
  }

  async insert(instance, tableName, values, options) {
    options = Utils.cloneDeep(options);
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;
    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);

    options.type = QueryTypes.INSERT;
    options.instance = instance;

    const results = await this.sequelize.query(sql, options);
    if (instance) results[0].isNewRecord = false;

    return results;
  }

  /**
   * Upsert
   *
   * @param {string} tableName    table to upsert on
   * @param {object} insertValues values to be inserted, mapped to field name
   * @param {object} updateValues values to be updated, mapped to field name
   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails
   * @param {object} options      query options
   *
   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    const model = options.model;
    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);
    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length >= 1).map(c => c.fields);
    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length >= 1).map(c => c.fields);

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);
    options.upsertKeys = [];

    // For fields in updateValues, try to find a constraint or unique index
    // that includes given field. Only first matching upsert key is used.
    for (const field of options.updateOnDuplicate) {
      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));
      if (uniqueKey) {
        options.upsertKeys = uniqueKey;
        break;
      }

      const indexKey = indexKeys.find(fields => fields.includes(field));
      if (indexKey) {
        options.upsertKeys = indexKey;
        break;
      }
    }

    // Always use PK, if no constraint available OR update data contains PK
    if (
      options.upsertKeys.length === 0
      || _.intersection(options.updateOnDuplicate, primaryKeys).length
    ) {
      options.upsertKeys = primaryKeys;
    }

    options.upsertKeys = _.uniq(options.upsertKeys);

    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Insert multiple records into a table
   *
   * @example
   * queryInterface.bulkInsert('roles', [{
   *    label: 'user',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }, {
   *    label: 'admin',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }]);
   *
   * @param {string} tableName   Table name to insert record to
   * @param {Array}  records     List of records to insert
   * @param {object} options     Various options, please see Model.bulkCreate options
   * @param {object} attributes  Various attributes mapped by field name
   *
   * @returns {Promise}
   */
  async bulkInsert(tableName, records, options, attributes) {
    options = { ...options };
    options.type = QueryTypes.INSERT;

    const results = await this.sequelize.query(
      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),
      options
    );

    return results[0];
  }

  async update(instance, tableName, values, identifier, options) {
    options = { ...options };
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);

    options.type = QueryTypes.UPDATE;

    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Update multiple records of a table
   *
   * @example
   * queryInterface.bulkUpdate('roles', {
   *     label: 'admin',
   *   }, {
   *     userType: 3,
   *   },
   * );
   *
   * @param {string} tableName     Table name to update
   * @param {object} values        Values to be inserted, mapped to field name
   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions
   * @param {object} [options]     Various options, please see Model.bulkCreate options
   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect
   *
   * @returns {Promise}
   */
  async bulkUpdate(tableName, values, identifier, options, attributes) {
    options = Utils.cloneDeep(options);
    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);
    const table = _.isObject(tableName) ? tableName : { tableName };
    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });

    options.type = QueryTypes.BULKUPDATE;
    options.model = model;
    return await this.sequelize.query(sql, options);
  }

  async delete(instance, tableName, identifier, options) {
    const cascades = [];
    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);

    options = { ...options };

    // Check for a restrict field
    if (!!instance.constructor && !!instance.constructor.associations) {
      const keys = Object.keys(instance.constructor.associations);
      const length = keys.length;
      let association;

      for (let i = 0; i < length; i++) {
        association = instance.constructor.associations[keys[i]];
        if (association.options && association.options.onDelete &&
          association.options.onDelete.toLowerCase() === 'cascade' &&
          association.options.useHooks === true) {
          cascades.push(association.accessors.get);
        }
      }
    }

    for (const cascade of cascades) {
      let instances = await instance[cascade](options);
      // Check for hasOne relationship with non-existing associate ("has zero")
      if (!instances) continue;
      if (!Array.isArray(instances)) instances = [instances];
      for (const _instance of instances) await _instance.destroy(options);
    }
    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Delete multiple records from a table
   *
   * @param {string}  tableName            table name from where to delete records
   * @param {object}  where                where conditions to find records to delete
   * @param {object}  [options]            options
   * @param {boolean} [options.truncate]   Use truncate table command
   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param {Model}   [model]              Model
   *
   * @returns {Promise}
   */
  async bulkDelete(tableName, where, options, model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { limit: null });

    if (options.truncate === true) {
      return this.sequelize.query(
        this.queryGenerator.truncateTableQuery(tableName, options),
        options
      );
    }

    if (typeof identifier === 'object') where = Utils.cloneDeep(where);

    return await this.sequelize.query(
      this.queryGenerator.deleteQuery(tableName, where, options, model),
      options
    );
  }

  async select(model, tableName, optionsArg) {
    const options = { ...optionsArg, type: QueryTypes.SELECT, model };

    return await this.sequelize.query(
      this.queryGenerator.selectQuery(tableName, options, model),
      options
    );
  }

  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async rawSelect(tableName, options, attributeSelector, Model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT
    });

    const sql = this.queryGenerator.selectQuery(tableName, options, Model);

    if (attributeSelector === undefined) {
      throw new Error('Please pass an attribute selector!');
    }

    const data = await this.sequelize.query(sql, options);
    if (!options.plain) {
      return data;
    }

    const result = data ? data[attributeSelector] : null;

    if (!options || !options.dataType) {
      return result;
    }

    const dataType = options.dataType;

    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {
      if (result !== null) {
        return parseFloat(result);
      }
    }
    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {
      return parseInt(result, 10);
    }
    if (dataType instanceof DataTypes.DATE) {
      if (result !== null && !(result instanceof Date)) {
        return new Date(result);
      }
    }
    return result;
  }

  async createTrigger(
    tableName,
    triggerName,
    timingType,
    fireOnArray,
    functionName,
    functionParams,
    optionsArray,
    options
  ) {
    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);
    options = options || {};
    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async dropTrigger(tableName, triggerName, options) {
    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {
    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Create an SQL function
   *
   * @example
   * queryInterface.createFunction(
   *   'someFunction',
   *   [
   *     {type: 'integer', name: 'param', direction: 'IN'}
   *   ],
   *   'integer',
   *   'plpgsql',
   *   'RETURN param + 1;',
   *   [
   *     'IMMUTABLE',
   *     'LEAKPROOF'
   *   ],
   *   {
   *    variables:
   *      [
   *        {type: 'integer', name: 'myVar', default: 100}
   *      ],
   *      force: true
   *   };
   * );
   *
   * @param {string}  functionName  Name of SQL function to create
   * @param {Array}   params        List of parameters declared for SQL function
   * @param {string}  returnType    SQL type of function returned value
   * @param {string}  language      The name of the language that the function is implemented in
   * @param {string}  body          Source code of function
   * @param {Array}   optionsArray  Extra-options for creation
   * @param {object}  [options]     query options
   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false
   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.
   *
   * @returns {Promise}
   */
  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Drop an SQL function
   *
   * @example
   * queryInterface.dropFunction(
   *   'someFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ]
   * );
   *
   * @param {string} functionName Name of SQL function to drop
   * @param {Array}  params       List of parameters declared for SQL function
   * @param {object} [options]    query options
   *
   * @returns {Promise}
   */
  async dropFunction(functionName, params, options) {
    const sql = this.queryGenerator.dropFunction(functionName, params);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Rename an SQL function
   *
   * @example
   * queryInterface.renameFunction(
   *   'fooFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ],
   *   'barFunction'
   * );
   *
   * @param {string} oldFunctionName  Current name of function
   * @param {Array}  params           List of parameters declared for SQL function
   * @param {string} newFunctionName  New name of function
   * @param {object} [options]        query options
   *
   * @returns {Promise}
   */
  async renameFunction(oldFunctionName, params, newFunctionName, options) {
    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  // Helper methods useful for querying

  /**
   * @private
   */
  ensureEnums() {
    // noop by default
  }

  async setIsolationLevel(transaction, value, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to set isolation level for a transaction without transaction object!');
    }

    if (transaction.parent || !value) {
      // Not possible to set a separate isolation level for savepoints
      return;
    }

    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.setIsolationLevelQuery(value, {
      parent: transaction.parent
    });

    if (!sql) return;

    return await this.sequelize.query(sql, options);
  }

  async startTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to start a transaction without transaction object!');
    }

    options = { ...options, transaction: transaction.parent || transaction };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.startTransactionQuery(transaction);

    return await this.sequelize.query(sql, options);
  }

  async deferConstraints(transaction, options) {
    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.deferConstraintsQuery(options);

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async commitTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to commit a transaction without transaction object!');
    }
    if (transaction.parent) {
      // Savepoints cannot be committed
      return;
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };

    const sql = this.queryGenerator.commitTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'commit';

    return await promise;
  }

  async rollbackTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to rollback a transaction without transaction object!');
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'rollback';

    return await promise;
  }
}

exports.QueryInterface = QueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Dot = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const uuid = __webpack_require__(/*! uuid */ "uuid").v4;

class AbstractQuery {

  constructor(connection, sequelize, options) {
    this.uuid = uuid();
    this.connection = connection;
    this.instance = options.instance;
    this.model = options.model;
    this.sequelize = sequelize;
    this.options = {
      plain: false,
      raw: false,
      // eslint-disable-next-line no-console
      logging: console.log,
      ...options
    };
    this.checkLoggingOption();
  }

  /**
   * rewrite query with parameters
   *
   * Examples:
   *
   *   query.formatBindParameters('select $1 as foo', ['fooval']);
   *
   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });
   *
   * Options
   *   skipUnescape: bool, skip unescaping $$
   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available
   *
   * @param {string} sql
   * @param {object|Array} values
   * @param {string} dialect
   * @param {Function} [replacementFunc]
   * @param {object} [options]
   * @private
   */
  static formatBindParameters(sql, values, dialect, replacementFunc, options) {
    if (!values) {
      return [sql, []];
    }

    options = options || {};
    if (typeof replacementFunc !== 'function') {
      options = replacementFunc || {};
      replacementFunc = undefined;
    }

    if (!replacementFunc) {
      if (options.skipValueReplace) {
        replacementFunc = (match, key, values) => {
          if (values[key] !== undefined) {
            return match;
          }
          return undefined;
        };
      } else {
        replacementFunc = (match, key, values, timeZone, dialect) => {
          if (values[key] !== undefined) {
            return SqlString.escape(values[key], timeZone, dialect);
          }
          return undefined;
        };
      }
    } else if (options.skipValueReplace) {
      const origReplacementFunc = replacementFunc;
      replacementFunc = (match, key, values, timeZone, dialect, options) => {
        if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {
          return match;
        }
        return undefined;
      };
    }

    const timeZone = null;
    const list = Array.isArray(values);
    sql = sql.replace(/\B\$(\$|\w+)/g, (match, key) => {
      if ('$' === key) {
        return options.skipUnescape ? match : key;
      }

      let replVal;
      if (list) {
        if (key.match(/^[1-9]\d*$/)) {
          key = key - 1;
          replVal = replacementFunc(match, key, values, timeZone, dialect, options);
        }
      } else if (!key.match(/^\d*$/)) {
        replVal = replacementFunc(match, key, values, timeZone, dialect, options);
      }
      if (replVal === undefined) {
        throw new Error(`Named bind parameter "${match}" has no value in the given object.`);
      }
      return replVal;
    });
    return [sql, []];
  }

  /**
   * Execute the passed sql query.
   *
   * Examples:
   *
   *     query.run('SELECT 1')
   *
   * @private
   */
  run() {
    throw new Error('The run method wasn\'t overwritten!');
  }

  /**
   * Check the logging option of the instance and print deprecation warnings.
   *
   * @private
   */
  checkLoggingOption() {
    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }
  }

  /**
   * Get the attributes of an insert query, which contains the just inserted id.
   *
   * @returns {string} The field name.
   * @private
   */
  getInsertIdField() {
    return 'insertId';
  }

  getUniqueConstraintErrorMessage(field) {
    let message = field ? `${field} must be unique` : 'Must be unique';

    if (field && this.model) {
      for (const key of Object.keys(this.model.uniqueKeys)) {
        if (this.model.uniqueKeys[key].fields.includes(field.replace(/"/g, ''))) {
          if (this.model.uniqueKeys[key].msg) {
            message = this.model.uniqueKeys[key].msg;
          }
        }
      }
    }
    return message;
  }

  isRawQuery() {
    return this.options.type === QueryTypes.RAW;
  }

  isVersionQuery() {
    return this.options.type === QueryTypes.VERSION;
  }

  isUpsertQuery() {
    return this.options.type === QueryTypes.UPSERT;
  }

  isInsertQuery(results, metaData) {
    let result = true;

    if (this.options.type === QueryTypes.INSERT) {
      return true;
    }

    // is insert query if sql contains insert into
    result = result && this.sql.toLowerCase().startsWith('insert into');

    // is insert query if no results are passed or if the result has the inserted id
    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));

    // is insert query if no metadata are passed or if the metadata has the inserted id
    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));

    return result;
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;

      id = id || results && results[this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];

      this.instance[autoIncrementAttribute] = id;
    }
  }

  isShowTablesQuery() {
    return this.options.type === QueryTypes.SHOWTABLES;
  }

  handleShowTablesQuery(results) {
    return _.flatten(results.map(resultSet => Object.values(resultSet)));
  }

  isShowIndexesQuery() {
    return this.options.type === QueryTypes.SHOWINDEXES;
  }

  isShowConstraintsQuery() {
    return this.options.type === QueryTypes.SHOWCONSTRAINTS;
  }

  isDescribeQuery() {
    return this.options.type === QueryTypes.DESCRIBE;
  }

  isSelectQuery() {
    return this.options.type === QueryTypes.SELECT;
  }

  isBulkUpdateQuery() {
    return this.options.type === QueryTypes.BULKUPDATE;
  }

  isBulkDeleteQuery() {
    return this.options.type === QueryTypes.BULKDELETE;
  }

  isForeignKeysQuery() {
    return this.options.type === QueryTypes.FOREIGNKEYS;
  }

  isUpdateQuery() {
    return this.options.type === QueryTypes.UPDATE;
  }

  handleSelectQuery(results) {
    let result = null;

    // Map raw fields to names if a mapping is provided
    if (this.options.fieldMap) {
      const fieldMap = this.options.fieldMap;
      results = results.map(result => _.reduce(fieldMap, (result, name, field) => {
        if (result[field] !== undefined && name !== field) {
          result[name] = result[field];
          delete result[field];
        }
        return result;
      }, result));
    }

    // Raw queries
    if (this.options.raw) {
      result = results.map(result => {
        let o = {};

        for (const key in result) {
          if (Object.prototype.hasOwnProperty.call(result, key)) {
            o[key] = result[key];
          }
        }

        if (this.options.nest) {
          o = Dot.transform(o);
        }

        return o;
      });
    // Queries with include
    } else if (this.options.hasJoin === true) {
      results = AbstractQuery._groupJoinData(results, {
        model: this.model,
        includeMap: this.options.includeMap,
        includeNames: this.options.includeNames
      }, {
        checkExisting: this.options.hasMultiAssociation
      });

      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        include: this.options.include,
        includeNames: this.options.includeNames,
        includeMap: this.options.includeMap,
        includeValidated: true,
        attributes: this.options.originalAttributes || this.options.attributes,
        raw: true
      });
    // Regular queries
    } else {
      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        raw: true,
        attributes: this.options.originalAttributes || this.options.attributes
      });
    }

    // return the first real model instance if options.plain is set (e.g. Model.find)
    if (this.options.plain) {
      result = result.length === 0 ? null : result[0];
    }
    return result;
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith('show');
    result = result || this.sql.toLowerCase().startsWith('describe');

    return result;
  }

  isCallQuery() {
    return this.sql.toLowerCase().startsWith('call');
  }

  /**
   * @param {string} sql
   * @param {Function} debugContext
   * @param {Array|object} parameters
   * @protected
   * @returns {Function} A function to call after the query was completed.
   */
  _logQuery(sql, debugContext, parameters) {
    const { connection, options } = this;
    const benchmark = this.sequelize.options.benchmark || options.benchmark;
    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;
    const startTime = Date.now();
    let logParameter = '';

    if (logQueryParameters && parameters) {
      const delimiter = sql.endsWith(';') ? '' : ';';
      let paramStr;
      if (Array.isArray(parameters)) {
        paramStr = parameters.map(p=>JSON.stringify(p)).join(', ');
      } else {
        paramStr = JSON.stringify(parameters);
      }
      logParameter = `${delimiter} ${paramStr}`;
    }
    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;
    const msg = `Executing ${fmt}`;
    debugContext(msg);
    if (!benchmark) {
      this.sequelize.log(`Executing ${fmt}`, options);
    }
    return () => {
      const afterMsg = `Executed ${fmt}`;
      debugContext(afterMsg);
      if (benchmark) {
        this.sequelize.log(afterMsg, Date.now() - startTime, options);
      }
    };
  }

  /**
   * The function takes the result of the query execution and groups
   * the associated data by the callee.
   *
   * Example:
   *   groupJoinData([
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 1 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 2 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 3 }
   *     }
   *   ])
   *
   * Result:
   *   Something like this:
   *
   *   [
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: [
   *         { foo: 'bar', id: 1 },
   *         { foo: 'bar', id: 2 },
   *         { foo: 'bar', id: 3 }
   *       ]
   *     }
   *   ]
   *
   * @param {Array} rows
   * @param {object} includeOptions
   * @param {object} options
   * @private
   */
  static _groupJoinData(rows, includeOptions, options) {

    /*
     * Assumptions
     * ID is not necessarily the first field
     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)
     * Parent keys will be seen before any include/child keys
     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)
     */

    /*
     * Author (MH) comment: This code is an unreadable mess, but it's performant.
     * groupJoinData is a performance critical function so we prioritize perf over readability.
     */
    if (!rows.length) {
      return [];
    }

    // Generic looping
    let i;
    let length;
    let $i;
    let $length;
    // Row specific looping
    let rowsI;
    let row;
    const rowsLength = rows.length;
    // Key specific looping
    let keys;
    let key;
    let keyI;
    let keyLength;
    let prevKey;
    let values;
    let topValues;
    let topExists;
    const checkExisting = options.checkExisting;
    // If we don't have to deduplicate we can pre-allocate the resulting array
    let itemHash;
    let parentHash;
    let topHash;
    const results = checkExisting ? [] : new Array(rowsLength);
    const resultMap = {};
    const includeMap = {};
    // Result variables for the respective functions
    let $keyPrefix;
    let $keyPrefixString;
    let $prevKeyPrefixString; // eslint-disable-line
    let $prevKeyPrefix;
    let $lastKeyPrefix;
    let $current;
    let $parent;
    // Map each key to an include option
    let previousPiece;
    const buildIncludeMap = piece => {
      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {
        includeMap[key] = $current = $current.includeMap[piece];
        if (previousPiece) {
          previousPiece = `${previousPiece}.${piece}`;
        } else {
          previousPiece = piece;
        }
        includeMap[previousPiece] = $current;
      }
    };
    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')
    const keyPrefixStringMemo = {};
    const keyPrefixString = (key, memo) => {
      if (!Object.prototype.hasOwnProperty.call(memo, key)) {
        memo[key] = key.substr(0, key.lastIndexOf('.'));
      }
      return memo[key];
    };
    // Removes the prefix from a key ('id' for 'User.Results.id')
    const removeKeyPrefixMemo = {};
    const removeKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {
        const index = key.lastIndexOf('.');
        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);
      }
      return removeKeyPrefixMemo[key];
    };
    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')
    const keyPrefixMemo = {};
    const keyPrefix = key => {
      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values
      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {
        const prefixString = keyPrefixString(key, keyPrefixStringMemo);
        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {
          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];
        }
        keyPrefixMemo[key] = keyPrefixMemo[prefixString];
      }
      return keyPrefixMemo[key];
    };
    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')
    const lastKeyPrefixMemo = {};
    const lastKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {
        const prefix = keyPrefix(key);
        const length = prefix.length;

        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];
      }
      return lastKeyPrefixMemo[key];
    };
    const getUniqueKeyAttributes = model => {
      let uniqueKeyAttributes = _.chain(model.uniqueKeys);
      uniqueKeyAttributes = uniqueKeyAttributes
        .result(`${uniqueKeyAttributes.findKey()}.fields`)
        .map(field => _.findKey(model.attributes, chr => chr.field === field))
        .value();

      return uniqueKeyAttributes;
    };
    const stringify = obj => obj instanceof Buffer ? obj.toString('hex') : obj;
    let primaryKeyAttributes;
    let uniqueKeyAttributes;
    let prefix;

    for (rowsI = 0; rowsI < rowsLength; rowsI++) {
      row = rows[rowsI];

      // Keys are the same for all rows, so only need to compute them on the first row
      if (rowsI === 0) {
        keys = Object.keys(row);
        keyLength = keys.length;
      }

      if (checkExisting) {
        topExists = false;

        // Compute top level hash key (this is usually just the primary key values)
        $length = includeOptions.model.primaryKeyAttributes.length;
        topHash = '';
        if ($length === 1) {
          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);
        }
        else if ($length > 1) {
          for ($i = 0; $i < $length; $i++) {
            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);
          }
        }
        else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {
          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);
          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
            topHash += row[uniqueKeyAttributes[$i]];
          }
        }
      }

      topValues = values = {};
      $prevKeyPrefix = undefined;
      for (keyI = 0; keyI < keyLength; keyI++) {
        key = keys[keyI];

        // The string prefix isn't actualy needed
        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix
        // TODO: Find a better way?
        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);
        $keyPrefix = keyPrefix(key);

        // On the first row we compute the includeMap
        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {
          if (!$keyPrefix.length) {
            includeMap[key] = includeMap[''] = includeOptions;
          } else {
            $current = includeOptions;
            previousPiece = undefined;
            $keyPrefix.forEach(buildIncludeMap);
          }
        }
        // End of key set
        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {
          if (checkExisting) {
            // Compute hash key for this set instance
            // TODO: Optimize
            length = $prevKeyPrefix.length;
            $parent = null;
            parentHash = null;

            if (length) {
              for (i = 0; i < length; i++) {
                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                $length = primaryKeyAttributes.length;
                itemHash = prefix;
                if ($length === 1) {
                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
                }
                else if ($length > 1) {
                  for ($i = 0; $i < $length; $i++) {
                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
                  }
                }
                else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
                  }
                }
                if (!parentHash) {
                  parentHash = topHash;
                }

                itemHash = parentHash + itemHash;
                $parent = prefix;
                if (i < length - 1) {
                  parentHash = itemHash;
                }
              }
            } else {
              itemHash = topHash;
            }

            if (itemHash === topHash) {
              if (!resultMap[itemHash]) {
                resultMap[itemHash] = values;
              } else {
                topExists = true;
              }
            } else if (!resultMap[itemHash]) {
              $parent = resultMap[parentHash];
              $lastKeyPrefix = lastKeyPrefix(prevKey);

              if (includeMap[prevKey].association.isSingleAssociation) {
                if ($parent) {
                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                }
              } else {
                if (!$parent[$lastKeyPrefix]) {
                  $parent[$lastKeyPrefix] = [];
                }
                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
              }
            }

            // Reset values
            values = {};
          } else {
            // If checkExisting is false it's because there's only 1:1 associations in this query
            // However we still need to map onto the appropriate parent
            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop
            $current = topValues;
            length = $keyPrefix.length;
            if (length) {
              for (i = 0; i < length; i++) {
                if (i === length - 1) {
                  values = $current[$keyPrefix[i]] = {};
                }
                $current = $current[$keyPrefix[i]] || {};
              }
            }
          }
        }

        // End of iteration, set value and set prev values (for next iteration)
        values[removeKeyPrefix(key)] = row[key];
        prevKey = key;
        $prevKeyPrefix = $keyPrefix;
        $prevKeyPrefixString = $keyPrefixString;
      }

      if (checkExisting) {
        length = $prevKeyPrefix.length;
        $parent = null;
        parentHash = null;

        if (length) {
          for (i = 0; i < length; i++) {
            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
            $length = primaryKeyAttributes.length;
            itemHash = prefix;
            if ($length === 1) {
              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
            }
            else if ($length > 0) {
              for ($i = 0; $i < $length; $i++) {
                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
              }
            }
            else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
              }
            }
            if (!parentHash) {
              parentHash = topHash;
            }

            itemHash = parentHash + itemHash;
            $parent = prefix;
            if (i < length - 1) {
              parentHash = itemHash;
            }
          }
        } else {
          itemHash = topHash;
        }

        if (itemHash === topHash) {
          if (!resultMap[itemHash]) {
            resultMap[itemHash] = values;
          } else {
            topExists = true;
          }
        } else if (!resultMap[itemHash]) {
          $parent = resultMap[parentHash];
          $lastKeyPrefix = lastKeyPrefix(prevKey);

          if (includeMap[prevKey].association.isSingleAssociation) {
            if ($parent) {
              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
            }
          } else {
            if (!$parent[$lastKeyPrefix]) {
              $parent[$lastKeyPrefix] = [];
            }
            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
          }
        }
        if (!topExists) {
          results.push(topValues);
        }
      } else {
        results[rowsI] = topValues;
      }
    }

    return results;
  }
}

module.exports = AbstractQuery;
module.exports.AbstractQuery = AbstractQuery;
module.exports.default = AbstractQuery;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract sync recursive":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/ sync ***!
  \************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize/lib/dialects/abstract sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mariadb');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mariadb');

/**
 * MariaDB Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MariaDB specific connections
 * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mariadb');
    this.refreshTypeParser(DataTypes);
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  /**
   * Connect with MariaDB database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    // Named timezone is not supported in mariadb, convert to offset
    let tzOffset = this.sequelize.options.timezone;
    tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')
      : tzOffset;

    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      password: config.password,
      database: config.database,
      timezone: tzOffset,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      foundRows: false,
      ...config.dialectOptions
    };

    if (!this.sequelize.config.keepDefaultTimezone) {
      // set timezone for this connection
      if (connectionConfig.initSql) {
        if (!Array.isArray(
          connectionConfig.initSql)) {
          connectionConfig.initSql = [connectionConfig.initSql];
        }
        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);
      } else {
        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;
      }
    }

    try {
      const connection = await this.lib.createConnection(connectionConfig);
      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });
      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
        case 'ENETUNREACH':
        case 'EADDRNOTAVAIL':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (!connection.isValid()) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }
    return await connection.end();
  }

  validate(connection) {
    return connection && connection.isValid();
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");

module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';

  /**
   * types: [buffer_type, ...]
   *
   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types
   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js
   */

  BaseTypes.DATE.types.mariadb = ['DATETIME'];
  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];
  BaseTypes.CHAR.types.mariadb = ['STRING'];
  BaseTypes.TEXT.types.mariadb = ['BLOB'];
  BaseTypes.TINYINT.types.mariadb = ['TINY'];
  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];
  BaseTypes.INTEGER.types.mariadb = ['LONG'];
  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];
  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];
  BaseTypes.TIME.types.mariadb = ['TIME'];
  BaseTypes.DATEONLY.types.mariadb = ['DATE'];
  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];
  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mariadb = false;
  BaseTypes.ENUM.types.mariadb = false;
  BaseTypes.REAL.types.mariadb = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];
  BaseTypes.JSON.types.mariadb = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      return date.format('YYYY-MM-DD HH:mm:ss.SSS');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
      }
      else {
        this.sqlType = this.type;
      }
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value
        : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mariadb/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js");
const { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;

class MariadbDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MariadbDialect.prototype.supports = _.merge(
  _.cloneDeep(AbstractDialect.prototype.supports), {
    'VALUES ()': true,
    'LIMIT ON UPDATE': true,
    lock: true,
    forShare: 'LOCK IN SHARE MODE',
    settingIsolationLevelDuringTransaction: false,
    schemas: true,
    inserts: {
      ignoreDuplicates: ' IGNORE',
      updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
    },
    index: {
      collate: false,
      length: true,
      parser: true,
      type: true,
      using: 1
    },
    constraints: {
      dropConstraint: false,
      check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: true,
    JSON: true,
    REGEXP: true
  });

MariadbDialect.prototype.defaultVersion = '10.1.44';
MariadbDialect.prototype.Query = Query;
MariadbDialect.prototype.QueryGenerator = QueryGenerator;
MariadbDialect.prototype.DataTypes = DataTypes;
MariadbDialect.prototype.name = 'mariadb';
MariadbDialect.prototype.TICK_CHAR = '`';
MariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;
MariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;

module.exports = MariadbDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const Utils = __webpack_require__(/*! ./../../utils */ "./node_modules/sequelize/lib/utils.js");

class MariaDBQueryGenerator extends MySQLQueryGenerator {
  createSchema(schema, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE SCHEMA IF NOT EXISTS',
      this.quoteIdentifier(schema),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;
  }

  showSchemasQuery(options) {
    const schemasToSkip = [
      '\'MYSQL\'',
      '\'INFORMATION_SCHEMA\'',
      '\'PERFORMANCE_SCHEMA\''
    ];
    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {
      for (const schemaName of options.skip) {
        schemasToSkip.push(this.escape(schemaName));
      }
    }
    return Utils.joinSQLFragments([
      'SELECT SCHEMA_NAME as schema_name',
      'FROM INFORMATION_SCHEMA.SCHEMATA',
      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(', ')})`,
      ';'
    ]);
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\')';
    }
    return `${query};`;
  }
}

module.exports = MariaDBQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mariadb');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      results = await connection.query(this.sql, parameters);
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MariaDB automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MariaDB automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          // ONLY TRUE IF @auto_increment_increment is set to 1 !!
          // Doesn't work with GALERA => each node will reserve increment (x for first server, x+1 for next node...)
          const startId = data[this.getInsertIdField()];
          result = new Array(data.affectedRows);
          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;
          for (let i = 0; i < data.affectedRows; i++) {
            result[i] = { [pkField]: startId + i };
          }
          return [result, data.affectedRows];
        }

        return [data[this.getInsertIdField()], data.affectedRows];
      }
    }

    if (this.isSelectQuery()) {
      this.handleJsonSelectQuery(data);
      return this.handleSelectQuery(data);
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isRawQuery()) {
      const meta = data.meta;
      delete data.meta;
      return [data, meta];
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        result[_result.Field] = {
          type: _result.Type.toLowerCase().startsWith('enum') ? _result.Type.replace(/^enum/i,
            'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }

    return result;
  }

  handleJsonSelectQuery(rows) {
    if (!this.model || !this.model.fieldRawAttributesMap) {
      return;
    }
    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {
      const modelField = this.model.fieldRawAttributesMap[_field];
      if (modelField.type instanceof DataTypes.JSON) {
        // Value is returned as String, not JSON
        rows = rows.map(row => {
          row[modelField.fieldName] = row[modelField.fieldName] ? JSON.parse(
            row[modelField.fieldName]) : null;
          if (DataTypes.JSON.parse) {
            return DataTypes.JSON.parse(modelField, this.sequelize.options,
              row[modelField.fieldName]);
          }
          return row;
        });
      }
    }
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MariaDB Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    switch (err.errno) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(
          /Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?\s.*$/);

        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: err.errno === ER_ROW_IS_REFERENCED ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => ({
      tableName: resultSet.TABLE_NAME,
      schema: resultSet.TABLE_SCHEMA
    }));
  }

  handleShowIndexesQuery(data) {

    let currItem;
    const result = [];

    data.forEach(item => {
      if (!currItem || currItem.name !== item.Key_name) {
        currItem = {
          primary: item.Key_name === 'PRIMARY',
          fields: [],
          name: item.Key_name,
          tableName: item.Table,
          unique: item.Non_unique !== 1,
          type: item.Index_type
        };
        result.push(currItem);
      }

      currItem.fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
    });

    return result;
  }
}

module.exports = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ../../errors/base-error */ "./node_modules/sequelize/lib/errors/base-error.js");
const ConnectionError = __webpack_require__(/*! ../../errors/connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is closed while an operation is in progress
 */
class AsyncQueueError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAsyncQueueError';
  }
}

exports.AsyncQueueError = AsyncQueueError;

class AsyncQueue {
  constructor() {
    this.previous = Promise.resolve();
    this.closed = false;
    this.rejectCurrent = () => {};
  }
  close() {
    this.closed = true;
    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));
  }
  enqueue(asyncFunction) {
    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).
    // However, this ensures that this.previous will never be a rejected promise so the queue will
    // always keep going, while still communicating rejection from asyncFunction to the user.
    return new Promise((resolve, reject) => {
      this.previous = this.previous.then(
        () => {
          this.rejectCurrent = reject;
          if (this.closed) {
            return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));
          }
          return asyncFunction().then(resolve, reject);
        }
      );
    });
  }
}

exports.default = AsyncQueue;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const AsyncQueue = __webpack_require__(/*! ./async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").default;
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const debug = logger.debugContext('connection:mssql');
const debugTedious = logger.debugContext('connection:mssql:tedious');

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 1433;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('tedious');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async connect(config) {
    const connectionConfig = {
      server: config.host,
      authentication: {
        type: 'default',
        options: {
          userName: config.username || undefined,
          password: config.password || undefined
        }
      },
      options: {
        port: parseInt(config.port, 10),
        database: config.database,
        trustServerCertificate: true
      }
    };

    if (config.dialectOptions) {
      // only set port if no instance name was provided
      if (
        config.dialectOptions.options &&
        config.dialectOptions.options.instanceName
      ) {
        delete connectionConfig.options.port;
      }

      if (config.dialectOptions.authentication) {
        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);
      }

      Object.assign(connectionConfig.options, config.dialectOptions.options);
    }

    try {
      return await new Promise((resolve, reject) => {
        const connection = new this.lib.Connection(connectionConfig);
        if (connection.state === connection.STATE.INITIALIZED) {
          connection.connect();
        }
        connection.queue = new AsyncQueue();
        connection.lib = this.lib;

        const connectHandler = error => {
          connection.removeListener('end', endHandler);
          connection.removeListener('error', errorHandler);

          if (error) return reject(error);

          debug('connection acquired');
          resolve(connection);
        };

        const endHandler = () => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', errorHandler);
          reject(new Error('Connection was closed by remote server'));
        };

        const errorHandler = error => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('end', endHandler);
          reject(error);
        };

        connection.once('error', errorHandler);
        connection.once('end', endHandler);
        connection.once('connect', connectHandler);

        /*
         * Permanently attach this event before connection is even acquired
         * tedious sometime emits error even after connect(with error).
         *
         * If we dont attach this even that unexpected error event will crash node process
         *
         * E.g. connectTimeout is set higher than requestTimeout
         */
        connection.on('error', error => {
          switch (error.code) {
            case 'ESOCKET':
            case 'ECONNRESET':
              this.pool.destroy(connection);
          }
        });

        if (config.dialectOptions && config.dialectOptions.debug) {
          connection.on('debug', debugTedious.log.bind(debugTedious));
        }
      });
    } catch (error) {
      if (!error.code) {
        throw new sequelizeErrors.ConnectionError(error);
      }

      switch (error.code) {
        case 'ESOCKET':
          if (error.message.includes('connect EHOSTUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect ENETUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect EADDRNOTAVAIL')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('getaddrinfo ENOTFOUND')) {
            throw new sequelizeErrors.HostNotFoundError(error);
          }
          if (error.message.includes('connect ECONNREFUSED')) {
            throw new sequelizeErrors.ConnectionRefusedError(error);
          }
          throw new sequelizeErrors.ConnectionError(error);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ELOGIN':
          throw new sequelizeErrors.AccessDeniedError(error);
        case 'EINVAL':
          throw new sequelizeErrors.InvalidConnectionError(error);
        default:
          throw new sequelizeErrors.ConnectionError(error);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect a connection that is already disconnected
    if (connection.closed) {
      return;
    }

    connection.queue.close();

    return new Promise(resolve => {
      connection.on('end', resolve);
      connection.close();
      debug('connection closed');
    });
  }

  validate(connection) {
    return connection && connection.loggedIn;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const moment = __webpack_require__(/*! moment */ "moment");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');

  /**
   * Removes unsupported MSSQL options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types: [hex, ...]
   *
   * @see hex here https://github.com/tediousjs/tedious/blob/master/src/data-type.ts
   */

  BaseTypes.DATE.types.mssql = [43];
  BaseTypes.STRING.types.mssql = [231, 173];
  BaseTypes.CHAR.types.mssql = [175];
  BaseTypes.TEXT.types.mssql = false;
  // https://msdn.microsoft.com/en-us/library/ms187745(v=sql.110).aspx
  BaseTypes.TINYINT.types.mssql = [30];
  BaseTypes.SMALLINT.types.mssql = [34];
  BaseTypes.MEDIUMINT.types.mssql = false;
  BaseTypes.INTEGER.types.mssql = [38];
  BaseTypes.BIGINT.types.mssql = false;
  BaseTypes.FLOAT.types.mssql = [109];
  BaseTypes.TIME.types.mssql = [41];
  BaseTypes.DATEONLY.types.mssql = [40];
  BaseTypes.BOOLEAN.types.mssql = [104];
  BaseTypes.BLOB.types.mssql = [165];
  BaseTypes.DECIMAL.types.mssql = [106];
  BaseTypes.UUID.types.mssql = false;
  BaseTypes.ENUM.types.mssql = false;
  BaseTypes.REAL.types.mssql = [109];
  BaseTypes.DOUBLE.types.mssql = [109];
  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported
  BaseTypes.GEOMETRY.types.mssql = false;

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');
          return 'VARBINARY(256)';
        }
        warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');
      }
      return 'VARBINARY(MAX)';
    }
    _hexify(hex) {
      return `0x${hex}`;
    }
  }


  class STRING extends BaseTypes.STRING {
    toSql() {
      if (!this._binary) {
        return `NVARCHAR(${this._length})`;
      }
      return `BINARY(${this._length})`;
    }
    _stringify(value, options) {
      if (this._binary) {
        return BLOB.prototype._stringify(value);
      }
      return options.escape(value);
    }
    _bindParam(value, options) {
      return options.bindParam(this._binary ? Buffer.from(value) : value);
    }
  }

  STRING.prototype.escape = false;

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.
      // Using unicode is just future proof
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');
          return 'NVARCHAR(256)';
        }
        warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');
      }
      return 'NVARCHAR(MAX)';
    }
  }

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BIT';
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36)';
    }
  }

  class NOW extends BaseTypes.NOW {
    toSql() {
      return 'GETDATE()';
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'DATETIMEOFFSET';
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return moment(value).format('YYYY-MM-DD');
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class REAL extends BaseTypes.REAL {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does not support any options for real
      if (this._length || this.options.length || this._unsigned || this._zerofill) {
        warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._unsigned = undefined;
        this._zerofill = undefined;
      }
    }
  }
  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does only support lengths as option.
      // Values between 1-24 result in 7 digits precision (4 bytes storage size)
      // Values between 25-53 result in 15 digits precision (8 bytes storage size)
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
      }
      if (this._unsigned) {
        warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'VARCHAR(255)';
    }
  }

  return {
    BLOB,
    BOOLEAN,
    ENUM,
    STRING,
    UUID,
    DATE,
    DATEONLY,
    NOW,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    REAL,
    FLOAT,
    TEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mssql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js");

class MssqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);
  }
}

MssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': true,
  'DEFAULT VALUES': true,
  'LIMIT ON UPDATE': true,
  'ORDER NULLS': false,
  lock: false,
  transactions: true,
  migrations: false,
  returnValues: {
    output: true
  },
  schemas: true,
  autoIncrement: {
    identityInsert: true,
    defaultValue: false,
    update: false
  },
  constraints: {
    restrict: false,
    default: true
  },
  index: {
    collate: false,
    length: false,
    parser: false,
    type: true,
    using: false,
    where: true
  },
  NUMERIC: true,
  tmpTableTrigger: true
});

MssqlDialect.prototype.defaultVersion = '12.0.2000'; // SQL Server 2014 Express
MssqlDialect.prototype.Query = Query;
MssqlDialect.prototype.name = 'mssql';
MssqlDialect.prototype.TICK_CHAR = '"';
MssqlDialect.prototype.TICK_CHAR_LEFT = '[';
MssqlDialect.prototype.TICK_CHAR_RIGHT = ']';
MssqlDialect.prototype.DataTypes = DataTypes;

module.exports = MssqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const TableHints = __webpack_require__(/*! ../../table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const randomBytes = __webpack_require__(/*! crypto */ "crypto").randomBytes;
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");

/* istanbul ignore next */
const throwMethodUndefined = function(methodName) {
  throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};

class MSSQLQueryGenerator extends AbstractQueryGenerator {
  createDatabaseQuery(databaseName, options) {
    options = { collate: null, ...options };

    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';

    return [
      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'CREATE DATABASE', this.quoteIdentifier(databaseName),
      `${collation};`,
      'END;'
    ].join(' ');
  }

  dropDatabaseQuery(databaseName) {
    return [
      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',
      'END;'
    ].join(' ');
  }

  createSchema(schema) {
    return [
      'IF NOT EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', wrapSingleQuote(schema), ')',
      'BEGIN',
      "EXEC sp_executesql N'CREATE SCHEMA",
      this.quoteIdentifier(schema),
      ";'",
      'END;'
    ].join(' ');
  }

  dropSchema(schema) {
    // Mimics Postgres CASCADE, will drop objects belonging to the schema
    const quotedSchema = wrapSingleQuote(schema);
    return [
      'IF EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', quotedSchema, ')',
      'BEGIN',
      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',
      'DECLARE @cascade TABLE (',
      'id INT NOT NULL IDENTITY PRIMARY KEY,',
      'ms_sql NVARCHAR(2000) NOT NULL );',
      'INSERT INTO @cascade ( ms_sql )',
      "SELECT CASE WHEN o.type IN ('F','PK')",
      "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'",
      "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END",
      'FROM sys.objects o',
      'JOIN sys.schemas s on o.schema_id = s.schema_id',
      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',
      "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ", quotedSchema,
      'ORDER BY o.type ASC;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'WHILE @id IS NOT NULL',
      'BEGIN',
      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',
      'BEGIN CATCH BREAK; THROW; END CATCH;',
      'DELETE FROM @cascade WHERE id = @id;',
      'SELECT @id = NULL, @ms_sql = NULL;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'END',
      "EXEC sp_executesql N'DROP SCHEMA", this.quoteIdentifier(schema), ";'",
      'END;'
    ].join(' ');
  }

  showSchemasQuery() {
    return [
      'SELECT "name" as "schema_name" FROM sys.schemas as s',
      'WHERE "s"."name" NOT IN (',
      "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'",
      ')', 'AND', '"s"."name" NOT LIKE', "'db_%'"
    ].join(' ');
  }

  versionQuery() {
    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch
    return [
      'DECLARE @ms_ver NVARCHAR(20);',
      "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));",
      "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"
    ].join(' ');
  }

  createTableQuery(tableName, attributes, options) {
    const primaryKeys = [],
      foreignKeys = {},
      attributesClauseParts = [];

    let commentStr = '';

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        let dataType = attributes[attr];
        let match;

        if (dataType.includes('COMMENT ')) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace('COMMENT', '').trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          // remove comment related substring from dataType
          dataType = commentMatch[1];
        }

        if (dataType.includes('PRIMARY KEY')) {
          primaryKeys.push(attr);

          if (dataType.includes('REFERENCES')) {
            // MSSQL doesn't support inline REFERENCES declarations: move to the end
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
          }
        } else if (dataType.includes('REFERENCES')) {
          // MSSQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }

    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClauseParts.push(`CONSTRAINT ${
            this.quoteIdentifier(indexName)
          } UNIQUE (${
            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')
          })`);
        }
      });
    }

    if (pkString.length > 0) {
      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
      }
    }

    const quotedTableName = this.quoteTable(tableName);

    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,
      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,
      ';',
      commentStr
    ]);
  }

  describeTableQuery(tableName, schema) {
    let sql = [
      'SELECT',
      "c.COLUMN_NAME AS 'Name',",
      "c.DATA_TYPE AS 'Type',",
      "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',",
      "c.IS_NULLABLE as 'IsNull',",
      "COLUMN_DEFAULT AS 'Default',",
      "pk.CONSTRAINT_TYPE AS 'Constraint',",
      "COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',",
      "CAST(prop.value AS NVARCHAR) AS 'Comment'",
      'FROM',
      'INFORMATION_SCHEMA.TABLES t',
      'INNER JOIN',
      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',
      'cu.column_name, tc.CONSTRAINT_TYPE ',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',
      'and tc.constraint_name=cu.constraint_name ',
      'and tc.CONSTRAINT_TYPE=\'PRIMARY KEY\') pk ',
      'ON pk.table_schema=c.table_schema ',
      'AND pk.table_name=c.table_name ',
      'AND pk.column_name=c.column_name ',
      'INNER JOIN sys.columns AS sc',
      "ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name",
      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',
      'AND prop.minor_id = sc.column_id',
      "AND prop.name = 'MS_Description'",
      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)
    ].join(' ');

    if (schema) {
      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;
    }

    return sql;
  }

  renameTableQuery(before, after) {
    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;
  }

  showTablesQuery() {
    return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';";
  }

  dropTableQuery(tableName) {
    const quoteTbl = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,
      'DROP TABLE',
      quoteTbl,
      ';'
    ]);
  }

  addColumnQuery(table, key, dataType) {
    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery
    //        but instead we need to pass the key along as the field here
    dataType.field = key;
    let commentStr = '';

    if (dataType.comment && _.isString(dataType.comment)) {
      commentStr = this.commentTemplate(dataType.comment, table, key);
      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key
      // is present. This is needed for createTable statement where that part is extracted with regex.
      // Here we can intercept the object and remove comment property since we have the original object.
      delete dataType['comment'];
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, { context: 'addColumn' }),
      ';',
      commentStr
    ]);
  }

  commentTemplate(comment, table, column) {
    return ' EXEC sp_addextendedproperty ' +
        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +
        '@level0type = N\'Schema\', @level0name = \'dbo\', ' +
        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +
        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP COLUMN',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [],
      constraintString = [];
    let commentString = '';

    for (const attributeName in attributes) {
      const quotedAttrName = this.quoteIdentifier(attributeName);
      let definition = attributes[attributeName];
      if (definition.includes('COMMENT ')) {
        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
        const commentText = commentMatch[2].replace('COMMENT', '').trim();
        commentString += this.commentTemplate(commentText, tableName, attributeName);
        // remove comment related substring from dataType
        definition = commentMatch[1];
      }
      if (definition.includes('REFERENCES')) {
        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);
      } else {
        attrString.push(`${quotedAttrName} ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';',
      commentString
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const newName = Object.keys(attributes)[0];
    return Utils.joinSQLFragments([
      'EXEC sp_rename',
      `'${this.quoteTable(tableName)}.${attrBefore}',`,
      `'${newName}',`,
      "'COLUMN'",
      ';'
    ]);
  }

  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    const quotedTable = this.quoteTable(tableName);
    options = options || {};
    attributes = attributes || {};

    const tuples = [];
    const allAttributes = [];
    const allQueries = [];

    let needIdentityInsertWrapper = false,
      outputFragment = '';

    if (options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      outputFragment = returnValues.outputFragment;
    }

    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;

    attrValueHashes.forEach(attrValueHash => {
      // special case for empty objects with primary keys
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
        allQueries.push(emptyQuery);
        return;
      }

      // normal case
      _.forOwn(attrValueHash, (value, key) => {
        if (value !== null && attributes[key] && attributes[key].autoIncrement) {
          needIdentityInsertWrapper = true;
        }

        if (!allAttributes.includes(key)) {
          if (value === null && attributes[key] && attributes[key].autoIncrement)
            return;

          allAttributes.push(key);
        }
      });
    });

    if (allAttributes.length > 0) {
      attrValueHashes.forEach(attrValueHash => {
        tuples.push(`(${
          allAttributes.map(key =>
            this.escape(attrValueHash[key])).join(',')
        })`);
      });

      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);
    }
    const commands = [];
    let offset = 0;
    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;
    while (offset < Math.max(tuples.length, 1)) {
      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');
      if (needIdentityInsertWrapper) {
        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;
      }
      commands.push(generatedQuery);
      offset += batch;
    }
    return commands.join(';');
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    if (options.limit) {
      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;
      sql.query = sql.query.replace('UPDATE', updateArgs);
    }
    return sql;
  }

  upsertQuery(tableName, insertValues, updateValues, where, model) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysAttrs = [];
    const identityAttrs = [];
    const uniqueAttrs = [];
    const tableNameQuoted = this.quoteTable(tableName);
    let needIdentityInsertWrapper = false;

    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed
    for (const key in model.rawAttributes) {
      if (model.rawAttributes[key].primaryKey) {
        primaryKeysAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].unique) {
        uniqueAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].autoIncrement) {
        identityAttrs.push(model.rawAttributes[key].field || key);
      }
    }

    //Add unique indexes defined by indexes option to uniqueAttrs
    for (const index of model._indexes) {
      if (index.unique && index.fields) {
        for (const field of index.fields) {
          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;
          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {
            uniqueAttrs.push(fieldName);
          }
        }
      }
    }

    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');
    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table
    let joinCondition;

    //IDENTITY_INSERT Condition
    identityAttrs.forEach(key => {
      if (updateValues[key] && updateValues[key] !== null) {
        needIdentityInsertWrapper = true;
        /*
         * IDENTITY_INSERT Column Cannot be updated, only inserted
         * http://stackoverflow.com/a/30176254/2254360
         */
      }
    });

    //Filter NULL Clauses
    const clauses = where[Op.or].filter(clause => {
      let valid = true;
      /*
       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row
       */
      for (const key in clause) {
        if (typeof clause[key] === 'undefined' || clause[key] == null) {
          valid = false;
          break;
        }
      }
      return valid;
    });

    /*
     * Generate ON condition using PK(s).
     * If not, generate using UK(s). Else throw error
     */
    const getJoinSnippet = array => {
      return array.map(key => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };

    if (clauses.length === 0) {
      throw new Error('Primary Key or Unique key should be passed to upsert query');
    } else {
      // Search for primary key attribute in clauses -- Model can have two separate unique keys
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.includes(keys[0])) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');
      }
    }

    // Remove the IDENTITY_INSERT Column from update
    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))
      .map(key => {
        const value = this.escape(updateValues[key]);
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${value}`;
      }).join(', ');

    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    const whereClause = this.getWhereConditions(where, null, model, options);

    return Utils.joinSQLFragments([
      'DELETE',
      options.limit && `TOP(${this.escape(options.limit)})`,
      'FROM',
      table,
      whereClause && `WHERE ${whereClause}`,
      ';',
      'SELECT @@ROWCOUNT AS AFFECTEDROWS',
      ';'
    ]);
  }

  showIndexesQuery(tableName) {
    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;
  }

  showConstraintsQuery(tableName) {
    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
  }

  attributeToSQL(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    // handle self referential constraints
    if (attribute.references) {

      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
        this.sequelize.log('MSSQL does not support self referencial constraints, '
          + 'we will remove it but we recommend restructuring your query');
        attribute.onDelete = '';
        attribute.onUpdate = '';
      }
    }

    let template;

    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;

      // enums are a special case
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {
        return this.escape(value);
      }).join(', ') }))`;
      return template;
    }
    template = attribute.type.toString();

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ' NULL';
    }

    if (attribute.autoIncrement) {
      template += ' IDENTITY(1,1)';
    }

    // Blobs/texts cannot have a defaultValue
    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&
        Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.references) {
      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      template += ` COMMENT ${attribute.comment}`;
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {},
      existingConstraints = [];
    let key,
      attribute;

    for (key in attributes) {
      attribute = attributes[key];

      if (attribute.references) {
        if (existingConstraints.includes(attribute.references.model.toString())) {
          // no cascading constraints to a table more than once
          attribute.onDelete = '';
          attribute.onUpdate = '';
        } else {
          existingConstraints.push(attribute.references.model.toString());

          // NOTE: this really just disables cascading updates for all
          //       definitions. Can be made more robust to support the
          //       few cases where MSSQL actually supports them
          attribute.onUpdate = '';
        }

      }

      if (key && !attribute.field) attribute.field = key;
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  createTrigger() {
    throwMethodUndefined('createTrigger');
  }

  dropTrigger() {
    throwMethodUndefined('dropTrigger');
  }

  renameTrigger() {
    throwMethodUndefined('renameTrigger');
  }

  createFunction() {
    throwMethodUndefined('createFunction');
  }

  dropFunction() {
    throwMethodUndefined('dropFunction');
  }

  renameFunction() {
    throwMethodUndefined('renameFunction');
  }

  /**
   * Generate common SQL prefix for ForeignKeysQuery.
   *
   * @param {string} catalogName
   * @returns {string}
   */
  _getForeignKeysQueryPrefix(catalogName) {
    return `${'SELECT ' +
        'constraint_name = OBJ.NAME, ' +
        'constraintName = OBJ.NAME, '}${
      catalogName ? `constraintCatalog = '${catalogName}', ` : ''
    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +
        'tableName = TB.NAME, ' +
        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${
          catalogName ? `tableCatalog = '${catalogName}', ` : ''
        }columnName = COL.NAME, ` +
        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${
          catalogName ? `referencedCatalog = '${catalogName}', ` : ''
        }referencedTableName = RTB.NAME, ` +
        'referencedColumnName = RCOL.NAME ' +
      'FROM sys.foreign_key_columns FKC ' +
        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +
        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +
        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +
        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +
        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * @param {string|object} table
   * @param {string} catalogName database name
   * @returns {string}
   */
  getForeignKeysQuery(table, catalogName) {
    const tableName = table.tableName || table;
    let sql = `${this._getForeignKeysQueryPrefix(catalogName)
    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;

    if (table.schema) {
      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
    }
    return sql;
  }

  getForeignKeyQuery(table, attributeName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      this._getForeignKeysQueryPrefix(),
      'WHERE',
      `TB.NAME =${wrapSingleQuote(tableName)}`,
      'AND',
      `COL.NAME =${wrapSingleQuote(attributeName)}`,
      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`
    ]);
  }

  getPrimaryKeyConstraintQuery(table, attributeName) {
    const tableName = wrapSingleQuote(table.tableName || table);
    return Utils.joinSQLFragments([
      'SELECT K.TABLE_NAME AS tableName,',
      'K.COLUMN_NAME AS columnName,',
      'K.CONSTRAINT_NAME AS constraintName',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',
      'ON C.TABLE_NAME = K.TABLE_NAME',
      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',
      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',
      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',
      'WHERE C.CONSTRAINT_TYPE = \'PRIMARY KEY\'',
      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
      `AND K.TABLE_NAME = ${tableName}`,
      ';'
    ]);
  }

  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(foreignKey)
    ]);
  }

  getDefaultConstraintQuery(tableName, attributeName) {
    const quotedTable = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      'SELECT name FROM sys.default_constraints',
      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,
      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,
      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,
      ';'
    ]);
  }

  dropConstraintQuery(tableName, constraintName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP CONSTRAINT',
      this.quoteIdentifier(constraintName),
      ';'
    ]);
  }

  setIsolationLevelQuery() {

  }

  generateTransactionId() {
    return randomBytes(10).toString('hex');
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'BEGIN TRANSACTION;';
  }

  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT TRANSACTION;';
  }

  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'ROLLBACK TRANSACTION;';
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    const dbVersion = this.sequelize.options.databaseVersion;
    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');

    if (isSQLServer2008 && options.offset) {
      // For earlier versions of SQL server, we need to nest several queries
      // in order to emulate the OFFSET behavior.
      //
      // 1. The outermost query selects all items from the inner query block.
      //    This is due to a limitation in SQL server with the use of computed
      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.
      // 2. The next query handles the LIMIT and OFFSET behavior by getting
      //    the TOP N rows of the query where the row number is > OFFSET
      // 3. The innermost query is the actual set we want information from

      const offset = options.offset || 0;
      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
      let orders = { mainQueryOrder: [] };
      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }

      if (orders.mainQueryOrder.length === 0) {
        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
      }

      const tmpTable = mainTableAs || 'OffsetTable';

      return Utils.joinSQLFragments([
        'SELECT TOP 100 PERCENT',
        attributes.join(', '),
        'FROM (',
        [
          'SELECT',
          options.limit && `TOP ${options.limit}`,
          '* FROM (',
          [
            'SELECT ROW_NUMBER() OVER (',
            [
              'ORDER BY',
              orders.mainQueryOrder.join(', ')
            ],
            `) as row_num, * FROM ${tables} AS ${tmpTable}`,
            where && `WHERE ${where}`
          ],
          `) AS ${tmpTable} WHERE row_num > ${offset}`
        ],
        `) AS ${tmpTable}`
      ]);
    }

    return Utils.joinSQLFragments([
      'SELECT',
      isSQLServer2008 && options.limit && `TOP ${options.limit}`,
      attributes.join(', '),
      `FROM ${tables}`,
      mainTableAs && `AS ${mainTableAs}`,
      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`
    ]);
  }

  addLimitAndOffset(options, model) {
    // Skip handling of limit and offset as postfixes for older SQL Server versions
    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {
      return '';
    }

    const offset = options.offset || 0;
    const isSubQuery = options.subQuery === undefined
      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation
      : options.subQuery;

    let fragment = '';
    let orders = {};

    if (options.order) {
      orders = this.getQueryOrders(options, model, isSubQuery);
    }

    if (options.limit || options.offset) {
      if (!options.order || !options.order.length || options.include && !orders.subQueryOrder.length) {
        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;
        if (!options.order || !options.order.length) {
          fragment += ` ORDER BY ${tablePkFragment}`;
        } else {
          const orderFieldNames = _.map(options.order, order => order[0]);
          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);

          if (!primaryKeyFieldAlreadyPresent) {
            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';
            fragment += tablePkFragment;
          }
        }
      }

      if (options.offset || options.limit) {
        fragment += ` OFFSET ${this.escape(offset)} ROWS`;
      }

      if (options.limit) {
        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
      }
    }

    return fragment;
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}

module.exports = MSSQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");

/**
 * The interface that Sequelize uses to talk with MSSQL database
 */
class MSSqlQueryInterface extends QueryInterface {
  /**
  * A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.
  *
  * @override
  */
  async removeColumn(tableName, attributeName, options) {
    options = { raw: true, ...options || {} };

    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);
    const [results0] = await this.sequelize.query(findConstraintSql, options);
    if (results0.length) {
      // No default constraint found -- we can cleanly remove the column
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);
    const [results] = await this.sequelize.query(findForeignKeySql, options);
    if (results.length) {
      // No foreign key constraints found, so we can remove the column
      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);
      await this.sequelize.query(dropForeignKeySql, options);
    }
    //Check if the current column is a primaryKey
    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);
    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);
    if (result.length) {
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);
    return this.sequelize.query(removeSql, options);
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    const model = options.model;
    const wheres = [];

    options = { ...options };

    if (!Utils.isWhereEmpty(where)) {
      wheres.push(where);
    }

    // Lets combine unique keys and indexes into one
    let indexes = Object.values(model.uniqueKeys).map(item => item.fields);
    indexes = indexes.concat(Object.values(model._indexes).filter(item => item.unique).map(item => item.fields));

    const attributes = Object.keys(insertValues);
    for (const index of indexes) {
      if (_.intersection(attributes, index).length === index.length) {
        where = {};
        for (const field of index) {
          where[field] = insertValues[field];
        }
        wheres.push(where);
      }
    }

    where = { [Op.or]: wheres };

    options.type = QueryTypes.UPSERT;
    options.raw = true;

    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
    return await this.sequelize.query(sql, options);
  }
}

exports.MSSqlQueryInterface = MSSqlQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:mssql');

function getScale(aNum) {
  if (!Number.isFinite(aNum)) return 0;
  let e = 1;
  while (Math.round(aNum * e) / e !== aNum) e *= 10;
  return Math.log10(e);
}

class Query extends AbstractQuery {
  getInsertIdField() {
    return 'id';
  }

  getSQLTypeFromJsType(value, TYPES) {
    const paramType = { type: TYPES.VarChar, typeOptions: {} };
    paramType.type = TYPES.NVarChar;
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        if (value >= -2147483648 && value <= 2147483647) {
          paramType.type = TYPES.Int;
        } else {
          paramType.type = TYPES.BigInt;
        }
      } else {
        paramType.type = TYPES.Numeric;
        //Default to a reasonable numeric precision/scale pending more sophisticated logic
        paramType.typeOptions = { precision: 30, scale: getScale(value) };
      }
    } else if (typeof value === 'boolean') {
      paramType.type = TYPES.Bit;
    }
    if (Buffer.isBuffer(value)) {
      paramType.type = TYPES.VarBinary;
    }
    return paramType;
  }

  async _run(connection, sql, parameters) {
    this.sql = sql;
    const { options } = this;

    const complete = this._logQuery(sql, debug, parameters);

    const query = new Promise((resolve, reject) => {
      // TRANSACTION SUPPORT
      if (sql.startsWith('BEGIN TRANSACTION')) {
        return connection.beginTransaction(error => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);
      }
      if (sql.startsWith('COMMIT TRANSACTION')) {
        return connection.commitTransaction(error => error ? reject(error) : resolve([]));
      }
      if (sql.startsWith('ROLLBACK TRANSACTION')) {
        return connection.rollbackTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }
      if (sql.startsWith('SAVE TRANSACTION')) {
        return connection.saveTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }

      const rows = [];
      const request = new connection.lib.Request(sql, (err, rowCount) => err ? reject(err) : resolve([rows, rowCount]));

      if (parameters) {
        _.forOwn(parameters, (value, key) => {
          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);
          request.addParameter(key, paramType.type, value, paramType.typeOptions);
        });
      }

      request.on('row', columns => {
        rows.push(columns);
      });

      connection.execSql(request);
    });

    let rows, rowCount;

    try {
      [rows, rowCount] = await query;
    } catch (err) {
      err.sql = sql;
      err.parameters = parameters;

      throw this.formatError(err);
    }

    complete();

    if (Array.isArray(rows)) {
      rows = rows.map(columns => {
        const row = {};
        for (const column of columns) {
          const typeid = column.metadata.type.id;
          const parse = parserStore.get(typeid);
          let value = column.value;

          if (value !== null & !!parse) {
            value = parse(value);
          }
          row[column.metadata.colName] = value;
        }
        return row;
      });
    }

    return this.formatResults(rows, rowCount);
  }

  run(sql, parameters) {
    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters));
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = {};
    const replacementFunc = (match, key, values) => {
      if (values[key] !== undefined) {
        bindParam[key] = values[key];
        return `@${key}`;
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];

    return [sql, bindParam];
  }

  /**
   * High level function that handles the results of a query execution.
   *
   * @param {Array} data - The result of the query execution.
   * @param {number} rowCount
   * @private
   * @example
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   */
  formatResults(data, rowCount) {
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);
      return [this.instance || data, rowCount];
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      const result = {};
      for (const _result of data) {
        if (_result.Default) {
          _result.Default = _result.Default.replace("('", '').replace("')", '').replace(/'/g, '');
        }

        result[_result.Name] = {
          type: _result.Type.toUpperCase(),
          allowNull: _result.IsNull === 'YES' ? true : false,
          defaultValue: _result.Default,
          primaryKey: _result.Constraint === 'PRIMARY KEY',
          autoIncrement: _result.IsIdentity === 1,
          comment: _result.Comment
        };

        if (
          result[_result.Name].type.includes('CHAR')
          && _result.Length
        ) {
          if (_result.Length === -1) {
            result[_result.Name].type += '(MAX)';
          } else {
            result[_result.Name].type += `(${_result.Length})`;
          }
        }
      }
      return result;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery()) {
      if (this.options.returning) {
        return this.handleSelectQuery(data);
      }

      return rowCount;
    }
    if (this.isBulkDeleteQuery()) {
      return data[0] ? data[0].AFFECTEDROWS : 0;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      this.handleInsertQuery(data);
      return [this.instance || data, data[0].$action === 'INSERT'];
    }
    if (this.isUpdateQuery()) {
      return [this.instance || data, rowCount];
    }
    if (this.isShowConstraintsQuery()) {
      return this.handleShowConstraintsQuery(data);
    }
    if (this.isRawQuery()) {
      return [data, rowCount];
    }
    return data;
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => {
      return {
        tableName: resultSet.TABLE_NAME,
        schema: resultSet.TABLE_SCHEMA
      };
    });
  }

  handleShowConstraintsQuery(data) {
    //Convert snake_case keys to camelCase as it's generated by stored procedure
    return data.slice(1).map(result => {
      const constraint = {};
      for (const key in result) {
        constraint[_.camelCase(key)] = result[key];
      }
      return constraint;
    });
  }

  formatError(err) {
    let match;

    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \((.*)\).)?/);
    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);
    if (match && match.length > 1) {
      let fields = {};
      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];
      let message = 'Validation error';

      if (uniqueKey && !!uniqueKey.msg) {
        message = uniqueKey.msg;
      }
      if (match[3]) {
        const values = match[3].split(',').map(part => part.trim());
        if (uniqueKey) {
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[match[1]] = match[3];
        }
      }

      const errors = [];
      _.forOwn(fields, (value, field) => {
        errors.push(new sequelizeErrors.ValidationErrorItem(
          this.getUniqueConstraintErrorMessage(field),
          'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
          field,
          value,
          this.instance,
          'not_unique'
        ));
      });

      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
    }

    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||
      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./) ||
      err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./);
    if (match && match.length > 0) {
      return new sequelizeErrors.ForeignKeyConstraintError({
        fields: null,
        index: match[1],
        parent: err
      });
    }

    match = err.message.match(/Could not drop constraint. See previous errors./);
    if (match && match.length > 0) {
      let constraint = err.sql.match(/(?:constraint|index) \[(.+?)\]/i);
      constraint = constraint ? constraint[1] : undefined;
      let table = err.sql.match(/table \[(.+?)\]/i);
      table = table ? table[1] : undefined;

      return new sequelizeErrors.UnknownConstraintError({
        message: match[1],
        constraint,
        table,
        parent: err
      });
    }

    return new sequelizeErrors.DatabaseError(err);
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith("select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'");
    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');
    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');

    return result;
  }

  isShowIndexesQuery() {
    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.index_name in acc)) {
        acc[item.index_name] = item;
        item.fields = [];
      }

      item.index_keys.split(',').forEach(column => {
        let columnName = column.trim();
        if (columnName.includes('(-)')) {
          columnName = columnName.replace('(-)', '');
        }

        acc[item.index_name].fields.push({
          attribute: columnName,
          length: undefined,
          order: column.includes('(-)') ? 'DESC' : 'ASC',
          collate: undefined
        });
      });
      delete item.index_keys;
      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.index_name.toLowerCase().startsWith('pk'),
      fields: item.fields,
      name: item.index_name,
      tableName: undefined,
      unique: item.index_description.toLowerCase().includes('unique'),
      type: undefined
    }));
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;
      let autoIncrementAttributeAlias = null;

      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) &&
        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)
        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;

      id = id || results && results[0][this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];
      id = id || results && results[0][autoIncrementAttribute];
      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];

      this.instance[autoIncrementAttribute] = id;

      if (this.instance.dataValues) {
        for (const key in results[0]) {
          if (Object.prototype.hasOwnProperty.call(results[0], key)) {
            const record = results[0][key];
  
            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);
  
            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }
      
    }
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mysql');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mysql');
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * MySQL Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MySQL specific connections
 * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mysql2');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  /**
   * Connect with MySQL database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      flags: '-FOUND_ROWS',
      password: config.password,
      database: config.database,
      timezone: this.sequelize.options.timezone,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      ...config.dialectOptions
    };

    try {
      const connection = await new Promise((resolve, reject) => {
        const connection = this.lib.createConnection(connectionConfig);

        const errorHandler = e => {
          // clean up connect & error event if there is error
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', connectHandler);
          reject(e);
        };

        const connectHandler = () => {
          // clean up error event if connected
          connection.removeListener('error', errorHandler);
          resolve(connection);
        };

        // don't use connection.once for error event handling here
        // mysql2 emit error two times in case handshake was failed
        // first error is protocol_lost and second is timeout
        // if we will use `once.error` node process will crash on 2nd error emit
        connection.on('error', errorHandler);
        connection.once('connect', connectHandler);
      });

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });

      if (!this.sequelize.config.keepDefaultTimezone) {
        // set timezone for this connection
        // but named timezone are not directly supported in mysql, so get its offset first
        let tzOffset = this.sequelize.options.timezone;
        tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;
        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();
      }

      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (connection._closing) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return connection
      && !connection._fatalError
      && !connection._protocolError
      && !connection._closing
      && !connection.stream.destroyed;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';

  /**
   * types: [buffer_type, ...]
   *
   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html
   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js
   */

  BaseTypes.DATE.types.mysql = ['DATETIME'];
  BaseTypes.STRING.types.mysql = ['VAR_STRING'];
  BaseTypes.CHAR.types.mysql = ['STRING'];
  BaseTypes.TEXT.types.mysql = ['BLOB'];
  BaseTypes.TINYINT.types.mysql = ['TINY'];
  BaseTypes.SMALLINT.types.mysql = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mysql = ['INT24'];
  BaseTypes.INTEGER.types.mysql = ['LONG'];
  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];
  BaseTypes.FLOAT.types.mysql = ['FLOAT'];
  BaseTypes.TIME.types.mysql = ['TIME'];
  BaseTypes.DATEONLY.types.mysql = ['DATE'];
  BaseTypes.BOOLEAN.types.mysql = ['TINY'];
  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mysql = false;
  BaseTypes.ENUM.types.mysql = false;
  BaseTypes.REAL.types.mysql = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];
  BaseTypes.JSON.types.mysql = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      // Fractional DATETIMEs only supported on MySQL 5.6.4+
      if (this._length) {
        return date.format('YYYY-MM-DD HH:mm:ss.SSS');
      }
      return date.format('YYYY-MM-DD HH:mm:ss');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }
  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
        return;
      }
      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {
        this.sqlType = this.type;
        return;
      }
      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(', ')}`);
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mysql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");

class MysqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'VALUES ()': true,
  'LIMIT ON UPDATE': true,
  lock: true,
  forShare: 'LOCK IN SHARE MODE',
  settingIsolationLevelDuringTransaction: false,
  inserts: {
    ignoreDuplicates: ' IGNORE',
    updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
  },
  index: {
    collate: false,
    length: true,
    parser: true,
    type: true,
    using: 1
  },
  constraints: {
    dropConstraint: false,
    check: false
  },
  indexViaAlter: true,
  indexHints: true,
  NUMERIC: true,
  GEOMETRY: true,
  JSON: true,
  REGEXP: true
});

MysqlDialect.prototype.defaultVersion = '5.7.0';
MysqlDialect.prototype.Query = Query;
MysqlDialect.prototype.QueryGenerator = QueryGenerator;
MysqlDialect.prototype.DataTypes = DataTypes;
MysqlDialect.prototype.name = 'mysql';
MysqlDialect.prototype.TICK_CHAR = '`';
MysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;
MysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;

module.exports = MysqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const util = __webpack_require__(/*! util */ "util");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");


const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
const FOREIGN_KEY_FIELDS = [
  'CONSTRAINT_NAME as constraint_name',
  'CONSTRAINT_NAME as constraintName',
  'CONSTRAINT_SCHEMA as constraintSchema',
  'CONSTRAINT_SCHEMA as constraintCatalog',
  'TABLE_NAME as tableName',
  'TABLE_SCHEMA as tableSchema',
  'TABLE_SCHEMA as tableCatalog',
  'COLUMN_NAME as columnName',
  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',
  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',
  'REFERENCED_TABLE_NAME as referencedTableName',
  'REFERENCED_COLUMN_NAME as referencedColumnName'
].join(',');

const typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);

class MySQLQueryGenerator extends AbstractQueryGenerator {
  constructor(options) {
    super(options);

    this.OperatorMap = {
      ...this.OperatorMap,
      [Op.regexp]: 'REGEXP',
      [Op.notRegexp]: 'NOT REGEXP'
    };
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE DATABASE IF NOT EXISTS',
      this.quoteIdentifier(databaseName),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;
  }

  createSchema() {
    return 'SHOW TABLES';
  }

  showSchemasQuery() {
    return 'SHOW TABLES';
  }

  versionQuery() {
    return 'SELECT VERSION() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = {
      engine: 'InnoDB',
      charset: null,
      rowFormat: null,
      ...options
    };

    const primaryKeys = [];
    const foreignKeys = {};
    const attrStr = [];

    for (const attr in attributes) {
      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
      const dataType = attributes[attr];
      let match;

      if (dataType.includes('PRIMARY KEY')) {
        primaryKeys.push(attr);

        if (dataType.includes('REFERENCES')) {
          // MySQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
        }
      } else if (dataType.includes('REFERENCES')) {
        // MySQL doesn't support inline REFERENCES declarations: move to the end
        match = dataType.match(/^(.+) (REFERENCES.*)$/);
        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
        foreignKeys[attr] = match[2];
      } else {
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attributesClause = attrStr.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }

    return Utils.joinSQLFragments([
      'CREATE TABLE IF NOT EXISTS',
      table,
      `(${attributesClause})`,
      `ENGINE=${options.engine}`,
      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,
      options.charset && `DEFAULT CHARSET=${options.charset}`,
      options.collate && `COLLATE ${options.collate}`,
      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,
      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,
      ';'
    ]);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `SHOW FULL COLUMNS FROM ${table};`;
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\', \'SYS\')';
    }
    return `${query};`;
  }

  addColumnQuery(table, key, dataType) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, {
        context: 'addColumn',
        tableName: table,
        foreignKey: key
      }),
      ';'
    ]);
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [];
    const constraintString = [];

    for (const attributeName in attributes) {
      let definition = attributes[attributeName];
      if (definition.includes('REFERENCES')) {
        const attrName = this.quoteIdentifier(attributeName);
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);
      } else {
        attrString.push(`\`${attributeName}\` \`${attributeName}\` ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `CHANGE ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';'
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const attrString = [];

    for (const attrName in attributes) {
      const definition = attributes[attrName];
      attrString.push(`\`${attrBefore}\` \`${attrName}\` ${definition}`);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'CHANGE',
      attrString.join(', '),
      ';'
    ]);
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the sqlite json functions
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    } else if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      } else if (smth.json && /boolean/i.test(smth.type)) {
        // true or false cannot be casted as booleans within a JSON structure
        smth.type = 'char';
      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {
        smth.type = 'decimal';
      } else if (/text/i.test(smth.type)) {
        smth.type = 'char';
      }
    }

    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
  }

  _toJSONValue(value) {
    // true/false are stored as strings in mysql
    if (typeof value === 'boolean') {
      return value.toString();
    }
    // null is stored as a string in mysql
    if (value === null) {
      return 'null';
    }
    return value;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    let limit = '';
    let query = `DELETE FROM ${this.quoteTable(tableName)}`;

    if (options.limit) {
      limit = ` LIMIT ${this.escape(options.limit)}`;
    }

    where = this.getWhereConditions(where, null, model, options);

    if (where) {
      query += ` WHERE ${where}`;
    }

    return query + limit;
  }

  showIndexesQuery(tableName, options) {
    return Utils.joinSQLFragments([
      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,
      options && options.database && `FROM \`${options.database}\``
    ]);
  }

  showConstraintsQuery(table, constraintName) {
    const tableName = table.tableName || table;
    const schemaName = table.schema;

    return Utils.joinSQLFragments([
      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',
      'CONSTRAINT_NAME AS constraintName,',
      'CONSTRAINT_SCHEMA AS constraintSchema,',
      'CONSTRAINT_TYPE AS constraintType,',
      'TABLE_NAME AS tableName,',
      'TABLE_SCHEMA AS tableSchema',
      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',
      `WHERE table_name='${tableName}'`,
      constraintName && `AND constraint_name = '${constraintName}'`,
      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,
      ';'
    ]);
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return Utils.joinSQLFragments([
      'DROP INDEX',
      this.quoteIdentifier(indexName),
      'ON',
      this.quoteTable(tableName)
    ]);
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });
    let template = attributeString;

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      template += ' auto_increment';
    }

    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value
    if (!typeWithoutDefault.has(attributeString)
      && attribute.type._binary !== true
      && Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.comment) {
      template += ` COMMENT ${this.escape(attribute.comment)}`;
    }

    if (attribute.first) {
      template += ' FIRST';
    }
    if (attribute.after) {
      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
    }

    if (attribute.references) {
      if (options && options.context === 'addColumn' && options.foreignKey) {
        const attrName = this.quoteIdentifier(options.foreignKey);
        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);

        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
      }

      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   * @private
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = JSON_FUNCTION_REGEX.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {object} table  The table.
   * @param  {string} schemaName The name of the schema.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(table, schemaName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,
      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,
      'AND REFERENCED_TABLE_NAME IS NOT NULL',
      ';'
    ]);
  }

  /**
   * Generates an SQL query that returns the foreign key constraint of a given column.
   *
   * @param  {object} table  The table.
   * @param  {string} columnName The name of the column.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeyQuery(table, columnName) {
    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';
    const quotedTableName = wrapSingleQuote(table.tableName || table);
    const quotedColumnName = wrapSingleQuote(columnName);

    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',
      'WHERE (',
      [
        `REFERENCED_TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`
      ],
      ') OR (',
      [
        `TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND COLUMN_NAME = ${quotedColumnName}`,
        'AND REFERENCED_TABLE_NAME IS NOT NULL'
      ],
      ')'
    ]);
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP FOREIGN KEY',
      this.quoteIdentifier(foreignKey),
      ';'
    ]);
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(identifier, '\'');
}

module.exports = MySQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk with MySQL/MariaDB database
 */
class MySQLQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.
   *
   * @override
   */
  async removeColumn(tableName, columnName, options) {
    options = options || {};

    const [results] = await this.sequelize.query(
      this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, columnName),
      { raw: true, ...options }
    );

    //Exclude primary key constraint
    if (results.length && results[0].constraint_name !== 'PRIMARY') {
      await Promise.all(results.map(constraint => this.sequelize.query(
        this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name),
        { raw: true, ...options }
      )));
    }

    return await this.sequelize.query(
      this.queryGenerator.removeColumnQuery(tableName, columnName),
      { raw: true, ...options }
    );
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);

    const model = options.model;
    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(
      tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, constraintName);

    const constraints = await this.sequelize.query(sql, { ...options,
      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS });

    const constraint = constraints[0];
    let query;
    if (!constraint || !constraint.constraintType) {
      throw new sequelizeErrors.UnknownConstraintError(
        {
          message: `Constraint ${constraintName} on table ${tableName} does not exist`,
          constraint: constraintName,
          table: tableName
        });
    }

    if (constraint.constraintType === 'FOREIGN KEY') {
      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);
    } else {
      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);
    }

    return await this.sequelize.query(query, options);
  }
}

exports.MySQLQueryInterface = MySQLQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mysql');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      if (parameters && parameters.length) {
        results = await new Promise((resolve, reject) => {
          connection
            .execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      } else {
        results = await new Promise((resolve, reject) => {
          connection
            .query({ sql }, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      }
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MySQL automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MySQL automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          data.constructor.name === 'ResultSetHeader'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = data[this.getInsertIdField()];
          result = [];
          for (let i = startId; i < startId + data.affectedRows; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = data[this.getInsertIdField()];
        }
      }
    }

    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        const enumRegex = /^enum/i;
        result[_result.Field] = {
          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isRawQuery()) {
      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta
      return [data, data];
    }

    return result;
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MySQL Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    const errCode = err.errno || err.code;

    switch (errCode) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?$/);
        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.Key_name in acc)) {
        acc[item.Key_name] = item;
        item.fields = [];
      }

      acc[item.Key_name].fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
      delete item.column_name;

      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.Key_name === 'PRIMARY',
      fields: item.fields,
      name: item.Key_name,
      tableName: item.Table,
      unique: item.Non_unique !== 1,
      type: item.Index_type
    }));
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/parserStore.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/parserStore.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


const stores = new Map();

module.exports = dialect => {
  if (!stores.has(dialect)) {
    stores.set(dialect, new Map());
  }

  return {
    clear() {
      stores.get(dialect).clear();
    },
    refresh(dataType) {
      for (const type of dataType.types[dialect]) {
        stores.get(dialect).set(type, dataType.parse);
      }
    },
    get(type) {
      return stores.get(dialect).get(type);
    }
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:pg');
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 5432;
    super(dialect, sequelize);

    const pgLib = this._loadDialectModule('pg');
    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;

    this._clearDynamicOIDs();
    this._clearTypeParser();
    this.refreshTypeParser(dataTypes.postgres);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    const arrayParserBuilder = parser => {
      return value => this.lib.types.arrayParser.create(value, parser).parse();
    };
    const rangeParserBuilder = parser => {
      return value => dataType.parse(value, { parser });
    };

    // Set range parsers
    if (dataType.key.toLowerCase() === 'range') {
      for (const name in this.nameOidMap) {
        const entry = this.nameOidMap[name];
        if (! entry.rangeOid) continue;

        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));
        const arrayRangeParser = arrayParserBuilder(rangeParser);

        this.oidParserMap.set(entry.rangeOid, rangeParser);
        if (! entry.arrayRangeOid) continue;
        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);
      }
      return;
    }

    // Create parsers for normal or enum data types
    const parser = value => dataType.parse(value);
    const arrayParser = arrayParserBuilder(parser);

    // Set enum parsers
    if (dataType.key.toLowerCase() === 'enum') {
      this.enumOids.oids.forEach(oid => {
        this.oidParserMap.set(oid, parser);
      });
      this.enumOids.arrayOids.forEach(arrayOid => {
        this.oidParserMap.set(arrayOid, arrayParser);
      });
      return;
    }

    // Set parsers for normal data types
    dataType.types.postgres.forEach(name => {
      if (! this.nameOidMap[name]) return;
      this.oidParserMap.set(this.nameOidMap[name].oid, parser);

      if (! this.nameOidMap[name].arrayOid) return;
      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);
    });
  }

  _clearTypeParser() {
    this.oidParserMap = new Map();
  }

  getTypeParser(oid, ...args) {
    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);

    return this.lib.types.getTypeParser(oid, ...args);
  }

  async connect(config) {
    config.user = config.username;
    const connectionConfig = _.pick(config, [
      'user', 'password', 'host', 'database', 'port'
    ]);

    connectionConfig.types = {
      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)
    };

    if (config.dialectOptions) {
      _.merge(connectionConfig,
        _.pick(config.dialectOptions, [
        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]
          'application_name',
          // choose the SSL mode with the PGSSLMODE environment variable
          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]
          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]
          'ssl',
          // In addition to the values accepted by the corresponding server,
          // you can use "auto" to determine the right encoding from the
          // current locale in the client (LC_CTYPE environment variable on Unix systems)
          'client_encoding',
          // !! DO NOT SET THIS TO TRUE !!
          // (unless you know what you're doing)
          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]
          'binary',
          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.
          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md
          'keepAlive',
          // Times out queries after a set time in milliseconds. Added in pg v7.3
          'statement_timeout',
          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10
          'idle_in_transaction_session_timeout'
        ]));
    }

    const connection = await new Promise((resolve, reject) => {
      let responded = false;

      const connection = new this.lib.Client(connectionConfig);

      const parameterHandler = message => {
        switch (message.parameterName) {
          case 'server_version':
            if (this.sequelize.options.databaseVersion === 0) {
              const version = semver.coerce(message.parameterValue).version;
              this.sequelize.options.databaseVersion = semver.valid(version)
                ? version
                : this.dialect.defaultVersion;
            }
            break;
          case 'standard_conforming_strings':
            connection['standard_conforming_strings'] = message.parameterValue;
            break;
        }
      };

      const endHandler = () => {
        debug('connection timeout');
        if (!responded) {
          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));
        }
      };

      // If we didn't ever hear from the client.connect() callback the connection timeout
      // node-postgres does not treat this as an error since no active query was ever emitted
      connection.once('end', endHandler);

      if (!this.sequelize.config.native) {
        // Receive various server parameters for further configuration
        connection.connection.on('parameterStatus', parameterHandler);
      }

      connection.connect(err => {
        responded = true;

        if (!this.sequelize.config.native) {
          // remove parameter handler
          connection.connection.removeListener('parameterStatus', parameterHandler);
        }

        if (err) {
          if (err.code) {
            switch (err.code) {
              case 'ECONNREFUSED':
                reject(new sequelizeErrors.ConnectionRefusedError(err));
                break;
              case 'ENOTFOUND':
                reject(new sequelizeErrors.HostNotFoundError(err));
                break;
              case 'EHOSTUNREACH':
                reject(new sequelizeErrors.HostNotReachableError(err));
                break;
              case 'EINVAL':
                reject(new sequelizeErrors.InvalidConnectionError(err));
                break;
              default:
                reject(new sequelizeErrors.ConnectionError(err));
                break;
            }
          } else {
            reject(new sequelizeErrors.ConnectionError(err));
          }
        } else {
          debug('connection acquired');
          connection.removeListener('end', endHandler);
          resolve(connection);
        }
      });
    });

    let query = '';

    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {
      // Disable escape characters in strings
      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)
      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS
      query += 'SET standard_conforming_strings=on;';
    }

    if (this.sequelize.options.clientMinMessages !== false) {
      query += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`;
    }

    if (!this.sequelize.config.keepDefaultTimezone) {
      const isZone = !!moment.tz.zone(this.sequelize.options.timezone);
      if (isZone) {
        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;
      } else {
        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;
      }
    }

    if (query) {
      await connection.query(query);
    }
    if (Object.keys(this.nameOidMap).length === 0 &&
      this.enumOids.oids.length === 0 &&
      this.enumOids.arrayOids.length === 0) {
      await this._refreshDynamicOIDs(connection);
    }
    // Don't let a Postgres restart (or error) to take down the whole app
    connection.on('error', error => {
      connection._invalid = true;
      debug(`connection error ${error.code || error.message}`);
      this.pool.destroy(connection);
    });

    return connection;
  }

  async disconnect(connection) {
    if (connection._ending) {
      debug('connection tried to disconnect but was already at ENDING state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return !connection._invalid && !connection._ending;
  }

  async _refreshDynamicOIDs(connection) {
    const databaseVersion = this.sequelize.options.databaseVersion;
    const supportedVersion = '8.3.0';

    // Check for supported version
    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {
      return;
    }

    const results = await (connection || this.sequelize).query(
      'WITH ranges AS (' +
      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +
      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +
      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +
      ')' +
      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +
      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +
      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +
      ' WHERE (pg_type.typtype IN(\'b\', \'e\'));'
    );

    let result = Array.isArray(results) ? results.pop() : results;

    // When searchPath is prepended then two statements are executed and the result is
    // an array of those two statements. First one is the SET search_path and second is
    // the SELECT query result.
    if (Array.isArray(result)) {
      if (result[0].command === 'SET') {
        result = result.pop();
      }
    }

    const newNameOidMap = {};
    const newEnumOids = { oids: [], arrayOids: [] };

    for (const row of result.rows) {
      // Mapping enums, handled separatedly
      if (row.typtype === 'e') {
        newEnumOids.oids.push(row.oid);
        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);
        continue;
      }

      // Mapping base types and their arrays
      newNameOidMap[row.typname] = { oid: row.oid };
      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;

      // Mapping ranges(of base types) and their arrays
      if (row.rngtypid) {
        newNameOidMap[row.typname].rangeOid = row.rngtypid;
        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;
      }
    }

    // Replace all OID mappings. Avoids temporary empty OID mappings.
    this.nameOidMap = newNameOidMap;
    this.enumOids = newEnumOids;

    this.refreshTypeParser(dataTypes.postgres);
  }

  _clearDynamicOIDs() {
    this.nameOidMap = {};
    this.enumOids = { oids: [], arrayOids: [] };
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');

  /**
   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types:
   * {
   *   oids: [oid],
   *   array_oids: [oid]
   * }
   *
   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go
   */

  BaseTypes.UUID.types.postgres = ['uuid'];
  BaseTypes.CIDR.types.postgres = ['cidr'];
  BaseTypes.INET.types.postgres = ['inet'];
  BaseTypes.MACADDR.types.postgres = ['macaddr'];
  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];
  BaseTypes.JSON.types.postgres = ['json'];
  BaseTypes.JSONB.types.postgres = ['jsonb'];
  BaseTypes.TIME.types.postgres = ['time'];

  class DATEONLY extends BaseTypes.DATEONLY {
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return super._sanitize(value);
      }
      return value;
    }
    static parse(value) {
      if (value === 'infinity') {
        return Infinity;
      }
      if (value === '-infinity') {
        return -Infinity;
      }
      return value;
    }
  }

  BaseTypes.DATEONLY.types.postgres = ['date'];

  class DECIMAL extends BaseTypes.DECIMAL {
    static parse(value) {
      return value;
    }
  }

  // numeric
  BaseTypes.DECIMAL.types.postgres = ['numeric'];

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.STRING.types.postgres = ['varchar'];

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  BaseTypes.TEXT.types.postgres = ['text'];

  class CITEXT extends BaseTypes.CITEXT {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.CITEXT.types.postgres = ['citext'];

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BOOLEAN';
    }
    _sanitize(value) {
      if (value !== null && value !== undefined) {
        if (Buffer.isBuffer(value) && value.length === 1) {
          // Bit fields are returned as buffers
          value = value[0];
        }
        if (typeof value === 'string') {
          // Only take action on valid boolean strings.
          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;
        }
        if (typeof value === 'number') {
          // Only take action on valid boolean integers.
          return value === 1 ? true : value === 0 ? false : value;
        }
      }
      return value;
    }
  }

  BOOLEAN.parse = BOOLEAN.prototype._sanitize;

  BaseTypes.BOOLEAN.types.postgres = ['bool'];

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'TIMESTAMP WITH TIME ZONE';
    }
    validate(value) {
      if (value !== Infinity && value !== -Infinity) {
        return super.validate(value);
      }
      return true;
    }
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return new Date(value);
      }
      return value;
    }
  }

  BaseTypes.DATE.types.postgres = ['timestamptz'];

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.TINYINT.types.postgres = ['int2'];

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.SMALLINT.types.postgres = ['int2'];

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  INTEGER.parse = function parse(value) {
    return parseInt(value, 10);
  };

  // int4
  BaseTypes.INTEGER.types.postgres = ['int4'];

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int8
  BaseTypes.BIGINT.types.postgres = ['int8'];

  class REAL extends BaseTypes.REAL {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float4
  BaseTypes.REAL.types.postgres = ['float4'];

  class DOUBLE extends BaseTypes.DOUBLE {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float8
  BaseTypes.DOUBLE.types.postgres = ['float8'];

  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // POSTGRES does only support lengths as parameter.
      // Values between 1-24 result in REAL
      // Values between 25-53 result in DOUBLE PRECISION
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._decimals = undefined;
      }
      if (this._unsigned) {
        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  delete FLOAT.parse; // Float has no separate type in PG

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');
        this._length = undefined;
      }
      return 'BYTEA';
    }
    _hexify(hex) {
      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html
      return `E'\\\\x${hex}'`;
    }
  }

  BaseTypes.BLOB.types.postgres = ['bytea'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    toSql() {
      let result = this.key;
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    _bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOMETRY.types.postgres = ['geometry'];


  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {
    toSql() {
      let result = 'GEOGRAPHY';
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];

  let hstore;

  class HSTORE extends BaseTypes.HSTORE {
    constructor() {
      super();
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
    }
    _value(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.stringify(value);
    }
    _stringify(value) {
      return `'${this._value(value)}'`;
    }
    _bindParam(value, options) {
      return options.bindParam(this._value(value));
    }
    static parse(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.parse(value);
    }
  }

  HSTORE.prototype.escape = false;

  BaseTypes.HSTORE.types.postgres = ['hstore'];

  class RANGE extends BaseTypes.RANGE {
    _value(values, options) {
      if (!Array.isArray(values)) {
        return this.options.subtype.stringify(values, options);
      }
      const valueInclusivity = [true, false];
      const valuesStringified = values.map((value, index) => {
        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {
          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {
            valueInclusivity[index] = value.inclusive;
          }
          value = value.value;
        }
        if (value === null || value === -Infinity || value === Infinity) {
          // Pass through "unbounded" bounds unchanged
          return value;
        }
        if (this.options.subtype.stringify) {
          return this.options.subtype.stringify(value, options);
        }
        return options.escape(value);
      });
      // Array.map does not preserve extra array properties
      valuesStringified.inclusive = valueInclusivity;
      return range.stringify(valuesStringified);
    }
    _stringify(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `'${value}'::${this.toCastType()}`;
      }
      return `'${value}'`;
    }
    _bindParam(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `${options.bindParam(value)}::${this.toCastType()}`;
      }
      return options.bindParam(value);
    }
    toSql() {
      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];
    }
    toCastType() {
      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];
    }
    static parse(value, options = { parser: val => val }) {
      return range.parse(value, options.parser);
    }
  }
  const range = __webpack_require__(/*! ./range */ "./node_modules/sequelize/lib/dialects/postgres/range.js");

  RANGE.prototype.escape = false;

  BaseTypes.RANGE.types.postgres = {
    subtypes: {
      integer: 'int4range',
      decimal: 'numrange',
      date: 'tstzrange',
      dateonly: 'daterange',
      bigint: 'int8range'
    },
    castTypes: {
      integer: 'int4',
      decimal: 'numeric',
      date: 'timestamptz',
      dateonly: 'date',
      bigint: 'int8'
    }
  };

  // TODO: Why are base types being manipulated??
  BaseTypes.ARRAY.prototype.escape = false;
  BaseTypes.ARRAY.prototype._value = function _value(values, options) {
    return values.map(value => {
      if (options && options.bindParam && this.type && this.type._value) {
        return this.type._value(value, options);
      }
      if (this.type && this.type.stringify) {
        value = this.type.stringify(value, options);

        if (this.type.escape === false) {
          return value;
        }
      }
      return options.escape(value);
    }, this);
  };
  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {
    let str = `ARRAY[${this._value(values, options).join(',')}]`;

    if (this.type) {
      const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
      let castKey = this.toSql();

      if (this.type instanceof BaseTypes.ENUM) {
        castKey = `${Utils.addTicks(
          Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName),
          '"'
        ) }[]`;
      }

      str += `::${castKey}`;
    }

    return str;
  };
  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {
    return options.bindParam(this._value(values, options));
  };

  class ENUM extends BaseTypes.ENUM {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.ENUM.types.postgres = [null];

  return {
    DECIMAL,
    BLOB,
    STRING,
    CHAR,
    TEXT,
    CITEXT,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    BOOLEAN,
    DATE,
    DATEONLY,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    FLOAT,
    GEOMETRY,
    GEOGRAPHY,
    HSTORE,
    RANGE,
    ENUM
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const hstore = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'pg-hstore'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))({ sanitize: true });

function stringify(data) {
  if (data === null) return null;
  return hstore.stringify(data);
}
exports.stringify = stringify;

function parse(value) {
  if (value === null) return null;
  return hstore.parse(value);
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/postgres/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").postgres;
const { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js");

class PostgresDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);
  }
}

PostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT VALUES': true,
  'EXCEPTION': true,
  'ON DUPLICATE KEY': false,
  'ORDER NULLS': true,
  returnValues: {
    returning: true
  },
  bulkDefault: true,
  schemas: true,
  lock: true,
  lockOf: true,
  lockKey: true,
  lockOuterJoinFailure: true,
  skipLocked: true,
  forShare: 'FOR SHARE',
  index: {
    concurrently: true,
    using: 2,
    where: true,
    functionBased: true,
    operator: true
  },
  inserts: {
    onConflictDoNothing: ' ON CONFLICT DO NOTHING',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  NUMERIC: true,
  ARRAY: true,
  RANGE: true,
  GEOMETRY: true,
  REGEXP: true,
  GEOGRAPHY: true,
  JSON: true,
  JSONB: true,
  HSTORE: true,
  TSVECTOR: true,
  deferrableConstraints: true,
  searchPath: true
});

PostgresDialect.prototype.defaultVersion = '9.5.0';
PostgresDialect.prototype.Query = Query;
PostgresDialect.prototype.DataTypes = DataTypes;
PostgresDialect.prototype.name = 'postgres';
PostgresDialect.prototype.TICK_CHAR = '"';
PostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;
PostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;

module.exports = PostgresDialect;
module.exports.default = PostgresDialect;
module.exports.PostgresDialect = PostgresDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const util = __webpack_require__(/*! util */ "util");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class PostgresQueryGenerator extends AbstractQueryGenerator {
  setSearchPath(searchPath) {
    return `SET search_path to ${searchPath};`;
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      encoding: null,
      collate: null,
      ...options
    };

    const values = {
      database: this.quoteTable(databaseName),
      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',
      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',
      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',
      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''
    };

    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
  }

  createSchema(schema) {
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);

    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {
      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;
    }

    return `CREATE SCHEMA ${schema};`;
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;
  }

  showSchemasQuery() {
    return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
  }

  versionQuery() {
    return 'SHOW SERVER_VERSION';
  }

  createTableQuery(tableName, attributes, options) {
    options = { ...options };

    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);
    const attrStr = [];
    let comments = '';
    let columnComments = '';

    const quotedTable = this.quoteTable(tableName);

    if (options.comment && typeof options.comment === 'string') {
      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
    }

    for (const attr in attributes) {
      const quotedAttr = this.quoteIdentifier(attr);
      const i = attributes[attr].indexOf('COMMENT ');
      if (i !== -1) {
        // Move comment to a separate query
        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
        attributes[attr] = attributes[attr].substring(0, i);
      }

      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
      attrStr.push(`${quotedAttr} ${dataType}`);
    }


    let attributesClause = attrStr.join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    const pks = _.reduce(attributes, (acc, attribute, key) => {
      if (attribute.includes('PRIMARY KEY')) {
        acc.push(this.quoteIdentifier(key));
      }
      return acc;
    }, []).join(',');

    if (pks.length > 0) {
      attributesClause += `, PRIMARY KEY (${pks})`;
    }

    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;
  }

  dropTableQuery(tableName, options) {
    options = options || {};
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;
  }

  showTablesQuery() {
    return "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';";
  }

  describeTableQuery(tableName, schema) {
    if (!schema) schema = 'public';

    return 'SELECT ' +
      'pk.constraint_type as "Constraint",' +
      'c.column_name as "Field", ' +
      'c.column_default as "Default",' +
      'c.is_nullable as "Null", ' +
      '(CASE WHEN c.udt_name = \'hstore\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \'(\' || c.character_maximum_length || \')\' ELSE \'\' END) as "Type", ' +
      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", ' +
      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" ' +
      'FROM information_schema.columns c ' +
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +
      'cu.column_name, tc.constraint_type ' +
      'FROM information_schema.TABLE_CONSTRAINTS tc ' +
      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +
      'and tc.constraint_name=cu.constraint_name ' +
      'and tc.constraint_type=\'PRIMARY KEY\') pk ' +
      'ON pk.table_schema=c.table_schema ' +
      'AND pk.table_name=c.table_name ' +
      'AND pk.column_name=c.column_name ' +
      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://www.postgresql.org/docs/current/static/functions-json.html
    const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
    const jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = jsonOperatorRegex.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the postgres json syntax
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    }
    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, attribute) {
    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });
    const dataType = attribute.type || attribute;
    const definition = this.dataTypeMapping(table, key, dbDataType);
    const quotedKey = this.quoteIdentifier(key);
    const quotedTable = this.quoteTable(this.extractTableDetails(table));

    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;

    if (dataType instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType) + query;
    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType.type) + query;
    }

    return query;
  }

  removeColumnQuery(tableName, attributeName) {
    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
    const quotedAttributeName = this.quoteIdentifier(attributeName);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
  }

  changeColumnQuery(tableName, attributes) {
    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
    const sql = [];
    for (const attributeName in attributes) {
      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
      let attrSql = '';

      if (definition.includes('NOT NULL')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);

        definition = definition.replace('NOT NULL', '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
      }

      if (definition.includes('DEFAULT')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);

        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
      }

      if (attributes[attributeName].startsWith('ENUM(')) {
        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
        definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, { schema: false }));
        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
      }

      if (definition.match(/UNIQUE;*$/)) {
        definition = definition.replace(/UNIQUE;*$/, '');
        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');
      }

      if (definition.includes('REFERENCES')) {
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');
      } else {
        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
      }

      sql.push(attrSql);
    }

    return sql.join('');
  }

  renameColumnQuery(tableName, attrBefore, attributes) {

    const attrString = [];

    for (const attributeName in attributes) {
      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
    }

    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;
  }

  fn(fnName, tableName, parameters, body, returns, language) {
    fnName = fnName || 'testfunc';
    language = language || 'plpgsql';
    returns = returns ? `RETURNS ${returns}` : '';
    parameters = parameters || '';

    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `TRUNCATE ${this.quoteTable(tableName)}`,
      options.restartIdentity ? ' RESTART IDENTITY' : '',
      options.cascade ? ' CASCADE' : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    let whereClause = this.getWhereConditions(where, null, model, options);
    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';
    let primaryKeys = '';
    let primaryKeysSelection = '';

    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }

    if (options.limit) {
      if (!model) {
        throw new Error('Cannot LIMIT delete without a model.');
      }

      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');

      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
      primaryKeysSelection = pks;

      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
    }
    return `DELETE FROM ${table}${whereClause}`;
  }

  showIndexesQuery(tableName) {
    let schemaJoin = '';
    let schemaWhere = '';
    if (typeof tableName !== 'string') {
      schemaJoin = ', pg_namespace s';
      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;
      tableName = tableName.tableName;
    }

    // This is ARCANE!
    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +
      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +
      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +
      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +
      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +
      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';
  }

  showConstraintsQuery(tableName) {
    //Postgres converts camelCased alias to lowercase unless quoted
    return [
      'SELECT constraint_catalog AS "constraintCatalog",',
      'constraint_schema AS "constraintSchema",',
      'constraint_name AS "constraintName",',
      'table_catalog AS "tableCatalog",',
      'table_schema AS "tableSchema",',
      'table_name AS "tableName",',
      'constraint_type AS "constraintType",',
      'is_deferrable AS "isDeferrable",',
      'initially_deferred AS "initiallyDeferred"',
      'from INFORMATION_SCHEMA.table_constraints',
      `WHERE table_name='${tableName}';`
    ].join(' ');
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;
  }

  addLimitAndOffset(options) {
    let fragment = '';
    /* eslint-disable */
    if (options.limit != null) {
      fragment += ' LIMIT ' + this.escape(options.limit);
    }
    if (options.offset != null) {
      fragment += ' OFFSET ' + this.escape(options.offset);
    }
    /* eslint-enable */

    return fragment;
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    let type;
    if (
      attribute.type instanceof DataTypes.ENUM ||
      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM
    ) {
      const enumType = attribute.type.type || attribute.type;
      let values = attribute.values;

      if (enumType.values && !attribute.values) {
        values = enumType.values;
      }

      if (Array.isArray(values) && values.length > 0) {
        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;

        if (attribute.type instanceof DataTypes.ARRAY) {
          type += '[]';
        }

      } else {
        throw new Error("Values for ENUM haven't been defined.");
      }
    }

    if (!type) {
      type = attribute.type;
    }

    let sql = type.toString();

    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {
      sql += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      if (attribute.autoIncrementIdentity) {
        sql += ' GENERATED BY DEFAULT AS IDENTITY';
      } else {
        sql += ' SERIAL';
      }
    }

    if (Utils.defaultValueSchemable(attribute.defaultValue)) {
      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
    }

    if (attribute.unique === true) {
      sql += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      sql += ' PRIMARY KEY';
    }

    if (attribute.references) {
      let referencesTable = this.quoteTable(attribute.references.model);
      let schema;

      if (options.schema) {
        schema = options.schema;
      } else if (
        (!attribute.references.model || typeof attribute.references.model == 'string')
        && options.table
        && options.table.schema
      ) {
        schema = options.table.schema;
      }

      if (schema) {
        referencesTable = this.quoteTable(this.addSchema({
          tableName: referencesTable,
          _schema: schema
        }));
      }

      let referencesKey;

      if (attribute.references.key) {
        referencesKey = this.quoteIdentifiers(attribute.references.key);
      } else {
        referencesKey = this.quoteIdentifier('id');
      }

      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

      if (attribute.onDelete) {
        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }

      if (attribute.references.deferrable) {
        sql += ` ${attribute.references.deferrable.toString(this)}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {
        const quotedAttr = this.quoteIdentifier(options.key);
        const escapedCommentText = this.escape(attribute.comment);
        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
      } else {
        // for createTable event which does it's own parsing
        // TODO: centralize creation of comment statements here
        sql += ` COMMENT ${attribute.comment}`;
      }
    }

    return sql;
  }

  deferConstraintsQuery(options) {
    return options.deferrable.toString(this);
  }

  setConstraintQuery(columns, type) {
    let columnFragment = 'ALL';

    if (columns) {
      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');
    }

    return `SET CONSTRAINTS ${columnFragment} ${type}`;
  }

  setDeferredQuery(columns) {
    return this.setConstraintQuery(columns, 'DEFERRED');
  }

  setImmediateQuery(columns) {
    return this.setConstraintQuery(columns, 'IMMEDIATE');
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });
    }

    return result;
  }

  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
    const decodedEventType = this.decodeTriggerEventType(eventType);
    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);
    const expandedOptions = this.expandOptions(optionsArray);
    const paramList = this._expandFunctionParamList(functionParams);

    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${
      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;
  }

  dropTrigger(tableName, triggerName) {
    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;
  }

  renameTrigger(tableName, oldTriggerName, newTriggerName) {
    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;
  }

  createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');

    const paramList = this._expandFunctionParamList(params);
    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';
    const expandedOptionsArray = this.expandOptions(optionsArray);

    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';

    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;
  }

  dropFunction(functionName, params) {
    if (!functionName) throw new Error('requires functionName');
    // RESTRICT is (currently, as of 9.2) default but we'll be explicit
    const paramList = this._expandFunctionParamList(params);
    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;
  }

  renameFunction(oldFunctionName, params, newFunctionName) {
    const paramList = this._expandFunctionParamList(params);
    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;
  }

  pgEscapeAndQuote(val) {
    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), "'"));
  }

  _expandFunctionParamList(params) {
    if (params === undefined || !Array.isArray(params)) {
      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');
    }

    const paramList = [];
    params.forEach(curParam => {
      const paramDef = [];
      if (curParam.type) {
        if (curParam.direction) { paramDef.push(curParam.direction); }
        if (curParam.name) { paramDef.push(curParam.name); }
        paramDef.push(curParam.type);
      } else {
        throw new Error('function or trigger used with a parameter without any type');
      }

      const joined = paramDef.join(' ');
      if (joined) paramList.push(joined);

    });

    return paramList.join(', ');
  }

  _expandFunctionVariableList(variables) {
    if (!Array.isArray(variables)) {
      throw new Error('_expandFunctionVariableList: function variables must be an array');
    }
    const variableDefinitions = [];
    variables.forEach(variable => {
      if (!variable.name || !variable.type) {
        throw new Error('function variable must have a name and type');
      }
      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;
      if (variable.default) {
        variableDefinition += ` := ${variable.default}`;
      }
      variableDefinition += ';';
      variableDefinitions.push(variableDefinition);
    });
    return variableDefinitions.join(' ');
  }

  expandOptions(options) {
    return options === undefined || _.isEmpty(options) ?
      '' : options.join(' ');
  }

  decodeTriggerEventType(eventSpecifier) {
    const EVENT_DECODER = {
      'after': 'AFTER',
      'before': 'BEFORE',
      'instead_of': 'INSTEAD OF',
      'after_constraint': 'AFTER'
    };

    if (!EVENT_DECODER[eventSpecifier]) {
      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);
    }

    return EVENT_DECODER[eventSpecifier];
  }

  triggerEventTypeIsConstraint(eventSpecifier) {
    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';
  }

  expandTriggerEventSpec(fireOnSpec) {
    if (_.isEmpty(fireOnSpec)) {
      throw new Error('no table change events specified to trigger on');
    }

    return _.map(fireOnSpec, (fireValue, fireKey) => {
      const EVENT_MAP = {
        'insert': 'INSERT',
        'update': 'UPDATE',
        'delete': 'DELETE',
        'truncate': 'TRUNCATE'
      };

      if (!EVENT_MAP[fireValue]) {
        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);
      }

      let eventSpec = EVENT_MAP[fireValue];
      if (eventSpec === 'UPDATE') {
        if (Array.isArray(fireValue) && fireValue.length > 0) {
          eventSpec += ` OF ${fireValue.join(', ')}`;
        }
      }

      return eventSpec;
    }).join(' OR ');
  }

  pgEnumName(tableName, attr, options) {
    options = options || {};

    const tableDetails = this.extractTableDetails(tableName, options);
    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '"');

    // pgListEnums requires the enum name only, without the schema
    if (options.schema !== false && tableDetails.schema) {
      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
    }

    return enumName;
  }

  pgListEnums(tableName, attrName, options) {
    let enumName = '';
    const tableDetails = this.extractTableDetails(tableName, options);

    if (tableDetails.tableName && attrName) {
      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/"/g, "'")}`;
    }

    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +
      'JOIN pg_enum e ON t.oid = e.enumtypid ' +
      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +
      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;
  }

  pgEnum(tableName, attr, dataType, options) {
    const enumName = this.pgEnumName(tableName, attr, options);
    let values;

    if (dataType.values) {
      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;
    } else {
      values = dataType.toString().match(/^ENUM\(.+\)/)[0];
    }

    let sql = `CREATE TYPE ${enumName} AS ${values};`;
    if (!!options && options.force === true) {
      sql = this.pgEnumDrop(tableName, attr) + sql;
    }
    return sql;
  }

  pgEnumAdd(tableName, attr, value, options) {
    const enumName = this.pgEnumName(tableName, attr);
    let sql = `ALTER TYPE ${enumName} ADD VALUE `;

    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {
      sql += 'IF NOT EXISTS ';
    }
    sql += this.escape(value);

    if (options.before) {
      sql += ` BEFORE ${this.escape(options.before)}`;
    } else if (options.after) {
      sql += ` AFTER ${this.escape(options.after)}`;
    }

    return sql;
  }

  pgEnumDrop(tableName, attr, enumName) {
    enumName = enumName || this.pgEnumName(tableName, attr);
    return `DROP TYPE IF EXISTS ${enumName}; `;
  }

  fromArray(text) {
    text = text.replace(/^{/, '').replace(/}$/, '');
    let matches = text.match(/("(?:\\.|[^"\\\\])*"|[^,]*)(?:\s*,\s*|\s*$)/ig);

    if (matches.length < 1) {
      return [];
    }

    matches = matches.map(m => m.replace(/",$/, '').replace(/,$/, '').replace(/(^"|"$)/g, ''));

    return matches.slice(0, -1);
  }

  dataTypeMapping(tableName, attr, dataType) {
    if (dataType.includes('PRIMARY KEY')) {
      dataType = dataType.replace('PRIMARY KEY', '');
    }

    if (dataType.includes('SERIAL')) {
      if (dataType.includes('BIGINT')) {
        dataType = dataType.replace('SERIAL', 'BIGSERIAL');
        dataType = dataType.replace('BIGINT', '');
      } else if (dataType.includes('SMALLINT')) {
        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');
        dataType = dataType.replace('SMALLINT', '');
      } else {
        dataType = dataType.replace('INTEGER', '');
      }
      dataType = dataType.replace('NOT NULL', '');
    }

    if (dataType.startsWith('ENUM(')) {
      dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
    }

    return dataType;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +
      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;
  }

  /**
   * Generate common SQL prefix for getForeignKeyReferencesQuery.
   *
   * @returns {string}
   */
  _getForeignKeyReferencesQueryPrefix() {
    return 'SELECT ' +
      'DISTINCT tc.constraint_name as constraint_name, ' +
      'tc.constraint_schema as constraint_schema, ' +
      'tc.constraint_catalog as constraint_catalog, ' +
      'tc.table_name as table_name,' +
      'tc.table_schema as table_schema,' +
      'tc.table_catalog as table_catalog,' +
      'kcu.column_name as column_name,' +
      'ccu.table_schema  AS referenced_table_schema,' +
      'ccu.table_catalog  AS referenced_table_catalog,' +
      'ccu.table_name  AS referenced_table_name,' +
      'ccu.column_name AS referenced_column_name ' +
      'FROM information_schema.table_constraints AS tc ' +
      'JOIN information_schema.key_column_usage AS kcu ' +
      'ON tc.constraint_name = kcu.constraint_name ' +
      'JOIN information_schema.constraint_column_usage AS ccu ' +
      'ON ccu.constraint_name = tc.constraint_name ';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.
   *
   * @param {string} tableName
   * @param {string} catalogName
   * @param {string} schemaName
   */
  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${
      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''
    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;
  }

  getForeignKeyReferenceQuery(table, columnName) {
    const tableName = table.tableName || table;
    const schema = table.schema;
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${
      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;
  }
}

module.exports = PostgresQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * The interface that Sequelize uses to talk with Postgres database
 */
class PostgresQueryInterface extends QueryInterface {
  /**
   * Ensure enum and their values.
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of normalized table attributes
   * @param {object} [options]
   * @param {Model}  [model]
   *
   * @protected
   */
  async ensureEnums(tableName, attributes, options, model) {
    const keys = Object.keys(attributes);
    const keyLen = keys.length;

    let sql = '';
    let promises = [];
    let i = 0;

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
        promises.push(this.sequelize.query(
          sql,
          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }
        ));
      }
    }

    const results = await Promise.all(promises);
    promises = [];
    let enumIdx = 0;

    // This little function allows us to re-use the same code that prepends or appends new value to enum array
    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {
      const valueOptions = { ...options };
      valueOptions.before = null;
      valueOptions.after = null;

      switch (position) {
        case 'after':
          valueOptions.after = relativeValue;
          break;
        case 'before':
        default:
          valueOptions.before = relativeValue;
          break;
      }

      promises.splice(spliceStart, 0, () => {
        return this.sequelize.query(this.queryGenerator.pgEnumAdd(
          tableName, field, value, valueOptions
        ), valueOptions);
      });
    };

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;
      const enumType = type.type || type;
      const field = attribute.field || keys[i];

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        // If the enum type doesn't exist then create it
        if (!results[enumIdx]) {
          promises.push(() => {
            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });
          });
        } else if (!!results[enumIdx] && !!model) {
          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);
          const vals = enumType.values;

          // Going through already existing values allows us to make queries that depend on those values
          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values
          // Then we append the rest of new values AFTER the latest already existing value
          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]
          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]
          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]
          let lastOldEnumValue;
          let rightestPosition = -1;
          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {
            const enumVal = enumVals[oldIndex];
            const newIdx = vals.indexOf(enumVal);
            lastOldEnumValue = enumVal;

            if (newIdx === -1) {
              continue;
            }

            const newValuesBefore = vals.slice(0, newIdx);
            const promisesLength = promises.length;
            // we go in reverse order so we could stop when we meet old value
            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {
              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {
                break;
              }

              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);
            }

            // we detect the most 'right' position of old value in new enum array so we can append new values to it
            if (newIdx > rightestPosition) {
              rightestPosition = newIdx;
            }
          }

          if (lastOldEnumValue && rightestPosition < vals.length - 1) {
            const remainingEnumValues = vals.slice(rightestPosition + 1);
            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {
              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');
            }
          }

          enumIdx++;
        }
      }
    }

    const result = await promises
      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());

    // If ENUM processed, then refresh OIDs
    if (promises.length) {
      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();
    }
    return result;
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };

    // postgres needs some special treatment as those field names returned are all lowercase
    // in order to keep same result with other dialects.
    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);
    const result = await this.sequelize.query(query, queryOptions);
    return result.map(Utils.camelizeObjectKeys);
  }

  /**
   * Drop specified enum from database (Postgres only)
   *
   * @param {string} [enumName]  Enum name to drop
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropEnum(enumName, options) {
    options = options || {};

    return this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),
      { ...options, raw: true }
    );
  }

  /**
   * Drop all enums from database (Postgres only)
   *
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropAllEnums(options) {
    options = options || {};

    const enums = await this.pgListEnums(null, options);

    return await Promise.all(enums.map(result => this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),
      { ...options, raw: true }
    )));
  }

  /**
   * List all enums (Postgres only)
   *
   * @param {string} [tableName]  Table whose enum to list
   * @param {object} [options]    Query options
   *
   * @returns {Promise}
   */
  async pgListEnums(tableName, options) {
    options = options || {};
    const sql = this.queryGenerator.pgListEnums(tableName);
    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });
  }

  /**
   * Since postgres has a special case for enums, we should drop the related
   * enum type within the table and attribute
   *
   * @override
   */
  async dropTable(tableName, options) {
    await super.dropTable(tableName, options);
    const promises = [];
    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });

    if (!instanceTable) {
      // Do nothing when model is not available
      return;
    }

    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;

    const keys = Object.keys(instanceTable.rawAttributes);
    const keyLen = keys.length;

    for (let i = 0; i < keyLen; i++) {
      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {
        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);
        options.supportsSearchPath = false;
        promises.push(this.sequelize.query(sql, { ...options, raw: true }));
      }
    }

    await Promise.all(promises);
  }
}

exports.PostgresQueryInterface = PostgresQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:pg');


class Query extends AbstractQuery {
  /**
   * Rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    const stringReplaceFunc = value => typeof value === 'string' ? value.replace(/\0/g, '\\0') : value;

    let bindParam;
    if (Array.isArray(values)) {
      bindParam = values.map(stringReplaceFunc);
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = [];
      let i = 0;
      const seen = {};
      const replacementFunc = (match, key, values) => {
        if (seen[key] !== undefined) {
          return seen[key];
        }
        if (values[key] !== undefined) {
          i = i + 1;
          bindParam.push(stringReplaceFunc(values[key]));
          seen[key] = `$${i}`;
          return `$${i}`;
        }
        return undefined;
      };
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    }
    return [sql, bindParam];
  }

  async run(sql, parameters) {
    const { connection } = this;

    if (!_.isEmpty(this.options.searchPath)) {
      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;
    }

    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {
      _.toPairs(this.options.includeAliases)
        // Sorting to replace the longest aliases first to prevent alias collision
        .sort((a, b) => b[1].length - a[1].length)
        .forEach(([alias, original]) => {
          const reg = new RegExp(_.escapeRegExp(original), 'g');

          sql = sql.replace(reg, alias);
        });
    }

    this.sql = sql;

    const query = parameters && parameters.length
      ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result)))
      : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));

    const complete = this._logQuery(sql, debug, parameters);

    let queryResult;

    try {
      queryResult = await query;
    } catch (err) {
      // set the client so that it will be reaped if the connection resets while executing
      if (err.code === 'ECONNRESET') {
        connection._invalid = true;
      }

      err.sql = sql;
      err.parameters = parameters;
      throw this.formatError(err);
    }

    complete();

    let rows = Array.isArray(queryResult)
      ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), [])
      : queryResult.rows;
    const rowCount = Array.isArray(queryResult)
      ? queryResult.reduce(
        (count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count,
        0
      )
      : queryResult.rowCount || 0;

    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {
      rows = rows
        .map(row => _.toPairs(row)
          .reduce((acc, [key, value]) => {
            const mapping = this.options.aliasesMapping.get(key);
            acc[mapping || key] = value;
            return acc;
          }, {})
        );
    }

    const isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');
    const isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');

    if (isRelNameQuery) {
      return rows.map(row => ({
        name: row.relname,
        tableName: row.relname.split('_')[0]
      }));
    }
    if (isTableNameQuery) {
      return rows.map(row => Object.values(row));
    }

    if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {
      if (rows[0].sequelize_caught_exception !== null) {
        throw this.formatError({
          sql,
          parameters,
          code: '23505',
          detail: rows[0].sequelize_caught_exception
        });
      }
      for (const row of rows) {
        delete row.sequelize_caught_exception;
      }
    }

    if (this.isShowIndexesQuery()) {
      for (const row of rows) {
        const attributes = /ON .*? (?:USING .*?\s)?\(([^]*)\)/gi.exec(row.definition)[1].split(',');

        // Map column index in table to column name
        const columns = _.zipObject(
          row.column_indexes,
          this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names)
        );
        delete row.column_indexes;
        delete row.column_names;

        let field;
        let attribute;

        // Indkey is the order of attributes in the index, specified by a string of attribute indexes
        row.fields = row.indkey.split(' ').map((indKey, index) => {
          field = columns[indKey];
          // for functional indices indKey = 0
          if (!field) {
            return null;
          }
          attribute = attributes[index];
          return {
            attribute: field,
            collate: attribute.match(/COLLATE "(.*?)"/) ? /COLLATE "(.*?)"/.exec(attribute)[1] : undefined,
            order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,
            length: undefined
          };
        }).filter(n => n !== null);
        delete row.columns;
      }
      return rows;
    }
    if (this.isForeignKeysQuery()) {
      const result = [];
      for (const row of rows) {
        let defParts;
        if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \((.+)\) REFERENCES (.+)\((.+)\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {
          row.id = row.constraint_name;
          row.table = defParts[2];
          row.from = defParts[1];
          row.to = defParts[3];
          let i;
          for (i = 5; i <= 8; i += 3) {
            if (/(UPDATE|DELETE)/.test(defParts[i])) {
              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];
            }
          }
        }
        result.push(row);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      let result = rows;
      // Postgres will treat tables as case-insensitive, so fix the case
      // of the returned values to match attributes
      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {
          m[k.toLowerCase()] = k;
          return m;
        }, {});
        result = rows.map(row => {
          return _.mapKeys(row, (value, key) => {
            const targetAttr = attrsMap[key];
            if (typeof targetAttr === 'string' && targetAttr !== key) {
              return targetAttr;
            }
            return key;
          });
        });
      }
      return this.handleSelectQuery(result);
    }
    if (QueryTypes.DESCRIBE === this.options.type) {
      const result = {};

      for (const row of rows) {
        result[row.Field] = {
          type: row.Type.toUpperCase(),
          allowNull: row.Null === 'YES',
          defaultValue: row.Default,
          comment: row.Comment,
          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],
          primaryKey: row.Constraint === 'PRIMARY KEY'
        };

        if (result[row.Field].type === 'BOOLEAN') {
          result[row.Field].defaultValue = { 'false': false, 'true': true }[result[row.Field].defaultValue];

          if (result[row.Field].defaultValue === undefined) {
            result[row.Field].defaultValue = null;
          }
        }

        if (typeof result[row.Field].defaultValue === 'string') {
          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');

          if (result[row.Field].defaultValue.includes('::')) {
            const split = result[row.Field].defaultValue.split('::');
            if (split[1].toLowerCase() !== 'regclass)') {
              result[row.Field].defaultValue = split[0];
            }
          }
        }
      }

      return result;
    }
    if (this.isVersionQuery()) {
      return rows[0].server_version;
    }
    if (this.isShowOrDescribeQuery()) {
      return rows;
    }
    if (QueryTypes.BULKUPDATE === this.options.type) {
      if (!this.options.returning) {
        return parseInt(rowCount, 10);
      }
      return this.handleSelectQuery(rows);
    }
    if (QueryTypes.BULKDELETE === this.options.type) {
      return parseInt(rowCount, 10);
    }
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        for (const key in rows[0]) {
          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {
            const record = rows[0][key];

            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }

      if (this.isUpsertQuery()) {
        return [
          this.instance,
          null
        ];
      }

      return [
        this.instance || rows && (this.options.plain && rows[0] || rows) || undefined,
        rowCount
      ];
    }
    if (this.isRawQuery()) {
      return [rows, queryResult];
    }
    return rows;
  }

  formatError(err) {
    let match;
    let table;
    let index;
    let fields;
    let errors;
    let message;

    const code = err.code || err.sqlState;
    const errMessage = err.message || err.messagePrimary;
    const errDetail = err.detail || err.messageDetail;

    switch (code) {
      case '23503':
        index = errMessage.match(/violates foreign key constraint "(.+?)"/);
        index = index ? index[1] : undefined;
        table = errMessage.match(/on table "(.+?)"/);
        table = table ? table[1] : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({ message: errMessage, fields: null, index, table, parent: err });
      case '23505':
        // there are multiple different formats of error messages for this error code
        // this regex should check at least two
        if (errDetail && (match = errDetail.replace(/"/g, '').match(/Key \((.*?)\)=\((.*?)\)/))) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
          errors = [];
          message = 'Validation error';

          _.forOwn(fields, (value, field) => {
            errors.push(new sequelizeErrors.ValidationErrorItem(
              this.getUniqueConstraintErrorMessage(field),
              'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
              field,
              value,
              this.instance,
              'not_unique'
            ));
          });

          if (this.model && this.model.uniqueKeys) {
            _.forOwn(this.model.uniqueKeys, constraint => {
              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {
                message = constraint.msg;
                return false;
              }
            });
          }

          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
        }

        return new sequelizeErrors.UniqueConstraintError({
          message: errMessage,
          parent: err
        });

      case '23P01':
        match = errDetail.match(/Key \((.*?)\)=\((.*?)\)/);

        if (match) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
        }
        message = 'Exclusion constraint error';

        return new sequelizeErrors.ExclusionConstraintError({
          message,
          constraint: err.constraint,
          fields,
          table: err.table,
          parent: err
        });

      case '42704':
        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {
          message = 'Unknown constraint error';
          index = errMessage.match(/(?:constraint|index) "(.+?)"/i);
          index = index ? index[1] : undefined;
          table = errMessage.match(/relation "(.+?)"/i);
          table = table ? table[1] : undefined;

          throw new sequelizeErrors.UnknownConstraintError({
            message,
            constraint: index,
            fields,
            table,
            parent: err
          });
        }
      // falls through
      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  isForeignKeysQuery() {
    return /SELECT conname as constraint_name, pg_catalog\.pg_get_constraintdef\(r\.oid, true\) as condef FROM pg_catalog\.pg_constraint r WHERE r\.conrelid = \(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\) AND r\.contype = 'f' ORDER BY 1;/.test(this.sql);
  }

  getInsertIdField() {
    return 'id';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/range.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

function stringifyRangeBound(bound) {
  if (bound === null) {
    return '' ;
  }
  if (bound === Infinity || bound === -Infinity) {
    return bound.toString().toLowerCase();
  }
  return JSON.stringify(bound);
}

function parseRangeBound(bound, parseType) {
  if (!bound) {
    return null;
  }
  if (bound === 'infinity') {
    return Infinity;
  }
  if (bound === '-infinity') {
    return -Infinity;
  }
  return parseType(bound);

}

function stringify(data) {
  if (data === null) return null;

  if (!Array.isArray(data)) throw new Error('range must be an array');
  if (!data.length) return 'empty';
  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');

  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {
    if (data.inclusive === false) data.inclusive = [false, false];
    else if (!data.inclusive) data.inclusive = [true, false];
    else if (data.inclusive === true) data.inclusive = [true, true];
  } else {
    data.inclusive = [true, false];
  }

  _.each(data, (value, index) => {
    if (_.isObject(value)) {
      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;
      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;
    }
  });

  const lowerBound = stringifyRangeBound(data[0]);
  const upperBound = stringifyRangeBound(data[1]);

  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;
}
exports.stringify = stringify;

function parse(value, parser) {
  if (value === null) return null;
  if (value === 'empty') {
    return [];
  }

  let result = value
    .substring(1, value.length - 1)
    .split(',', 2);

  if (result.length !== 2) return value;

  result = result.map((item, index) => {
    return {
      value: parseRangeBound(item, parser),
      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'
    };
  });

  return result;
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:sqlite');
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    super(dialect, sequelize);

    // We attempt to parse file location from a connection uri
    // but we shouldn't match sequelize default host.
    if (this.sequelize.options.host === 'localhost') {
      delete this.sequelize.options.host;
    }

    this.connections = {};
    this.lib = this._loadDialectModule('sqlite3');
    this.refreshTypeParser(dataTypes);
  }

  async _onProcessExit() {
    await Promise.all(
      Object.getOwnPropertyNames(this.connections)
        .map(connection => promisify(callback => this.connections[connection].close(callback))())
    );
    return super._onProcessExit.call(this);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async getConnection(options) {
    options = options || {};
    options.uuid = options.uuid || 'default';
    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';
    options.inMemory = options.storage === ':memory:' ? 1 : 0;

    const dialectOptions = this.sequelize.options.dialectOptions;
    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;

    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;

    if (this.connections[options.inMemory || options.uuid]) {
      return this.connections[options.inMemory || options.uuid];
    }

    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {
      // automatic path provision for `options.storage`
      fs.mkdirSync(path.dirname(options.storage), { recursive: true });
    }

    const connection = await new Promise((resolve, reject) => {
      this.connections[options.inMemory || options.uuid] = new this.lib.Database(
        options.storage,
        options.readWriteMode,
        err => {
          if (err) return reject(new sequelizeErrors.ConnectionError(err));
          debug(`connection acquired ${options.uuid}`);
          resolve(this.connections[options.inMemory || options.uuid]);
        }
      );
    });

    if (this.sequelize.config.password) {
      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher
      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);
    }
    if (this.sequelize.options.foreignKeys !== false) {
      // Make it possible to define and use foreign key constraints unless
      // explicitly disallowed. It's still opt-in per relation
      connection.run('PRAGMA FOREIGN_KEYS=ON');
    }

    return connection;
  }

  releaseConnection(connection, force) {
    if (connection.filename === ':memory:' && force !== true) return;

    if (connection.uuid) {
      connection.close();
      debug(`connection released ${connection.uuid}`);
      delete this.connections[connection.uuid];
    }
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');

  /**
   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._zerofill || dataType._unsigned) {
      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * @see https://sqlite.org/datatype3.html
   */

  BaseTypes.DATE.types.sqlite = ['DATETIME'];
  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];
  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];
  BaseTypes.TEXT.types.sqlite = ['TEXT'];
  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];
  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];
  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];
  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];
  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];
  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];
  BaseTypes.TIME.types.sqlite = ['TIME'];
  BaseTypes.DATEONLY.types.sqlite = ['DATE'];
  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];
  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];
  BaseTypes.UUID.types.sqlite = ['UUID'];
  BaseTypes.ENUM.types.sqlite = false;
  BaseTypes.REAL.types.sqlite = ['REAL'];
  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];
  BaseTypes.GEOMETRY.types.sqlite = false;
  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];

  class JSONTYPE extends BaseTypes.JSON {
    static parse(data) {
      return JSON.parse(data);
    }
  }

  class DATE extends BaseTypes.DATE {
    static parse(date, options) {
      if (!date.includes('+')) {
        // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set
        return new Date(date + options.timezone);
      }
      return new Date(date); // We already have a timezone stored in the string
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(date) {
      return date;
    }
  }

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return `VARCHAR BINARY(${this._length})`;
      }
      return super.toSql(this);
    }
  }

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  class CITEXT extends BaseTypes.CITEXT {
    toSql() {
      return 'TEXT COLLATE NOCASE';
    }
  }

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return `CHAR BINARY(${this._length})`;
      }
      return super.toSql();
    }
  }

  class NUMBER extends BaseTypes.NUMBER {
    toSql() {
      let result = this.key;
      if (this._unsigned) {
        result += ' UNSIGNED';
      }
      if (this._zerofill) {
        result += ' ZEROFILL';
      }
      if (this._length) {
        result += `(${this._length}`;
        if (typeof this._decimals === 'number') {
          result += `,${this._decimals}`;
        }
        result += ')';
      }
      return result;
    }
  }

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class MEDIUMINT extends BaseTypes.MEDIUMINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class FLOAT extends BaseTypes.FLOAT {
  }

  class DOUBLE extends BaseTypes.DOUBLE {
  }

  class REAL extends BaseTypes.REAL { }

  function parseFloating(value) {
    if (typeof value !== 'string') {
      return value;
    }
    if (value === 'NaN') {
      return NaN;
    }
    if (value === 'Infinity') {
      return Infinity;
    }
    if (value === '-Infinity') {
      return -Infinity;
    }
  }
  for (const floating of [FLOAT, DOUBLE, REAL]) {
    floating.parse = parseFloating;
  }


  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {
    num.prototype.toSql = NUMBER.prototype.toSql;
  }

  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'TEXT';
    }
  }

  return {
    DATE,
    DATEONLY,
    STRING,
    CHAR,
    NUMBER,
    FLOAT,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    TINYINT,
    SMALLINT,
    MEDIUMINT,
    INTEGER,
    BIGINT,
    TEXT,
    ENUM,
    JSON: JSONTYPE,
    CITEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/sqlite/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js");

class SqliteDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });

    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);
  }
}

SqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': false,
  'DEFAULT VALUES': true,
  'UNION ALL': false,
  'RIGHT JOIN': false,
  inserts: {
    ignoreDuplicates: ' OR IGNORE',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  index: {
    using: false,
    where: true,
    functionBased: true
  },
  transactionOptions: {
    type: true
  },
  constraints: {
    addConstraint: false,
    dropConstraint: false
  },
  joinTableDependent: false,
  groupedLimit: false,
  JSON: true
});

SqliteDialect.prototype.defaultVersion = '3.8.0';
SqliteDialect.prototype.Query = Query;
SqliteDialect.prototype.DataTypes = DataTypes;
SqliteDialect.prototype.name = 'sqlite';
SqliteDialect.prototype.TICK_CHAR = '`';
SqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;
SqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;

module.exports = SqliteDialect;
module.exports.SqliteDialect = SqliteDialect;
module.exports.default = SqliteDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");

class SQLiteQueryGenerator extends MySqlQueryGenerator {
  createSchema() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  showSchemasQuery() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  versionQuery() {
    return 'SELECT sqlite_version() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = options || {};

    const primaryKeys = [];
    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;
    const attrArray = [];

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        const dataType = attributes[attr];
        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');

        let dataTypeString = dataType;
        if (dataType.includes('PRIMARY KEY')) {
          if (dataType.includes('INT')) {
            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)
            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';

            if (dataType.includes(' REFERENCES')) {
              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));
            }
          }

          if (needsMultiplePrimaryKeys) {
            primaryKeys.push(attr);
            if (dataType.includes('NOT NULL')) {
              dataTypeString = dataType.replace(' PRIMARY KEY', '');
            } else {
              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');
            }
          }
        }
        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attrStr = attrArray.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attrStr += `, PRIMARY KEY (${pkString})`;
    }

    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;
    return this.replaceBooleanDefaults(sql);
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://sqlite.org/json1.html
    const jsonFunctionRegex = /^\s*(json(?:_[a-z]+){0,2})\([^)]*\)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  //sqlite can't cast to datetime so we need to convert date values to their ISO strings
  _toJSONValue(value) {
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (Array.isArray(value) && value[0] instanceof Date) {
      return value.map(val => val.toISOString());
    }
    return value;
  }


  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }

    if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      }
    }

    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, dataType) {
    const attributes = {};
    attributes[key] = dataType;
    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });
    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;

    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;

    return this.replaceBooleanDefaults(sql);
  }

  showTablesQuery() {
    return 'SELECT name FROM `sqlite_master` WHERE type=\'table\' and name!=\'sqlite_sequence\';';
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const modelAttributeMap = {};
    const values = [];
    const bind = [];
    const bindParam = options.bindParam || this.bindParam(bind);

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    let query;
    const whereOptions = { ...options, bindParam };

    if (options.limit) {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;
    } else {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;
    }

    return { query, bind };
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `DELETE FROM ${this.quoteTable(tableName)}`,
      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), "'")};` : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    _.defaults(options, this.options);

    let whereClause = this.getWhereConditions(where, null, model, options);

    if (whereClause) {
      whereClause = `WHERE ${whereClause}`;
    }

    if (options.limit) {
      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;
    }

    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;
  }

  attributesToSQL(attributes) {
    const result = {};
    for (const name in attributes) {
      const dataType = attributes[name];
      const fieldName = dataType.field || name;

      if (_.isObject(dataType)) {
        let sql = dataType.type.toString();

        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {
          sql += ' NOT NULL';
        }

        if (Utils.defaultValueSchemable(dataType.defaultValue)) {
          // TODO thoroughly check that DataTypes.NOW will properly
          // get populated on all databases as DEFAULT value
          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP
          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;
        }

        if (dataType.unique === true) {
          sql += ' UNIQUE';
        }

        if (dataType.primaryKey) {
          sql += ' PRIMARY KEY';

          if (dataType.autoIncrement) {
            sql += ' AUTOINCREMENT';
          }
        }

        if (dataType.references) {
          const referencesTable = this.quoteTable(dataType.references.model);

          let referencesKey;
          if (dataType.references.key) {
            referencesKey = this.quoteIdentifier(dataType.references.key);
          } else {
            referencesKey = this.quoteIdentifier('id');
          }

          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

          if (dataType.onDelete) {
            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;
          }

          if (dataType.onUpdate) {
            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;
          }

        }

        result[fieldName] = sql;
      } else {
        result[fieldName] = dataType;
      }
    }

    return result;
  }

  showIndexesQuery(tableName) {
    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;
  }

  showConstraintsQuery(tableName, constraintName) {
    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;

    if (constraintName) {
      sql += ` AND sql LIKE '%${constraintName}%'`;
    }

    return `${sql};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = {
      _schema: schema,
      _schemaDelimiter: schemaDelimiter,
      tableName
    };
    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;
  }

  describeCreateTableQuery(tableName) {
    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;
  }

  removeColumnQuery(tableName, attributes) {

    attributes = this.attributesToSQL(attributes);

    let backupTableName;
    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary table cannot work for foreign keys.
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  _alterConstraintQuery(tableName, attributes, createTableSql) {
    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }
    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    return `${createTableSql
      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)
      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '"')}`, `CREATE TABLE ${quotedBackupTableName}`)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};`
      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;
  }

  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {

    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNamesImport = Object.keys(attributes).map(attr =>
      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)
    ).join(', ');
    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;
    }

    return `BEGIN ${transaction.options.type} TRANSACTION;`;
  }

  setIsolationLevelQuery(value) {
    switch (value) {
      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';
      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
        return 'PRAGMA read_uncommitted = ON;';
      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
        return 'PRAGMA read_uncommitted = OFF;';
      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
        return '-- SQLite\'s default isolation level is SERIALIZABLE. Nothing to do.';
      default:
        throw new Error(`Unknown isolation level: ${value}`);
    }
  }

  replaceBooleanDefaults(sql) {
    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return `PRAGMA foreign_key_list(${tableName})`;
  }
}

module.exports = SQLiteQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const { cloneDeep } = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

/**
 * The interface that Sequelize uses to talk with SQLite database
 */
class SQLiteQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes SQLite's inability to remove columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but without the obsolete column.
   *
   * @override
   */
  async removeColumn(tableName, attributeName, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    delete fields[attributeName];

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to change columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a modified version of the respective column.
   *
   * @override
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to rename columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a renamed version of the respective column.
   *
   * @override
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);

    fields[attrNameAfter] = { ...fields[attrNameBefore] };
    delete fields[attrNameBefore];

    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    let createTableSql;

    const constraints = await this.showConstraint(tableName, constraintName);
    // sqlite can't show only one constraint, so we find here the one to remove
    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);

    if (!constraint) {
      throw new sequelizeErrors.UnknownConstraintError({
        message: `Constraint ${constraintName} on table ${tableName} does not exist`,
        constraint: constraintName,
        table: tableName
      });
    }
    createTableSql = constraint.sql;
    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;

    if (constraint.constraintType === 'FOREIGN KEY') {
      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);
      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));
      const referenceTableKeys = constraint.referenceTableKeys.join(', ');
      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;
      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;
      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;
    }

    createTableSql = createTableSql.replace(constraintSnippet, '');
    createTableSql += ';';

    const fields = await this.describeTable(tableName, options);

    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = cloneDeep(options);

    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);

    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options, type: QueryTypes.SELECT, raw: true });
    let sql = constraints[0].sql;
    const index = sql.length - 1;
    //Replace ending ')' with constraint snippet - Simulates String.replaceAt
    //http://stackoverflow.com/questions/1431094
    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;

    const fields = await this.describeTable(tableName, options);
    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const database = this.sequelize.config.database;
    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);
    const result = await this.sequelize.query(query, options);
    return result.map(row => ({
      tableName,
      columnName: row.from,
      referencedTableName: row.table,
      referencedColumnName: row.to,
      tableCatalog: database,
      referencedTableCatalog: database
    }));
  }

  /**
   * @override
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);
    await this._dropAllTables(tableNames, skip, options);
    await this.sequelize.query('PRAGMA foreign_keys = ON', options);
  }

  /**
   * @override
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };
    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      const indexes = await this.sequelize.query(sqlIndexes, options);
      for (const prop in data) {
        data[prop].unique = false;
      }
      for (const index of indexes) {
        for (const field of index.fields) {
          if (index.unique !== undefined) {
            data[field.attribute].unique = index.unique;
          }
        }
      }

      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);
      for (const foreignKey of foreignKeys) {
        data[foreignKey.columnName].references = {
          model: foreignKey.referencedTableName,
          key: foreignKey.referencedColumnName
        };
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }
}

exports.SQLiteQueryInterface = SQLiteQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:sqlite');


class Query extends AbstractQuery {
  getInsertIdField() {
    return 'lastID';
  }

  /**
   * rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    let bindParam;
    if (Array.isArray(values)) {
      bindParam = {};
      values.forEach((v, i) => {
        bindParam[`$${i + 1}`] = v;
      });
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = {};
      if (typeof values === 'object') {
        for (const k of Object.keys(values)) {
          bindParam[`$${k}`] = values[k];
        }
      }
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    }
    return [sql, bindParam];
  }

  _collectModels(include, prefix) {
    const ret = {};

    if (include) {
      for (const _include of include) {
        let key;
        if (!prefix) {
          key = _include.as;
        } else {
          key = `${prefix}.${_include.as}`;
        }
        ret[key] = _include.model;

        if (_include.include) {
          _.merge(ret, this._collectModels(_include.include, key));
        }
      }
    }

    return ret;
  }

  _handleQueryResponse(metaData, columnTypes, err, results) {
    if (err) {
      err.sql = this.sql;
      throw this.formatError(err);
    }
    let result = this.instance;

    // add the inserted row id to the instance
    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
      this.handleInsertQuery(results, metaData);
      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          metaData.constructor.name === 'Statement'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
          result = [];
          for (let i = startId; i < startId + metaData.changes; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = metaData[this.getInsertIdField()];
        }
      }
    }

    if (this.isShowTablesQuery()) {
      return results.map(row => row.name);
    }
    if (this.isShowConstraintsQuery()) {
      result = results;
      if (results && results[0] && results[0].sql) {
        result = this.parseConstraintsFromSql(results[0].sql);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      if (this.options.raw) {
        return this.handleSelectQuery(results);
      }
      // This is a map of prefix strings to models, e.g. user.projects -> Project model
      const prefixes = this._collectModels(this.options.include);

      results = results.map(result => {
        return _.mapValues(result, (value, name) => {
          let model;
          if (name.includes('.')) {
            const lastind = name.lastIndexOf('.');

            model = prefixes[name.substr(0, lastind)];

            name = name.substr(lastind + 1);
          } else {
            model = this.options.model;
          }

          const tableName = model.getTableName().toString().replace(/`/g, '');
          const tableTypes = columnTypes[tableName] || {};

          if (tableTypes && !(name in tableTypes)) {
            // The column is aliased
            _.forOwn(model.rawAttributes, (attribute, key) => {
              if (name === key && attribute.field) {
                name = attribute.field;
                return false;
              }
            });
          }

          return Object.prototype.hasOwnProperty.call(tableTypes, name)
            ? this.applyParsers(tableTypes[name], value)
            : value;
        });
      });

      return this.handleSelectQuery(results);
    }
    if (this.isShowOrDescribeQuery()) {
      return results;
    }
    if (this.sql.includes('PRAGMA INDEX_LIST')) {
      return this.handleShowIndexesQuery(results);
    }
    if (this.sql.includes('PRAGMA INDEX_INFO')) {
      return results;
    }
    if (this.sql.includes('PRAGMA TABLE_INFO')) {
      // this is the sqlite way of getting the metadata of a table
      result = {};

      let defaultValue;
      for (const _result of results) {
        if (_result.dflt_value === null) {
          // Column schema omits any "DEFAULT ..."
          defaultValue = undefined;
        } else if (_result.dflt_value === 'NULL') {
          // Column schema is a "DEFAULT NULL"
          defaultValue = null;
        } else {
          defaultValue = _result.dflt_value;
        }

        result[_result.name] = {
          type: _result.type,
          allowNull: _result.notnull === 0,
          defaultValue,
          primaryKey: _result.pk !== 0
        };

        if (result[_result.name].type === 'TINYINT(1)') {
          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];
        }

        if (typeof result[_result.name].defaultValue === 'string') {
          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');
        }
      }
      return result;
    }
    if (this.sql.includes('PRAGMA foreign_keys;')) {
      return results[0];
    }
    if (this.sql.includes('PRAGMA foreign_keys')) {
      return results;
    }
    if (this.sql.includes('PRAGMA foreign_key_list')) {
      return results;
    }
    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {
      return metaData.changes;
    }
    if (this.options.type === QueryTypes.VERSION) {
      return results[0].version;
    }
    if (this.options.type === QueryTypes.RAW) {
      return [results, metaData];
    }
    if (this.isUpsertQuery()) {
      return [result, null];
    }
    if (this.isUpdateQuery() || this.isInsertQuery()) {
      return [result, metaData.changes];
    }
    return result;
  }

  async run(sql, parameters) {
    const conn = this.connection;
    this.sql = sql;
    const method = this.getDatabaseMethod();
    const complete = this._logQuery(sql, debug, parameters);

    return new Promise((resolve, reject) => conn.serialize(async () => {
      const columnTypes = {};
      const executeSql = () => {
        if (sql.startsWith('-- ')) {
          return resolve();
        }
        const query = this;
        // cannot use arrow function here because the function is bound to the statement
        function afterExecute(executionError, results) {
          try {
            complete();
            // `this` is passed from sqlite, we have no control over this.
            // eslint-disable-next-line no-invalid-this
            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));
            return;
          } catch (error) {
            reject(error);
          }
        }

        if (!parameters) parameters = [];
        conn[method](sql, parameters, afterExecute);

        return null;
      };

      if (this.getDatabaseMethod() === 'all') {
        let tableNames = [];
        if (this.options && this.options.tableNames) {
          tableNames = this.options.tableNames;
        } else if (/FROM `(.*?)`/i.exec(this.sql)) {
          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);
        }

        // If we already have the metadata for the table, there's no need to ask for it again
        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');

        if (!tableNames.length) {
          return executeSql();
        }
        await Promise.all(tableNames.map(tableName =>
          new Promise(resolve => {
            tableName = tableName.replace(/`/g, '');
            columnTypes[tableName] = {};

            conn.all(`PRAGMA table_info(\`${tableName}\`)`, (err, results) => {
              if (!err) {
                for (const result of results) {
                  columnTypes[tableName][result.name] = result.type;
                }
              }
              resolve();
            });
          })));
      }
      return executeSql();
    }));
  }

  parseConstraintsFromSql(sql) {
    let constraints = sql.split('CONSTRAINT ');
    let referenceTableName, referenceTableKeys, updateAction, deleteAction;
    constraints.splice(0, 1);
    constraints = constraints.map(constraintSql => {
      //Parse foreign key snippets
      if (constraintSql.includes('REFERENCES')) {
        //Parse out the constraint condition form sql string
        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);

        if (updateAction) {
          updateAction = updateAction[1];
        }

        if (deleteAction) {
          deleteAction = deleteAction[1];
        }

        const referencesRegex = /REFERENCES.+\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/;
        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');
        referenceTableName = Utils.removeTicks(referenceConditions[1]);
        let columnNames = referenceConditions[2];
        columnNames = columnNames.replace(/\(|\)/g, '').split(', ');
        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));
      }

      const constraintCondition = constraintSql.match(/\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/)[0];
      constraintSql = constraintSql.replace(/\(.+\)/, '');
      const constraint = constraintSql.split(' ');

      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {
        constraint[1] += ' KEY';
      }

      return {
        constraintName: Utils.removeTicks(constraint[0]),
        constraintType: constraint[1],
        updateAction,
        deleteAction,
        sql: sql.replace(/"/g, '`'), //Sqlite returns double quotes for table name
        constraintCondition,
        referenceTableName,
        referenceTableKeys
      };
    });

    return constraints;
  }

  applyParsers(type, value) {
    if (type.includes('(')) {
      // Remove the length part
      type = type.substr(0, type.indexOf('('));
    }
    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');
    type = type.trim().toUpperCase();
    const parse = parserStore.get(type);

    if (value !== null && parse) {
      return parse(value, { timezone: this.sequelize.options.timezone });
    }
    return value;
  }

  formatError(err) {

    switch (err.code) {
      case 'SQLITE_CONSTRAINT': {
        if (err.message.includes('FOREIGN KEY constraint failed')) {
          return new sequelizeErrors.ForeignKeyConstraintError({
            parent: err
          });
        }

        let fields = [];

        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique
        let match = err.message.match(/columns (.*?) are/);
        if (match !== null && match.length >= 2) {
          fields = match[1].split(', ');
        } else {

          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y
          match = err.message.match(/UNIQUE constraint failed: (.*)/);
          if (match !== null && match.length >= 2) {
            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);
          }
        }

        const errors = [];
        let message = 'Validation error';

        for (const field of fields) {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            this.instance && this.instance[field],
            this.instance,
            'not_unique'
          ));
        }

        if (this.model) {
          _.forOwn(this.model.uniqueKeys, constraint => {
            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {
              message = constraint.msg;
              return false;
            }
          });
        }

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }
      case 'SQLITE_BUSY':
        return new sequelizeErrors.TimeoutError(err);

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  async handleShowIndexesQuery(data) {
    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!
    return Promise.all(data.reverse().map(async item => {
      item.fields = [];
      item.primary = false;
      item.unique = !!item.unique;
      item.constraintName = item.name;
      const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
      for (const column of columns) {
        item.fields[column.seqno] = {
          attribute: column.name,
          length: undefined,
          order: undefined
        };
      }

      return item;
    }));
  }

  getDatabaseMethod() {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
      return 'run';
    }
    return 'all';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/aggregate-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A wrapper for multiple Errors
 *
 * @param {Error[]} [errors] Array of errors
 *
 * @property errors {Error[]}
 */
class AggregateError extends BaseError {
  constructor(errors) {
    super();
    this.errors = errors;
    this.name = 'AggregateError';
  }

  toString() {
    const message = `AggregateError of:\n${
      this.errors.map(error =>
        error === this
          ? '[Circular AggregateError]'
          : error instanceof AggregateError
            ? String(error).replace(/\n$/, '').replace(/^/mg, '  ')
            : String(error).replace(/^/mg, '    ').substring(2)
        
      ).join('\n')
    }\n`;
    return message;
  }
}

module.exports = AggregateError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/association-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/association-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an association is improperly constructed (see message for details)
 */
class AssociationError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAssociationError';
  }
}

module.exports = AssociationError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/base-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/base-error.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.
 * All sequelize errors inherit from the base JS error object.
 *
 * This means that errors can be accessed using `Sequelize.ValidationError`
 * The Base Error all Sequelize Errors inherit from.
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'SequelizeBaseError';
  }
}

module.exports = BaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when bulk operation fails, it represent per record level error.
 * Used with AggregateError
 *
 * @param {Error}  error   Error for a given record/instance
 * @param {object} record  DAO instance that error belongs to
 */
class BulkRecordError extends BaseError {
  constructor(error, record) {
    super(error.message);
    this.name = 'SequelizeBulkRecordError';
    this.errors = error;
    this.record = record;
  }
}

module.exports = BulkRecordError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all connection related errors.
 */
class ConnectionError extends BaseError {
  constructor(parent) {
    super(parent ? parent.message : '');
    this.name = 'SequelizeConnectionError';
    /**
     * The connection specific error which triggered this one
     *
     * @type {Error}
     */
    this.parent = parent;
    this.original = parent;
  }
}

module.exports = ConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused due to insufficient privileges
 */
class AccessDeniedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeAccessDeniedError';
  }
}

module.exports = AccessDeniedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when connection is not acquired due to timeout
 */
class ConnectionAcquireTimeoutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionAcquireTimeoutError';
  }
}

module.exports = ConnectionAcquireTimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused
 */
class ConnectionRefusedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionRefusedError';
  }
}

module.exports = ConnectionRefusedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database times out
 */
class ConnectionTimedOutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionTimedOutError';
  }
}

module.exports = ConnectionTimedOutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not found
 */
class HostNotFoundError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotFoundError';
  }
}

module.exports = HostNotFoundError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not reachable
 */
class HostNotReachableError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotReachableError';
  }
}

module.exports = HostNotReachableError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has invalid values for any of the connection parameters
 */
class InvalidConnectionError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeInvalidConnectionError';
  }
}

module.exports = InvalidConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all database related errors.
 */
class DatabaseError extends BaseError {
  constructor(parent) {
    super(parent.message);
    this.name = 'SequelizeDatabaseError';
    /**
     * @type {Error}
     */
    this.parent = parent;
    /**
     * @type {Error}
     */
    this.original = parent;
    /**
     * The SQL that triggered the error
     *
     * @type {string}
     */
    this.sql = parent.sql;
    /**
     * The parameters for the sql that triggered the error
     *
     * @type {Array<any>}
     */
    this.parameters = parent.parameters;
  }
}

module.exports = DatabaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when an exclusion constraint is violated in the database
 */
class ExclusionConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeExclusionConstraintError';

    this.message = options.message || options.parent.message || '';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = ExclusionConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a foreign key constraint is violated in the database
 */
class ForeignKeyConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeForeignKeyConstraintError';

    this.message = options.message || options.parent.message || 'Database Error';
    this.fields = options.fields;
    this.table = options.table;
    this.value = options.value;
    this.index = options.index;
    this.reltype = options.reltype;
  }
}

module.exports = ForeignKeyConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a database query times out because of a deadlock
 */
class TimeoutError extends DatabaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeTimeoutError';
  }
}

module.exports = TimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when constraint name is not found in the database
 */
class UnknownConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeUnknownConstraintError';

    this.message = options.message || 'The specified constraint does not exist';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = UnknownConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an include statement is improperly constructed (see message for details)
 */
class EagerLoadingError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEagerLoadingError';
  }
}

module.exports = EagerLoadingError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/empty-result-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)
 */
class EmptyResultError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEmptyResultError';
  }
}

module.exports = EmptyResultError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

exports.AggregateError = __webpack_require__(/*! ./aggregate-error */ "./node_modules/sequelize/lib/errors/aggregate-error.js");
exports.AsyncQueueError = __webpack_require__(/*! ../dialects/mssql/async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").AsyncQueueError;
exports.AssociationError = __webpack_require__(/*! ./association-error */ "./node_modules/sequelize/lib/errors/association-error.js");
exports.BulkRecordError = __webpack_require__(/*! ./bulk-record-error */ "./node_modules/sequelize/lib/errors/bulk-record-error.js");
exports.ConnectionError = __webpack_require__(/*! ./connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");
exports.DatabaseError = __webpack_require__(/*! ./database-error */ "./node_modules/sequelize/lib/errors/database-error.js");
exports.EagerLoadingError = __webpack_require__(/*! ./eager-loading-error */ "./node_modules/sequelize/lib/errors/eager-loading-error.js");
exports.EmptyResultError = __webpack_require__(/*! ./empty-result-error */ "./node_modules/sequelize/lib/errors/empty-result-error.js");
exports.InstanceError = __webpack_require__(/*! ./instance-error */ "./node_modules/sequelize/lib/errors/instance-error.js");
exports.OptimisticLockError = __webpack_require__(/*! ./optimistic-lock-error */ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js");
exports.QueryError = __webpack_require__(/*! ./query-error */ "./node_modules/sequelize/lib/errors/query-error.js");
exports.SequelizeScopeError = __webpack_require__(/*! ./sequelize-scope-error */ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js");
exports.ValidationError = __webpack_require__(/*! ./validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");
exports.ValidationErrorItem = exports.ValidationError.ValidationErrorItem;

exports.AccessDeniedError = __webpack_require__(/*! ./connection/access-denied-error */ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js");
exports.ConnectionAcquireTimeoutError = __webpack_require__(/*! ./connection/connection-acquire-timeout-error */ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js");
exports.ConnectionRefusedError = __webpack_require__(/*! ./connection/connection-refused-error */ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js");
exports.ConnectionTimedOutError = __webpack_require__(/*! ./connection/connection-timed-out-error */ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js");
exports.HostNotFoundError = __webpack_require__(/*! ./connection/host-not-found-error */ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js");
exports.HostNotReachableError = __webpack_require__(/*! ./connection/host-not-reachable-error */ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js");
exports.InvalidConnectionError = __webpack_require__(/*! ./connection/invalid-connection-error */ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js");

exports.ExclusionConstraintError = __webpack_require__(/*! ./database/exclusion-constraint-error */ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js");
exports.ForeignKeyConstraintError = __webpack_require__(/*! ./database/foreign-key-constraint-error */ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js");
exports.TimeoutError = __webpack_require__(/*! ./database/timeout-error */ "./node_modules/sequelize/lib/errors/database/timeout-error.js");
exports.UnknownConstraintError = __webpack_require__(/*! ./database/unknown-constraint-error */ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js");

exports.UniqueConstraintError = __webpack_require__(/*! ./validation/unique-constraint-error */ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/instance-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/instance-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a some problem occurred with Instance methods (see message for details)
 */
class InstanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeInstanceError';
  }
}

module.exports = InstanceError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when attempting to update a stale model instance
 */
class OptimisticLockError extends BaseError {
  constructor(options) {
    options = options || {};
    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;
    super(options.message);
    this.name = 'SequelizeOptimisticLockError';
    /**
     * The name of the model on which the update was attempted
     *
     * @type {string}
     */
    this.modelName = options.modelName;
    /**
     * The values of the attempted update
     *
     * @type {object}
     */
    this.values = options.values;
    /**
     *
     * @type {object}
     */
    this.where = options.where;
  }
}

module.exports = OptimisticLockError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/query-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/query-error.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a query is passed invalid options (see message for details)
 */
class QueryError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeQueryError';
  }
}

module.exports = QueryError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Scope Error. Thrown when the sequelize cannot query the specified scope.
 */
class SequelizeScopeError extends BaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeScopeError';
  }
}

module.exports = SequelizeScopeError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,
 * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.
 *
 * @param {string} message Error message
 * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors
 *
 * @property errors {ValidationErrorItems[]}
 */
class ValidationError extends BaseError {
  constructor(message, errors) {
    super(message);
    this.name = 'SequelizeValidationError';
    this.message = 'Validation Error';
    /**
     *
     * @type {ValidationErrorItem[]}
     */
    this.errors = errors || [];

    // Use provided error message if available...
    if (message) {
      this.message = message;

      // ... otherwise create a concatenated message out of existing errors.
    } else if (this.errors.length > 0 && this.errors[0].message) {
      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\n');
    }
  }

  /**
   * Gets all validation error items for the path / field specified.
   *
   * @param {string} path The path to be checked for error items
   *
   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path
   */
  get(path) {
    return this.errors.reduce((reduced, error) => {
      if (error.path === path) {
        reduced.push(error);
      }
      return reduced;
    }, []);
  }
}

/**
 * Validation Error Item
 * Instances of this class are included in the `ValidationError.errors` property.
 */
class ValidationErrorItem {
  /**
   * Creates a new ValidationError item. Instances of this class are included in the `ValidationError.errors` property.
   *
   * @param {string} [message] An error message
   * @param {string} [type] The type/origin of the validation error
   * @param {string} [path] The field that triggered the validation error
   * @param {string} [value] The value that generated the error
   * @param {Model} [instance] the DAO instance that caused the validation error
   * @param {string} [validatorKey] a validation "key", used for identification
   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
   * @param {Array} [fnArgs] parameters used with the BUILT-IN validator function, if applicable
   */
  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {
    /**
     * An error message
     *
     * @type {string} message
     */
    this.message = message || '';

    /**
     * The type/origin of the validation error
     *
     * @type {string | null}
     */
    this.type = null;

    /**
     * The field that triggered the validation error
     *
     * @type {string | null}
     */
    this.path = path || null;

    /**
     * The value that generated the error
     *
     * @type {string | null}
     */
    this.value = value !== undefined ? value : null;

    this.origin = null;

    /**
     * The DAO instance that caused the validation error
     *
     * @type {Model | null}
     */
    this.instance = instance || null;

    /**
     * A validation "key", used for identification
     *
     * @type {string | null}
     */
    this.validatorKey = validatorKey || null;

    /**
     * Property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
     *
     * @type {string | null}
     */
    this.validatorName = fnName || null;

    /**
     * Parameters used with the BUILT-IN validator function, if applicable
     *
     * @type {Array}
     */
    this.validatorArgs = fnArgs || [];

    if (type) {
      if (ValidationErrorItem.Origins[ type ]) {
        this.origin = type;
      } else {
        const lowercaseType = `${type}`.toLowerCase().trim();
        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];

        if (realType && ValidationErrorItem.Origins[ realType ]) {
          this.origin = realType;
          this.type = type;
        }
      }
    }

    // This doesn't need captureStackTrace because it's not a subclass of Error
  }

  /**
   * return a lowercase, trimmed string "key" that identifies the validator.
   *
   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property
   *
   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is "namespace",
   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins
   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,
   *                                            defaults to "." (fullstop). only used and validated if useTypeAsNS is TRUE.
   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.
   * @returns  {string}
   *
   * @private
   */
  getValidatorKey(useTypeAsNS, NSSeparator) {
    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;
    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;

    const type = this.origin;
    const key = this.validatorKey || this.validatorName;
    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];

    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {
      throw new Error('Invalid namespace separator given, must be a non-empty string');
    }

    if (!(typeof key === 'string' && key.length)) {
      return '';
    }

    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();
  }
}

/**
 * An enum that defines valid ValidationErrorItem `origin` values
 *
 * @type {object}
 * @property CORE       {string}  specifies errors that originate from the sequelize "core"
 * @property DB         {string}  specifies validation errors that originate from the storage engine
 * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute
 */
ValidationErrorItem.Origins = {
  CORE: 'CORE',
  DB: 'DB',
  FUNCTION: 'FUNCTION'
};

/**
 * An object that is used internally by the `ValidationErrorItem` class
 * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to
 * our new `origin` values.
 *
 * @type {object}
 */
ValidationErrorItem.TypeStringMap = {
  'notnull violation': 'CORE',
  'string violation': 'CORE',
  'unique violation': 'DB',
  'validation error': 'FUNCTION'
};

module.exports = ValidationError;
module.exports.ValidationErrorItem = ValidationErrorItem;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ValidationError = __webpack_require__(/*! ./../validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");

/**
 * Thrown when a unique constraint is violated in the database
 */
class UniqueConstraintError extends ValidationError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };
    options.message = options.message || options.parent.message || 'Validation Error';
    options.errors = options.errors || {};
    super(options.message, options.errors);

    this.name = 'SequelizeUniqueConstraintError';
    this.errors = options.errors;
    this.fields = options.fields;
    this.parent = options.parent;
    this.original = options.parent;
    this.sql = options.parent.sql;
  }
}

module.exports = UniqueConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('hooks');

const hookTypes = {
  beforeValidate: { params: 2 },
  afterValidate: { params: 2 },
  validationFailed: { params: 3 },
  beforeCreate: { params: 2 },
  afterCreate: { params: 2 },
  beforeDestroy: { params: 2 },
  afterDestroy: { params: 2 },
  beforeRestore: { params: 2 },
  afterRestore: { params: 2 },
  beforeUpdate: { params: 2 },
  afterUpdate: { params: 2 },
  beforeSave: { params: 2, proxies: ['beforeUpdate', 'beforeCreate'] },
  afterSave: { params: 2, proxies: ['afterUpdate', 'afterCreate'] },
  beforeUpsert: { params: 2 },
  afterUpsert: { params: 2 },
  beforeBulkCreate: { params: 2 },
  afterBulkCreate: { params: 2 },
  beforeBulkDestroy: { params: 1 },
  afterBulkDestroy: { params: 1 },
  beforeBulkRestore: { params: 1 },
  afterBulkRestore: { params: 1 },
  beforeBulkUpdate: { params: 1 },
  afterBulkUpdate: { params: 1 },
  beforeFind: { params: 1 },
  beforeFindAfterExpandIncludeAll: { params: 1 },
  beforeFindAfterOptions: { params: 1 },
  afterFind: { params: 2 },
  beforeCount: { params: 1 },
  beforeDefine: { params: 2, sync: true, noModel: true },
  afterDefine: { params: 1, sync: true, noModel: true },
  beforeInit: { params: 2, sync: true, noModel: true },
  afterInit: { params: 1, sync: true, noModel: true },
  beforeAssociate: { params: 2, sync: true },
  afterAssociate: { params: 2, sync: true },
  beforeConnect: { params: 1, noModel: true },
  afterConnect: { params: 2, noModel: true },
  beforeDisconnect: { params: 1, noModel: true },
  afterDisconnect: { params: 1, noModel: true },
  beforeSync: { params: 1 },
  afterSync: { params: 1 },
  beforeBulkSync: { params: 1 },
  afterBulkSync: { params: 1 },
  beforeQuery: { params: 2 },
  afterQuery: { params: 2 }
};
exports.hooks = hookTypes;


/**
 * get array of current hook and its proxies combined
 *
 * @param {string} hookType any hook type @see {@link hookTypes}
 *
 * @private
 */
const getProxiedHooks = hookType =>
  hookTypes[hookType].proxies
    ? hookTypes[hookType].proxies.concat(hookType)
    : [hookType]
;

function getHooks(hooked, hookType) {
  return (hooked.options.hooks || {})[hookType] || [];
}

const Hooks = {
  /**
   * Process user supplied hooks definition
   *
   * @param {object} hooks hooks definition
   *
   * @private
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  _setupHooks(hooks) {
    this.options.hooks = {};
    _.map(hooks || {}, (hooksArray, hookName) => {
      if (!Array.isArray(hooksArray)) hooksArray = [hooksArray];
      hooksArray.forEach(hookFn => this.addHook(hookName, hookFn));
    });
  },

  async runHooks(hooks, ...hookArgs) {
    if (!hooks) throw new Error('runHooks requires at least 1 argument');

    let hookType;

    if (typeof hooks === 'string') {
      hookType = hooks;
      hooks = getHooks(this, hookType);

      if (this.sequelize) {
        hooks = hooks.concat(getHooks(this.sequelize, hookType));
      }
    }

    if (!Array.isArray(hooks)) {
      hooks = [hooks];
    }

    // synchronous hooks
    if (hookTypes[hookType] && hookTypes[hookType].sync) {
      for (let hook of hooks) {
        if (typeof hook === 'object') {
          hook = hook.fn;
        }

        debug(`running hook(sync) ${hookType}`);
        hook.apply(this, hookArgs);
      }
      return;
    }

    // asynchronous hooks (default)
    for (let hook of hooks) {
      if (typeof hook === 'object') {
        hook = hook.fn;
      }

      debug(`running hook ${hookType}`);
      await hook.apply(this, hookArgs);
    }
  },

  /**
   * Add a hook to the model
   *
   * @param {string}          hookType hook name @see {@link hookTypes}
   * @param {string|Function} [name] Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.
   * @param {Function}        fn The hook function
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  addHook(hookType, name, fn) {
    if (typeof name === 'function') {
      fn = name;
      name = null;
    }

    debug(`adding hook ${hookType}`);
    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    hookType.forEach(type => {
      const hooks = getHooks(this, type);
      hooks.push(name ? { name, fn } : fn);
      this.options.hooks[type] = hooks;
    });

    return this;
  },

  /**
   * Remove hook from the model
   *
   * @param {string} hookType @see {@link hookTypes}
   * @param {string|Function} name name of hook or function reference which was attached
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  removeHook(hookType, name) {
    const isReference = typeof name === 'function' ? true : false;

    if (!this.hasHook(hookType)) {
      return this;
    }

    debug(`removing hook ${hookType}`);

    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    for (const type of hookType) {
      this.options.hooks[type] = this.options.hooks[type].filter(hook => {
        if (isReference && typeof hook === 'function') {
          return hook !== name; // check if same method
        }
        if (!isReference && typeof hook === 'object') {
          return hook.name !== name;
        }
        return true;
      });
    }

    return this;
  },

  /**
   * Check whether the mode has any hooks of this type
   *
   * @param {string} hookType @see {@link hookTypes}
   *
   * @alias hasHooks
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  hasHook(hookType) {
    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;
  }
};
Hooks.hasHooks = Hooks.hasHook;


function applyTo(target, isModel = false) {
  _.mixin(target, Hooks);

  for (const hook of Object.keys(hookTypes)) {
    if (isModel && hookTypes[hook].noModel) {
      continue;
    }
    target[hook] = function(name, callback) {
      return this.addHook(hook, name, callback);
    };
  }
}
exports.applyTo = applyTo;

/**
 * A hook that is run before validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run when validation fails
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options, error. Error is the
 * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.
 * @name validationFailed
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name afterCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeSave
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeUpsert
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the result of upsert(), options
 * @name afterUpsert
 * @memberof Sequelize.Model
 */

/**
  * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with attributes, options
  * @name afterSave
  * @memberof Sequelize.Model
  */

/**
 * A hook that is run before destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name beforeBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name afterBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name afterBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterExpandIncludeAll
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after all option parsing is complete
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterOptions
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance(s), options
 * @name afterFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a count query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeCount
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run after a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with factory
 * @name afterDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run before Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config, options
 * @name beforeInit
 * @memberof Sequelize
 */

/**
 * A hook that is run after Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with sequelize
 * @name afterInit
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config passed to connection
 * @name beforeConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object and the config passed to connection
 * @name afterConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name beforeDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name afterDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name beforeSync
 * @memberof Sequelize
 */

/**
 * A hook that is run after Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name afterSync
 * @memberof Sequelize
 */

/**
  * A hook that is run before sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name beforeBulkSync
  * @memberof Sequelize
  */

/**
  * A hook that is run after sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name afterBulkSync
  * @memberof Sequelize
  */


/***/ }),

/***/ "./node_modules/sequelize/lib/index-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/index-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of index hints to be used in mysql for querying with index hints
 *
 * @property USE
 * @property FORCE
 * @property IGNORE
 */
const IndexHints = module.exports = { // eslint-disable-line
  USE: 'USE',
  FORCE: 'FORCE',
  IGNORE: 'IGNORE'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/instance-validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/instance-validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const sequelizeError = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * Instance Validator.
 *
 * @param {Instance} modelInstance The model instance.
 * @param {object} options A dictionary with options.
 *
 * @private
 */
class InstanceValidator {
  constructor(modelInstance, options) {
    options = {
      // assign defined and default options
      hooks: true,
      ...options
    };

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } else {
      options.skip = options.skip || [];
    }

    this.options = options;

    this.modelInstance = modelInstance;

    /**
     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
     *
     * @name validator
     * @private
     */
    this.validator = validator;

    /**
     *  All errors will be stored here from the validations.
     *
     * @type {Array} Will contain keys that correspond to attributes which will
     *   be Arrays of Errors.
     * @private
     */
    this.errors = [];

    /**
     * @type {boolean} Indicates if validations are in progress
     * @private
     */
    this.inProgress = false;
  }

  /**
   * The main entry point for the Validation module, invoke to start the dance.
   *
   * @returns {Promise}
   * @private
   */
  async _validate() {
    if (this.inProgress) throw new Error('Validations already in progress.');

    this.inProgress = true;

    await Promise.all([
      this._perAttributeValidators(),
      this._customValidators()
    ]);

    if (this.errors.length) {
      throw new sequelizeError.ValidationError(null, this.errors);
    }
  }

  /**
   * Invoke the Validation sequence and run validation hooks if defined
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async validate() {
    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());
  }

  /**
   * Invoke the Validation sequence and run hooks
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async _validateAndRunHooks() {
    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
    await runHooks('beforeValidate', this.modelInstance, this.options);

    try {
      await this._validate();
    } catch (error) {
      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);
      throw newError || error;
    }

    await runHooks('afterValidate', this.modelInstance, this.options);
    return this.modelInstance;
  }

  /**
   * Will run all the validators defined per attribute (built-in validators and custom validators)
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _perAttributeValidators() {
    // promisify all attribute invocations
    const validators = [];

    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
      if (this.options.skip.includes(field)) {
        return;
      }

      const value = this.modelInstance.dataValues[field];

      if (value instanceof Utils.SequelizeMethod) {
        return;
      }

      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
        // perform validations based on schema
        this._validateSchema(rawAttribute, field, value);
      }

      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));
      }
    });

    return await Promise.all(validators);
  }

  /**
   * Will run all the custom validators defined in the model's options.
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _customValidators() {
    const validators = [];
    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {
      if (this.options.skip.includes(validatorType)) {
        return;
      }

      const valprom = this._invokeCustomValidator(validator, validatorType)
        // errors are handled in settling, stub this
        .catch(() => {});

      validators.push(valprom);
    });

    return await Promise.all(validators);
  }

  /**
   * Validate a single attribute with all the defined built-in validators and custom validators.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {string} field The field name.
   * @param {boolean} allowNull Whether or not the schema allows null values
   *
   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.
   */
  async _singleAttrValidate(value, field, allowNull) {
    // If value is null and allowNull is false, no validators should run (see #9143)
    if ((value === null || value === undefined) && !allowNull) {
      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.
      return;
    }

    // Promisify each validator
    const validators = [];
    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {

      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {
        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
        if (typeof test === 'object' && test !== null && test.msg) {
          test = {
            msg: test.msg
          };
        } else if (test === true) {
          test = {};
        }
      }

      // Custom validators should always run, except if value is null and allowNull is false (see #9143)
      if (typeof test === 'function') {
        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));
        return;
      }

      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).
      if (value === null || value === undefined) {
        return;
      }

      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);
      // errors are handled in settling, stub this
      validatorPromise.catch(() => {});
      validators.push(validatorPromise);
    });

    return Promise
      .all(validators.map(validator => validator.catch(rejection => {
        const isBuiltIn = !!rejection.validatorName;
        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
      })));
  }

  /**
   * Prepare and invoke a custom validator.
   *
   * @private
   *
   * @param {Function} validator The custom validator.
   * @param {string} validatorType the custom validator type (name).
   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute
   * @param {*} optValue value for attribute
   * @param {string} optField field for attribute
   *
   * @returns {Promise} A promise.
   */
  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {
    let isAsync = false;

    const validatorArity = validator.length;
    // check if validator is async and requires a callback
    let asyncArity = 1;
    let errorKey = validatorType;
    let invokeArgs;
    if (optAttrDefined) {
      asyncArity = 2;
      invokeArgs = optValue;
      errorKey = optField;
    }
    if (validatorArity === asyncArity) {
      isAsync = true;
    }

    if (isAsync) {
      try {
        if (optAttrDefined) {
          return await promisify(validator.bind(this.modelInstance, invokeArgs))();
        }
        return await promisify(validator.bind(this.modelInstance))();
      } catch (e) {
        return this._pushError(false, errorKey, e, optValue, validatorType);
      }
    }

    try {
      return await validator.call(this.modelInstance, invokeArgs);
    } catch (e) {
      return this._pushError(false, errorKey, e, optValue, validatorType);
    }
  }

  /**
   * Prepare and invoke a build-in validator.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated
   *
   * @returns {object} An object with specific keys to invoke the validator.
   */
  async _invokeBuiltinValidator(value, test, validatorType, field) {
    // Cast value as string to pass new Validator.js string requirement
    const valueString = String(value);
    // check if Validator knows that kind of validation test
    if (typeof validator[validatorType] !== 'function') {
      throw new Error(`Invalid validator function: ${validatorType}`);
    }

    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

    if (!validator[validatorType](valueString, ...validatorArgs)) {
      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });
    }
  }

  /**
   * Will extract arguments for the validator.
   *
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated.
   *
   * @private
   */
  _extractValidatorArgs(test, validatorType, field) {
    let validatorArgs = test.args || test;
    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

    if (!Array.isArray(validatorArgs)) {
      if (validatorType === 'isImmutable') {
        validatorArgs = [validatorArgs, field, this.modelInstance];
      } else if (isLocalizedValidator || validatorType === 'isIP') {
        validatorArgs = [];
      } else {
        validatorArgs = [validatorArgs];
      }
    } else {
      validatorArgs = validatorArgs.slice(0);
    }
    return validatorArgs;
  }

  /**
   * Will validate a single field against its schema definition (isnull).
   *
   * @param {object} rawAttribute As defined in the Schema.
   * @param {string} field The field name.
   * @param {*} value anything.
   *
   * @private
   */
  _validateSchema(rawAttribute, field, value) {
    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);
      if (!association || !this.modelInstance.get(association.associationAccessor)) {
        const validators = this.modelInstance.validators[field];
        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

        this.errors.push(new sequelizeError.ValidationErrorItem(
          errMsg,
          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'is_null'
        ));
      }
    }

    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
        this.errors.push(new sequelizeError.ValidationErrorItem(
          `${field} cannot be an array or an object`,
          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'not_a_string'
        ));
      }
    }
  }

  /**
   * Signs all errors retaining the original.
   *
   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.
   * @param {string}        errorKey    - name of invalid attribute.
   * @param {Error|string}  rawError    - The original error.
   * @param {string|number} value       - The data that triggered the error.
   * @param {string}        fnName      - Name of the validator, if any
   * @param {Array}         fnArgs      - Arguments for the validator [function], if any
   *
   * @private
   */
  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
    const message = rawError.message || rawError || 'Validation error';
    const error = new sequelizeError.ValidationErrorItem(
      message,
      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey,
      value,
      this.modelInstance,
      fnName,
      isBuiltin ? fnName : undefined,
      isBuiltin ? fnArgs : undefined
    );

    error[InstanceValidator.RAW_KEY_NAME] = rawError;

    this.errors.push(error);
  }
}
/**
 * The error key for arguments as passed by custom validators
 *
 * @type {string}
 * @private
 */
InstanceValidator.RAW_KEY_NAME = 'original';

module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator;


/***/ }),

/***/ "./node_modules/sequelize/lib/model-manager.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize/lib/model-manager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Toposort = __webpack_require__(/*! toposort-class */ "./node_modules/toposort-class/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class ModelManager {
  constructor(sequelize) {
    this.models = [];
    this.sequelize = sequelize;
  }

  addModel(model) {
    this.models.push(model);
    this.sequelize.models[model.name] = model;

    return model;
  }

  removeModel(modelToRemove) {
    this.models = this.models.filter(model => model.name !== modelToRemove.name);

    delete this.sequelize.models[modelToRemove.name];
  }

  getModel(against, options) {
    options = _.defaults(options || {}, {
      attribute: 'name'
    });

    return this.models.find(model => model[options.attribute] === against);
  }

  get all() {
    return this.models;
  }

  /**
   * Iterate over Models in an order suitable for e.g. creating tables.
   * Will take foreign key constraints into account so that dependencies are visited before dependents.
   *
   * @param {Function} iterator method to execute on each model
   * @param {object} [options] iterator options
   * @private
   */
  forEachModel(iterator, options) {
    const models = {};
    const sorter = new Toposort();
    let sorted;
    let dep;

    options = _.defaults(options || {}, {
      reverse: true
    });

    for (const model of this.models) {
      let deps = [];
      let tableName = model.getTableName();

      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      models[tableName] = model;

      for (const attrName in model.rawAttributes) {
        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
          const attribute = model.rawAttributes[attrName];

          if (attribute.references) {
            dep = attribute.references.model;

            if (_.isObject(dep)) {
              dep = `${dep.schema}.${dep.tableName}`;
            }

            deps.push(dep);
          }
        }
      }

      deps = deps.filter(dep => tableName !== dep);

      sorter.add(tableName, deps);
    }

    sorted = sorter.sort();
    if (options.reverse) {
      sorted = sorted.reverse();
    }
    for (const name of sorted) {
      iterator(models[name], name);
    }
  }
}

module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports.default = ModelManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/model.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Dottie = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const InstanceValidator = __webpack_require__(/*! ./instance-validator */ "./node_modules/sequelize/lib/instance-validator.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Association = __webpack_require__(/*! ./associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const HasMany = __webpack_require__(/*! ./associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const associationsMixin = __webpack_require__(/*! ./associations/mixin */ "./node_modules/sequelize/lib/associations/mixin.js");
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");


// This list will quickly become dated, but failing to maintain this list just means
// we won't throw a warning when we should. At least most common cases will forever be covered
// so we stop throwing erroneous warnings when we shouldn't.
const validQueryKeywords = new Set(['where', 'attributes', 'paranoid', 'include', 'order', 'limit', 'offset',
  'transaction', 'lock', 'raw', 'logging', 'benchmark', 'having', 'searchPath', 'rejectOnEmpty', 'plain',
  'scope', 'group', 'through', 'defaults', 'distinct', 'primary', 'exception', 'type', 'hooks', 'force',
  'name']);

// List of attributes that should not be implicitly passed into subqueries/includes.
const nonCascadingOptions = ['include', 'attributes', 'originalAttributes', 'order', 'where', 'limit', 'offset', 'plain', 'group', 'having'];

/**
 * A Model represents a table in the database. Instances of this class represent a database row.
 *
 * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.
 * By default, the values from dataValues can also be accessed directly from the Instance, that is:
 * ```js
 * instance.field
 * // is the same as
 * instance.get('field')
 * // is the same as
 * instance.getDataValue('field')
 * ```
 * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.
 * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.
 *
 * @see
   * {@link Sequelize#define} for more information about getters and setters
 * @mixes Hooks
 */
class Model {
  static get queryInterface() {
    return this.sequelize.getQueryInterface();
  }

  static get queryGenerator() {
    return this.queryInterface.queryGenerator;
  }

  /**
   * A reference to the sequelize instance
   *
   * @see
   * {@link Sequelize}
   *
   * @property sequelize
   *
   * @returns {Sequelize}
   */
  get sequelize() {
    return this.constructor.sequelize;
  }

  /**
   * Builds a new model instance.
   *
   * @param {object}  [values={}] an object of key value pairs
   * @param {object}  [options] instance construction options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this a new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   */
  constructor(values = {}, options = {}) {
    options = {
      isNewRecord: true,
      _schema: this.constructor._schema,
      _schemaDelimiter: this.constructor._schemaDelimiter,
      ...options
    };

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    if (!options.includeValidated) {
      this.constructor._conformIncludes(options, this.constructor);
      if (options.include) {
        this.constructor._expandIncludeAll(options);
        this.constructor._validateIncludedElements(options);
      }
    }

    this.dataValues = {};
    this._previousDataValues = {};
    this._changed = new Set();
    this._options = options || {};

    /**
     * Returns true if this instance has not yet been persisted to the database
     *
     * @property isNewRecord
     * @returns {boolean}
     */
    this.isNewRecord = options.isNewRecord;

    this._initValues(values, options);
  }

  _initValues(values, options) {
    let defaults;
    let key;

    values = { ...values };

    if (options.isNewRecord) {
      defaults = {};

      if (this.constructor._hasDefaultValues) {
        defaults = _.mapValues(this.constructor._defaultValues, valueFn => {
          const value = valueFn();
          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);
        });
      }

      // set id to null if not passed as value, a newly created dao has no id
      // removing this breaks bulkCreate
      // do after default values since it might have UUID as a default value
      if (this.constructor.primaryKeyAttributes.length) {
        this.constructor.primaryKeyAttributes.forEach(primaryKeyAttribute => {
          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {
            defaults[primaryKeyAttribute] = null;
          }
        });
      }

      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {
        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.createdAt];
      }

      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {
        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.updatedAt];
      }

      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {
        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.deletedAt];
      }

      for (key in defaults) {
        if (values[key] === undefined) {
          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });
          delete values[key];
        }
      }
    }

    this.set(values, options);
  }

  // validateIncludedElements should have been called before this method
  static _paranoidClause(model, options = {}) {
    // Apply on each include
    // This should be handled before handling where conditions because of logic with returns
    // otherwise this code will never run on includes of a already conditionable where
    if (options.include) {
      for (const include of options.include) {
        this._paranoidClause(include.model, include);
      }
    }

    // apply paranoid when groupedLimit is used
    if (_.get(options, 'groupedLimit.on.options.paranoid')) {
      const throughModel = _.get(options, 'groupedLimit.on.through.model');
      if (throughModel) {
        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);
      }
    }

    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {
      // This model is not paranoid, nothing to do here;
      return options;
    }

    const deletedAtCol = model._timestampAttributes.deletedAt;
    const deletedAtAttribute = model.rawAttributes[deletedAtCol];
    const deletedAtObject = {};

    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    deletedAtDefaultValue = deletedAtDefaultValue || {
      [Op.eq]: null
    };

    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;

    if (Utils.isWhereEmpty(options.where)) {
      options.where = deletedAtObject;
    } else {
      options.where = { [Op.and]: [deletedAtObject, options.where] };
    }

    return options;
  }

  static _addDefaultAttributes() {
    const tail = {};
    let head = {};

    // Add id if no primary key was manually added to definition
    // Can't use this.primaryKeys here, since this function is called before PKs are identified
    if (!_.some(this.rawAttributes, 'primaryKey')) {
      if ('id' in this.rawAttributes) {
        // Something is fishy here!
        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);
      }

      head = {
        id: {
          type: new DataTypes.INTEGER(),
          allowNull: false,
          primaryKey: true,
          autoIncrement: true,
          _autoGenerated: true
        }
      };
    }

    if (this._timestampAttributes.createdAt) {
      tail[this._timestampAttributes.createdAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.updatedAt) {
      tail[this._timestampAttributes.updatedAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.deletedAt) {
      tail[this._timestampAttributes.deletedAt] = {
        type: DataTypes.DATE,
        _autoGenerated: true
      };
    }

    if (this._versionAttribute) {
      tail[this._versionAttribute] = {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 0,
        _autoGenerated: true
      };
    }

    const newRawAttributes = {
      ...head,
      ...this.rawAttributes
    };
    _.each(tail, (value, attr) => {
      if (newRawAttributes[attr] === undefined) {
        newRawAttributes[attr] = value;
      }
    });

    this.rawAttributes = newRawAttributes;

    if (!Object.keys(this.primaryKeys).length) {
      this.primaryKeys.id = this.rawAttributes.id;
    }
  }

  static _findAutoIncrementAttribute() {
    this.autoIncrementAttribute = null;

    for (const name in this.rawAttributes) {
      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {
        const definition = this.rawAttributes[name];
        if (definition && definition.autoIncrement) {
          if (this.autoIncrementAttribute) {
            throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');
          }
          this.autoIncrementAttribute = name;
        }
      }
    }
  }

  static _conformIncludes(options, self) {
    if (!options.include) return;

    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
      options.include = [options.include];
    } else if (!options.include.length) {
      delete options.include;
      return;
    }

    // convert all included elements to { model: Model } form
    options.include = options.include.map(include => this._conformInclude(include, self));
  }

  static _transformStringAssociation(include, self) {
    if (self && typeof include === 'string') {
      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {
        throw new Error(`Association with alias "${include}" does not exist on ${self.name}`);
      }
      return self.associations[include];
    }
    return include;
  }

  static _conformInclude(include, self) {
    if (include) {
      let model;

      if (include._pseudo) return include;

      include = this._transformStringAssociation(include, self);

      if (include instanceof Association) {
        if (self && include.target.name === self.name) {
          model = include.source;
        } else {
          model = include.target;
        }

        return { model, association: include, as: include.as };
      }

      if (include.prototype && include.prototype instanceof Model) {
        return { model: include };
      }

      if (_.isPlainObject(include)) {
        if (include.association) {
          include.association = this._transformStringAssociation(include.association, self);

          if (self && include.association.target.name === self.name) {
            model = include.association.source;
          } else {
            model = include.association.target;
          }

          if (!include.model) include.model = model;
          if (!include.as) include.as = include.association.as;

          this._conformIncludes(include, model);
          return include;
        }

        if (include.model) {
          this._conformIncludes(include, include.model);
          return include;
        }

        if (include.all) {
          this._conformIncludes(include);
          return include;
        }
      }
    }

    throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');
  }

  static _expandIncludeAllElement(includes, include) {
    // check 'all' attribute provided is valid
    let all = include.all;
    delete include.all;

    if (all !== true) {
      if (!Array.isArray(all)) {
        all = [all];
      }

      const validTypes = {
        BelongsTo: true,
        HasOne: true,
        HasMany: true,
        One: ['BelongsTo', 'HasOne'],
        Has: ['HasOne', 'HasMany'],
        Many: ['HasMany']
      };

      for (let i = 0; i < all.length; i++) {
        const type = all[i];
        if (type === 'All') {
          all = true;
          break;
        }

        const types = validTypes[type];
        if (!types) {
          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);
        }

        if (types !== true) {
          // replace type placeholder e.g. 'One' with its constituent types e.g. 'HasOne', 'BelongsTo'
          all.splice(i, 1);
          i--;
          for (let j = 0; j < types.length; j++) {
            if (!all.includes(types[j])) {
              all.unshift(types[j]);
              i++;
            }
          }
        }
      }
    }

    // add all associations of types specified to includes
    const nested = include.nested;
    if (nested) {
      delete include.nested;

      if (!include.include) {
        include.include = [];
      } else if (!Array.isArray(include.include)) {
        include.include = [include.include];
      }
    }

    const used = [];
    (function addAllIncludes(parent, includes) {
      _.forEach(parent.associations, association => {
        if (all !== true && !all.includes(association.associationType)) {
          return;
        }

        // check if model already included, and skip if so
        const model = association.target;
        const as = association.options.as;

        const predicate = { model };
        if (as) {
          // We only add 'as' to the predicate if it actually exists
          predicate.as = as;
        }

        if (_.some(includes, predicate)) {
          return;
        }

        // skip if recursing over a model already nested
        if (nested && used.includes(model)) {
          return;
        }
        used.push(parent);

        // include this model
        const thisInclude = Utils.cloneDeep(include);
        thisInclude.model = model;
        if (as) {
          thisInclude.as = as;
        }
        includes.push(thisInclude);

        // run recursively if nested
        if (nested) {
          addAllIncludes(model, thisInclude.include);
          if (thisInclude.include.length === 0) delete thisInclude.include;
        }
      });
      used.pop();
    })(this, includes);
  }

  static _validateIncludedElements(options, tableNames) {
    if (!options.model) options.model = this;

    tableNames = tableNames || {};
    options.includeNames = [];
    options.includeMap = {};

    /* Legacy */
    options.hasSingleAssociation = false;
    options.hasMultiAssociation = false;

    if (!options.parent) {
      options.topModel = options.model;
      options.topLimit = options.limit;
    }

    options.include = options.include.map(include => {
      include = this._conformInclude(include);
      include.parent = options;
      include.topLimit = options.topLimit;

      this._validateIncludedElement.call(options.model, include, tableNames, options);

      if (include.duplicating === undefined) {
        include.duplicating = include.association.isMultiAssociation;
      }

      include.hasDuplicating = include.hasDuplicating || include.duplicating;
      include.hasRequired = include.hasRequired || include.required;

      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;
      options.hasRequired = options.hasRequired || include.required;

      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;
      return include;
    });

    for (const include of options.include) {
      include.hasParentWhere = options.hasParentWhere || !!options.where;
      include.hasParentRequired = options.hasParentRequired || !!options.required;

      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {
        if (include.duplicating) {
          include.subQuery = false;
          include.subQueryFilter = include.hasRequired;
        } else {
          include.subQuery = include.hasRequired;
          include.subQueryFilter = false;
        }
      } else {
        include.subQuery = include.subQuery || false;
        if (include.duplicating) {
          include.subQueryFilter = include.subQuery;
          include.subQuery = false;
        } else {
          include.subQueryFilter = false;
          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;
        }
      }

      options.includeMap[include.as] = include;
      options.includeNames.push(include.as);

      // Set top level options
      if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {
        if (include.subQuery) {
          options.subQuery = include.subQuery;
        } else if (include.hasDuplicating) {
          options.subQuery = true;
        }
      }

      /* Legacy */
      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;
      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;

      if (include.association.isMultiAssociation || include.hasMultiAssociation) {
        options.hasMultiAssociation = true;
      }
      if (include.association.isSingleAssociation || include.hasSingleAssociation) {
        options.hasSingleAssociation = true;
      }
    }

    if (options.topModel === options.model && options.subQuery === undefined) {
      options.subQuery = false;
    }
    return options;
  }

  static _validateIncludedElement(include, tableNames, options) {
    tableNames[include.model.getTableName()] = true;

    if (include.attributes && !options.raw) {
      include.model._expandAttributes(include);

      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);

      include = Utils.mapFinderOptions(include, include.model);

      if (include.attributes.length) {
        _.each(include.model.primaryKeys, (attr, key) => {
          // Include the primary key if it's not already included - take into account that the pk might be aliased (due to a .field prop)
          if (!include.attributes.some(includeAttr => {
            if (attr.field !== key) {
              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;
            }
            return includeAttr === key;
          })) {
            include.attributes.unshift(key);
          }
        });
      }
    } else {
      include = Utils.mapFinderOptions(include, include.model);
    }

    // pseudo include just needed the attribute logic, return
    if (include._pseudo) {
      if (!include.attributes) {
        include.attributes = Object.keys(include.model.tableAttributes);
      }
      return Utils.mapFinderOptions(include, include.model);
    }

    // check if the current Model is actually associated with the passed Model - or it's a pseudo include
    const association = include.association || this._getIncludedAssociation(include.model, include.as);

    include.association = association;
    include.as = association.as;

    // If through, we create a pseudo child include, to ease our parsing later on
    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {
      if (!include.include) include.include = [];
      const through = include.association.through;

      include.through = _.defaults(include.through || {}, {
        model: through.model,
        as: through.model.name,
        association: {
          isSingleAssociation: true
        },
        _pseudo: true,
        parent: include
      });


      if (through.scope) {
        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;
      }

      include.include.push(include.through);
      tableNames[through.tableName] = true;
    }

    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source
    let model;
    if (include.model.scoped === true) {
      // If the passed model is already scoped, keep that
      model = include.model;
    } else {
      // Otherwise use the model that was originally passed to the association
      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;
    }

    model._injectScope(include);

    // This check should happen after injecting the scope, since the scope may contain a .attributes
    if (!include.attributes) {
      include.attributes = Object.keys(include.model.tableAttributes);
    }

    include = Utils.mapFinderOptions(include, include.model);

    if (include.required === undefined) {
      include.required = !!include.where;
    }

    if (include.association.scope) {
      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;
    }

    if (include.limit && include.separate === undefined) {
      include.separate = true;
    }

    if (include.separate === true) {
      if (!(include.association instanceof HasMany)) {
        throw new Error('Only HasMany associations support include.separate');
      }

      include.duplicating = false;

      if (
        options.attributes
        && options.attributes.length
        && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)
      ) {
        options.attributes.push(association.sourceKey);
      }

      if (
        include.attributes
        && include.attributes.length
        && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)
      ) {
        include.attributes.push(association.foreignKey);
      }
    }

    // Validate child includes
    if (Object.prototype.hasOwnProperty.call(include, 'include')) {
      this._validateIncludedElements.call(include.model, include, tableNames);
    }

    return include;
  }

  static _getIncludedAssociation(targetModel, targetAlias) {
    const associations = this.getAssociations(targetModel);
    let association = null;
    if (associations.length === 0) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);
    }
    if (associations.length === 1) {
      association = this.getAssociationForAlias(targetModel, targetAlias);
      if (association) {
        return association;
      }
      if (targetAlias) {
        const existingAliases = this.getAssociations(targetModel).map(association => association.as);
        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
          `You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(', ')}).`);
      }
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
        'You must use the \'as\' keyword to specify the alias within your include statement.');
    }
    association = this.getAssociationForAlias(targetModel, targetAlias);
    if (!association) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. ` +
        'To identify the correct association, you must use the \'as\' keyword to specify the alias of the association you want to include.');
    }
    return association;
  }


  static _expandIncludeAll(options) {
    const includes = options.include;
    if (!includes) {
      return;
    }

    for (let index = 0; index < includes.length; index++) {
      const include = includes[index];

      if (include.all) {
        includes.splice(index, 1);
        index--;

        this._expandIncludeAllElement(includes, include);
      }
    }

    includes.forEach(include => {
      this._expandIncludeAll.call(include.model, include);
    });
  }

  static _conformIndex(index) {
    if (!index.fields) {
      throw new Error('Missing "fields" property for index definition');
    }

    index = _.defaults(index, {
      type: '',
      parser: null
    });

    if (index.type && index.type.toLowerCase() === 'unique') {
      index.unique = true;
      delete index.type;
    }

    return index;
  }


  static _uniqIncludes(options) {
    if (!options.include) return;

    options.include = _(options.include)
      .groupBy(include => `${include.model && include.model.name}-${include.as}`)
      .map(includes => this._assignOptions(...includes))
      .value();
  }

  static _baseMerge(...args) {
    _.assignWith(...args);
    this._conformIncludes(args[0], this);
    this._uniqIncludes(args[0]);
    return args[0];
  }

  static _mergeFunction(objValue, srcValue, key) {
    if (Array.isArray(objValue) && Array.isArray(srcValue)) {
      return _.union(objValue, srcValue);
    }
    if (key === 'where' || key === 'having') {
      if (srcValue instanceof Utils.SequelizeMethod) {
        srcValue = { [Op.and]: srcValue };
      }
      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
        return Object.assign(objValue, srcValue);
      }
    } else if (key === 'attributes' && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
      return _.assignWith(objValue, srcValue, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
          return _.union(objValue, srcValue);
        }
      });
    }
    // If we have a possible object/array to clone, we try it.
    // Otherwise, we return the original value when it's not undefined,
    // or the resulting object in that case.
    if (srcValue) {
      return Utils.cloneDeep(srcValue, true);
    }
    return srcValue === undefined ? objValue : srcValue;
  }

  static _assignOptions(...args) {
    return this._baseMerge(...args, this._mergeFunction);
  }

  static _defaultsOptions(target, opts) {
    return this._baseMerge(target, opts, (srcValue, objValue, key) => {
      return this._mergeFunction(objValue, srcValue, key);
    });
  }

  /**
   * Initialize a model, representing a table in the DB, with attributes and options.
   *
   * The table columns are defined by the hash that is given as the first argument.
   * Each attribute of the hash represents a column.
   *
   * @example
   * Project.init({
   *   columnA: {
   *     type: Sequelize.BOOLEAN,
   *     validate: {
   *       is: ['[a-z]','i'],        // will only allow letters
   *       max: 23,                  // only allow values <= 23
   *       isIn: {
   *         args: [['en', 'zh']],
   *         msg: "Must be English or Chinese"
   *       }
   *     },
   *     field: 'column_a'
   *     // Other attributes here
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * }, {sequelize})
   *
   * sequelize.models.modelName // The model will now be available in models under the class name
   *
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @see
   * <a href="/master/manual/model-basics.html">Hooks</a> guide
   *
   * @see
   * <a href="/master/manual/validations-and-constraints.html"/>Validations & Constraints</a> guide
   *
   * @param {object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:
   * @param {string|DataTypes|object} attributes.column The description of a database column
   * @param {string|DataTypes}        attributes.column.type A string or a data type
   * @param {boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.
   * @param {any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)
   * @param {string|boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index
   * @param {boolean}                 [attributes.column.primaryKey=false] If true, this attribute will be marked as primary key
   * @param {string}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database
   * @param {boolean}                 [attributes.column.autoIncrement=false] If true, this column will be set to auto increment
   * @param {boolean}                 [attributes.column.autoIncrementIdentity=false] If true, combined with autoIncrement=true, will use Postgres `GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL`. Postgres 10+ only.
   * @param {string}                  [attributes.column.comment=null] Comment for this column
   * @param {string|Model}            [attributes.column.references=null] An object with reference configurations
   * @param {string|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string
   * @param {string}                  [attributes.column.references.key='id'] The column of the foreign table that this column references
   * @param {string}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {string}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.
   * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.
   * @param {object}                  [attributes.column.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field and the instance itself as the `this` binding, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation; if it is async, the callback should be called with the error text.
   * @param {object}                  options These options are merged with the default define options provided to the Sequelize constructor
   * @param {object}                  options.sequelize Define the sequelize instance to attach to the new Model. Throw error if none is provided.
   * @param {string}                  [options.modelName] Set name of the model. By default its same as Class name.
   * @param {object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll
   * @param {object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them
   * @param {boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved
   * @param {boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.
   * @param {boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work
   * @param {boolean}                 [options.underscored=false] Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set `field` option
   * @param {boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized
   * @param {object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.
   * @param {string}                  [options.name.singular=Utils.singularize(modelName)] Singular name for model
   * @param {string}                  [options.name.plural=Utils.pluralize(modelName)] Plural name for model
   * @param {Array<object>}           [options.indexes] indexes definitions
   * @param {string}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated
   * @param {string}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`
   * @param {string}                  [options.indexes[].using] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.
   * @param {string}                  [options.indexes[].operator] Specify index operator.
   * @param {boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`
   * @param {boolean}                 [options.indexes[].concurrently=false] PostgresSQL will build the index without taking any write locks. Postgres only
   * @param {Array<string|object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)
   * @param {string|boolean}          [options.createdAt] Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.updatedAt] Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.deletedAt] Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim
   * @param {string}                  [options.schema='public'] schema
   * @param {string}                  [options.engine] Specify engine for model's table
   * @param {string}                  [options.charset] Specify charset for model's table
   * @param {string}                  [options.comment] Specify comment for model's table
   * @param {string}                  [options.collate] Specify collation for model's table
   * @param {string}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.
   * @param {object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, beforeSave, afterDestroy, afterUpdate, afterBulkCreate, afterSave, afterBulkDestroy and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.
   * @param {object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.
   *
   * @returns {Model}
   */
  static init(attributes, options = {}) {
    if (!options.sequelize) {
      throw new Error('No Sequelize instance passed');
    }

    this.sequelize = options.sequelize;

    const globalOptions = this.sequelize.options;

    options = Utils.merge(_.cloneDeep(globalOptions.define), options);

    if (!options.modelName) {
      options.modelName = this.name;
    }

    options = Utils.merge({
      name: {
        plural: Utils.pluralize(options.modelName),
        singular: Utils.singularize(options.modelName)
      },
      indexes: [],
      omitNull: globalOptions.omitNull,
      schema: globalOptions.schema
    }, options);

    this.sequelize.runHooks('beforeDefine', attributes, options);

    if (options.modelName !== this.name) {
      Object.defineProperty(this, 'name', { value: options.modelName });
    }
    delete options.modelName;

    this.options = {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      ...options
    };

    // if you call "define" multiple times for the same modelName, do not clutter the factory
    if (this.sequelize.isDefined(this.name)) {
      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));
    }

    this.associations = {};
    this._setupHooks(options.hooks);

    this.underscored = this.options.underscored;

    if (!this.options.tableName) {
      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);
    } else {
      this.tableName = this.options.tableName;
    }

    this._schema = this.options.schema;
    this._schemaDelimiter = this.options.schemaDelimiter;

    // error check options
    _.each(options.validate, (validator, validatorType) => {
      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {
        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);
      }

      if (typeof validator !== 'function') {
        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);
      }
    });

    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {
      attribute = this.sequelize.normalizeAttribute(attribute);

      if (attribute.type === undefined) {
        throw new Error(`Unrecognized datatype for attribute "${this.name}.${name}"`);
      }

      if (attribute.allowNull !== false && _.get(attribute, 'validate.notNull')) {
        throw new Error(`Invalid definition for "${this.name}.${name}", "notNull" validator is only allowed with "allowNull:false"`);
      }

      if (_.get(attribute, 'references.model.prototype') instanceof Model) {
        attribute.references.model = attribute.references.model.getTableName();
      }

      return attribute;
    });

    const tableName = this.getTableName();
    this._indexes = this.options.indexes
      .map(index => Utils.nameIndex(this._conformIndex(index), tableName));

    this.primaryKeys = {};
    this._readOnlyAttributes = new Set();
    this._timestampAttributes = {};

    // setup names of timestamp attributes
    if (this.options.timestamps) {
      for (const key of ['createdAt', 'updatedAt', 'deletedAt']) {
        if (!['undefined', 'string', 'boolean'].includes(typeof this.options[key])) {
          throw new Error(`Value for "${key}" option must be a string or a boolean, got ${typeof this.options[key]}`);
        }
        if (this.options[key] === '') {
          throw new Error(`Value for "${key}" option cannot be an empty string`);
        }
      }

      if (this.options.createdAt !== false) {
        this._timestampAttributes.createdAt =
          typeof this.options.createdAt === 'string' ? this.options.createdAt : 'createdAt';
        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);
      }
      if (this.options.updatedAt !== false) {
        this._timestampAttributes.updatedAt =
          typeof this.options.updatedAt === 'string' ? this.options.updatedAt : 'updatedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);
      }
      if (this.options.paranoid && this.options.deletedAt !== false) {
        this._timestampAttributes.deletedAt =
          typeof this.options.deletedAt === 'string' ? this.options.deletedAt : 'deletedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);
      }
    }

    // setup name for version attribute
    if (this.options.version) {
      this._versionAttribute = typeof this.options.version === 'string' ? this.options.version : 'version';
      this._readOnlyAttributes.add(this._versionAttribute);
    }

    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;

    // Add head and tail default attributes (id, timestamps)
    this._addDefaultAttributes();
    this.refreshAttributes();
    this._findAutoIncrementAttribute();

    this._scope = this.options.defaultScope;
    this._scopeNames = ['defaultScope'];

    this.sequelize.modelManager.addModel(this);
    this.sequelize.runHooks('afterDefine', this);

    return this;
  }

  static refreshAttributes() {
    const attributeManipulation = {};

    this.prototype._customGetters = {};
    this.prototype._customSetters = {};

    ['get', 'set'].forEach(type => {
      const opt = `${type}terMethods`;
      const funcs = { ...this.options[opt] };
      const _custom = type === 'get' ? this.prototype._customGetters : this.prototype._customSetters;

      _.each(funcs, (method, attribute) => {
        _custom[attribute] = method;

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(this.rawAttributes, (options, attribute) => {
        if (Object.prototype.hasOwnProperty.call(options, type)) {
          _custom[attribute] = options[type];
        }

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(funcs, (fct, name) => {
        if (!attributeManipulation[name]) {
          attributeManipulation[name] = {
            configurable: true
          };
        }
        attributeManipulation[name][type] = fct;
      });
    });

    this._dataTypeChanges = {};
    this._dataTypeSanitizers = {};

    this._hasBooleanAttributes = false;
    this._hasDateAttributes = false;
    this._jsonAttributes = new Set();
    this._virtualAttributes = new Set();
    this._defaultValues = {};
    this.prototype.validators = {};

    this.fieldRawAttributesMap = {};

    this.primaryKeys = {};
    this.uniqueKeys = {};

    _.each(this.rawAttributes, (definition, name) => {
      definition.type = this.sequelize.normalizeDataType(definition.type);

      definition.Model = this;
      definition.fieldName = name;
      definition._modelAttribute = true;

      if (definition.field === undefined) {
        definition.field = Utils.underscoredIf(name, this.underscored);
      }

      if (definition.primaryKey === true) {
        this.primaryKeys[name] = definition;
      }

      this.fieldRawAttributesMap[definition.field] = definition;

      if (definition.type._sanitize) {
        this._dataTypeSanitizers[name] = definition.type._sanitize;
      }

      if (definition.type._isChanged) {
        this._dataTypeChanges[name] = definition.type._isChanged;
      }

      if (definition.type instanceof DataTypes.BOOLEAN) {
        this._hasBooleanAttributes = true;
      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {
        this._hasDateAttributes = true;
      } else if (definition.type instanceof DataTypes.JSON) {
        this._jsonAttributes.add(name);
      } else if (definition.type instanceof DataTypes.VIRTUAL) {
        this._virtualAttributes.add(name);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'defaultValue')) {
        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'unique') && definition.unique) {
        let idxName;
        if (
          typeof definition.unique === 'object' &&
          Object.prototype.hasOwnProperty.call(definition.unique, 'name')
        ) {
          idxName = definition.unique.name;
        } else if (typeof definition.unique === 'string') {
          idxName = definition.unique;
        } else {
          idxName = `${this.tableName}_${name}_unique`;
        }

        const idx = this.uniqueKeys[idxName] || { fields: [] };

        idx.fields.push(definition.field);
        idx.msg = idx.msg || definition.unique.msg || null;
        idx.name = idxName || false;
        idx.column = name;
        idx.customIndex = definition.unique !== true;

        this.uniqueKeys[idxName] = idx;
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'validate')) {
        this.prototype.validators[name] = definition.validate;
      }

      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {
        this._indexes.push(
          Utils.nameIndex(
            this._conformIndex({
              fields: [definition.field || name],
              using: 'gin'
            }),
            this.getTableName()
          )
        );

        delete definition.index;
      }
    });

    // Create a map of field to attribute names
    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {
      if (key !== value.fieldName) {
        map[key] = value.fieldName;
      }
      return map;
    }, {});

    this._hasJsonAttributes = !!this._jsonAttributes.size;

    this._hasVirtualAttributes = !!this._virtualAttributes.size;

    this._hasDefaultValues = !_.isEmpty(this._defaultValues);

    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));

    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;
    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;

    for (const key of Object.keys(attributeManipulation)) {
      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {
        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);
        continue;
      }
      Object.defineProperty(this.prototype, key, attributeManipulation[key]);
    }

    this.prototype.rawAttributes = this.rawAttributes;
    this.prototype._isAttribute = key => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);

    // Primary key convenience constiables
    this.primaryKeyAttributes = Object.keys(this.primaryKeys);
    this.primaryKeyAttribute = this.primaryKeyAttributes[0];
    if (this.primaryKeyAttribute) {
      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
    }

    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;
    this._isPrimaryKey = key => this.primaryKeyAttributes.includes(key);
  }

  /**
   * Remove attribute from model definition
   *
   * @param {string} attribute name of attribute to remove
   */
  static removeAttribute(attribute) {
    delete this.rawAttributes[attribute];
    this.refreshAttributes();
  }

  /**
   * Sync this Model to the DB, that is create the table.
   *
   * @param {object} [options] sync options
   *
   * @see
   * {@link Sequelize#sync} for options
   *
   * @returns {Promise<Model>}
   */
  static async sync(options) {
    options = { ...this.options, ...options };
    options.hooks = options.hooks === undefined ? true : !!options.hooks;

    const attributes = this.tableAttributes;
    const rawAttributes = this.fieldRawAttributesMap;

    if (options.hooks) {
      await this.runHooks('beforeSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }

    const tableName = this.getTableName(options);

    await this.queryInterface.createTable(tableName, attributes, options, this);

    if (options.alter) {
      const tableInfos = await Promise.all([
        this.queryInterface.describeTable(tableName, options),
        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)
      ]);
      const columns = tableInfos[0];
      // Use for alter foreign keys
      const foreignKeyReferences = tableInfos[1];
      const removedConstraints = {};

      for (const columnName in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, columnName)) continue;
        if (!columns[columnName] && !columns[attributes[columnName].field]) {
          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);
        }
      }

      if (options.alter === true || typeof options.alter === 'object' && options.alter.drop !== false) {
        for (const columnName in columns) {
          if (!Object.prototype.hasOwnProperty.call(columns, columnName)) continue;
          const currentAttribute = rawAttributes[columnName];
          if (!currentAttribute) {
            await this.queryInterface.removeColumn(tableName, columnName, options);
            continue;
          }
          if (currentAttribute.primaryKey) continue;
          // Check foreign keys. If it's a foreign key, it should remove constraint first.
          const references = currentAttribute.references;
          if (currentAttribute.references) {
            const database = this.sequelize.config.database;
            const schema = this.sequelize.config.schema;
            // Find existed foreign keys
            for (const foreignKeyReference of foreignKeyReferences) {
              const constraintName = foreignKeyReference.constraintName;
              if (!!constraintName
                && foreignKeyReference.tableCatalog === database
                && (schema ? foreignKeyReference.tableSchema === schema : true)
                && foreignKeyReference.referencedTableName === references.model
                && foreignKeyReference.referencedColumnName === references.key
                && (schema ? foreignKeyReference.referencedTableSchema === schema : true)
                && !removedConstraints[constraintName]) {
                // Remove constraint on foreign keys.
                await this.queryInterface.removeConstraint(tableName, constraintName, options);
                removedConstraints[constraintName] = true;
              }
            }
          }
          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);
        }
      }
    }
    let indexes = await this.queryInterface.showIndex(tableName, options);
    indexes = this._indexes.filter(item1 =>
      !indexes.some(item2 => item1.name === item2.name)
    ).sort((index1, index2) => {
      if (this.sequelize.options.dialect === 'postgres') {
      // move concurrent indexes to the bottom to avoid weird deadlocks
        if (index1.concurrently === true) return 1;
        if (index2.concurrently === true) return -1;
      }

      return 0;
    });

    for (const index of indexes) {
      await this.queryInterface.addIndex(tableName, { ...options, ...index });
    }

    if (options.hooks) {
      await this.runHooks('afterSync', options);
    }

    return this;
  }

  /**
   * Drop the table represented by this Model
   *
   * @param {object}   [options] drop options
   * @param {boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres
   * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise}
   */
  static async drop(options) {
    return await this.queryInterface.dropTable(this.getTableName(options), options);
  }

  static async dropSchema(schema) {
    return await this.queryInterface.dropSchema(schema);
  }

  /**
   * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `"schema"."tableName"`,
   * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.
   *
   * This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important
   * to call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.
   *
   * If a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call
   * for the model.
   *
   * @param {string}   schema The name of the schema
   * @param {object}   [options] schema options
   * @param {string}   [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @see
   * {@link Sequelize#define} for more information about setting a default schema.
   *
   * @returns {Model}
   */
  static schema(schema, options) {

    const clone = class extends this {};
    Object.defineProperty(clone, 'name', { value: this.name });

    clone._schema = schema;

    if (options) {
      if (typeof options === 'string') {
        clone._schemaDelimiter = options;
      } else if (options.schemaDelimiter) {
        clone._schemaDelimiter = options.schemaDelimiter;
      }
    }

    return clone;
  }

  /**
   * Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema,
   * or an object with `tableName`, `schema` and `delimiter` properties.
   *
   * @returns {string|object}
   */
  static getTableName() {
    return this.queryGenerator.addSchema(this);
  }

  /**
   * Get un-scoped model
   *
   * @returns {Model}
   */
  static unscoped() {
    return this.scope();
  }

  /**
   * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.
   *
   * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.
   *
   * @param {string}          name The name of the scope. Use `defaultScope` to override the default scope
   * @param {object|Function} scope scope or options
   * @param {object}          [options] scope options
   * @param {boolean}         [options.override=false] override old scope if already defined
   */
  static addScope(name, scope, options) {
    options = { override: false, ...options };

    if ((name === 'defaultScope' && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {
      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);
    }

    if (name === 'defaultScope') {
      this.options.defaultScope = this._scope = scope;
    } else {
      this.options.scopes[name] = scope;
    }
  }

  /**
   * Apply a scope created in `define` to the model.
   *
   * @example <caption>how to create scopes</caption>
   * const Model = sequelize.define('model', attributes, {
   *   defaultScope: {
   *     where: {
   *       username: 'dan'
   *     },
   *     limit: 12
   *   },
   *   scopes: {
   *     isALie: {
   *       where: {
   *         stuff: 'cake'
   *       }
   *     },
   *     complexFunction: function(email, accessLevel) {
   *       return {
   *         where: {
   *           email: {
   *             [Op.like]: email
   *           },
   *           access_level {
   *             [Op.gte]: accessLevel
   *           }
   *         }
   *       }
   *     }
   *   }
   * })
   *
   * # As you have defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:
   *
   * Model.findAll() // WHERE username = 'dan'
   * Model.findAll({ where: { age: { [Op.gt]: 12 } } }) // WHERE age > 12 AND username = 'dan'
   *
   * @example <caption>To invoke scope functions you can do</caption>
   * Model.scope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()
   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42
   *
   * @param {?Array|object|string} [option] The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.
   *
   * @returns {Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.
   */
  static scope(option) {
    const self = class extends this {};
    let scope;
    let scopeName;

    Object.defineProperty(self, 'name', { value: this.name });

    self._scope = {};
    self._scopeNames = [];
    self.scoped = true;

    if (!option) {
      return self;
    }

    const options = _.flatten(arguments);

    for (const option of options) {
      scope = null;
      scopeName = null;

      if (_.isPlainObject(option)) {
        if (option.method) {
          if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {
            scopeName = option.method[0];
            scope = self.options.scopes[scopeName].apply(self, option.method.slice(1));
          }
          else if (self.options.scopes[option.method]) {
            scopeName = option.method;
            scope = self.options.scopes[scopeName].apply(self);
          }
        } else {
          scope = option;
        }
      } else if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {
        scope = self.options.defaultScope;
      } else {
        scopeName = option;
        scope = self.options.scopes[scopeName];
        if (typeof scope === 'function') {
          scope = scope();
        }
      }

      if (scope) {
        this._conformIncludes(scope, this);
        // clone scope so it doesn't get modified
        this._assignOptions(self._scope, Utils.cloneDeep(scope));
        self._scopeNames.push(scopeName ? scopeName : 'defaultScope');
      } else {
        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);
      }
    }

    return self;
  }

  /**
   * Search for multiple instances.
   *
   * @example <caption>Simple search using AND and =</caption>
   * Model.findAll({
   *   where: {
   *     attr1: 42,
   *     attr2: 'cake'
   *   }
   * })
   *
   * # WHERE attr1 = 42 AND attr2 = 'cake'
   *
   * @example <caption>Using greater than, less than etc.</caption>
   * const {gt, lte, ne, in: opIn} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     attr1: {
   *       [gt]: 50
   *     },
   *     attr2: {
   *       [lte]: 45
   *     },
   *     attr3: {
   *       [opIn]: [1,2,3]
   *     },
   *     attr4: {
   *       [ne]: 5
   *     }
   *   }
   * })
   *
   * # WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5
   *
   * @example <caption>Queries using OR</caption>
   * const {or, and, gt, lt} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     name: 'a project',
   *     [or]: [
   *       {id: [1, 2, 3]},
   *       {
   *         [and]: [
   *           {id: {[gt]: 10}},
   *           {id: {[lt]: 100}}
   *         ]
   *       }
   *     ]
   *   }
   * });
   *
   * # WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));
   *
   * @see
   * {@link Operators} for possible operators
   * __Alias__: _all_
   *
   * The promise is resolved with an array of Model instances if the query succeeds._
   *
   * @param  {object}                                                    [options] A hash of options to describe the scope of the search
   * @param  {object}                                                    [options.where] A hash of attributes to describe your search. See above for examples.
   * @param  {Array<string>|object}                                      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance
   * @param  {Array<string>}                                             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`
   * @param  {Array<string>}                                             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`
   * @param  {boolean}                                                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.
   * @param  {Array<object|Model|string>}                                [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).
   * @param  {Model}                                                     [options.include[].model] The model you want to eagerly load
   * @param  {string}                                                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural
   * @param  {Association}                                               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)
   * @param  {object}                                                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`
   * @param  {boolean}                                                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.
   * @param  {object}                                                    [options.include[].on] Supply your own ON condition for the join.
   * @param  {Array<string>}                                             [options.include[].attributes] A list of attributes to select from the child model
   * @param  {boolean}                                                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.
   * @param  {boolean}                                                   [options.include[].right] If true, converts to a right join if dialect support it. Ignored if `include.required` is true.
   * @param  {boolean}                                                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations
   * @param  {number}                                                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true
   * @param  {string}                                                    [options.include[].through.as] The alias for the join model, in case you want to give it a different name than the default one.
   * @param  {object}                                                    [options.include[].through.where] Filter on the join model for belongsToMany relations
   * @param  {Array}                                                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations
   * @param  {Array<object|Model|string>}                                [options.include[].include] Load further nested related models
   * @param  {boolean}                                                   [options.include[].duplicating] Mark the include as duplicating, will prevent a subquery from being used.
   * @param  {Array|Sequelize.fn|Sequelize.col|Sequelize.literal}        [options.order] Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.
   * @param  {number}                                                    [options.limit] Limit for result
   * @param  {number}                                                    [options.offset] Offset for result
   * @param  {Transaction}                                               [options.transaction] Transaction to run query under
   * @param  {string|object}                                             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.
   * @param  {boolean}                                                   [options.skipLocked] Skip locked rows. Only supported in Postgres.
   * @param  {boolean}                                                   [options.raw] Return raw result. See sequelize.query for more information.
   * @param  {Function}                                                  [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param  {boolean}                                                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {object}                                                    [options.having] Having options
   * @param  {string}                                                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Error}                                             [options.rejectOnEmpty=false] Throws an error when no records found
   *
   * @see
   * {@link Sequelize#query}
   *
   * @returns {Promise<Array<Model>>}
   */
  static async findAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new sequelizeErrors.QueryError('The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    if (options !== undefined && options.attributes) {
      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {
        throw new sequelizeErrors.QueryError('The attributes option must be an array of column names or an object');
      }
    }

    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));

    const tableNames = {};

    tableNames[this.getTableName(options)] = true;
    options = Utils.cloneDeep(options);

    _.defaults(options, { hooks: true });

    // set rejectOnEmpty option, defaults to model options
    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, 'rejectOnEmpty')
      ? options.rejectOnEmpty
      : this.options.rejectOnEmpty;

    this._injectScope(options);

    if (options.hooks) {
      await this.runHooks('beforeFind', options);
    }
    this._conformIncludes(options, this);
    this._expandAttributes(options);
    this._expandIncludeAll(options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterExpandIncludeAll', options);
    }
    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);

    if (options.include) {
      options.hasJoin = true;

      this._validateIncludedElements(options, tableNames);

      // If we're not raw, we have to make sure we include the primary key for de-duplication
      if (
        options.attributes
        && !options.raw
        && this.primaryKeyAttribute
        && !options.attributes.includes(this.primaryKeyAttribute)
        && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)
      ) {
        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);
      }
    }

    if (!options.attributes) {
      options.attributes = Object.keys(this.rawAttributes);
      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
    }

    // whereCollection is used for non-primary key updates
    this.options.whereCollection = options.where || null;

    Utils.mapFinderOptions(options, this);

    options = this._paranoidClause(this, options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterOptions', options);
    }
    const selectOptions = { ...options, tableNames: Object.keys(tableNames) };
    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);
    if (options.hooks) {
      await this.runHooks('afterFind', results, options);
    }

    //rejectOnEmpty mode
    if (_.isEmpty(results) && options.rejectOnEmpty) {
      if (typeof options.rejectOnEmpty === 'function') {
        throw new options.rejectOnEmpty();
      }
      if (typeof options.rejectOnEmpty === 'object') {
        throw options.rejectOnEmpty;
      }
      throw new sequelizeErrors.EmptyResultError();
    }

    return await Model._findSeparate(results, options);
  }

  static warnOnInvalidOptions(options, validColumnNames) {
    if (!_.isPlainObject(options)) {
      return;
    }

    const unrecognizedOptions = Object.keys(options).filter(k => !validQueryKeywords.has(k));
    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);
    if (!options.where && unexpectedModelAttributes.length > 0) {
      logger.warn(`Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);
    }
  }

  static _injectDependentVirtualAttributes(attributes) {
    if (!this._hasVirtualAttributes) return attributes;
    if (!attributes || !Array.isArray(attributes)) return attributes;

    for (const attribute of attributes) {
      if (
        this._virtualAttributes.has(attribute)
        && this.rawAttributes[attribute].type.fields
      ) {
        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);
      }
    }

    attributes = _.uniq(attributes);

    return attributes;
  }

  static async _findSeparate(results, options) {
    if (!options.include || options.raw || !results) return results;

    const original = results;
    if (options.plain) results = [results];

    if (!results.length) return original;

    await Promise.all(options.include.map(async include => {
      if (!include.separate) {
        return await Model._findSeparate(
          results.reduce((memo, result) => {
            let associations = result.get(include.association.as);

            // Might be an empty belongsTo relation
            if (!associations) return memo;

            // Force array so we can concat no matter if it's 1:1 or :M
            if (!Array.isArray(associations)) associations = [associations];

            for (let i = 0, len = associations.length; i !== len; ++i) {
              memo.push(associations[i]);
            }
            return memo;
          }, []),
          {

            ..._.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'offset', 'plain', 'scope'),
            include: include.include || []
          }
        );
      }

      const map = await include.association.get(results, {

        ..._.omit(options, nonCascadingOptions),
        ..._.omit(include, ['parent', 'association', 'as', 'originalAttributes'])
      });

      for (const result of results) {
        result.set(
          include.association.as,
          map[result.get(include.association.sourceKey)],
          { raw: true }
        );
      }
    }));

    return original;
  }

  /**
   * Search for a single instance by its primary key._
   *
   * @param  {number|string|Buffer}      param The value of the desired instance's primary key.
   * @param  {object}                    [options] find options
   * @param  {Transaction}               [options.transaction] Transaction to run query under
   * @param  {string}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll}           for a full explanation of options, Note that options.where is not supported.
   *
   * @returns {Promise<Model>}
   */
  static async findByPk(param, options) {
    // return Promise resolved with null if no arguments are passed
    if ([null, undefined].includes(param)) {
      return null;
    }

    options = Utils.cloneDeep(options) || {};

    if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {
      options.where = {
        [this.primaryKeyAttribute]: param
      };
    } else {
      throw new Error(`Argument passed to findByPk is invalid: ${param}`);
    }

    // Bypass a possible overloaded findOne
    return await this.findOne(options);
  }

  /**
   * Search for a single instance. Returns the first instance found, or null if none can be found.
   *
   * @param  {object}       [options] A hash of options to describe the scope of the search
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {string}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll} for an explanation of options
   *
   * @returns {Promise<Model|null>}
   */
  static async findOne(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value');
    }
    options = Utils.cloneDeep(options);

    if (options.limit === undefined) {
      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter(c => c.fields.length === 1).map('column').value();

      // Don't add limit if querying directly on the pk or a unique column
      if (!options.where || !_.some(options.where, (value, key) =>
        (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) &&
          (Utils.isPrimitive(value) || Buffer.isBuffer(value))
      )) {
        options.limit = 1;
      }
    }

    // Bypass a possible overloaded findAll.
    return await this.findAll(_.defaults(options, {
      plain: true
    }));
  }

  /**
   * Run an aggregation method on the specified field
   *
   * @param {string}          attribute The attribute to aggregate over. Can be a field name or *
   * @param {string}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.
   * @param {object}          [options] Query options. See sequelize.query for full options
   * @param {object}          [options.where] A hash of search attributes.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {DataTypes|string} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.
   * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over
   * @param {Transaction}     [options.transaction] Transaction to run query under
   * @param {boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`
   *
   * @returns {Promise<DataTypes|object>} Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.
   */
  static async aggregate(attribute, aggregateFunction, options) {
    options = Utils.cloneDeep(options);

    // We need to preserve attributes here as the `injectScope` call would inject non aggregate columns.
    const prevAttributes = options.attributes;
    this._injectScope(options);
    options.attributes = prevAttributes;
    this._conformIncludes(options, this);

    if (options.include) {
      this._expandIncludeAll(options);
      this._validateIncludedElements(options);
    }

    const attrOptions = this.rawAttributes[attribute];
    const field = attrOptions && attrOptions.field || attribute;
    let aggregateColumn = this.sequelize.col(field);

    if (options.distinct) {
      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);
    }

    let { group } = options;
    if (Array.isArray(group) && Array.isArray(group[0])) {
      noDoubleNestedGroup();
      group = _.flatten(group);
    }
    options.attributes = _.unionBy(
      options.attributes,
      group,
      [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]],
      a => Array.isArray(a) ? a[1] : a
    );

    if (!options.dataType) {
      if (attrOptions) {
        options.dataType = attrOptions.type;
      } else {
        // Use FLOAT as fallback
        options.dataType = new DataTypes.FLOAT();
      }
    } else {
      options.dataType = this.sequelize.normalizeDataType(options.dataType);
    }

    Utils.mapOptionFieldNames(options, this);
    options = this._paranoidClause(this, options);

    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);
    if (value === null) {
      return 0;
    }
    return value;
  }

  /**
   * Count the number of records matching the provided where clause.
   *
   * If you provide an `include` option, the number of matching associations will be counted instead.
   *
   * @param {object}        [options] options
   * @param {object}        [options.where] A hash of search attributes.
   * @param {object}        [options.include] Include options. See `find` for details
   * @param {boolean}       [options.paranoid=true] Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled
   * @param {boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key or on options.col.
   * @param {string}        [options.col] Column on which COUNT() should be applied
   * @param {Array}         [options.attributes] Used in conjunction with `group`
   * @param {Array}         [options.group] For creating complex counts. Will return multiple rows as needed.
   * @param {Transaction}   [options.transaction] Transaction to run query under
   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<number>}
   */
  static async count(options) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { hooks: true });
    options.raw = true;
    if (options.hooks) {
      await this.runHooks('beforeCount', options);
    }
    let col = options.col || '*';
    if (options.include) {
      col = `${this.name}.${options.col || this.primaryKeyField}`;
    }
    if (options.distinct && col === '*') {
      col = this.primaryKeyField;
    }
    options.plain = !options.group;
    options.dataType = new DataTypes.INTEGER();
    options.includeIgnoreAttributes = false;

    // No limit, offset or order for the options max be given to count()
    // Set them to null to prevent scopes setting those values
    options.limit = null;
    options.offset = null;
    options.order = null;

    return await this.aggregate(col, 'count', options);
  }

  /**
   * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging
   *
   * @example
   * const result = await Model.findAndCountAll({
   *   where: ...,
   *   limit: 12,
   *   offset: 12
   * });
   *
   * # In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.
   *
   * # When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.
   *
   * # Suppose you want to find all users who have a profile attached:
   *
   * User.findAndCountAll({
   *   include: [
   *      { model: Profile, required: true}
   *   ],
   *   limit: 3
   * });
   *
   * # Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted
   *
   * @param {object} [options] See findAll options
   *
   * @see
   * {@link Model.findAll} for a specification of find and query options
   * @see
   * {@link Model.count} for a specification of count options
   *
   * @returns {Promise<{count: number, rows: Model[]}>}
   */
  static async findAndCountAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    const countOptions = Utils.cloneDeep(options);

    if (countOptions.attributes) {
      countOptions.attributes = undefined;
    }

    const [count, rows] = await Promise.all([
      this.count(countOptions),
      this.findAll(options)
    ]);

    return {
      count,
      rows: count === 0 ? [] : rows
    };
  }

  /**
   * Find the maximum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async max(field, options) {
    return await this.aggregate(field, 'max', options);
  }

  /**
   * Find the minimum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async min(field, options) {
    return await this.aggregate(field, 'min', options);
  }

  /**
   * Find the sum of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<number>}
   */
  static async sum(field, options) {
    return await this.aggregate(field, 'sum', options);
  }

  /**
   * Builds a new model instance.
   *
   * @param {object|Array} values An object of key value pairs or an array of such. If an array, the function will return an array of instances.
   * @param {object}  [options] Instance build options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   *
   * @returns {Model|Array<Model>}
   */
  static build(values, options) {
    if (Array.isArray(values)) {
      return this.bulkBuild(values, options);
    }

    return new this(values, options);
  }

  static bulkBuild(valueSets, options) {
    options = { isNewRecord: true, ...options };

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    return valueSets.map(values => this.build(values, options));
  }

  /**
   * Builds a new model instance and calls save on it.
   *
   * @see
   * {@link Model.build}
   * @see
   * {@link Model.save}
   *
   * @param  {object}         values                       Hash of data values to create new record with
   * @param  {object}         [options]                    Build and query options
   * @param  {boolean}        [options.raw=false]          If set to true, values will ignore field and virtual setters.
   * @param  {boolean}        [options.isNewRecord=true]   Is this new record
   * @param  {Array}          [options.include]            An array of include options - Used to build prefetched/included model instances. See `set`
   * @param  {string[]}       [options.fields]             An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param  {boolean}        [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {boolean}        [options.validate=true]      If false, validations won't be run.
   * @param  {boolean}        [options.hooks=true]         Run before and after create / update + validate hooks
   * @param  {Function}       [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]    Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]        Transaction to run query under
   * @param  {string}         [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Array}  [options.returning=true]     Appends RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   *
   * @returns {Promise<Model>}
   *
   */
  static async create(values, options) {
    options = Utils.cloneDeep(options || {});

    return await this.build(values, {
      isNewRecord: true,
      attributes: options.fields,
      include: options.include,
      raw: options.raw,
      silent: options.silent
    }).save(options);
  }

  /**
   * Find a row that matches the query, or build (but don't save) the row if none is found.
   * The successful result of the promise will be (instance, built)
   *
   * @param {object}   options find options
   * @param {object}   options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}   [options.defaults] Default values to use if building a new instance
   * @param {object}   [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrBuild(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrBuild. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    let values;

    let instance = await this.findOne(options);
    if (instance === null) {
      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      instance = this.build(values, options);

      return [instance, true];
    }

    return [instance, false];
  }

  /**
   * Find a row that matches the query, or build and save the row if none is found
   * The successful result of the promise will be (instance, created)
   *
   * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.
   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.
   * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object}      options find and create options
   * @param {object}      options.where where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}      [options.defaults] Default values to use if creating a new instance
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrCreate(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrCreate. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    options = { ...options };

    if (options.defaults) {
      const defaults = Object.keys(options.defaults);
      const unknownDefaults = defaults.filter(name => !this.rawAttributes[name]);

      if (unknownDefaults.length) {
        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);
      }
    }

    if (options.transaction === undefined && this.sequelize.constructor._cls) {
      const t = this.sequelize.constructor._cls.get('transaction');
      if (t) {
        options.transaction = t;
      }
    }

    const internalTransaction = !options.transaction;
    let values;
    let transaction;

    try {
      const t = await this.sequelize.transaction(options);
      transaction = t;
      options.transaction = t;

      const found = await this.findOne(Utils.defaults({ transaction }, options));
      if (found !== null) {
        return [found, false];
      }

      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      options.exception = true;
      options.returning = true;

      try {
        const created = await this.create(values, options);
        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {
          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation
          throw new sequelizeErrors.UniqueConstraintError();
        }

        return [created, true];
      } catch (err) {
        if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
        const flattenedWhere = Utils.flattenObjectDeep(options.where);
        const flattenedWhereKeys = Object.keys(flattenedWhere).map(name => _.last(name.split('.')));
        const whereFields = flattenedWhereKeys.map(name => _.get(this.rawAttributes, `${name}.field`, name));
        const defaultFields = options.defaults && Object.keys(options.defaults)
          .filter(name => this.rawAttributes[name])
          .map(name => this.rawAttributes[name].field || name);

        const errFieldKeys = Object.keys(err.fields);
        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);
        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {
          throw err;
        }

        if (errFieldsWhereIntersects) {
          _.each(err.fields, (value, key) => {
            const name = this.fieldRawAttributesMap[key].fieldName;
            if (value.toString() !== options.where[name].toString()) {
              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);
            }
          });
        }

        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!
        const otherCreated = await this.findOne(Utils.defaults({
          transaction: internalTransaction ? null : transaction
        }, options));

        // Sanity check, ideally we caught this at the defaultFeilds/err.fields check
        // But if we didn't and instance is null, we will throw
        if (otherCreated === null) throw err;

        return [otherCreated, false];
      }
    } finally {
      if (internalTransaction && transaction) {
        await transaction.commit();
      }
    }
  }

  /**
   * A more performant findOrCreate that will not work under a transaction (at least not in postgres)
   * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object} options find options
   * @param {object} options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object} [options.defaults] Default values to use if creating a new instance
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findCreateFind(options) {
    if (!options || !options.where) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findCreateFind.'
      );
    }

    let values = { ...options.defaults };
    if (_.isPlainObject(options.where)) {
      values = Utils.defaults(values, options.where);
    }


    const found = await this.findOne(options);
    if (found) return [found, false];

    try {
      const created = await this.create(values, options);
      return [created, true];
    } catch (err) {
      if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
      const foundAgain = await this.findOne(options);
      return [foundAgain, false];
    }
  }

  /**
   * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.
   *
   * **Implementation details:**
   *
   * * MySQL - Implemented with ON DUPLICATE KEY UPDATE`
   * * PostgreSQL - Implemented with ON CONFLICT DO UPDATE. If update data contains PK field, then PK is selected as the default conflict key. Otherwise first unique constraint/index will be selected, which can satisfy conflict key requirements.
   * * SQLite - Implemented with ON CONFLICT DO UPDATE
   * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`
   *
   * **Note** that Postgres/SQLite returns null for created, no matter if the row was created or updated
   *
   * @param  {object}       values                                        hash of values to upsert
   * @param  {object}       [options]                                     upsert options
   * @param  {boolean}      [options.validate=true]                       Run validations before the row is inserted
   * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all changed fields
   * @param  {boolean}      [options.hooks=true]                          Run before / after upsert hooks?
   * @param  {boolean}      [options.returning=true]                      If true, fetches back auto generated values
   * @param  {Transaction}  [options.transaction]                         Transaction to run query under
   * @param  {Function}     [options.logging=false]                       A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]                     Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {string}       [options.searchPath=DEFAULT]                  An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<[Model, boolean | null]>} returns an array with two elements, the first being the new record and the second being `true` if it was just created or `false` if it already existed (except on Postgres and SQLite, which can't detect this and will always return `null` instead of a boolean).
   */
  static async upsert(values, options) {
    options = {
      hooks: true,
      returning: true,
      validate: true,
      ...Utils.cloneDeep(options)
    };

    const createdAtAttr = this._timestampAttributes.createdAt;
    const updatedAtAttr = this._timestampAttributes.updatedAt;
    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;
    const instance = this.build(values);

    options.model = this;
    options.instance = instance;

    const changed = Array.from(instance._changed);
    if (!options.fields) {
      options.fields = changed;
    }

    if (options.validate) {
      await instance.validate(options);
    }
    // Map field names
    const updatedDataValues = _.pick(instance.dataValues, changed);
    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);
    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);
    const now = Utils.now(this.sequelize.options.dialect);

    // Attach createdAt
    if (createdAtAttr && !updateValues[createdAtAttr]) {
      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;
      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;
    }
    if (updatedAtAttr && !insertValues[updatedAtAttr]) {
      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;
    }

    // Build adds a null value for the primary key, if none was given by the user.
    // We need to remove that because of some Postgres technicalities.
    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {
      delete insertValues[this.primaryKeyField];
      delete updateValues[this.primaryKeyField];
    }

    if (options.hooks) {
      await this.runHooks('beforeUpsert', values, options);
    }
    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);

    const [record] = result;
    record.isNewRecord = false;

    if (options.hooks) {
      await this.runHooks('afterUpsert', result, options);
      return result;
    }
    return result;
  }

  /**
   * Create and insert multiple instances in bulk.
   *
   * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL
   * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.
   * To obtain Instances for the newly created values, you will need to query for them again.
   *
   * If validation fails, the promise is rejected with an array-like AggregateError
   *
   * @param  {Array}          records                          List of objects (key/value pairs) to create instances from
   * @param  {object}         [options]                        Bulk create options
   * @param  {Array}          [options.fields]                 Fields to insert (defaults to all fields)
   * @param  {boolean}        [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]             Run before / after bulk create hooks?
   * @param  {boolean}        [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.
   * @param  {boolean}        [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres < 9.5)
   * @param  {Array}          [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite >= 3.24.0 & Postgres >= 9.5). By default, all fields are updated.
   * @param  {Transaction}    [options.transaction]            Transaction to run query under
   * @param  {Function}       [options.logging=false]          A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]        Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {boolean|Array}  [options.returning=false]        If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {string}         [options.searchPath=DEFAULT]     An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Array<Model>>}
   */
  static async bulkCreate(records, options = {}) {
    if (!records.length) {
      return [];
    }

    const dialect = this.sequelize.options.dialect;
    const now = Utils.now(this.sequelize.options.dialect);

    options.model = this;

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    const instances = records.map(values => this.build(values, { isNewRecord: true, include: options.include }));

    const recursiveBulkCreate = async (instances, options) => {
      options = {
        validate: false,
        hooks: true,
        individualHooks: false,
        ignoreDuplicates: false,
        ...options
      };

      if (options.returning === undefined) {
        if (options.association) {
          options.returning = false;
        } else {
          options.returning = true;
        }
      }

      if (options.ignoreDuplicates && ['mssql'].includes(dialect)) {
        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);
      }
      if (options.updateOnDuplicate && (dialect !== 'mysql' && dialect !== 'mariadb' && dialect !== 'sqlite' && dialect !== 'postgres')) {
        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);
      }

      const model = options.model;

      options.fields = options.fields || Object.keys(model.rawAttributes);
      const createdAtAttr = model._timestampAttributes.createdAt;
      const updatedAtAttr = model._timestampAttributes.updatedAt;

      if (options.updateOnDuplicate !== undefined) {
        if (Array.isArray(options.updateOnDuplicate) && options.updateOnDuplicate.length) {
          options.updateOnDuplicate = _.intersection(
            _.without(Object.keys(model.tableAttributes), createdAtAttr),
            options.updateOnDuplicate
          );
        } else {
          throw new Error('updateOnDuplicate option only supports non-empty array.');
        }
      }

      // Run before hook
      if (options.hooks) {
        await model.runHooks('beforeBulkCreate', instances, options);
      }
      // Validate
      if (options.validate) {
        const errors = [];
        const validateOptions = { ...options };
        validateOptions.hooks = options.individualHooks;

        await Promise.all(instances.map(async instance => {
          try {
            await instance.validate(validateOptions);
          } catch (err) {
            errors.push(new sequelizeErrors.BulkRecordError(err, instance));
          }
        }));

        delete options.skip;
        if (errors.length) {
          throw new sequelizeErrors.AggregateError(errors);
        }
      }
      if (options.individualHooks) {
        await Promise.all(instances.map(async instance => {
          const individualOptions = {
            ...options,
            validate: false,
            hooks: true
          };
          delete individualOptions.fields;
          delete individualOptions.individualHooks;
          delete individualOptions.ignoreDuplicates;

          await instance.save(individualOptions);
        }));
      } else {
        if (options.include && options.include.length) {
          await Promise.all(options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
            const associationInstances = [];
            const associationInstanceIndexToInstanceMap = [];

            for (const instance of instances) {
              const associationInstance = instance.get(include.as);
              if (associationInstance) {
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }

            if (!associationInstances.length) {
              return;
            }

            const includeOptions = _(Utils.cloneDeep(include))
              .omit(['association'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();

            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              await include.association.set(instance, associationInstance, { save: false, logging: options.logging });
            }
          }));
        }

        // Create all in one query
        // Recreate records from instances to represent any changes made in hooks or validation
        records = instances.map(instance => {
          const values = instance.dataValues;

          // set createdAt/updatedAt attributes
          if (createdAtAttr && !values[createdAtAttr]) {
            values[createdAtAttr] = now;
            if (!options.fields.includes(createdAtAttr)) {
              options.fields.push(createdAtAttr);
            }
          }
          if (updatedAtAttr && !values[updatedAtAttr]) {
            values[updatedAtAttr] = now;
            if (!options.fields.includes(updatedAtAttr)) {
              options.fields.push(updatedAtAttr);
            }
          }

          const out = Utils.mapValueFieldNames(values, options.fields, model);
          for (const key of model._virtualAttributes) {
            delete out[key];
          }
          return out;
        });

        // Map attributes to fields for serial identification
        const fieldMappedAttributes = {};
        for (const attr in model.tableAttributes) {
          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];
        }

        // Map updateOnDuplicate attributes to fields
        if (options.updateOnDuplicate) {
          options.updateOnDuplicate = options.updateOnDuplicate.map(attr => model.rawAttributes[attr].field || attr);
          // Get primary keys for postgres to enable updateOnDuplicate
          options.upsertKeys = _.chain(model.primaryKeys).values().map('field').value();
          if (Object.keys(model.uniqueKeys).length > 0) {
            options.upsertKeys = _.chain(model.uniqueKeys).values().filter(c => c.fields.length >= 1).map(c => c.fields).reduce(c => c[0]).value();
          }
        }

        // Map returning attributes to fields
        if (options.returning && Array.isArray(options.returning)) {
          options.returning = options.returning.map(attr => _.get(model.rawAttributes[attr], 'field', attr));
        }

        const results = await model.queryInterface.bulkInsert(model.getTableName(options), records, options, fieldMappedAttributes);
        if (Array.isArray(results)) {
          results.forEach((result, i) => {
            const instance = instances[i];

            for (const key in result) {
              if (!instance || key === model.primaryKeyAttribute &&
                instance.get(model.primaryKeyAttribute) &&
                ['mysql', 'mariadb', 'sqlite'].includes(dialect)) {
                // The query.js for these DBs is blind, it autoincrements the
                // primarykey value, even if it was set manually. Also, it can
                // return more results than instances, bug?.
                continue;
              }
              if (Object.prototype.hasOwnProperty.call(result, key)) {
                const record = result[key];

                const attr = _.find(model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

                instance.dataValues[attr && attr.fieldName || key] = record;
              }
            }
          });
        }
      }

      if (options.include && options.include.length) {
        await Promise.all(options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          const associationInstances = [];
          const associationInstanceIndexToInstanceMap = [];

          for (const instance of instances) {
            let associated = instance.get(include.as);
            if (!Array.isArray(associated)) associated = [associated];

            for (const associationInstance of associated) {
              if (associationInstance) {
                if (!(include.association instanceof BelongsToMany)) {
                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
                  Object.assign(associationInstance, include.association.scope);
                }
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }
          }

          if (!associationInstances.length) {
            return;
          }

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging
            }).value();

          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
          if (include.association instanceof BelongsToMany) {
            const valueSets = [];

            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              const values = {
                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };
              if (associationInstance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof associationInstance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values[attr] = associationInstance[include.association.through.model.name][attr];
                }
              }

              valueSets.push(values);
            }

            const throughOptions = _(Utils.cloneDeep(include))
              .omit(['association', 'attributes'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();
            throughOptions.model = include.association.throughModel;
            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);

            await recursiveBulkCreate(throughInstances, throughOptions);
          }
        }));
      }

      // map fields back to attributes
      instances.forEach(instance => {
        for (const attr in model.rawAttributes) {
          if (model.rawAttributes[attr].field &&
              instance.dataValues[model.rawAttributes[attr].field] !== undefined &&
              model.rawAttributes[attr].field !== attr
          ) {
            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];
            delete instance.dataValues[model.rawAttributes[attr].field];
          }
          instance._previousDataValues[attr] = instance.dataValues[attr];
          instance.changed(attr, false);
        }
        instance.isNewRecord = false;
      });

      // Run after hook
      if (options.hooks) {
        await model.runHooks('afterBulkCreate', instances, options);
      }

      return instances;
    };

    return await recursiveBulkCreate(instances, options);
  }

  /**
   * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).
   *
   * @param {object}           [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.cascade = false] Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean}          [options.restartIdentity=false] Automatically restart sequences owned by columns of the truncated table.
   * @param {Transaction}      [options.transaction] Transaction to run query under
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @param {boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   *
   * @see
   * {@link Model.destroy} for more information
   */
  static async truncate(options) {
    options = Utils.cloneDeep(options) || {};
    options.truncate = true;
    return await this.destroy(options);
  }

  /**
   * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.
   *
   * @param  {object}       options                         destroy options
   * @param  {object}       [options.where]                 Filter the destroy
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row
   * @param  {number}       [options.limit]                 How many rows to delete
   * @param  {boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)
   * @param  {boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored
   * @param  {boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param  {boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise<number>} The number of destroyed rows
   */
  static async destroy(options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);

    if (!options || !(options.where || options.truncate)) {
      throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');
    }

    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {
      throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');
    }

    options = _.defaults(options, {
      hooks: true,
      individualHooks: false,
      force: false,
      cascade: false,
      restartIdentity: false
    });

    options.type = QueryTypes.BULKDELETE;

    Utils.mapOptionFieldNames(options, this);
    options.model = this;


    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkDestroy', options);
    }
    let instances;
    // Get daos and run beforeDestroy hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });

      await Promise.all(instances.map(instance => this.runHooks('beforeDestroy', instance, options)));
    }
    let result;
    // Run delete query (or update if paranoid)
    if (this._timestampAttributes.deletedAt && !options.force) {
      // Set query type appropriately when running soft delete
      options.type = QueryTypes.BULKUPDATE;

      const attrValueHash = {};
      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];
      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;
      const where = {
        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null
      };


      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);
      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);
    } else {
      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);
    }
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterDestroy', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkDestroy', options);
    }
    return result;
  }

  /**
   * Restore multiple instances if `paranoid` is enabled.
   *
   * @param  {object}       options                         restore options
   * @param  {object}       [options.where]                 Filter the restore
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk restore hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row
   * @param  {number}       [options.limit]                 How many rows to undelete (only for mysql)
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}  [options.transaction]           Transaction to run query under
   *
   * @returns {Promise}
   */
  static async restore(options) {
    if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      individualHooks: false,
      ...options
    };

    options.type = QueryTypes.RAW;
    options.model = this;

    Utils.mapOptionFieldNames(options, this);

    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkRestore', options);
    }

    let instances;
    // Get daos and run beforeRestore hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });

      await Promise.all(instances.map(instance => this.runHooks('beforeRestore', instance, options)));
    }
    // Run undelete query
    const attrValueHash = {};
    const deletedAtCol = this._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
    options.omitNull = false;
    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterRestore', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkRestore', options);
    }
    return result;
  }

  /**
   * Update multiple instances that match the where options.
   *
   * @param  {object}         values                          hash of values to update
   * @param  {object}         options                         update options
   * @param  {object}         options.where                   Options to describe the scope of the search.
   * @param  {boolean}        [options.paranoid=true]         If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if `options.paranoid` is true for the model.
   * @param  {Array}          [options.fields]                Fields to update (defaults to all fields)
   * @param  {boolean}        [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]            Run before / after bulk update hooks?
   * @param  {boolean}        [options.sideEffects=true]      Whether or not to update the side effects of any virtual setters.
   * @param  {boolean}        [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks
   * @param  {boolean|Array}  [options.returning=false]       If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {number}         [options.limit]                 How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)
   * @param  {Function}       [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]           Transaction to run query under
   * @param  {boolean}        [options.silent=false]          If true, the updatedAt timestamp will not be updated.
   *
   * @returns {Promise<Array<number,number>>}  The promise returns an array with one or two elements. The first element is always the number
   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true).
   *
   */
  static async update(values, options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = this._paranoidClause(this, _.defaults(options, {
      validate: true,
      hooks: true,
      individualHooks: false,
      returning: false,
      force: false,
      sideEffects: true
    }));

    options.type = QueryTypes.BULKUPDATE;

    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    // Remove values that are not in the options.fields
    if (options.fields && options.fields instanceof Array) {
      for (const key of Object.keys(values)) {
        if (!options.fields.includes(key)) {
          delete values[key];
        }
      }
    } else {
      const updatedAtAttr = this._timestampAttributes.updatedAt;
      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));
      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {
        options.fields.push(updatedAtAttr);
      }
    }

    if (this._timestampAttributes.updatedAt && !options.silent) {
      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);
    }

    options.model = this;

    let valuesUse;
    // Validate
    if (options.validate) {
      const build = this.build(values);
      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });

      if (options.sideEffects) {
        Object.assign(values, _.pick(build.get(), build.changed()));
        options.fields = _.union(options.fields, Object.keys(values));
      }

      // We want to skip validations for all other fields
      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));
      const attributes = await build.validate(options);
      options.skip = undefined;
      if (attributes && attributes.dataValues) {
        values = _.pick(attributes.dataValues, Object.keys(values));
      }
    }
    // Run before hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('beforeBulkUpdate', options);
      values = options.attributes;
      delete options.attributes;
    }

    valuesUse = values;

    // Get instances and run beforeUpdate hook on each record individually
    let instances;
    let updateDoneRowByRow = false;
    if (options.individualHooks) {
      instances = await this.findAll({
        where: options.where,
        transaction: options.transaction,
        logging: options.logging,
        benchmark: options.benchmark,
        paranoid: options.paranoid
      });

      if (instances.length) {
        // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly
        // i.e. whether they change values for each record in the same way
        let changedValues;
        let different = false;

        instances = await Promise.all(instances.map(async instance => {
          // Record updates in instances dataValues
          Object.assign(instance.dataValues, values);
          // Set the changed fields on the instance
          _.forIn(valuesUse, (newValue, attr) => {
            if (newValue !== instance._previousDataValues[attr]) {
              instance.setDataValue(attr, newValue);
            }
          });

          // Run beforeUpdate hook
          await this.runHooks('beforeUpdate', instance, options);
          if (!different) {
            const thisChangedValues = {};
            _.forIn(instance.dataValues, (newValue, attr) => {
              if (newValue !== instance._previousDataValues[attr]) {
                thisChangedValues[attr] = newValue;
              }
            });

            if (!changedValues) {
              changedValues = thisChangedValues;
            } else {
              different = !_.isEqual(changedValues, thisChangedValues);
            }
          }

          return instance;
        }));

        if (!different) {
          const keys = Object.keys(changedValues);
          // Hooks do not change values or change them uniformly
          if (keys.length) {
            // Hooks change values - record changes in valuesUse so they are executed
            valuesUse = changedValues;
            options.fields = _.union(options.fields, keys);
          }
        } else {
          instances = await Promise.all(instances.map(async instance => {
            const individualOptions = {
              ...options,
              hooks: false,
              validate: false
            };
            delete individualOptions.individualHooks;

            return instance.save(individualOptions);
          }));
          updateDoneRowByRow = true;
        }
      }
    }
    let result;
    if (updateDoneRowByRow) {
      result = [instances.length, instances];
    } else if (_.isEmpty(valuesUse)
       || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {
      // only updatedAt is being passed, then skip update
      result = [0];
    } else {
      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);
      options = Utils.mapOptionFieldNames(options, this);
      options.hasTrigger = this.options ? this.options.hasTrigger : false;

      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);
      if (options.returning) {
        result = [affectedRows.length, affectedRows];
        instances = affectedRows;
      } else {
        result = [affectedRows];
      }
    }

    if (options.individualHooks) {
      await Promise.all(instances.map(instance => this.runHooks('afterUpdate', instance, options)));
      result[1] = instances;
    }
    // Run after hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('afterBulkUpdate', options);
      delete options.attributes;
    }
    return result;
  }

  /**
   * Run a describe query on the table.
   *
   * @param {string} [schema] schema name to search table in
   * @param {object} [options] query options
   *
   * @returns {Promise} hash of attributes and their types
   */
  static async describe(schema, options) {
    return await this.queryInterface.describeTable(this.tableName, { schema: schema || this._schema || undefined, ...options });
  }

  static _getDefaultTimestamp(attr) {
    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {
      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);
    }
    return undefined;
  }

  static _expandAttributes(options) {
    if (!_.isPlainObject(options.attributes)) {
      return;
    }
    let attributes = Object.keys(this.rawAttributes);

    if (options.attributes.exclude) {
      attributes = attributes.filter(elem => !options.attributes.exclude.includes(elem));
    }

    if (options.attributes.include) {
      attributes = attributes.concat(options.attributes.include);
    }

    options.attributes = attributes;
  }

  // Inject _scope into options.
  static _injectScope(options) {
    const scope = Utils.cloneDeep(this._scope);
    this._defaultsOptions(options, scope);
  }

  static [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.name;
  }

  static hasAlias(alias) {
    return Object.prototype.hasOwnProperty.call(this.associations, alias);
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ``` SET column = column + X WHERE foo = 'bar' ``` query. To get the correct value after an increment into the Instance you should do a reload.
   *
   * @example <caption>increment number by 1</caption>
   * Model.increment('number', { where: { foo: 'bar' });
   *
   * @example <caption>increment number and count by 2</caption>
   * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>increment answer by 42, and decrement tries by 1</caption>
   * // `by` is ignored, as each column has its own value
   * Model.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @see
   * {@link Model#reload}
   *
   * @param  {string|Array|object}  fields                       If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param  {object}               options                      increment options
   * @param  {object}               options.where                conditions hash
   * @param  {number}               [options.by=1]               The number to increment by
   * @param  {boolean}              [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {Function}             [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {Transaction}          [options.transaction]        Transaction to run query under
   * @param  {string}               [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async increment(fields, options) {
    options = options || {};
    if (typeof fields === 'string') fields = [fields];
    if (Array.isArray(fields)) {
      fields = fields.map(f => {
        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {
          return this.rawAttributes[f].field;
        }
        return f;
      });
    }

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = Utils.defaults({}, options, {
      by: 1,
      where: {},
      increment: true
    });
    const isSubtraction = !options.increment;

    Utils.mapOptionFieldNames(options, this);

    const where = { ...options.where };

    // A plain object whose keys are the fields to be incremented and whose values are
    // the amounts to be incremented by.
    let incrementAmountsByField = {};
    if (Array.isArray(fields)) {
      incrementAmountsByField = {};
      for (const field of fields) {
        incrementAmountsByField[field] = options.by;
      }
    } else {
      // If the `fields` argument is not an array, then we assume it already has the
      // form necessary to be placed directly in the `incrementAmountsByField` variable.
      incrementAmountsByField = fields;
    }

    // If optimistic locking is enabled, we can take advantage that this is an
    // increment/decrement operation and send it here as well. We put `-1` for
    // decrementing because it will be subtracted, getting `-(-1)` which is `+1`
    if (this._versionAttribute) {
      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;
    }

    const extraAttributesToBeUpdated = {};

    const updatedAtAttr = this._timestampAttributes.updatedAt;
    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {
      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);
    }

    const tableName = this.getTableName(options);
    let affectedRows;
    if (isSubtraction) {
      affectedRows = await this.queryInterface.decrement(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    } else {
      affectedRows = await this.queryInterface.increment(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    }

    if (options.returning) {
      return [affectedRows, affectedRows.length];
    }

    return [affectedRows];
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance you should do a reload.
   *
   * @example <caption>decrement number by 1</caption>
   * Model.decrement('number', { where: { foo: 'bar' });
   *
   * @example <caption>decrement number and count by 2</caption>
   * Model.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>decrement answer by 42, and decrement tries by -1</caption>
   * // `by` is ignored, since each column has its own value
   * Model.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} options decrement options, similar to increment
   *
   * @see
   * {@link Model.increment}
   * @see
   * {@link Model#reload}
   * @since 4.36.0
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  static _optionsMustContainWhere(options) {
    assert(options && options.where, 'Missing where attribute in the options parameter');
    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod,
      'Expected plain object, array or sequelize method in the options.where parameter');
  }

  /**
   * Get an object representing the query for this instance, use with `options.where`
   *
   * @param {boolean} [checkVersion=false] include version attribute in where hash
   *
   * @returns {object}
   */
  where(checkVersion) {
    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {
      result[attribute] = this.get(attribute, { raw: true });
      return result;
    }, {});

    if (_.size(where) === 0) {
      return this.constructor.options.whereCollection;
    }
    const versionAttr = this.constructor._versionAttribute;
    if (checkVersion && versionAttr) {
      where[versionAttr] = this.get(versionAttr, { raw: true });
    }
    return Utils.mapWhereFieldNames(where, this.constructor);
  }

  toString() {
    return `[object SequelizeInstance:${this.constructor.name}]`;
  }

  /**
   * Get the value of the underlying data value
   *
   * @param {string} key key to look in instance data store
   *
   * @returns {any}
   */
  getDataValue(key) {
    return this.dataValues[key];
  }

  /**
   * Update the underlying data value
   *
   * @param {string} key key to set in instance data store
   * @param {any} value new value for given key
   *
   */
  setDataValue(key, value) {
    const originalValue = this._previousDataValues[key];

    if (!_.isEqual(value, originalValue)) {
      this.changed(key, true);
    }

    this.dataValues[key] = value;
  }

  /**
   * If no key is given, returns all values of the instance, also invoking virtual getters.
   *
   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.
   *
   * @param {string}  [key] key to get value of
   * @param {object}  [options] get options
   * @param {boolean} [options.plain=false] If set to true, included instances will be returned as plain objects
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   *
   * @returns {object|any}
   */
  get(key, options) {
    if (options === undefined && typeof key === 'object') {
      options = key;
      key = undefined;
    }

    options = options || {};

    if (key) {
      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {
        return this._customGetters[key].call(this, key, options);
      }

      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {
        if (Array.isArray(this.dataValues[key])) {
          return this.dataValues[key].map(instance => instance.get(options));
        }
        if (this.dataValues[key] instanceof Model) {
          return this.dataValues[key].get(options);
        }
        return this.dataValues[key];
      }

      return this.dataValues[key];
    }

    if (
      this._hasCustomGetters
      || options.plain && this._options.include
      || options.clone
    ) {
      const values = {};
      let _key;

      if (this._hasCustomGetters) {
        for (_key in this._customGetters) {
          if (
            this._options.attributes
            && !this._options.attributes.includes(_key)
          ) {
            continue;
          }

          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {
            values[_key] = this.get(_key, options);
          }
        }
      }

      for (_key in this.dataValues) {
        if (
          !Object.prototype.hasOwnProperty.call(values, _key)
          && Object.prototype.hasOwnProperty.call(this.dataValues, _key)
        ) {
          values[_key] = this.get(_key, options);
        }
      }

      return values;
    }

    return this.dataValues;
  }

  /**
   * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).
   * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function
   * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.
   *
   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be
   * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.
   *
   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).
   *
   * Set can also be used to build instances for associations, if you have values for those.
   * When using set with associations you need to make sure the property key matches the alias of the association
   * while also making sure that the proper include options have been set (from .build() or .findOne())
   *
   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.
   *
   * @see
   * {@link Model.findAll} for more information about includes
   *
   * @param {string|object} key key to set, it can be string or object. When string it will set that key, for object it will loop over all object properties nd set them.
   * @param {any} value value to set
   * @param {object} [options] set options
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   * @param {boolean} [options.reset=false] Clear all previously set data values
   *
   * @returns {Model}
   */
  set(key, value, options) {
    let values;
    let originalValue;

    if (typeof key === 'object' && key !== null) {
      values = key;
      options = value || {};

      if (options.reset) {
        this.dataValues = {};
        for (const key in values) {
          this.changed(key, false);
        }
      }

      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object
      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {
        if (Object.keys(this.dataValues).length) {
          Object.assign(this.dataValues, values);
        } else {
          this.dataValues = values;
        }
        // If raw, .changed() shouldn't be true
        this._previousDataValues = { ...this.dataValues };
      } else {
        // Loop and call set
        if (options.attributes) {
          const setKeys = data => {
            for (const k of data) {
              if (values[k] === undefined) {
                continue;
              }
              this.set(k, values[k], options);
            }
          };
          setKeys(options.attributes);
          if (this.constructor._hasVirtualAttributes) {
            setKeys(this.constructor._virtualAttributes);
          }
          if (this._options.includeNames) {
            setKeys(this._options.includeNames);
          }
        } else {
          for (const key in values) {
            this.set(key, values[key], options);
          }
        }

        if (options.raw) {
          // If raw, .changed() shouldn't be true
          this._previousDataValues = { ...this.dataValues };
        }
      }
      return this;
    }
    if (!options)
      options = {};
    if (!options.raw) {
      originalValue = this.dataValues[key];
    }

    // If not raw, and there's a custom setter
    if (!options.raw && this._customSetters[key]) {
      this._customSetters[key].call(this, value, key);
      // custom setter should have changed value, get that changed value
      // TODO: v5 make setters return new value instead of changing internal store
      const newValue = this.dataValues[key];
      if (!_.isEqual(newValue, originalValue)) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }
    } else {
      // Check if we have included models, and if this key matches the include model names/aliases
      if (this._options && this._options.include && this._options.includeNames.includes(key)) {
        // Pass it on to the include handler
        this._setInclude(key, value, options);
        return this;
      }
      // Bunch of stuff we won't do when it's raw
      if (!options.raw) {
        // If attribute is not in model definition, return
        if (!this._isAttribute(key)) {
          if (key.includes('.') && this.constructor._jsonAttributes.has(key.split('.')[0])) {
            const previousNestedValue = Dottie.get(this.dataValues, key);
            if (!_.isEqual(previousNestedValue, value)) {
              Dottie.set(this.dataValues, key, value);
              this.changed(key.split('.')[0], true);
            }
          }
          return this;
        }

        // If attempting to set primary key and primary key is already defined, return
        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {
          return this;
        }

        // If attempting to set read only attributes, return
        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {
          return this;
        }
      }

      // If there's a data type sanitizer
      if (
        !(value instanceof Utils.SequelizeMethod)
        && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)
      ) {
        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);
      }

      // Set when the value has changed and not raw
      if (
        !options.raw &&
        (
          // True when sequelize method
          (value instanceof Utils.SequelizeMethod ||
          // Check for data type type comparators
          !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || // Check default
          !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))
        )
      ) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }

      // set data value
      this.dataValues[key] = value;
    }
    return this;
  }

  setAttributes(updates) {
    return this.set(updates);
  }

  /**
   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.
   *
   * If changed is called without an argument, it will return an array of keys that have changed.
   *
   * If changed is called without an argument and no keys have changed, it will return `false`.
   *
   * Please note that this function will return `false` when a property from a nested (for example JSON) property
   * was edited manually, you must call `changed('key', true)` manually in these cases.
   * Writing an entirely new object (eg. deep cloned) will be detected.
   *
   * @example
   * ```
   * const mdl = await MyModel.findOne();
   * mdl.myJsonField.a = 1;
   * console.log(mdl.changed()) => false
   * mdl.save(); // this will not save anything
   * mdl.changed('myJsonField', true);
   * console.log(mdl.changed()) => ['myJsonField']
   * mdl.save(); // will save
   * ```
   *
   * @param {string} [key] key to check or change status of
   * @param {any} [value] value to set
   *
   * @returns {boolean|Array}
   */
  changed(key, value) {
    if (key === undefined) {
      if (this._changed.size > 0) {
        return Array.from(this._changed);
      }
      return false;
    }
    if (value === true) {
      this._changed.add(key);
      return this;
    }
    if (value === false) {
      this._changed.delete(key);
      return this;
    }
    return this._changed.has(key);
  }

  /**
   * Returns the previous value for key from `_previousDataValues`.
   *
   * If called without a key, returns the previous values for all values which have changed
   *
   * @param {string} [key] key to get previous value of
   *
   * @returns {any|Array<any>}
   */
  previous(key) {
    if (key) {
      return this._previousDataValues[key];
    }

    return _.pickBy(this._previousDataValues, (value, key) => this.changed(key));
  }

  _setInclude(key, value, options) {
    if (!Array.isArray(value)) value = [value];
    if (value[0] instanceof Model) {
      value = value.map(instance => instance.dataValues);
    }

    const include = this._options.includeMap[key];
    const association = include.association;
    const accessor = key;
    const primaryKeyAttribute = include.model.primaryKeyAttribute;
    const childOptions = {
      isNewRecord: this.isNewRecord,
      include: include.include,
      includeNames: include.includeNames,
      includeMap: include.includeMap,
      includeValidated: true,
      raw: options.raw,
      attributes: include.originalAttributes
    };
    let isEmpty;

    if (include.originalAttributes === undefined || include.originalAttributes.length) {
      if (association.isSingleAssociation) {
        if (Array.isArray(value)) {
          value = value[0];
        }
        isEmpty = value && value[primaryKeyAttribute] === null || value === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);
      } else {
        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);
      }
    }
  }

  /**
   * Validates this instance, and if the validation passes, persists it to the database.
   *
   * Returns a Promise that resolves to the saved instance (or rejects with a `Sequelize.ValidationError`, which will have a property for each of the fields for which the validation failed, with the error message for that field).
   *
   * This method is optimized to perform an UPDATE only into the fields that changed. If nothing has changed, no SQL query will be performed.
   *
   * This method is not aware of eager loaded associations. In other words, if some other model instance (child) was eager loaded with this instance (parent), and you change something in the child, calling `save()` will simply ignore the change that happened on the child.
   *
   * @param {object}      [options] save options
   * @param {string[]}    [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {boolean}     [options.validate=true] If false, validations won't be run.
   * @param {boolean}     [options.hooks=true] Run before and after create / update + validate hooks
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   */
  async save(options) {
    if (arguments.length > 1) {
      throw new Error('The second argument was removed in favor of the options object.');
    }

    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      hooks: true,
      validate: true
    });

    if (!options.fields) {
      if (this.isNewRecord) {
        options.fields = Object.keys(this.constructor.rawAttributes);
      } else {
        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));
      }

      options.defaultFields = options.fields;
    }

    if (options.returning === undefined) {
      if (options.association) {
        options.returning = false;
      } else if (this.isNewRecord) {
        options.returning = true;
      }
    }

    const primaryKeyName = this.constructor.primaryKeyAttribute;
    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];
    const createdAtAttr = this.constructor._timestampAttributes.createdAt;
    const versionAttr = this.constructor._versionAttribute;
    const hook = this.isNewRecord ? 'Create' : 'Update';
    const wasNewRecord = this.isNewRecord;
    const now = Utils.now(this.sequelize.options.dialect);
    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;

    if (updatedAtAttr && options.fields.length >= 1 && !options.fields.includes(updatedAtAttr)) {
      options.fields.push(updatedAtAttr);
    }
    if (versionAttr && options.fields.length >= 1 && !options.fields.includes(versionAttr)) {
      options.fields.push(versionAttr);
    }

    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {
      // UpdateAtAttr might have been added as a result of Object.keys(Model.rawAttributes). In that case we have to remove it again
      _.remove(options.fields, val => val === updatedAtAttr);
      updatedAtAttr = false;
    }

    if (this.isNewRecord === true) {
      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {
        options.fields.push(createdAtAttr);
      }

      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {
        options.fields.unshift(primaryKeyName);
      }
    }

    if (this.isNewRecord === false) {
      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === undefined) {
        throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');
      }
    }

    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {
      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;
    }

    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {
      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;
    }

    // Validate
    if (options.validate) {
      await this.validate(options);
    }
    // Run before hook
    if (options.hooks) {
      const beforeHookValues = _.pick(this.dataValues, options.fields);
      let ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values
      let hookChanged;
      let afterHookValues;

      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {
        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);
      }

      await this.constructor.runHooks(`before${hook}`, this, options);
      if (options.defaultFields && !this.isNewRecord) {
        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));

        hookChanged = [];
        for (const key of Object.keys(afterHookValues)) {
          if (afterHookValues[key] !== beforeHookValues[key]) {
            hookChanged.push(key);
          }
        }

        options.fields = _.uniq(options.fields.concat(hookChanged));
      }

      if (hookChanged) {
        if (options.validate) {
          // Validate again

          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);
          await this.validate(options);
          delete options.skip;
        }
      }
    }
    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(this._options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
        const instance = this.get(include.as);
        if (!instance) return;

        const includeOptions = _(Utils.cloneDeep(include))
          .omit(['association'])
          .defaults({
            transaction: options.transaction,
            logging: options.logging,
            parentRecord: this
          }).value();

        await instance.save(includeOptions);

        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });
      }));
    }
    const realFields = options.fields.filter(field => !this.constructor._virtualAttributes.has(field));
    if (!realFields.length) return this;
    if (!this.changed() && !this.isNewRecord) return this;

    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], 'field') || versionAttr;
    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);
    let query = null;
    let args = [];
    let where;

    if (this.isNewRecord) {
      query = 'insert';
      args = [this, this.constructor.getTableName(options), values, options];
    } else {
      where = this.where(true);
      if (versionAttr) {
        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;
      }
      query = 'update';
      args = [this, this.constructor.getTableName(options), values, where, options];
    }

    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);
    if (versionAttr) {
      // Check to see that a row was updated, otherwise it's an optimistic locking error.
      if (rowsUpdated < 1) {
        throw new sequelizeErrors.OptimisticLockError({
          modelName: this.constructor.name,
          values,
          where
        });
      } else {
        result.dataValues[versionAttr] = values[versionFieldName];
      }
    }

    // Transfer database generated values (defaults, autoincrement, etc)
    for (const attr of Object.keys(this.constructor.rawAttributes)) {
      if (this.constructor.rawAttributes[attr].field &&
          values[this.constructor.rawAttributes[attr].field] !== undefined &&
          this.constructor.rawAttributes[attr].field !== attr
      ) {
        values[attr] = values[this.constructor.rawAttributes[attr].field];
        delete values[this.constructor.rawAttributes[attr].field];
      }
    }
    Object.assign(values, result.dataValues);

    Object.assign(result.dataValues, values);
    if (wasNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(
        this._options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          let instances = this.get(include.as);

          if (!instances) return;
          if (!Array.isArray(instances)) instances = [instances];

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging,
              parentRecord: this
            }).value();

          // Instances will be updated in place so we can safely treat HasOne like a HasMany
          await Promise.all(instances.map(async instance => {
            if (include.association instanceof BelongsToMany) {
              await instance.save(includeOptions);
              const values0 = {
                [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };

              if (instance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof instance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values0[attr] = instance[include.association.through.model.name][attr];
                }
              }

              await include.association.throughModel.create(values0, includeOptions);
            } else {
              instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
              Object.assign(instance, include.association.scope);
              await instance.save(includeOptions);
            }
          }));
        })
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks(`after${hook}`, result, options);
    }
    for (const field of options.fields) {
      result._previousDataValues[field] = result.dataValues[field];
      this.changed(field, false);
    }
    this.isNewRecord = false;

    return result;
  }

  /**
   * Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.
   * This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,
   * all references to the Instance are updated with the new data and no new objects are created.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} [options] Options that are passed on to `Model.find`
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   *
   * @returns {Promise<Model>}
   */
  async reload(options) {
    options = Utils.defaults({
      where: this.where()
    }, options, {
      include: this._options.include || undefined
    });

    const reloaded = await this.constructor.findOne(options);
    if (!reloaded) {
      throw new sequelizeErrors.InstanceError(
        'Instance could not be reloaded because it does not exist anymore (find call returned null)'
      );
    }
    // update the internal options of the instance
    this._options = reloaded._options;
    // re-set instance values
    this.set(reloaded.dataValues, {
      raw: true,
      reset:  true && !options.attributes
    });

    return this;
  }

  /**
  * Validate the attributes of this instance according to validation rules set in the model definition.
  *
  * The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.
  *
  * @param {object} [options] Options that are passed to the validator
  * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated
  * @param {Array} [options.fields] An array of strings. Only the properties that are in this array will be validated
  * @param {boolean} [options.hooks=true] Run before and after validate hooks
  *
  * @returns {Promise}
  */
  async validate(options) {
    return new InstanceValidator(this, options).validate();
  }

  /**
   * This is the same as calling `set` and then calling `save` but it only saves the
   * exact values passed to it, making it more atomic and safer.
   *
   * @see
   * {@link Model#set}
   * @see
   * {@link Model#save}
   *
   * @param {object} values See `set`
   * @param {object} options See `save`
   *
   * @returns {Promise<Model>}
   */
  async update(values, options) {
    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    const changedBefore = this.changed() || [];

    options = options || {};
    if (Array.isArray(options)) options = { fields: options };

    options = Utils.cloneDeep(options);
    const setOptions = Utils.cloneDeep(options);
    setOptions.attributes = options.fields;
    this.set(values, setOptions);

    // Now we need to figure out which fields were actually affected by the setter.
    const sideEffects = _.without(this.changed(), ...changedBefore);
    const fields = _.union(Object.keys(values), sideEffects);

    if (!options.fields) {
      options.fields = _.intersection(fields, this.changed());
      options.defaultFields = options.fields;
    }

    return await this.save(options);
  }

  /**
   * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.
   *
   * @param {object}      [options={}] destroy options
   * @param {boolean}     [options.force=false] If set to true, paranoid models will actually be deleted
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   */
  async destroy(options) {
    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeDestroy', this, options);
    }
    const where = this.where(true);

    let result;
    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {
      const attributeName = this.constructor._timestampAttributes.deletedAt;
      const attribute = this.constructor.rawAttributes[attributeName];
      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')
        ? attribute.defaultValue
        : null;
      const currentValue = this.getDataValue(attributeName);
      const undefinedOrNull = currentValue == null && defaultValue == null;
      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {
        // only update timestamp if it wasn't already set
        this.setDataValue(attributeName, new Date());
      }

      result = await this.save({ ...options, hooks: false });
    } else {
      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, { type: QueryTypes.DELETE, limit: null, ...options });
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterDestroy', this, options);
    }
    return result;
  }

  /**
   * Helper method to determine if a instance is "soft deleted".  This is
   * particularly useful if the implementer renamed the `deletedAt` attribute
   * to something different.  This method requires `paranoid` to be enabled.
   *
   * @returns {boolean}
   */
  isSoftDeleted() {
    if (!this.constructor._timestampAttributes.deletedAt) {
      throw new Error('Model is not paranoid');
    }

    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];
    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;
    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;
    const isSet = deletedAt !== defaultValue;

    return isSet;
  }

  /**
   * Restore the row corresponding to this instance. Only available for paranoid models.
   *
   * @param {object}      [options={}] restore options
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise}
   */
  async restore(options) {
    if (!this.constructor._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeRestore', this, options);
    }
    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    this.setDataValue(deletedAtCol, deletedAtDefaultValue);
    const result = await this.save({ ...options, hooks: false, omitNull: false });
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterRestore', this, options);
      return result;
    }
    return result;
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ```sql
   * SET column = column + X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.increment('number') // increment number by 1
   *
   * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2
   *
   * // increment answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.increment({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} [options] options
   * @param {number} [options.by=1] The number to increment by
   * @param {boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   * @since 4.0.0
   */
  async increment(fields, options) {
    const identifier = this.where();

    options = Utils.cloneDeep(options);
    options.where = { ...options.where, ...identifier };
    options.instance = this;

    await this.constructor.increment(fields, options);

    return this;
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql
   * SET column = column - X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.decrement('number') // decrement number by 1
   *
   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2
   *
   * // decrement answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.decrement({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   * @param {string|Array|object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given
   * @param {object}      [options] decrement options
   * @param {number}      [options.by=1] The number to decrement by
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise}
   */
  async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  /**
   * Check whether this and `other` Instance refer to the same row
   *
   * @param {Model} other Other instance to compare against
   *
   * @returns {boolean}
   */
  equals(other) {
    if (!other || !other.constructor) {
      return false;
    }

    if (!(other instanceof this.constructor)) {
      return false;
    }

    return this.constructor.primaryKeyAttributes.every(attribute => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));
  }

  /**
   * Check if this is equal to one of `others` by calling equals
   *
   * @param {Array<Model>} others An array of instances to check against
   *
   * @returns {boolean}
   */
  equalsOneOf(others) {
    return others.some(other => this.equals(other));
  }

  setValidators(attribute, validators) {
    this.validators[attribute] = validators;
  }

  /**
   * Convert the instance to a JSON representation.
   * Proxies to calling `get` with no keys.
   * This means get all values gotten from the DB, and apply all custom getters.
   *
   * @see
   * {@link Model#get}
   *
   * @returns {object}
   */
  toJSON() {
    return _.cloneDeep(
      this.get({
        plain: true
      })
    );
  }

  /**
   * Creates a 1:m association between this (the source) and the provided target.
   * The foreign key is added on the target.
   *
   * @param {Model}               target Target model
   * @param {object}              [options] hasMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string|object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}              [options.onUpdate='CASCADE'] Set `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {HasMany}
   *
   * @example
   * User.hasMany(Profile) // This will add userId to the profile table
   */
  static hasMany(target, options) {} // eslint-disable-line

  /**
   * Create an N:M association with a join table. Defining `through` is required.
   *
   * @param {Model}               target Target model
   * @param {object}              options belongsToMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {Model|string|object} options.through The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.
   * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.
   * @param {object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)
   * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)
   * @param {string|object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string|object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m
   * @param {string}              [options.onUpdate='CASCADE'] Sets `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsToMany}
   *
   * @example
   * // Automagically generated join model
   * User.belongsToMany(Project, { through: 'UserProjects' })
   * Project.belongsToMany(User, { through: 'UserProjects' })
   *
   * // Join model with additional attributes
   * const UserProjects = sequelize.define('UserProjects', {
   *   started: Sequelize.BOOLEAN
   * })
   * User.belongsToMany(Project, { through: UserProjects })
   * Project.belongsToMany(User, { through: UserProjects })
   */
  static belongsToMany(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the target.
   *
   * @param {Model}           target Target model
   * @param {object}          [options] hasOne association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}          [options.sourceKey] The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   * @param {string}          [options.uniqueKey] The custom name for unique constraint.
   *
   * @returns {HasOne}
   *
   * @example
   * User.hasOne(Profile) // This will add userId to the profile table
   */
  static hasOne(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the source.
   *
   * @param {Model}           target The target model
   * @param {object}          [options] belongsTo association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {string}          [options.targetKey] The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsTo}
   *
   * @example
   * Profile.belongsTo(User) // This will add userId to the profile table
   */
  static belongsTo(target, options) {} // eslint-disable-line
}

Object.assign(Model, associationsMixin);
Hooks.applyTo(Model, true);

module.exports = Model;


/***/ }),

/***/ "./node_modules/sequelize/lib/operators.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/operators.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * Operator symbols to be used when querying data
 *
 * @see {@link Model#where}
 *
 * @property eq
 * @property ne
 * @property gte
 * @property gt
 * @property lte
 * @property lt
 * @property not
 * @property is
 * @property in
 * @property notIn
 * @property like
 * @property notLike
 * @property iLike
 * @property notILike
 * @property startsWith
 * @property endsWith
 * @property substring
 * @property regexp
 * @property notRegexp
 * @property iRegexp
 * @property notIRegexp
 * @property between
 * @property notBetween
 * @property overlap
 * @property contains
 * @property contained
 * @property adjacent
 * @property strictLeft
 * @property strictRight
 * @property noExtendRight
 * @property noExtendLeft
 * @property and
 * @property or
 * @property any
 * @property all
 * @property values
 * @property col
 * @property placeholder
 * @property join
 */
const Op = {
  eq: Symbol.for('eq'),
  ne: Symbol.for('ne'),
  gte: Symbol.for('gte'),
  gt: Symbol.for('gt'),
  lte: Symbol.for('lte'),
  lt: Symbol.for('lt'),
  not: Symbol.for('not'),
  is: Symbol.for('is'),
  in: Symbol.for('in'),
  notIn: Symbol.for('notIn'),
  like: Symbol.for('like'),
  notLike: Symbol.for('notLike'),
  iLike: Symbol.for('iLike'),
  notILike: Symbol.for('notILike'),
  startsWith: Symbol.for('startsWith'),
  endsWith: Symbol.for('endsWith'),
  substring: Symbol.for('substring'),
  regexp: Symbol.for('regexp'),
  notRegexp: Symbol.for('notRegexp'),
  iRegexp: Symbol.for('iRegexp'),
  notIRegexp: Symbol.for('notIRegexp'),
  between: Symbol.for('between'),
  notBetween: Symbol.for('notBetween'),
  overlap: Symbol.for('overlap'),
  contains: Symbol.for('contains'),
  contained: Symbol.for('contained'),
  adjacent: Symbol.for('adjacent'),
  strictLeft: Symbol.for('strictLeft'),
  strictRight: Symbol.for('strictRight'),
  noExtendRight: Symbol.for('noExtendRight'),
  noExtendLeft: Symbol.for('noExtendLeft'),
  and: Symbol.for('and'),
  or: Symbol.for('or'),
  any: Symbol.for('any'),
  all: Symbol.for('all'),
  values: Symbol.for('values'),
  col: Symbol.for('col'),
  placeholder: Symbol.for('placeholder'),
  join: Symbol.for('join'),
  match: Symbol.for('match')
};

module.exports = Op;


/***/ }),

/***/ "./node_modules/sequelize/lib/query-types.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/query-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of query types used by `sequelize.query`
 *
 * @see {@link Sequelize#query}
 *
 * @property SELECT
 * @property INSERT
 * @property UPDATE
 * @property BULKUPDATE
 * @property BULKDELETE
 * @property DELETE
 * @property UPSERT
 * @property VERSION
 * @property SHOWTABLES
 * @property SHOWINDEXES
 * @property DESCRIBE
 * @property RAW
 * @property FOREIGNKEYS
 * @property SHOWCONSTRAINTS
 */
const QueryTypes = module.exports = { // eslint-disable-line
  SELECT: 'SELECT',
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  BULKUPDATE: 'BULKUPDATE',
  BULKDELETE: 'BULKDELETE',
  DELETE: 'DELETE',
  UPSERT: 'UPSERT',
  VERSION: 'VERSION',
  SHOWTABLES: 'SHOWTABLES',
  SHOWINDEXES: 'SHOWINDEXES',
  DESCRIBE: 'DESCRIBE',
  RAW: 'RAW',
  FOREIGNKEYS: 'FOREIGNKEYS',
  SHOWCONSTRAINTS: 'SHOWCONSTRAINTS'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/sequelize.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/sequelize.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const retry = __webpack_require__(/*! retry-as-promised */ "./node_modules/retry-as-promised/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const Model = __webpack_require__(/*! ./model */ "./node_modules/sequelize/lib/model.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Deferrable = __webpack_require__(/*! ./deferrable */ "./node_modules/sequelize/lib/deferrable.js");
const ModelManager = __webpack_require__(/*! ./model-manager */ "./node_modules/sequelize/lib/model-manager.js");
const Transaction = __webpack_require__(/*! ./transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const TableHints = __webpack_require__(/*! ./table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const IndexHints = __webpack_require__(/*! ./index-hints */ "./node_modules/sequelize/lib/index-hints.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const Association = __webpack_require__(/*! ./associations/index */ "./node_modules/sequelize/lib/associations/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const deprecations = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");

/**
 * This is the main class, the entry point to sequelize.
 */
class Sequelize {
  /**
   * Instantiate sequelize with name of database, username and password.
   *
   * @example
   * // without password / with blank password
   * const sequelize = new Sequelize('database', 'username', null, {
   *   dialect: 'mysql'
   * })
   *
   * // with password and options
   * const sequelize = new Sequelize('my_database', 'john', 'doe', {
   *   dialect: 'postgres'
   * })
   *
   * // with database, username, and password in the options object
   * const sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });
   *
   * // with uri
   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})
   *
   * // option examples
   * const sequelize = new Sequelize('database', 'username', 'password', {
   *   // the sql dialect of the database
   *   // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'
   *   dialect: 'mysql',
   *
   *   // custom host; default: localhost
   *   host: 'my.server.tld',
   *   // for postgres, you can also specify an absolute path to a directory
   *   // containing a UNIX socket to connect over
   *   // host: '/sockets/psql_sockets'.
   *
   *   // custom port; default: dialect default
   *   port: 12345,
   *
   *   // custom protocol; default: 'tcp'
   *   // postgres only, useful for Heroku
   *   protocol: null,
   *
   *   // disable logging or provide a custom logging function; default: console.log
   *   logging: false,
   *
   *   // you can also pass any dialect options to the underlying dialect library
   *   // - default is empty
   *   // - currently supported: 'mysql', 'postgres', 'mssql'
   *   dialectOptions: {
   *     socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',
   *     supportBigNumbers: true,
   *     bigNumberStrings: true
   *   },
   *
   *   // the storage engine for sqlite
   *   // - default ':memory:'
   *   storage: 'path/to/database.sqlite',
   *
   *   // disable inserting undefined values as NULL
   *   // - default: false
   *   omitNull: true,
   *
   *   // a flag for using a native library or not.
   *   // in the case of 'pg' -- set this to true will allow SSL support
   *   // - default: false
   *   native: true,
   *
   *   // Specify options, which are used when sequelize.define is called.
   *   // The following example:
   *   //   define: { timestamps: false }
   *   // is basically the same as:
   *   //   Model.init(attributes, { timestamps: false });
   *   //   sequelize.define(name, attributes, { timestamps: false });
   *   // so defining the timestamps for each model will be not necessary
   *   define: {
   *     underscored: false,
   *     freezeTableName: false,
   *     charset: 'utf8',
   *     dialectOptions: {
   *       collate: 'utf8_general_ci'
   *     },
   *     timestamps: true
   *   },
   *
   *   // similar for sync: you can define this to always force sync for models
   *   sync: { force: true },
   *
   *   // pool configuration used to pool database connections
   *   pool: {
   *     max: 5,
   *     idle: 30000,
   *     acquire: 60000,
   *   },
   *
   *   // isolation level of each transaction
   *   // defaults to dialect default
   *   isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
   * })
   *
   * @param {string}   [database] The name of the database
   * @param {string}   [username=null] The username which is used to authenticate against the database.
   * @param {string}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.
   * @param {object}   [options={}] An object with options.
   * @param {string}   [options.host='localhost'] The host of the relational database.
   * @param {number}   [options.port=] The port of the relational database.
   * @param {string}   [options.username=null] The username which is used to authenticate against the database.
   * @param {string}   [options.password=null] The password which is used to authenticate against the database.
   * @param {string}   [options.database=null] The name of the database
   * @param {string}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.
   * @param {string}   [options.dialectModule=null] If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require("pg.js")' here
   * @param {string}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here
   * @param {object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library
   * @param {string}   [options.storage] Only used by sqlite. Defaults to ':memory:'
   * @param {string}   [options.protocol='tcp'] The protocol of the relational database.
   * @param {object}   [options.define={}] Default options for model definitions. See {@link Model.init}.
   * @param {object}   [options.query={}] Default options for sequelize.query
   * @param {string}   [options.schema=null] A schema to use
   * @param {object}   [options.set={}] Default options for sequelize.set
   * @param {object}   [options.sync={}] Default options for sequelize.sync
   * @param {string}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.
   * @param {string|boolean} [options.clientMinMessages='warning'] The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default.
   * @param {boolean}  [options.standardConformingStrings=true] The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something. Function may receive multiple parameters but only first one is printed by `console.log`. To print all values use `(...msg) => console.log(msg)`
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {boolean}  [options.omitNull=false] A flag that defines if null values should be passed as values to CREATE/UPDATE SQL queries or not.
   * @param {boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   * @param {boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`
   * @param {object}   [options.pool] sequelize connection pool configuration
   * @param {number}   [options.pool.max=5] Maximum number of connection in pool
   * @param {number}   [options.pool.min=0] Minimum number of connection in pool
   * @param {number}   [options.pool.idle=10000] The maximum time, in milliseconds, that a connection can be idle before being released.
   * @param {number}   [options.pool.acquire=60000] The maximum time, in milliseconds, that pool will try to get connection before throwing error
   * @param {number}   [options.pool.evict=1000] The time interval, in milliseconds, after which sequelize-pool will remove idle connections.
   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected
   * @param {number}   [options.pool.maxUses=Infinity] The number of times a connection can be used before discarding it for a replacement, [`used for eventual cluster rebalancing`](https://github.com/sequelize/sequelize-pool).
   * @param {boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {string}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.
   * @param {object}   [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {number}   [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.
   * @param {boolean}  [options.typeValidation=false] Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.
   * @param {object}   [options.operatorsAliases] String based operator alias. Pass object to limit set of aliased operators.
   * @param {object}   [options.hooks] An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here.
   * @param {boolean}  [options.minifyAliases=false] A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)
   * @param {boolean}  [options.logQueryParameters=false] A flag that defines if show bind parameters in log.
   */
  constructor(database, username, password, options) {
    let config;

    if (arguments.length === 1 && typeof database === 'object') {
      // new Sequelize({ ... options })
      options = database;
      config = _.pick(options, 'host', 'port', 'database', 'username', 'password');
    } else if (arguments.length === 1 && typeof database === 'string' || arguments.length === 2 && typeof username === 'object') {
      // new Sequelize(URI, { ... options })

      config = {};
      options = username || {};

      const urlParts = url.parse(arguments[0], true);

      options.dialect = urlParts.protocol.replace(/:$/, '');
      options.host = urlParts.hostname;

      if (options.dialect === 'sqlite' && urlParts.pathname && !urlParts.pathname.startsWith('/:memory')) {
        const storagePath = path.join(options.host, urlParts.pathname);
        options.storage = path.resolve(options.storage || storagePath);
      }

      if (urlParts.pathname) {
        config.database = urlParts.pathname.replace(/^\//, '');
      }

      if (urlParts.port) {
        options.port = urlParts.port;
      }

      if (urlParts.auth) {
        const authParts = urlParts.auth.split(':');

        config.username = authParts[0];

        if (authParts.length > 1)
          config.password = authParts.slice(1).join(':');
      }

      if (urlParts.query) {
        // Allow host query argument to override the url host.
        // Enables specifying domain socket hosts which cannot be specified via the typical
        // host part of a url.
        if (urlParts.query.host) {
          options.host = urlParts.query.host;
        }

        if (options.dialectOptions) {
          Object.assign(options.dialectOptions, urlParts.query);
        } else {
          options.dialectOptions = urlParts.query;
          if (urlParts.query.options) {
            try {
              const o = JSON.parse(urlParts.query.options);
              options.dialectOptions.options = o;
            } catch (e) {
              // Nothing to do, string is not a valid JSON
              // an thus does not need any further processing
            }
          }
        }
      }
    } else {
      // new Sequelize(database, username, password, { ... options })
      options = options || {};
      config = { database, username, password };
    }

    Sequelize.runHooks('beforeInit', config, options);

    this.options = {
      dialect: null,
      dialectModule: null,
      dialectModulePath: null,
      host: 'localhost',
      protocol: 'tcp',
      define: {},
      query: {},
      sync: {},
      timezone: '+00:00',
      clientMinMessages: 'warning',
      standardConformingStrings: true,
      // eslint-disable-next-line no-console
      logging: console.log,
      omitNull: false,
      native: false,
      replication: false,
      ssl: undefined,
      pool: {},
      quoteIdentifiers: true,
      hooks: {},
      retry: {
        max: 5,
        match: [
          'SQLITE_BUSY: database is locked'
        ]
      },
      transactionType: Transaction.TYPES.DEFERRED,
      isolationLevel: null,
      databaseVersion: 0,
      typeValidation: false,
      benchmark: false,
      minifyAliases: false,
      logQueryParameters: false,
      ...options
    };

    if (!this.options.dialect) {
      throw new Error('Dialect needs to be explicitly supplied as of v4.0.0');
    }

    if (this.options.dialect === 'postgresql') {
      this.options.dialect = 'postgres';
    }

    if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {
      throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');
    }

    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }

    this._setupHooks(options.hooks);

    this.config = {
      database: config.database || this.options.database,
      username: config.username || this.options.username,
      password: config.password || this.options.password || null,
      host: config.host || this.options.host,
      port: config.port || this.options.port,
      pool: this.options.pool,
      protocol: this.options.protocol,
      native: this.options.native,
      ssl: this.options.ssl,
      replication: this.options.replication,
      dialectModule: this.options.dialectModule,
      dialectModulePath: this.options.dialectModulePath,
      keepDefaultTimezone: this.options.keepDefaultTimezone,
      dialectOptions: this.options.dialectOptions
    };

    let Dialect;
    // Requiring the dialect in a switch-case to keep the
    // require calls static. (Browserify fix)
    switch (this.getDialect()) {
      case 'mariadb':
        Dialect = __webpack_require__(/*! ./dialects/mariadb */ "./node_modules/sequelize/lib/dialects/mariadb/index.js");
        break;
      case 'mssql':
        Dialect = __webpack_require__(/*! ./dialects/mssql */ "./node_modules/sequelize/lib/dialects/mssql/index.js");
        break;
      case 'mysql':
        Dialect = __webpack_require__(/*! ./dialects/mysql */ "./node_modules/sequelize/lib/dialects/mysql/index.js");
        break;
      case 'postgres':
        Dialect = __webpack_require__(/*! ./dialects/postgres */ "./node_modules/sequelize/lib/dialects/postgres/index.js");
        break;
      case 'sqlite':
        Dialect = __webpack_require__(/*! ./dialects/sqlite */ "./node_modules/sequelize/lib/dialects/sqlite/index.js");
        break;
      default:
        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, postgres, and sqlite.`);
    }

    this.dialect = new Dialect(this);
    this.dialect.queryGenerator.typeValidation = options.typeValidation;

    if (_.isPlainObject(this.options.operatorsAliases)) {
      deprecations.noStringOperators();
      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);
    } else if (typeof this.options.operatorsAliases === 'boolean') {
      deprecations.noBoolOperatorAliases();
    }

    this.queryInterface = this.dialect.queryInterface;

    /**
     * Models are stored here under the name given to `sequelize.define`
     */
    this.models = {};
    this.modelManager = new ModelManager(this);
    this.connectionManager = this.dialect.connectionManager;

    Sequelize.runHooks('afterInit', this);
  }

  /**
   * Refresh data types and parsers.
   *
   * @private
   */
  refreshTypes() {
    this.connectionManager.refreshTypeParser(DataTypes);
  }

  /**
   * Returns the specified dialect.
   *
   * @returns {string} The specified dialect.
   */
  getDialect() {
    return this.options.dialect;
  }

  /**
   * Returns the database name.
   *
   * @returns {string} The database name.
   */
  getDatabaseName() {
    return this.config.database;
  }

  /**
   * Returns an instance of QueryInterface.
   *
   * @returns {QueryInterface} An instance (singleton) of QueryInterface.
   */
  getQueryInterface() {
    return this.queryInterface;
  }

  /**
   * Define a new model, representing a table in the database.
   *
   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column
   *
   * @param {string} modelName The name of the model. The model will be stored in `sequelize.models` under this name
   * @param {object} attributes An object, where each attribute is a column of the table. See {@link Model.init}
   * @param {object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()
   *
   * @see
   * {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @returns {Model} Newly defined model
   *
   * @example
   * sequelize.define('modelName', {
   *   columnA: {
   *       type: Sequelize.BOOLEAN,
   *       validate: {
   *         is: ["[a-z]",'i'],        // will only allow letters
   *         max: 23,                  // only allow values <= 23
   *         isIn: {
   *           args: [['en', 'zh']],
   *           msg: "Must be English or Chinese"
   *         }
   *       },
   *       field: 'column_a'
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * });
   *
   * sequelize.models.modelName // The model will now be available in models under the name given to define
   */
  define(modelName, attributes, options = {}) {
    options.modelName = modelName;
    options.sequelize = this;

    const model = class extends Model {};

    model.init(attributes, options);

    return model;
  }

  /**
   * Fetch a Model which is already defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)
   * @returns {Model} Specified model
   */
  model(modelName) {
    if (!this.isDefined(modelName)) {
      throw new Error(`${modelName} has not been defined`);
    }

    return this.modelManager.getModel(modelName);
  }

  /**
   * Checks whether a model with the given name is defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @returns {boolean} Returns true if model is already defined, otherwise false
   */
  isDefined(modelName) {
    return !!this.modelManager.models.find(model => model.name === modelName);
  }

  /**
   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.
   *
   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.
   *
   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:
   *
   * ```js
   * const [results, metadata] = await sequelize.query('SELECT...'); // Raw query - use array destructuring
   *
   * const results = await sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }); // SELECT query - no destructuring
   * ```
   *
   * @param {string}          sql
   * @param {object}          [options={}] Query options.
   * @param {boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result
   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under
   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   * @param {boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified
   * @param {boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row
   * @param {object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.
   * @param {object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.
   * @param {boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Model}           [options.instance] A sequelize model instance whose Model is to be used to build the query result
   * @param {typeof Model}    [options.model] A sequelize model used to build the returned model instances
   * @param {object}          [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.
   * @param {string}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)
   * @param {boolean}         [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.
   * @param {object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.
   *
   * @returns {Promise}
   *
   * @see {@link Model.build} for more information about instance option.
   */

  async query(sql, options) {
    options = { ...this.options.query, ...options };

    if (options.instance && !options.model) {
      options.model = options.instance.constructor;
    }

    if (!options.instance && !options.model) {
      options.raw = true;
    }

    // map raw fields to model attributes
    if (options.mapToModel) {
      options.fieldMap = _.get(options, 'model.fieldAttributeMap', {});
    }

    options = _.defaults(options, {
      // eslint-disable-next-line no-console
      logging: Object.prototype.hasOwnProperty.call(this.options, 'logging') ? this.options.logging : console.log,
      searchPath: Object.prototype.hasOwnProperty.call(this.options, 'searchPath') ? this.options.searchPath : 'DEFAULT'
    });

    if (!options.type) {
      if (options.model || options.nest || options.plain) {
        options.type = QueryTypes.SELECT;
      } else {
        options.type = QueryTypes.RAW;
      }
    }

    //if dialect doesn't support search_path or dialect option
    //to prepend searchPath is not true delete the searchPath option
    if (
      !this.dialect.supports.searchPath ||
      !this.options.dialectOptions ||
      !this.options.dialectOptions.prependSearchPath ||
      options.supportsSearchPath === false
    ) {
      delete options.searchPath;
    } else if (!options.searchPath) {
      //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)
      //then set to DEFAULT if none is provided
      options.searchPath = 'DEFAULT';
    }

    if (typeof sql === 'object') {
      if (sql.values !== undefined) {
        if (options.replacements !== undefined) {
          throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');
        }
        options.replacements = sql.values;
      }

      if (sql.bind !== undefined) {
        if (options.bind !== undefined) {
          throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');
        }
        options.bind = sql.bind;
      }

      if (sql.query !== undefined) {
        sql = sql.query;
      }
    }

    sql = sql.trim();

    if (options.replacements && options.bind) {
      throw new Error('Both `replacements` and `bind` cannot be set at the same time');
    }

    if (options.replacements) {
      if (Array.isArray(options.replacements)) {
        sql = Utils.format([sql].concat(options.replacements), this.options.dialect);
      } else {
        sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);
      }
    }

    let bindParameters;

    if (options.bind) {
      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);
    }

    const checkTransaction = () => {
      if (options.transaction && options.transaction.finished && !options.completesTransaction) {
        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);
        error.sql = sql;
        throw error;
      }
    };

    const retryOptions = { ...this.options.retry, ...options.retry };

    return retry(async () => {
      if (options.transaction === undefined && Sequelize._cls) {
        options.transaction = Sequelize._cls.get('transaction');
      }

      checkTransaction();

      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));
      const query = new this.dialect.Query(connection, this, options);

      try {
        await this.runHooks('beforeQuery', options, query);
        checkTransaction();
        return await query.run(sql, bindParameters);
      } finally {
        await this.runHooks('afterQuery', options, query);
        if (!options.transaction) {
          await this.connectionManager.releaseConnection(connection);
        }
      }
    }, retryOptions);
  }

  /**
   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.
   * Only works for MySQL.
   *
   * @param {object}        variables Object with multiple variables.
   * @param {object}        [options] query options.
   * @param {Transaction}   [options.transaction] The transaction that the query should be executed under
   *
   * @memberof Sequelize
   *
   * @returns {Promise}
   */
  async set(variables, options) {

    // Prepare options
    options = { ...this.options.set, ...typeof options === 'object' && options };

    if (this.options.dialect !== 'mysql') {
      throw new Error('sequelize.set is only supported for mysql');
    }
    if (!options.transaction || !(options.transaction instanceof Transaction) ) {
      throw new TypeError('options.transaction is required');
    }

    // Override some options, since this isn't a SELECT
    options.raw = true;
    options.plain = true;
    options.type = 'SET';

    // Generate SQL Query
    const query =
      `SET ${
        _.map(variables, (v, k) => `@${k} := ${typeof v === 'string' ? `"${v}"` : v}`).join(', ')}`;

    return await this.query(query, options);
  }

  /**
   * Escape value.
   *
   * @param {string} value string value to escape
   *
   * @returns {string}
   */
  escape(value) {
    return this.dialect.queryGenerator.escape(value);
  }

  /**
   * Create a new database schema.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this command will do nothing.
   *
   * @see
   * {@link Model.schema}
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    return await this.getQueryInterface().createSchema(schema, options);
  }

  /**
   * Show all defined schemas
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this will show all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async showAllSchemas(options) {
    return await this.getQueryInterface().showAllSchemas(options);
  }

  /**
   * Drop a single schema
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this drop a table matching the schema name
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    return await this.getQueryInterface().dropSchema(schema, options);
  }

  /**
   * Drop all schemas.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    return await this.getQueryInterface().dropAllSchemas(options);
  }

  /**
   * Sync all defined models to the DB.
   *
   * @param {object} [options={}] sync options
   * @param {boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table
   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code
   * @param {boolean|Function} [options.logging=console.log] A function that logs sql queries, or false for no logging
   * @param {string} [options.schema='public'] The schema that the tables should be created in. This can be overridden for each table in sequelize.define
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called
   * @param {boolean|object} [options.alter=false] Alters tables to fit models. Provide an object for additional configuration. Not recommended for production use. If not further configured deletes data in columns that were removed or had their type changed in the model.
   * @param {boolean} [options.alter.drop=true] Prevents any drop statements while altering a table when set to `false`
   *
   * @returns {Promise}
   */
  async sync(options) {
    options = {
      ...this.options,
      ...this.options.sync,
      ...options,
      hooks: options ? options.hooks !== false : true
    };

    if (options.match) {
      if (!options.match.test(this.config.database)) {
        throw new Error(`Database "${this.config.database}" does not match sync match parameter "${options.match}"`);
      }
    }

    if (options.hooks) {
      await this.runHooks('beforeBulkSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }
    const models = [];

    // Topologically sort by foreign key constraints to give us an appropriate
    // creation order
    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      } else {
        // DB should throw an SQL error if referencing non-existent table
      }
    });

    // no models defined, just authenticate
    if (!models.length) {
      await this.authenticate(options);
    } else {
      for (const model of models) await model.sync(options);
    }
    if (options.hooks) {
      await this.runHooks('afterBulkSync', options);
    }
    return this;
  }

  /**
   * Truncate all tables defined through the sequelize models.
   * This is done by calling `Model.truncate()` on each model.
   *
   * @param {object} [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @returns {Promise}
   *
   * @see
   * {@link Model.truncate} for more information
   */
  async truncate(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    if (options && options.cascade) {
      for (const model of models) await model.truncate(options);
    } else {
      await Promise.all(models.map(model => model.truncate(options)));
    }
  }

  /**
   * Drop all tables defined through this sequelize instance.
   * This is done by calling Model.drop on each model.
   *
   * @see
   * {@link Model.drop} for options
   *
   * @param {object} [options] The options passed to each call to Model.drop
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async drop(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    for (const model of models) await model.drop(options);
  }

  /**
   * Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.
   *
   * @param {object} [options={}] query options
   *
   * @returns {Promise}
   */
  async authenticate(options) {
    options = {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT,
      ...options
    };

    await this.query('SELECT 1+1 AS result', options);

    return;
  }

  async databaseVersion(options) {
    return await this.getQueryInterface().databaseVersion(options);
  }

  /**
   * Get the fn for random based on the dialect
   *
   * @returns {Sequelize.fn}
   */
  random() {
    const dia = this.getDialect();
    if (dia === 'postgres' || dia === 'sqlite') {
      return this.fn('RANDOM');
    }
    return this.fn('RAND');
  }

  /**
   * Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.
   * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.
   *
   * @see
   * {@link Model.findAll}
   * @see
   * {@link Sequelize.define}
   * @see
   * {@link Sequelize.col}
   *
   * @param {string} fn The function you want to call
   * @param {any} args All further arguments will be passed as arguments to the function
   *
   * @since v2.0.0-dev3
   * @memberof Sequelize
   * @returns {Sequelize.fn}
   *
   * @example <caption>Convert a user's username to upper case</caption>
   * instance.update({
   *   username: sequelize.fn('upper', sequelize.col('username'))
   * });
   */
  static fn(fn, ...args) {
    return new Utils.Fn(fn, args);
  }

  /**
   * Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.
   *
   * @see
   * {@link Sequelize#fn}
   *
   * @param {string} col The name of the column
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.col}
   */
  static col(col) {
    return new Utils.Col(col);
  }

  /**
   * Creates an object representing a call to the cast function.
   *
   * @param {any} val The value to cast
   * @param {string} type The type to cast it to
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.cast}
   */
  static cast(val, type) {
    return new Utils.Cast(val, type);
  }

  /**
   * Creates an object representing a literal, i.e. something that will not be escaped.
   *
   * @param {any} val literal value
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.literal}
   */
  static literal(val) {
    return new Utils.Literal(val);
  }

  /**
   * An AND query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by AND
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.and}
   */
  static and(...args) {
    return { [Op.and]: args };
  }

  /**
   * An OR query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by OR
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.or}
   */
  static or(...args) {
    return { [Op.or]: args };
  }

  /**
   * Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {string|object} conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres/sqlite/mysql json syntax.
   * @param {string|number|boolean} [value] An optional value to compare against. Produces a string of the form "<json path> = '<value>'".
   * @memberof Sequelize
   *
   * @returns {Sequelize.json}
   */
  static json(conditionsOrPath, value) {
    return new Utils.Json(conditionsOrPath, value);
  }

  /**
   * A way of specifying attr = condition.
   *
   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The
   * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)
   *
   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax
   * @param {symbol} [comparator='Op.eq'] operator
   * @param {string|object} logic The condition. Can be both a simply type, or a further condition (`or`, `and`, `.literal` etc.)
   * @since v2.0.0-dev3
   */
  static where(attr, comparator, logic) {
    return new Utils.Where(attr, comparator, logic);
  }

  /**
   * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see {@link Transaction}
   *
   * If you have [CLS](https://github.com/Jeff-Lewis/cls-hooked) enabled, the transaction will automatically be passed to any query that runs within the callback
   *
   * @example
   *
   * try {
   *   const transaction = await sequelize.transaction();
   *   const user = await User.findOne(..., { transaction });
   *   await user.update(..., { transaction });
   *   await transaction.commit();
   * } catch {
   *   await transaction.rollback()
   * }
   *
   * @example <caption>A syntax for automatically committing or rolling back based on the promise chain resolution is also supported</caption>
   *
   * try {
   *   await sequelize.transaction(transaction => { // Note that we pass a callback rather than awaiting the call with no arguments
   *     const user = await User.findOne(..., {transaction});
   *     await user.update(..., {transaction});
   *   });
   *   // Committed
   * } catch(err) {
   *   // Rolled back
   *   console.error(err);
   * }
   * @example <caption>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</caption>
   *
   * const cls = require('cls-hooked');
   * const namespace = cls.createNamespace('....');
   * const Sequelize = require('sequelize');
   * Sequelize.useCLS(namespace);
   *
   * // Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace
   *
   * @param {object}   [options] Transaction options
   * @param {string}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options
   * @param {string}   [options.deferrable] Sets the constraints to be deferred or immediately checked. See `Sequelize.Deferrable`. PostgreSQL Only
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Function} [autoCallback] The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back
   *
   * @returns {Promise}
   */
  async transaction(options, autoCallback) {
    if (typeof options === 'function') {
      autoCallback = options;
      options = undefined;
    }

    const transaction = new Transaction(this, options);

    if (!autoCallback) {
      await transaction.prepareEnvironment(false);
      return transaction;
    }

    // autoCallback provided
    return Sequelize._clsRun(async () => {
      try {
        await transaction.prepareEnvironment();
        const result = await autoCallback(transaction);
        await transaction.commit();
        return await result;
      } catch (err) {
        try {
          if (!transaction.finished) {
            await transaction.rollback();
          } else {
            // release the connection, even if we don't need to rollback
            await transaction.cleanup();
          }
        } catch (err0) {
          // ignore
        }
        throw err;
      }
    });
  }

  /**
   * Use CLS (Continuation Local Storage) with Sequelize. With Continuation
   * Local Storage, all queries within the transaction callback will
   * automatically receive the transaction object.
   *
   * CLS namespace provided is stored as `Sequelize._cls`
   *
   * @param {object} ns CLS namespace
   * @returns {object} Sequelize constructor
   */
  static useCLS(ns) {
    // check `ns` is valid CLS namespace
    if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new Error('Must provide CLS namespace');

    // save namespace as `Sequelize._cls`
    this._cls = ns;

    // return Sequelize for chaining
    return this;
  }

  /**
   * Run function in CLS context.
   * If no CLS context in use, just runs the function normally
   *
   * @private
   * @param {Function} fn Function to run
   * @returns {*} Return value of function
   */
  static _clsRun(fn) {
    const ns = Sequelize._cls;
    if (!ns) return fn();

    let res;
    ns.run(context => res = fn(context));
    return res;
  }

  log(...args) {
    let options;

    const last = _.last(args);

    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, 'logging')) {
      options = last;

      // remove options from set of logged arguments if options.logging is equal to console.log
      // eslint-disable-next-line no-console
      if (options.logging === console.log) {
        args.splice(args.length - 1, 1);
      }
    } else {
      options = this.options;
    }

    if (options.logging) {
      if (options.logging === true) {
        deprecations.noTrueLogging();
        // eslint-disable-next-line no-console
        options.logging = console.log;
      }

      // second argument is sql-timings, when benchmarking option enabled
      // eslint-disable-next-line no-console
      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {
        args = [`${args[0]} Elapsed time: ${args[1]}ms`];
      }

      options.logging(...args);
    }
  }

  /**
   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.
   *
   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want
   * to garbage collect some of them.
   *
   * @returns {Promise}
   */
  close() {
    return this.connectionManager.close();
  }

  normalizeDataType(Type) {
    let type = typeof Type === 'function' ? new Type() : Type;
    const dialectTypes = this.dialect.DataTypes || {};

    if (dialectTypes[type.key]) {
      type = dialectTypes[type.key].extend(type);
    }

    if (type instanceof DataTypes.ARRAY) {
      if (!type.type) {
        throw new Error('ARRAY is missing type definition for its values.');
      }
      if (dialectTypes[type.type.key]) {
        type.type = dialectTypes[type.type.key].extend(type.type);
      }
    }

    return type;
  }

  normalizeAttribute(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = { type: attribute };
    }

    if (!attribute.type) return attribute;

    attribute.type = this.normalizeDataType(attribute.type);

    if (Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')) {
      if (typeof attribute.defaultValue === 'function' && (
        attribute.defaultValue === DataTypes.NOW ||
          attribute.defaultValue === DataTypes.UUIDV1 ||
          attribute.defaultValue === DataTypes.UUIDV4
      )) {
        attribute.defaultValue = new attribute.defaultValue();
      }
    }

    if (attribute.type instanceof DataTypes.ENUM) {
      // The ENUM is a special case where the type is an object containing the values
      if (attribute.values) {
        attribute.type.values = attribute.type.options.values = attribute.values;
      } else {
        attribute.values = attribute.type.values;
      }

      if (!attribute.values.length) {
        throw new Error('Values for ENUM have not been defined.');
      }
    }

    return attribute;
  }
}

// Aliases
Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;

/**
 * Sequelize version number.
 */
Sequelize.version = __webpack_require__(/*! ../package.json */ "./node_modules/sequelize/package.json").version;

Sequelize.options = { hooks: {} };

/**
 * @private
 */
Sequelize.Utils = Utils;

/**
 * Operators symbols to be used for querying data
 *
 * @see  {@link Operators}
 */
Sequelize.Op = Op;

/**
 * Available table hints to be used for querying data in mssql for table hints
 *
 * @see {@link TableHints}
 */
Sequelize.TableHints = TableHints;

/**
 * Available index hints to be used for querying data in mysql for index hints
 *
 * @see {@link IndexHints}
 */
Sequelize.IndexHints = IndexHints;

/**
 * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction
 *
 * @see {@link Transaction}
 * @see {@link Sequelize.transaction}
 */
Sequelize.Transaction = Transaction;

/**
 * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.
 *
 * @see {@link Sequelize}
 */
Sequelize.prototype.Sequelize = Sequelize;

/**
 * Available query types for use with `sequelize.query`
 *
 * @see {@link QueryTypes}
 */
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;

/**
 * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.
 *
 * @see https://github.com/chriso/validator.js
 */
Sequelize.prototype.Validator = Sequelize.Validator = Validator;

Sequelize.Model = Model;

Sequelize.DataTypes = DataTypes;
for (const dataType in DataTypes) {
  Sequelize[dataType] = DataTypes[dataType];
}

/**
 * A reference to the deferrable collection. Use this to access the different deferrable options.
 *
 * @see {@link Transaction.Deferrable}
 * @see {@link Sequelize#transaction}
 */
Sequelize.Deferrable = Deferrable;

/**
 * A reference to the sequelize association class.
 *
 * @see {@link Association}
 */
Sequelize.prototype.Association = Sequelize.Association = Association;

/**
 * Provide alternative version of `inflection` module to be used by `Utils.pluralize` etc.
 *
 * @param {object} _inflection - `inflection` module
 */
Sequelize.useInflection = Utils.useInflection;

/**
 * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models
 * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()
 */
Hooks.applyTo(Sequelize);
Hooks.applyTo(Sequelize.prototype);

/**
 * Expose various errors available
 */

// expose alias to BaseError
Sequelize.Error = sequelizeErrors.BaseError;

for (const error of Object.keys(sequelizeErrors)) {
  Sequelize[error] = sequelizeErrors[error];
}

module.exports = Sequelize;
module.exports.Sequelize = Sequelize;
module.exports.default = Sequelize;


/***/ }),

/***/ "./node_modules/sequelize/lib/sql-string.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/sql-string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const dataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

function arrayToList(array, timeZone, dialect, format) {
  return array.reduce((sql, val, i) => {
    if (i !== 0) {
      sql += ', ';
    }
    if (Array.isArray(val)) {
      sql += `(${arrayToList(val, timeZone, dialect, format)})`;
    } else {
      sql += escape(val, timeZone, dialect, format);
    }
    return sql;
  }, '');
}
exports.arrayToList = arrayToList;

function escape(val, timeZone, dialect, format) {
  let prependN = false;
  if (val === undefined || val === null) {
    return 'NULL';
  }
  switch (typeof val) {
    case 'boolean':
    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0
    // for us. Postgres actually has a boolean type with true/false literals,
    // but sequelize doesn't use it yet.
      if (dialect === 'sqlite' || dialect === 'mssql') {
        return +!!val;
      }
      return (!!val).toString();
    case 'number':
      return val.toString();
    case 'string':
    // In mssql, prepend N to all quoted vals which are originally a string (for
    // unicode compatibility)
      prependN = dialect === 'mssql';
      break;
  }

  if (val instanceof Date) {
    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });
  }

  if (Buffer.isBuffer(val)) {
    if (dataTypes[dialect].BLOB) {
      return dataTypes[dialect].BLOB.prototype.stringify(val);
    }

    return dataTypes.BLOB.prototype.stringify(val);
  }

  if (Array.isArray(val)) {
    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);
    if (dialect === 'postgres' && !format) {
      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });
    }
    return arrayToList(val, timeZone, dialect, format);
  }

  if (!val.replace) {
    throw new Error(`Invalid value ${logger.inspect(val)}`);
  }

  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {
    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS
    // http://stackoverflow.com/q/603572/130598
    val = val.replace(/'/g, "''");

    if (dialect === 'postgres') {
      // null character is not allowed in Postgres
      val = val.replace(/\0/g, '\\0');
    }
  } else {
    // eslint-disable-next-line no-control-regex
    val = val.replace(/[\0\n\r\b\t\\'"\x1a]/g, s => {
      switch (s) {
        case '\0': return '\\0';
        case '\n': return '\\n';
        case '\r': return '\\r';
        case '\b': return '\\b';
        case '\t': return '\\t';
        case '\x1a': return '\\Z';
        default: return `\\${s}`;
      }
    });
  }
  return `${(prependN ? "N'" : "'") + val}'`;
}
exports.escape = escape;

function format(sql, values, timeZone, dialect) {
  values = [].concat(values);

  if (typeof sql !== 'string') {
    throw new Error(`Invalid SQL string provided: ${sql}`);
  }

  return sql.replace(/\?/g, match => {
    if (!values.length) {
      return match;
    }

    return escape(values.shift(), timeZone, dialect, true);
  });
}
exports.format = format;

function formatNamedParameters(sql, values, timeZone, dialect) {
  return sql.replace(/:+(?!\d)(\w+)/g, (value, key) => {
    if ('postgres' === dialect && '::' === value.slice(0, 2)) {
      return value;
    }

    if (values[key] !== undefined) {
      return escape(values[key], timeZone, dialect, true);
    }
    throw new Error(`Named parameter "${value}" has no value in the given object.`);
  });
}
exports.formatNamedParameters = formatNamedParameters;


/***/ }),

/***/ "./node_modules/sequelize/lib/table-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/table-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of table hints to be used in mssql for querying with table hints
 *
 * @property NOLOCK
 * @property READUNCOMMITTED
 * @property UPDLOCK
 * @property REPEATABLEREAD
 * @property SERIALIZABLE
 * @property READCOMMITTED
 * @property TABLOCK
 * @property TABLOCKX
 * @property PAGLOCK
 * @property ROWLOCK
 * @property NOWAIT
 * @property READPAST
 * @property XLOCK
 * @property SNAPSHOT
 * @property NOEXPAND
 */
const TableHints = module.exports = { // eslint-disable-line
  NOLOCK: 'NOLOCK',
  READUNCOMMITTED: 'READUNCOMMITTED',
  UPDLOCK: 'UPDLOCK',
  REPEATABLEREAD: 'REPEATABLEREAD',
  SERIALIZABLE: 'SERIALIZABLE',
  READCOMMITTED: 'READCOMMITTED',
  TABLOCK: 'TABLOCK',
  TABLOCKX: 'TABLOCKX',
  PAGLOCK: 'PAGLOCK',
  ROWLOCK: 'ROWLOCK',
  NOWAIT: 'NOWAIT',
  READPAST: 'READPAST',
  XLOCK: 'XLOCK',
  SNAPSHOT: 'SNAPSHOT',
  NOEXPAND: 'NOEXPAND'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/transaction.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * The transaction object is used to identify a running transaction.
 * It is created by calling `Sequelize.transaction()`.
 * To run a query under a transaction, you should pass the transaction in the options object.
 *
 * @class Transaction
 * @see {@link Sequelize.transaction}
 */
class Transaction {
  /**
   * Creates a new transaction instance
   *
   * @param {Sequelize} sequelize A configured sequelize Instance
   * @param {object} options An object with options
   * @param {string} [options.type] Sets the type of the transaction. Sqlite only
   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.
   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only
   */
  constructor(sequelize, options) {
    this.sequelize = sequelize;
    this.savepoints = [];
    this._afterCommitHooks = [];

    // get dialect specific transaction options
    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;

    this.options = {
      type: sequelize.options.transactionType,
      isolationLevel: sequelize.options.isolationLevel,
      readOnly: false,
      ...options
    };

    this.parent = this.options.transaction;

    if (this.parent) {
      this.id = this.parent.id;
      this.parent.savepoints.push(this);
      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;
    } else {
      this.id = this.name = generateTransactionId();
    }

    delete this.options.transaction;
  }

  /**
   * Commit the transaction
   *
   * @returns {Promise}
   */
  async commit() {
    if (this.finished) {
      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);
    }

    try {
      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);
    } finally {
      this.finished = 'commit';
      this.cleanup();
      for (const hook of this._afterCommitHooks) {
        await hook.apply(this, [this]);
      }
    }
  }

  /**
   * Rollback (abort) the transaction
   *
   * @returns {Promise}
   */
  async rollback() {
    if (this.finished) {
      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);
    }

    if (!this.connection) {
      throw new Error('Transaction cannot be rolled back because it never started');
    }

    try {
      return await this
        .sequelize
        .getQueryInterface()
        .rollbackTransaction(this, this.options);
    } finally {
      this.cleanup();
    }
  }

  /**
   * Called to acquire a connection to use and set the correct options on the connection.
   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.
   *
   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.
   * @returns {Promise}
   */
  async prepareEnvironment(useCLS) {
    let connectionPromise;

    if (useCLS === undefined) {
      useCLS = true;
    }

    if (this.parent) {
      connectionPromise = Promise.resolve(this.parent.connection);
    } else {
      const acquireOptions = { uuid: this.id };
      if (this.options.readOnly) {
        acquireOptions.type = 'SELECT';
      }
      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);
    }

    let result;
    const connection = await connectionPromise;
    this.connection = connection;
    this.connection.uuid = this.id;

    try {
      await this.begin();
      result = await this.setDeferrable();
    } catch (setupErr) {
      try {
        result = await this.rollback();
      } finally {
        throw setupErr; // eslint-disable-line no-unsafe-finally
      }
    }

    if (useCLS && this.sequelize.constructor._cls) {
      this.sequelize.constructor._cls.set('transaction', this);
    }

    return result;
  }

  async setDeferrable() {
    if (this.options.deferrable) {
      return await this
        .sequelize
        .getQueryInterface()
        .deferConstraints(this, this.options);
    }
  }

  async begin() {
    const queryInterface = this.sequelize.getQueryInterface();

    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {
      await queryInterface.startTransaction(this, this.options);
      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);
    }

    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);

    return queryInterface.startTransaction(this, this.options);
  }

  cleanup() {
    // Don't release the connection if there's a parent transaction or
    // if we've already cleaned up
    if (this.parent || this.connection.uuid === undefined) return;

    this._clearCls();
    const res = this.sequelize.connectionManager.releaseConnection(this.connection);
    this.connection.uuid = undefined;
    return res;
  }

  _clearCls() {
    const cls = this.sequelize.constructor._cls;

    if (cls) {
      if (cls.get('transaction') === this) {
        cls.set('transaction', null);
      }
    }
  }

  /**
   * A hook that is run after a transaction is committed
   *
   * @param {Function} fn   A callback function that is called with the committed transaction
   * @name afterCommit
   * @memberof Sequelize.Transaction
   */
  afterCommit(fn) {
    if (!fn || typeof fn !== 'function') {
      throw new Error('"fn" must be a function');
    }
    this._afterCommitHooks.push(fn);
  }

  /**
   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.
   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.
   * Sqlite only.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {
   *      // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property DEFERRED
   * @property IMMEDIATE
   * @property EXCLUSIVE
   */
  static get TYPES() {
    return {
      DEFERRED: 'DEFERRED',
      IMMEDIATE: 'IMMEDIATE',
      EXCLUSIVE: 'EXCLUSIVE'
    };
  }

  /**
   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.
   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {
   *     // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property READ_UNCOMMITTED
   * @property READ_COMMITTED
   * @property REPEATABLE_READ
   * @property SERIALIZABLE
   */
  static get ISOLATION_LEVELS() {
    return {
      READ_UNCOMMITTED: 'READ UNCOMMITTED',
      READ_COMMITTED: 'READ COMMITTED',
      REPEATABLE_READ: 'REPEATABLE READ',
      SERIALIZABLE: 'SERIALIZABLE'
    };
  }


  /**
   * Possible options for row locking. Used in conjunction with `find` calls:
   *
   * @example
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: t1.LOCK...
   * });
   *
   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>
   * UserModel.findAll({
   *   where: ...,
   *   include: [TaskModel, ...],
   *   transaction: t1,
   *   lock: {
   *     level: t1.LOCK...,
   *     of: UserModel
   *   }
   * });
   *
   * # UserModel will be locked but TaskModel won't!
   *
   * @example <caption>You can also skip locked rows:</caption>
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: true,
   *   skipLocked: true
   * });
   * # The query will now return any rows that aren't locked by another transaction
   *
   * @returns {object}
   * @property UPDATE
   * @property SHARE
   * @property KEY_SHARE Postgres 9.3+ only
   * @property NO_KEY_UPDATE Postgres 9.3+ only
   */
  static get LOCK() {
    return {
      UPDATE: 'UPDATE',
      SHARE: 'SHARE',
      KEY_SHARE: 'KEY SHARE',
      NO_KEY_UPDATE: 'NO KEY UPDATE'
    };
  }

  /**
   * Please see {@link Transaction.LOCK}
   */
  get LOCK() {
    return Transaction.LOCK;
  }
}

module.exports = Transaction;
module.exports.Transaction = Transaction;
module.exports.default = Transaction;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const SqlString = __webpack_require__(/*! ./sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ "lodash/_baseIsNative");
const uuidv1 = __webpack_require__(/*! uuid */ "uuid").v1;
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;
const operators = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const operatorsSet = new Set(Object.values(operators));

let inflection = __webpack_require__(/*! inflection */ "./node_modules/inflection/lib/inflection.js");

exports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js").classToInvokable;
exports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js").joinSQLFragments;

function useInflection(_inflection) {
  inflection = _inflection;
}
exports.useInflection = useInflection;

function camelizeIf(str, condition) {
  let result = str;

  if (condition) {
    result = camelize(str);
  }

  return result;
}
exports.camelizeIf = camelizeIf;

function underscoredIf(str, condition) {
  let result = str;

  if (condition) {
    result = underscore(str);
  }

  return result;
}
exports.underscoredIf = underscoredIf;

function isPrimitive(val) {
  const type = typeof val;
  return type === 'string' || type === 'number' || type === 'boolean';
}
exports.isPrimitive = isPrimitive;

// Same concept as _.merge, but don't overwrite properties that have already been assigned
function mergeDefaults(a, b) {
  return _.mergeWith(a, b, (objectValue, sourceValue) => {
    // If it's an object, let _ handle it this time, we will be called again for each property
    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {
      // _.isNative includes a check for core-js and throws an error if present.
      // Depending on _baseIsNative bypasses the core-js check.
      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {
        return sourceValue || objectValue;
      }
      return objectValue;
    }
  });
}
exports.mergeDefaults = mergeDefaults;

// An alternative to _.merge, which doesn't clone its arguments
// Cloning is a bad idea because options arguments may contain references to sequelize
// models - which again reference database libs which don't like to be cloned (in particular pg-native)
function merge() {
  const result = {};

  for (const obj of arguments) {
    _.forOwn(obj, (value, key) => {
      if (value !== undefined) {
        if (!result[key]) {
          result[key] = value;
        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {
          result[key] = merge(result[key], value);
        } else if (Array.isArray(value) && Array.isArray(result[key])) {
          result[key] = value.concat(result[key]);
        } else {
          result[key] = value;
        }
      }
    });
  }

  return result;
}
exports.merge = merge;

function spliceStr(str, index, count, add) {
  return str.slice(0, index) + add + str.slice(index + count);
}
exports.spliceStr = spliceStr;

function camelize(str) {
  return str.trim().replace(/[-_\s]+(.)?/g, (match, c) => c.toUpperCase());
}
exports.camelize = camelize;

function underscore(str) {
  return inflection.underscore(str);
}
exports.underscore = underscore;

function singularize(str) {
  return inflection.singularize(str);
}
exports.singularize = singularize;

function pluralize(str) {
  return inflection.pluralize(str);
}
exports.pluralize = pluralize;

function format(arr, dialect) {
  const timeZone = null;
  // Make a clone of the array beacuse format modifies the passed args
  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);
}
exports.format = format;

function formatNamedParameters(sql, parameters, dialect) {
  const timeZone = null;
  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);
}
exports.formatNamedParameters = formatNamedParameters;

function cloneDeep(obj, onlyPlain) {
  obj = obj || {};
  return _.cloneDeepWith(obj, elem => {
    // Do not try to customize cloning of arrays or POJOs
    if (Array.isArray(elem) || _.isPlainObject(elem)) {
      return undefined;
    }

    // If we specified to clone only plain objects & arrays, we ignore everyhing else
    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances
    if (onlyPlain || typeof elem === 'object') {
      return elem;
    }

    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain
    if (elem && typeof elem.clone === 'function') {
      return elem.clone();
    }
  });
}
exports.cloneDeep = cloneDeep;

/* Expand and normalize finder options */
function mapFinderOptions(options, Model) {
  if (options.attributes && Array.isArray(options.attributes)) {
    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);
    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));
  }

  mapOptionFieldNames(options, Model);

  return options;
}
exports.mapFinderOptions = mapFinderOptions;

/* Used to map field names in attributes and where conditions */
function mapOptionFieldNames(options, Model) {
  if (Array.isArray(options.attributes)) {
    options.attributes = options.attributes.map(attr => {
      // Object lookups will force any variable to strings, we don't want that for special objects etc
      if (typeof attr !== 'string') return attr;
      // Map attributes to aliased syntax attributes
      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {
        return [Model.rawAttributes[attr].field, attr];
      }
      return attr;
    });
  }

  if (options.where && _.isPlainObject(options.where)) {
    options.where = mapWhereFieldNames(options.where, Model);
  }

  return options;
}
exports.mapOptionFieldNames = mapOptionFieldNames;

function mapWhereFieldNames(attributes, Model) {
  if (attributes) {
    getComplexKeys(attributes).forEach(attribute => {
      const rawAttribute = Model.rawAttributes[attribute];

      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {
        attributes[rawAttribute.field] = attributes[attribute];
        delete attributes[attribute];
      }

      if (_.isPlainObject(attributes[attribute])
        && !(rawAttribute && (
          rawAttribute.type instanceof DataTypes.HSTORE
          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields
        attributes[attribute] = mapOptionFieldNames({
          where: attributes[attribute]
        }, Model).where;
      }

      if (Array.isArray(attributes[attribute])) {
        attributes[attribute].forEach((where, index) => {
          if (_.isPlainObject(where)) {
            attributes[attribute][index] = mapWhereFieldNames(where, Model);
          }
        });
      }

    });
  }

  return attributes;
}
exports.mapWhereFieldNames = mapWhereFieldNames;

/* Used to map field names in values */
function mapValueFieldNames(dataValues, fields, Model) {
  const values = {};

  for (const attr of fields) {
    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {
      // Field name mapping
      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {
        values[Model.rawAttributes[attr].field] = dataValues[attr];
      } else {
        values[attr] = dataValues[attr];
      }
    }
  }

  return values;
}
exports.mapValueFieldNames = mapValueFieldNames;

function isColString(value) {
  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';
}
exports.isColString = isColString;

function canTreatArrayAsAnd(arr) {
  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);
}
exports.canTreatArrayAsAnd = canTreatArrayAsAnd;

function combineTableNames(tableName1, tableName2) {
  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;
}
exports.combineTableNames = combineTableNames;

function toDefaultValue(value, dialect) {
  if (typeof value === 'function') {
    const tmp = value();
    if (tmp instanceof DataTypes.ABSTRACT) {
      return tmp.toSql();
    }
    return tmp;
  }
  if (value instanceof DataTypes.UUIDV1) {
    return uuidv1();
  }
  if (value instanceof DataTypes.UUIDV4) {
    return uuidv4();
  }
  if (value instanceof DataTypes.NOW) {
    return now(dialect);
  }
  if (Array.isArray(value)) {
    return value.slice();
  }
  if (_.isPlainObject(value)) {
    return { ...value };
  }
  return value;
}
exports.toDefaultValue = toDefaultValue;

/**
 * Determine if the default value provided exists and can be described
 * in a db schema using the DEFAULT directive.
 *
 * @param  {*} value Any default value.
 * @returns {boolean} yes / no.
 * @private
 */
function defaultValueSchemable(value) {
  if (value === undefined) { return false; }

  // TODO this will be schemable when all supported db
  // have been normalized for this case
  if (value instanceof DataTypes.NOW) { return false; }

  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }

  return typeof value !== 'function';
}
exports.defaultValueSchemable = defaultValueSchemable;

function removeNullValuesFromHash(hash, omitNull, options) {
  let result = hash;

  options = options || {};
  options.allowNull = options.allowNull || [];

  if (omitNull) {
    const _hash = {};

    _.forIn(hash, (val, key) => {
      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {
        _hash[key] = val;
      }
    });

    result = _hash;
  }

  return result;
}
exports.removeNullValuesFromHash = removeNullValuesFromHash;

const dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);

function now(dialect) {
  const d = new Date();
  if (!dialects.has(dialect)) {
    d.setMilliseconds(0);
  }
  return d;
}
exports.now = now;

// Note: Use the `quoteIdentifier()` and `escape()` methods on the
// `QueryInterface` instead for more portable code.

const TICK_CHAR = '`';
exports.TICK_CHAR = TICK_CHAR;

function addTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return tickChar + removeTicks(s, tickChar) + tickChar;
}
exports.addTicks = addTicks;

function removeTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return s.replace(new RegExp(tickChar, 'g'), '');
}
exports.removeTicks = removeTicks;

/**
 * Receives a tree-like object and returns a plain object which depth is 1.
 *
 * - Input:
 *
 *  {
 *    name: 'John',
 *    address: {
 *      street: 'Fake St. 123',
 *      coordinates: {
 *        longitude: 55.6779627,
 *        latitude: 12.5964313
 *      }
 *    }
 *  }
 *
 * - Output:
 *
 *  {
 *    name: 'John',
 *    address.street: 'Fake St. 123',
 *    address.coordinates.latitude: 55.6779627,
 *    address.coordinates.longitude: 12.5964313
 *  }
 *
 * @param {object} value an Object
 * @returns {object} a flattened object
 * @private
 */
function flattenObjectDeep(value) {
  if (!_.isPlainObject(value)) return value;
  const flattenedObj = {};

  function flattenObject(obj, subPath) {
    Object.keys(obj).forEach(key => {
      const pathToProperty = subPath ? `${subPath}.${key}` : key;
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        flattenObject(obj[key], pathToProperty);
      } else {
        flattenedObj[pathToProperty] = _.get(obj, key);
      }
    });
    return flattenedObj;
  }

  return flattenObject(value, undefined);
}
exports.flattenObjectDeep = flattenObjectDeep;

/**
 * Utility functions for representing SQL functions, and columns that should be escaped.
 * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.
 *
 * @private
 */
class SequelizeMethod {}
exports.SequelizeMethod = SequelizeMethod;

class Fn extends SequelizeMethod {
  constructor(fn, args) {
    super();
    this.fn = fn;
    this.args = args;
  }
  clone() {
    return new Fn(this.fn, this.args);
  }
}
exports.Fn = Fn;

class Col extends SequelizeMethod {
  constructor(col, ...args) {
    super();
    if (args.length > 0) {
      col = args;
    }
    this.col = col;
  }
}
exports.Col = Col;

class Cast extends SequelizeMethod {
  constructor(val, type, json) {
    super();
    this.val = val;
    this.type = (type || '').trim();
    this.json = json || false;
  }
}
exports.Cast = Cast;

class Literal extends SequelizeMethod {
  constructor(val) {
    super();
    this.val = val;
  }
}
exports.Literal = Literal;

class Json extends SequelizeMethod {
  constructor(conditionsOrPath, value) {
    super();
    if (_.isObject(conditionsOrPath)) {
      this.conditions = conditionsOrPath;
    } else {
      this.path = conditionsOrPath;
      if (value) {
        this.value = value;
      }
    }
  }
}
exports.Json = Json;

class Where extends SequelizeMethod {
  constructor(attribute, comparator, logic) {
    super();
    if (logic === undefined) {
      logic = comparator;
      comparator = '=';
    }

    this.attribute = attribute;
    this.comparator = comparator;
    this.logic = logic;
  }
}
exports.Where = Where;

//Collection of helper methods to make it easier to work with symbol operators

/**
 * getOperators
 *
 * @param  {object} obj
 * @returns {Array<symbol>} All operators properties of obj
 * @private
 */
function getOperators(obj) {
  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));
}
exports.getOperators = getOperators;

/**
 * getComplexKeys
 *
 * @param  {object} obj
 * @returns {Array<string|symbol>} All keys including operators
 * @private
 */
function getComplexKeys(obj) {
  return getOperators(obj).concat(Object.keys(obj));
}
exports.getComplexKeys = getComplexKeys;

/**
 * getComplexSize
 *
 * @param  {object|Array} obj
 * @returns {number}      Length of object properties including operators if obj is array returns its length
 * @private
 */
function getComplexSize(obj) {
  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;
}
exports.getComplexSize = getComplexSize;

/**
 * Returns true if a where clause is empty, even with Symbols
 *
 * @param  {object} obj
 * @returns {boolean}
 * @private
 */
function isWhereEmpty(obj) {
  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;
}
exports.isWhereEmpty = isWhereEmpty;

/**
 * Returns ENUM name by joining table and column name
 *
 * @param {string} tableName
 * @param {string} columnName
 * @returns {string}
 * @private
 */
function generateEnumName(tableName, columnName) {
  return `enum_${tableName}_${columnName}`;
}
exports.generateEnumName = generateEnumName;

/**
 * Returns an new Object which keys are camelized
 *
 * @param {object} obj
 * @returns {string}
 * @private
 */
function camelizeObjectKeys(obj) {
  const newObj = new Object();
  Object.keys(obj).forEach(key => {
    newObj[camelize(key)] = obj[key];
  });
  return newObj;
}
exports.camelizeObjectKeys = camelizeObjectKeys;

/**
 * Assigns own and inherited enumerable string and symbol keyed properties of source
 * objects to the destination object.
 *
 * https://lodash.com/docs/4.17.4#defaults
 *
 * **Note:** This method mutates `object`.
 *
 * @param {object} object The destination object.
 * @param {...object} [sources] The source objects.
 * @returns {object} Returns `object`.
 * @private
 */
function defaults(object, ...sources) {
  object = Object(object);

  sources.forEach(source => {
    if (source) {
      source = Object(source);

      getComplexKeys(source).forEach(key => {
        const value = object[key];
        if (
          value === undefined ||
            _.eq(value, Object.prototype[key]) &&
            !Object.prototype.hasOwnProperty.call(object, key)

        ) {
          object[key] = source[key];
        }
      });
    }
  });

  return object;
}
exports.defaults = defaults;

/**
 *
 * @param {object} index
 * @param {Array}  index.fields
 * @param {string} [index.name]
 * @param {string|object} tableName
 *
 * @returns {object}
 * @private
 */
function nameIndex(index, tableName) {
  if (tableName.tableName) tableName = tableName.tableName;

  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {
    const fields = index.fields.map(
      field => typeof field === 'string' ? field : field.name || field.attribute
    );
    index.name = underscore(`${tableName}_${fields.join('_')}`);
  }

  return index;
}
exports.nameIndex = nameIndex;

/**
 * Checks if 2 arrays intersect.
 *
 * @param {Array} arr1
 * @param {Array} arr2
 * @private
 */
function intersects(arr1, arr2) {
  return arr1.some(v => arr2.includes(v));
}
exports.intersects = intersects;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Wraps a constructor to not need the `new` keyword using a proxy.
 * Only used for data types.
 *
 * @param {Function} Class The class instance to wrap as invocable.
 * @returns {Proxy} Wrapped class instance.
 * @private
 */
function classToInvokable(Class) {
  return new Proxy(Class, {
    apply(Target, thisArg, args) {
      return new Target(...args);
    },
    construct(Target, args) {
      return new Target(...args);
    },
    get(target, p) {
      return target[p];
    }
  });
}
exports.classToInvokable = classToInvokable;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/deprecations.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/deprecations.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const { deprecate } = __webpack_require__(/*! util */ "util");

const noop = () => {};

exports.noRawAttributes = deprecate(noop, 'Use sequelize.fn / sequelize.literal to construct attributes', 'SEQUELIZE0001');
exports.noTrueLogging = deprecate(noop, 'The logging-option should be either a function or false. Default: console.log', 'SEQUELIZE0002');
exports.noStringOperators = deprecate(noop, 'String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators', 'SEQUELIZE0003');
exports.noBoolOperatorAliases = deprecate(noop, 'A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.', 'SEQUELIZE0004');
exports.noDoubleNestedGroup = deprecate(noop, 'Passing a double nested nested array to `group` is unsupported and will be removed in v6.', 'SEQUELIZE0005');
exports.unsupportedEngine = deprecate(noop, 'This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md', 'SEQUELIZE0006');


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function doesNotWantLeadingSpace(str) {
  return /^[;,)]/.test(str);
}
function doesNotWantTrailingSpace(str) {
  return /\($/.test(str);
}

/**
 * Joins an array of strings with a single space between them,
 * except for:
 * 
 * - Strings starting with ';', ',' and ')', which do not get a leading space.
 * - Strings ending with '(', which do not get a trailing space.
 * 
 * @param {string[]} parts
 * @returns {string}
 * @private
 */
function singleSpaceJoinHelper(parts) {
  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {
    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {
      result += part.trim();
    } else {
      result += ` ${part.trim()}`;
    }
    return {
      skipNextLeadingSpace: doesNotWantTrailingSpace(part),
      result
    };
  }, {
    skipNextLeadingSpace: true,
    result: ''
  }).result;
}

/**
 * Joins an array with a single space, auto trimming when needed.
 * 
 * Certain elements do not get leading/trailing spaces.
 * 
 * @param {any[]} array The array to be joined. Falsy values are skipped. If an
 * element is another array, this function will be called recursively on that array.
 * Otherwise, if a non-string, non-falsy value is present, a TypeError will be thrown.
 * 
 * @returns {string} The joined string.
 * 
 * @private
 */
function joinSQLFragments(array) {
  if (array.length === 0) return '';

  // Skip falsy fragments
  array = array.filter(x => x);

  // Resolve recursive calls
  array = array.map(fragment => {
    if (Array.isArray(fragment)) {
      return joinSQLFragments(fragment);
    }
    return fragment;
  });

  // Ensure strings
  for (const fragment of array) {
    if (fragment && typeof fragment !== 'string') {
      const error = new TypeError(`Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);
      error.args = array;
      error.fragment = fragment;
      throw error;
    }
  }

  // Trim fragments
  array = array.map(x => x.trim());

  // Skip full-whitespace fragments (empty after the above trim)
  array = array.filter(x => x !== '');

  return singleSpaceJoinHelper(array);
}
exports.joinSQLFragments = joinSQLFragments;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/logger.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Sequelize module for debug and deprecation messages.
 * It require a `context` for which messages will be printed.
 *
 * @module logging
 * @private
 */

const debug = __webpack_require__(/*! debug */ "debug");
const util = __webpack_require__(/*! util */ "util");

class Logger {
  constructor(config) {

    this.config = {
      context: 'sequelize',
      debug: true,
      ...config
    };
  }

  warn(message) {
    // eslint-disable-next-line no-console
    console.warn(`(${this.config.context}) Warning: ${message}`);
  }

  inspect(value) {
    return util.inspect(value, false, 3);
  }

  debugContext(name) {
    return debug(`${this.config.context}:${name}`);
  }
}

exports.logger = new Logger();

exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/validator-extras.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/validator-extras.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const validator = _.cloneDeep(__webpack_require__(/*! validator */ "./node_modules/validator/index.js"));
const moment = __webpack_require__(/*! moment */ "moment");

const extensions = {
  extend(name, fn) {
    this[name] = fn;

    return this;
  },
  notEmpty(str) {
    return !str.match(/^[\s\t\r\n]*$/);
  },
  len(str, min, max) {
    return this.isLength(str, min, max);
  },
  isUrl(str) {
    return this.isURL(str);
  },
  isIPv6(str) {
    return this.isIP(str, 6);
  },
  isIPv4(str) {
    return this.isIP(str, 4);
  },
  notIn(str, values) {
    return !this.isIn(str, values);
  },
  regex(str, pattern, modifiers) {
    str += '';
    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {
      pattern = new RegExp(pattern, modifiers);
    }
    return str.match(pattern);
  },
  notRegex(str, pattern, modifiers) {
    return !this.regex(str, pattern, modifiers);
  },
  isDecimal(str) {
    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);
  },
  min(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number >= val;
  },
  max(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number <= val;
  },
  not(str, pattern, modifiers) {
    return this.notRegex(str, pattern, modifiers);
  },
  contains(str, elem) {
    return !!elem && str.includes(elem);
  },
  notContains(str, elem) {
    return !this.contains(str, elem);
  },
  is(str, pattern, modifiers) {
    return this.regex(str, pattern, modifiers);
  }
};
exports.extensions = extensions;

// instance based validators
validator.isImmutable = function(value, validatorArgs, field, modelInstance) {
  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];
};

// extra validators
validator.notNull = function(val) {
  return val !== null && val !== undefined;
};

// https://github.com/chriso/validator.js/blob/6.2.0/validator.js
_.forEach(extensions, (extend, key) => {
  validator[key] = extend;
});

// map isNull to isEmpty
// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125
validator.isNull = validator.isEmpty;

// isDate removed in 7.0.0
// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9
validator.isDate = function(dateString) {
  // avoid http://momentjs.com/guides/#/warnings/js-date/
  // by doing a preliminary check on `dateString`
  const parsed = Date.parse(dateString);
  if (isNaN(parsed)) {
    // fail if we can't parse it
    return false;
  }
  // otherwise convert to ISO 8601 as moment prefers
  // http://momentjs.com/docs/#/parsing/string/
  const date = new Date(parsed);
  return moment(date.toISOString()).isValid();
};

exports.validator = validator;


/***/ }),

/***/ "./node_modules/sequelize/package.json":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"sequelize","description":"Multi dialect ORM for Node.JS","version":"6.6.2","maintainers":["Sascha Depold <sascha@depold.com>","Jan Aagaard Meier <janzeh@gmail.com>","Daniel Durante <me@danieldurante.com>","Mick Hansen <mick.kasper.hansen@gmail.com>","Sushant Dhiman <sushantdhiman@outlook.com>","Pedro Augusto de Paula Barbosa <papb1996@gmail.com>"],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"index.js","types":"types","engines":{"node":">=10.0.0"},"files":["lib","types/index.d.ts","types/lib","types/type-helpers"],"license":"MIT","dependencies":{"debug":"^4.1.1","dottie":"^2.0.0","inflection":"1.12.0","lodash":"^4.17.20","moment":"^2.26.0","moment-timezone":"^0.5.31","retry-as-promised":"^3.2.0","semver":"^7.3.2","sequelize-pool":"^6.0.0","toposort-class":"^1.0.1","uuid":"^8.1.0","validator":"^10.11.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^11.0.0","@commitlint/config-angular":"^11.0.0","@types/node":"^12.12.42","@types/validator":"^10.11.0","acorn":"^8.0.4","chai":"^4.x","chai-as-promised":"^7.x","chai-datetime":"^1.6.0","cheerio":"^1.0.0-rc.3","cls-hooked":"^4.2.2","cross-env":"^7.0.2","delay":"^4.3.0","env-cmd":"^10.1.0","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^6.8.0","eslint-plugin-jsdoc":"^20.4.0","eslint-plugin-mocha":"^6.2.2","expect-type":"^0.11.0","fs-jetpack":"^4.1.0","husky":"^4.2.5","js-combinatorics":"^0.5.5","lcov-result-merger":"^3.0.0","lint-staged":"^10.2.6","mariadb":"^2.3.1","markdownlint-cli":"^0.26.0","marked":"^1.1.0","mocha":"^7.1.2","mysql2":"^2.1.0","nyc":"^15.0.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.2.1","pg-hstore":"^2.x","rimraf":"^3.0.2","semantic-release":"^17.3.0","sinon":"^9.0.2","sinon-chai":"^3.3.0","sqlite3":"^4.2.0","tedious":"8.3.0","typescript":"^4.1.3"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","mssql","orm","nodejs","object relational mapper"],"options":{"env_cmd":"-f ./test/config/.docker.env"},"commitlint":{"extends":["@commitlint/config-angular"]},"lint-staged":{"*.js":"eslint"},"husky":{"hooks":{"pre-commit":"lint-staged","commit-msg":"commitlint -E HUSKY_GIT_PARAMS"}},"release":{"branches":["v6"],"verifyConditions":["@semantic-release/npm","@semantic-release/github"]},"publishConfig":{"tag":"latest"},"scripts":{"lint":"eslint lib test --quiet","lint-docs":"markdownlint docs","test":"npm run teaser && npm run test-unit && npm run test-integration","test-docker":"npm run test-docker-unit && npm run test-docker-integration","test-docker-unit":"npm run test-unit","test-docker-integration":"env-cmd $npm_package_options_env_cmd npm run test-integration","docs":"rimraf esdoc && esdoc -c docs/esdoc-config.js && cp docs/favicon.ico esdoc/favicon.ico && cp docs/ROUTER.txt esdoc/ROUTER && node docs/run-docs-transforms.js && node docs/redirects/create-redirects.js && rimraf esdoc/file esdoc/source.html","teaser":"node scripts/teaser","test-unit":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/unit/**/*.js\\"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite","test-integration":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/integration/**/*.test.js\\"","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-all":"npm run test-integration-mariadb && npm run test-integration-mysql && npm run test-integration-postgres && npm run test-integration-postgres-native && npm run test-integration-mssql && npm run test-integration-sqlite","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-pgsql":"npm run test-postgres","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-postgresn":"npm run test-postgres-native","test-mssql":"cross-env DIALECT=mssql npm test","test-all":"npm run test-mariadb && npm run test-mysql && npm run test-sqlite && npm run test-postgres && npm run test-postgres-native && npm run test-mssql","test-typings":"tsc -b types/tsconfig.json && tsc -b types/test/tsconfig.json","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/integration/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/unit/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","sscce":"env-cmd $npm_package_options_env_cmd node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb npm run sscce","sscce-mysql":"cross-env DIALECT=mysql npm run sscce","sscce-postgres":"cross-env DIALECT=postgres npm run sscce","sscce-sqlite":"cross-env DIALECT=sqlite npm run sscce","sscce-mssql":"cross-env DIALECT=mssql npm run sscce","setup-mssql":"env-cmd $npm_package_options_env_cmd ./scripts/setup-mssql","semantic-release":"semantic-release"}}');

/***/ }),

/***/ "./node_modules/toposort-class/build/toposort.js":
/*!*******************************************************!*\
  !*** ./node_modules/toposort-class/build/toposort.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Gustavo Henke and Aaron Trent
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ****/
(function( global, factory ) {
    if( true ) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var mod; }
})( this, function( exports, module ) {
    "use strict";

    function _classCallCheck( instance, Constructor ) {
        if( !(instance instanceof Constructor) ) {
            throw new TypeError( "Cannot call a class as a function" );
        }
    }

    var Toposort = (function() {
        function Toposort() {
            _classCallCheck( this, Toposort );

            this.edges = [];
            this.Toposort = Toposort;
        }

        /**
         * Adds dependency edges.
         *
         * @since   0.1.0
         * @param   {String} item               An dependent name. Must be an string and not empty
         * @param   {String[]|String} [deps]    An dependency or array of dependencies
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.add = function add( item, deps ) {
            if( typeof item !== "string" || !item ) {
                throw new TypeError( "Dependent name must be given as a not empty string" );
            }

            deps = Array.isArray( deps ) ? deps : [deps];

            if( deps.length > 0 ) {
                for( var _iterator = deps, _isArray = Array.isArray( _iterator ), _i = 0, _iterator = _isArray ?
                                                                                                      _iterator :
                                                                                                      _iterator[Symbol.iterator](); ; ) {
                    var _ref;

                    if( _isArray ) {
                        if( _i >= _iterator.length ) {
                            break;
                        }
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if( _i.done ) {
                            break;
                        }
                        _ref = _i.value;
                    }

                    var dep = _ref;

                    if( typeof dep !== "string" || !dep ) {
                        throw new TypeError( "Dependency name must be given as a not empty string" );
                    }

                    this.edges.push( [item, dep] );
                }
            } else {
                this.edges.push( [item] );
            }

            return this;
        };

        /**
         * Runs the toposorting and return an ordered array of strings
         *
         * @since   0.1.0
         * @returns {String[]}  The list of items topologically sorted.
         */

        Toposort.prototype.sort = function sort() {
            var _this = this;

            var nodes = [];

            //accumulate unique nodes into a large list
            for( var _iterator2 = this.edges, _isArray2 = Array.isArray( _iterator2 ), _i2 = 0, _iterator2 = _isArray2 ?
                                                                                                             _iterator2 :
                                                                                                             _iterator2[Symbol.iterator](); ; ) {
                var _ref2;

                if( _isArray2 ) {
                    if( _i2 >= _iterator2.length ) {
                        break;
                    }
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if( _i2.done ) {
                        break;
                    }
                    _ref2 = _i2.value;
                }

                var edge = _ref2;

                for( var _iterator3 = edge, _isArray3 = Array.isArray( _iterator3 ), _i3 = 0, _iterator3 = _isArray3 ?
                                                                                                           _iterator3 :
                                                                                                           _iterator3[Symbol.iterator](); ; ) {
                    var _ref3;

                    if( _isArray3 ) {
                        if( _i3 >= _iterator3.length ) {
                            break;
                        }
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if( _i3.done ) {
                            break;
                        }
                        _ref3 = _i3.value;
                    }

                    var node = _ref3;

                    if( nodes.indexOf( node ) === -1 ) {
                        nodes.push( node );
                    }
                }
            }

            //initialize the placement of nodes into the sorted array at the end
            var place = nodes.length;

            //initialize the sorted array with the same length as the unique nodes array
            var sorted = new Array( nodes.length );

            //define a visitor function that recursively traverses dependencies.
            var visit = function visit( node, predecessors ) {
                //check if a node is dependent of itself
                if( predecessors.length !== 0 && predecessors.indexOf( node ) !== -1 ) {
                    throw new Error( "Cyclic dependency found. " + node + " is dependent of itself.\nDependency chain: "
                                     + predecessors.join( " -> " ) + " => " + node );
                }

                var index = nodes.indexOf( node );

                //if the node still exists, traverse its dependencies
                if( index !== -1 ) {
                    var copy = false;

                    //mark the node as false to exclude it from future iterations
                    nodes[index] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator4 = _this.edges, _isArray4 = Array.isArray( _iterator4 ), _i4 = 0, _iterator4 = _isArray4 ?
                                                                                                                      _iterator4 :
                                                                                                                      _iterator4[Symbol.iterator](); ; ) {
                        var _ref4;

                        if( _isArray4 ) {
                            if( _i4 >= _iterator4.length ) {
                                break;
                            }
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if( _i4.done ) {
                                break;
                            }
                            _ref4 = _i4.value;
                        }

                        var edge = _ref4;

                        if( edge[0] === node ) {
                            //lazily create a copy of predecessors with the current node concatenated onto it
                            copy = copy || predecessors.concat( [node] );

                            //recurse to node dependencies
                            visit( edge[1], copy );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            };

            for( var i = 0; i < nodes.length; i++ ) {
                var node = nodes[i];

                //ignore nodes that have been excluded
                if( node !== false ) {
                    //mark the node as false to exclude it from future iterations
                    nodes[i] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator5 = this.edges, _isArray5 = Array.isArray( _iterator5 ), _i5 = 0, _iterator5 = _isArray5 ?
                                                                                                                     _iterator5 :
                                                                                                                     _iterator5[Symbol.iterator](); ; ) {
                        var _ref5;

                        if( _isArray5 ) {
                            if( _i5 >= _iterator5.length ) {
                                break;
                            }
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if( _i5.done ) {
                                break;
                            }
                            _ref5 = _i5.value;
                        }

                        var edge = _ref5;

                        if( edge[0] === node ) {
                            //recurse to node dependencies
                            visit( edge[1], [node] );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            }

            return sorted;
        };

        /**
         * Clears edges
         *
         * @since   0.4.0
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.clear = function clear() {
            this.edges = [];

            return this;
        };

        return Toposort;
    })();

    module.exports = Toposort;
} );


/***/ }),

/***/ "./node_modules/toposort-class/index.js":
/*!**********************************************!*\
  !*** ./node_modules/toposort-class/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./build/toposort.js */ "./node_modules/toposort-class/build/toposort.js");


/***/ }),

/***/ "./src/configs/sequalize.ts":
/*!**********************************!*\
  !*** ./src/configs/sequalize.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = exports.sequelize = void 0;
var sequelize_typescript_1 = __webpack_require__(/*! sequelize-typescript */ "./node_modules/sequelize-typescript/dist/index.js");
var init = function () { return __awaiter(void 0, void 0, void 0, function () {
    var e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 3, , 4]);
                exports.sequelize = new sequelize_typescript_1.Sequelize({
                    models: [__dirname + '/../database/model/**/*.model.ts'],
                    logging: false,
                    host: process.env.DB_HOST,
                    database: process.env.DB_DATABASE,
                    dialect: 'mysql',
                    username: process.env.DB_USERNAME,
                    password: process.env.DB_PASSWORD
                });
                return [4, exports.sequelize.authenticate()];
            case 1:
                _a.sent();
                return [4, exports.sequelize.sync({ alter: true })];
            case 2:
                _a.sent();
                console.log("DB Connected");
                return [3, 4];
            case 3:
                e_1 = _a.sent();
                console.error("Unable to connect to DB", e_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
exports.init = init;


/***/ }),

/***/ "./src/database/model/Pet.model.ts":
/*!*****************************************!*\
  !*** ./src/database/model/Pet.model.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var sequelize_typescript_1 = __webpack_require__(/*! sequelize-typescript */ "./node_modules/sequelize-typescript/dist/index.js");
var User_model_1 = __importDefault(__webpack_require__(/*! ./User.model */ "./src/database/model/User.model.ts"));
var Pet = (function (_super) {
    __extends(Pet, _super);
    function Pet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sequelize_typescript_1.Column
    ], Pet.prototype, "name", void 0);
    __decorate([
        sequelize_typescript_1.Default("Dog"),
        sequelize_typescript_1.Column
    ], Pet.prototype, "type", void 0);
    __decorate([
        sequelize_typescript_1.ForeignKey(function () { return User_model_1.default; }),
        sequelize_typescript_1.Column
    ], Pet.prototype, "ownerId", void 0);
    __decorate([
        sequelize_typescript_1.BelongsTo(function () { return User_model_1.default; })
    ], Pet.prototype, "owner", void 0);
    Pet = __decorate([
        sequelize_typescript_1.Table({
            timestamps: true,
            createdAt: true,
            updatedAt: true
        })
    ], Pet);
    return Pet;
}(sequelize_typescript_1.Model));
exports.default = Pet;


/***/ }),

/***/ "./src/database/model/User.model.ts":
/*!******************************************!*\
  !*** ./src/database/model/User.model.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var sequelize_typescript_1 = __webpack_require__(/*! sequelize-typescript */ "./node_modules/sequelize-typescript/dist/index.js");
var Pet_model_1 = __importDefault(__webpack_require__(/*! ./Pet.model */ "./src/database/model/Pet.model.ts"));
var User = (function (_super) {
    __extends(User, _super);
    function User() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sequelize_typescript_1.Column
    ], User.prototype, "firstName", void 0);
    __decorate([
        sequelize_typescript_1.Column
    ], User.prototype, "lastName", void 0);
    __decorate([
        sequelize_typescript_1.HasMany(function () { return Pet_model_1.default; })
    ], User.prototype, "pets", void 0);
    User = __decorate([
        sequelize_typescript_1.Table({
            timestamps: true,
            createdAt: true,
            updatedAt: true
        })
    ], User);
    return User;
}(sequelize_typescript_1.Model));
exports.default = User;


/***/ }),

/***/ "./src/resolvers/Pet.resolver.ts":
/*!***************************************!*\
  !*** ./src/resolvers/Pet.resolver.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Pet_model_1 = __importDefault(__webpack_require__(/*! ../database/model/Pet.model */ "./src/database/model/Pet.model.ts"));
exports.default = {
    User: {
        pets: function (parent, args) {
            console.log("QUERY PETS");
            return Pet_model_1.default.findAll({ where: { ownerId: parent.id } });
        },
    },
    Query: {
        pets: function (parent, args) {
            console.log("QUERY PETS");
            return Pet_model_1.default.findAll({ where: { ownerId: args.ownerId } });
        },
        pet: function (parent, args, context, info) {
            console.log("QUERY PET");
            return Pet_model_1.default.findOne({ where: { ownerId: args.ownerId } });
        }
    },
    Mutation: {
        pet: function (parent, args) {
            var pet = { name: args.name, ownerId: args.ownerId, type: args.type };
            return Pet_model_1.default.create(pet);
        }
    }
};


/***/ }),

/***/ "./src/resolvers/User.resolver.ts":
/*!****************************************!*\
  !*** ./src/resolvers/User.resolver.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var User_model_1 = __importDefault(__webpack_require__(/*! ../database/model/User.model */ "./src/database/model/User.model.ts"));
exports.default = {
    Query: {
        users: function () {
            console.log("QUERY USERS");
            return User_model_1.default.findAll();
        },
        user: function (parent, args, context, info) {
            console.log("QUERY USER");
            return User_model_1.default.findOne({ where: { id: args.id } });
        }
    },
    Mutation: {
        user: function (parent, args) {
            var user = { firstName: args.firstName, lastName: args.lastName };
            return User_model_1.default.create(user);
        }
    }
};


/***/ }),

/***/ "./src/resolvers/index.ts":
/*!********************************!*\
  !*** ./src/resolvers/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var User_resolver_1 = __importDefault(__webpack_require__(/*! ./User.resolver */ "./src/resolvers/User.resolver.ts"));
var Pet_resolver_1 = __importDefault(__webpack_require__(/*! ./Pet.resolver */ "./src/resolvers/Pet.resolver.ts"));
exports.default = lodash_1.merge(User_resolver_1.default, Pet_resolver_1.default);


/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var index_1 = __importDefault(__webpack_require__(/*! ./typeDefs/index */ "./src/typeDefs/index.ts"));
var index_2 = __importDefault(__webpack_require__(/*! ./resolvers/index */ "./src/resolvers/index.ts"));
var sequalize_1 = __webpack_require__(/*! ./configs/sequalize */ "./src/configs/sequalize.ts");
var server = new apollo_server_1.ApolloServer({ typeDefs: index_1.default, resolvers: index_2.default });
server.listen()
    .then(function (_a) {
    var url = _a.url;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    console.log("Server ready at " + url + ".");
                    return [4, sequalize_1.init()];
                case 1:
                    _b.sent();
                    return [2];
            }
        });
    });
});


/***/ }),

/***/ "./src/typeDefs/Pet.type.ts":
/*!**********************************!*\
  !*** ./src/typeDefs/Pet.type.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pet = void 0;
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
exports.Pet = apollo_server_1.gql(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    type Pet {\n        id: ID!\n        name: String!\n        ownerId: String!\n        owner: User\n    }\n\n    extend type Query {\n        pets: [Pet!]!\n        pet: Pet!\n    }\n\n    extend type Mutation {\n        pet(name: String!, type: String, ownerId: String!): Pet!\n    }\n"], ["\n    type Pet {\n        id: ID!\n        name: String!\n        ownerId: String!\n        owner: User\n    }\n\n    extend type Query {\n        pets: [Pet!]!\n        pet: Pet!\n    }\n\n    extend type Mutation {\n        pet(name: String!, type: String, ownerId: String!): Pet!\n    }\n"])));
var templateObject_1;


/***/ }),

/***/ "./src/typeDefs/User.ts":
/*!******************************!*\
  !*** ./src/typeDefs/User.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = void 0;
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
exports.User = apollo_server_1.gql(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    type User {\n        id: ID!\n        firstName: String!\n        lastName: String!\n        pets: [Pet!]!\n    }\n\n    extend type Query {\n        users: [User!]!\n        user(id: ID!): User!\n    }\n\n    extend type Mutation {\n        user(firstName: String!, lastName: String!): User!\n    }\n"], ["\n    type User {\n        id: ID!\n        firstName: String!\n        lastName: String!\n        pets: [Pet!]!\n    }\n\n    extend type Query {\n        users: [User!]!\n        user(id: ID!): User!\n    }\n\n    extend type Mutation {\n        user(firstName: String!, lastName: String!): User!\n    }\n"])));
var templateObject_1;


/***/ }),

/***/ "./src/typeDefs/index.ts":
/*!*******************************!*\
  !*** ./src/typeDefs/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var User_1 = __webpack_require__(/*! ./User */ "./src/typeDefs/User.ts");
var Pet_type_1 = __webpack_require__(/*! ./Pet.type */ "./src/typeDefs/Pet.type.ts");
var baseTypeDefs = apollo_server_1.gql(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    type Query\n    type Mutation\n"], ["\n    type Query\n    type Mutation\n"])));
exports.default = [baseTypeDefs, User_1.User, Pet_type_1.Pet];
var templateObject_1;


/***/ }),

/***/ "./node_modules/validator/index.js":
/*!*****************************************!*\
  !*** ./node_modules/validator/index.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./lib/toDate */ "./node_modules/validator/lib/toDate.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./lib/toFloat */ "./node_modules/validator/lib/toFloat.js"));

var _toInt = _interopRequireDefault(__webpack_require__(/*! ./lib/toInt */ "./node_modules/validator/lib/toInt.js"));

var _toBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/toBoolean */ "./node_modules/validator/lib/toBoolean.js"));

var _equals = _interopRequireDefault(__webpack_require__(/*! ./lib/equals */ "./node_modules/validator/lib/equals.js"));

var _contains = _interopRequireDefault(__webpack_require__(/*! ./lib/contains */ "./node_modules/validator/lib/contains.js"));

var _matches = _interopRequireDefault(__webpack_require__(/*! ./lib/matches */ "./node_modules/validator/lib/matches.js"));

var _isEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmail */ "./node_modules/validator/lib/isEmail.js"));

var _isURL = _interopRequireDefault(__webpack_require__(/*! ./lib/isURL */ "./node_modules/validator/lib/isURL.js"));

var _isMACAddress = _interopRequireDefault(__webpack_require__(/*! ./lib/isMACAddress */ "./node_modules/validator/lib/isMACAddress.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./lib/isIP */ "./node_modules/validator/lib/isIP.js"));

var _isIPRange = _interopRequireDefault(__webpack_require__(/*! ./lib/isIPRange */ "./node_modules/validator/lib/isIPRange.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./lib/isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/isBoolean */ "./node_modules/validator/lib/isBoolean.js"));

var _isAlpha = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlpha */ "./node_modules/validator/lib/isAlpha.js"));

var _isAlphanumeric = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlphanumeric */ "./node_modules/validator/lib/isAlphanumeric.js"));

var _isNumeric = _interopRequireDefault(__webpack_require__(/*! ./lib/isNumeric */ "./node_modules/validator/lib/isNumeric.js"));

var _isPort = _interopRequireDefault(__webpack_require__(/*! ./lib/isPort */ "./node_modules/validator/lib/isPort.js"));

var _isLowercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isLowercase */ "./node_modules/validator/lib/isLowercase.js"));

var _isUppercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isUppercase */ "./node_modules/validator/lib/isUppercase.js"));

var _isAscii = _interopRequireDefault(__webpack_require__(/*! ./lib/isAscii */ "./node_modules/validator/lib/isAscii.js"));

var _isFullWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isFullWidth */ "./node_modules/validator/lib/isFullWidth.js"));

var _isHalfWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js"));

var _isVariableWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isVariableWidth */ "./node_modules/validator/lib/isVariableWidth.js"));

var _isMultibyte = _interopRequireDefault(__webpack_require__(/*! ./lib/isMultibyte */ "./node_modules/validator/lib/isMultibyte.js"));

var _isSurrogatePair = _interopRequireDefault(__webpack_require__(/*! ./lib/isSurrogatePair */ "./node_modules/validator/lib/isSurrogatePair.js"));

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./lib/isInt */ "./node_modules/validator/lib/isInt.js"));

var _isFloat = _interopRequireWildcard(__webpack_require__(/*! ./lib/isFloat */ "./node_modules/validator/lib/isFloat.js"));

var _isDecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isDecimal */ "./node_modules/validator/lib/isDecimal.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

var _isDivisibleBy = _interopRequireDefault(__webpack_require__(/*! ./lib/isDivisibleBy */ "./node_modules/validator/lib/isDivisibleBy.js"));

var _isHexColor = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexColor */ "./node_modules/validator/lib/isHexColor.js"));

var _isISRC = _interopRequireDefault(__webpack_require__(/*! ./lib/isISRC */ "./node_modules/validator/lib/isISRC.js"));

var _isMD = _interopRequireDefault(__webpack_require__(/*! ./lib/isMD5 */ "./node_modules/validator/lib/isMD5.js"));

var _isHash = _interopRequireDefault(__webpack_require__(/*! ./lib/isHash */ "./node_modules/validator/lib/isHash.js"));

var _isJWT = _interopRequireDefault(__webpack_require__(/*! ./lib/isJWT */ "./node_modules/validator/lib/isJWT.js"));

var _isJSON = _interopRequireDefault(__webpack_require__(/*! ./lib/isJSON */ "./node_modules/validator/lib/isJSON.js"));

var _isEmpty = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmpty */ "./node_modules/validator/lib/isEmpty.js"));

var _isLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isLength */ "./node_modules/validator/lib/isLength.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isUUID = _interopRequireDefault(__webpack_require__(/*! ./lib/isUUID */ "./node_modules/validator/lib/isUUID.js"));

var _isMongoId = _interopRequireDefault(__webpack_require__(/*! ./lib/isMongoId */ "./node_modules/validator/lib/isMongoId.js"));

var _isAfter = _interopRequireDefault(__webpack_require__(/*! ./lib/isAfter */ "./node_modules/validator/lib/isAfter.js"));

var _isBefore = _interopRequireDefault(__webpack_require__(/*! ./lib/isBefore */ "./node_modules/validator/lib/isBefore.js"));

var _isIn = _interopRequireDefault(__webpack_require__(/*! ./lib/isIn */ "./node_modules/validator/lib/isIn.js"));

var _isCreditCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isCreditCard */ "./node_modules/validator/lib/isCreditCard.js"));

var _isIdentityCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isIdentityCard */ "./node_modules/validator/lib/isIdentityCard.js"));

var _isISIN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISIN */ "./node_modules/validator/lib/isISIN.js"));

var _isISBN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISBN */ "./node_modules/validator/lib/isISBN.js"));

var _isISSN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISSN */ "./node_modules/validator/lib/isISSN.js"));

var _isMobilePhone = _interopRequireWildcard(__webpack_require__(/*! ./lib/isMobilePhone */ "./node_modules/validator/lib/isMobilePhone.js"));

var _isCurrency = _interopRequireDefault(__webpack_require__(/*! ./lib/isCurrency */ "./node_modules/validator/lib/isCurrency.js"));

var _isISO = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO8601 */ "./node_modules/validator/lib/isISO8601.js"));

var _isRFC = _interopRequireDefault(__webpack_require__(/*! ./lib/isRFC3339 */ "./node_modules/validator/lib/isRFC3339.js"));

var _isISO31661Alpha = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha2 */ "./node_modules/validator/lib/isISO31661Alpha2.js"));

var _isISO31661Alpha2 = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha3 */ "./node_modules/validator/lib/isISO31661Alpha3.js"));

var _isBase = _interopRequireDefault(__webpack_require__(/*! ./lib/isBase64 */ "./node_modules/validator/lib/isBase64.js"));

var _isDataURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isDataURI */ "./node_modules/validator/lib/isDataURI.js"));

var _isMagnetURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isMagnetURI */ "./node_modules/validator/lib/isMagnetURI.js"));

var _isMimeType = _interopRequireDefault(__webpack_require__(/*! ./lib/isMimeType */ "./node_modules/validator/lib/isMimeType.js"));

var _isLatLong = _interopRequireDefault(__webpack_require__(/*! ./lib/isLatLong */ "./node_modules/validator/lib/isLatLong.js"));

var _isPostalCode = _interopRequireWildcard(__webpack_require__(/*! ./lib/isPostalCode */ "./node_modules/validator/lib/isPostalCode.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./lib/ltrim */ "./node_modules/validator/lib/ltrim.js"));

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./lib/rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _trim = _interopRequireDefault(__webpack_require__(/*! ./lib/trim */ "./node_modules/validator/lib/trim.js"));

var _escape = _interopRequireDefault(__webpack_require__(/*! ./lib/escape */ "./node_modules/validator/lib/escape.js"));

var _unescape = _interopRequireDefault(__webpack_require__(/*! ./lib/unescape */ "./node_modules/validator/lib/unescape.js"));

var _stripLow = _interopRequireDefault(__webpack_require__(/*! ./lib/stripLow */ "./node_modules/validator/lib/stripLow.js"));

var _whitelist = _interopRequireDefault(__webpack_require__(/*! ./lib/whitelist */ "./node_modules/validator/lib/whitelist.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./lib/blacklist */ "./node_modules/validator/lib/blacklist.js"));

var _isWhitelisted = _interopRequireDefault(__webpack_require__(/*! ./lib/isWhitelisted */ "./node_modules/validator/lib/isWhitelisted.js"));

var _normalizeEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/normalizeEmail */ "./node_modules/validator/lib/normalizeEmail.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./lib/util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = '10.11.0';
var validator = {
  version: version,
  toDate: _toDate.default,
  toFloat: _toFloat.default,
  toInt: _toInt.default,
  toBoolean: _toBoolean.default,
  equals: _equals.default,
  contains: _contains.default,
  matches: _matches.default,
  isEmail: _isEmail.default,
  isURL: _isURL.default,
  isMACAddress: _isMACAddress.default,
  isIP: _isIP.default,
  isIPRange: _isIPRange.default,
  isFQDN: _isFQDN.default,
  isBoolean: _isBoolean.default,
  isAlpha: _isAlpha.default,
  isAlphaLocales: _isAlpha.locales,
  isAlphanumeric: _isAlphanumeric.default,
  isAlphanumericLocales: _isAlphanumeric.locales,
  isNumeric: _isNumeric.default,
  isPort: _isPort.default,
  isLowercase: _isLowercase.default,
  isUppercase: _isUppercase.default,
  isAscii: _isAscii.default,
  isFullWidth: _isFullWidth.default,
  isHalfWidth: _isHalfWidth.default,
  isVariableWidth: _isVariableWidth.default,
  isMultibyte: _isMultibyte.default,
  isSurrogatePair: _isSurrogatePair.default,
  isInt: _isInt.default,
  isFloat: _isFloat.default,
  isFloatLocales: _isFloat.locales,
  isDecimal: _isDecimal.default,
  isHexadecimal: _isHexadecimal.default,
  isDivisibleBy: _isDivisibleBy.default,
  isHexColor: _isHexColor.default,
  isISRC: _isISRC.default,
  isMD5: _isMD.default,
  isHash: _isHash.default,
  isJWT: _isJWT.default,
  isJSON: _isJSON.default,
  isEmpty: _isEmpty.default,
  isLength: _isLength.default,
  isByteLength: _isByteLength.default,
  isUUID: _isUUID.default,
  isMongoId: _isMongoId.default,
  isAfter: _isAfter.default,
  isBefore: _isBefore.default,
  isIn: _isIn.default,
  isCreditCard: _isCreditCard.default,
  isIdentityCard: _isIdentityCard.default,
  isISIN: _isISIN.default,
  isISBN: _isISBN.default,
  isISSN: _isISSN.default,
  isMobilePhone: _isMobilePhone.default,
  isMobilePhoneLocales: _isMobilePhone.locales,
  isPostalCode: _isPostalCode.default,
  isPostalCodeLocales: _isPostalCode.locales,
  isCurrency: _isCurrency.default,
  isISO8601: _isISO.default,
  isRFC3339: _isRFC.default,
  isISO31661Alpha2: _isISO31661Alpha.default,
  isISO31661Alpha3: _isISO31661Alpha2.default,
  isBase64: _isBase.default,
  isDataURI: _isDataURI.default,
  isMagnetURI: _isMagnetURI.default,
  isMimeType: _isMimeType.default,
  isLatLong: _isLatLong.default,
  ltrim: _ltrim.default,
  rtrim: _rtrim.default,
  trim: _trim.default,
  escape: _escape.default,
  unescape: _unescape.default,
  stripLow: _stripLow.default,
  whitelist: _whitelist.default,
  blacklist: _blacklist.default,
  isWhitelisted: _isWhitelisted.default,
  normalizeEmail: _normalizeEmail.default,
  toString: _toString.default
};
var _default = validator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/alpha.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/alpha.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
var alpha = {
  'en-US': /^[A-Z]+$/i,
  'bg-BG': /^[-]+$/i,
  'cs-CZ': /^[A-Z]+$/i,
  'da-DK': /^[A-Z]+$/i,
  'de-DE': /^[A-Z]+$/i,
  'el-GR': /^[-]+$/i,
  'es-ES': /^[A-Z]+$/i,
  'fr-FR': /^[A-Z]+$/i,
  'it-IT': /^[A-Z]+$/i,
  'nb-NO': /^[A-Z]+$/i,
  'nl-NL': /^[A-Z]+$/i,
  'nn-NO': /^[A-Z]+$/i,
  'hu-HU': /^[A-Z]+$/i,
  'pl-PL': /^[A-Z]+$/i,
  'pt-PT': /^[A-Z]+$/i,
  'ru-RU': /^[-]+$/i,
  'sl-SI': /^[A-Z]+$/i,
  'sk-SK': /^[A-Z]+$/i,
  'sr-RS@latin': /^[A-Z]+$/i,
  'sr-RS': /^[-]+$/i,
  'sv-SE': /^[A-Z]+$/i,
  'tr-TR': /^[A-Z]+$/i,
  'uk-UA': /^[-I]+$/i,
  'ku-IQ': /^[]+$/i,
  ar: /^[]+$/
};
exports.alpha = alpha;
var alphanumeric = {
  'en-US': /^[0-9A-Z]+$/i,
  'bg-BG': /^[0-9-]+$/i,
  'cs-CZ': /^[0-9A-Z]+$/i,
  'da-DK': /^[0-9A-Z]+$/i,
  'de-DE': /^[0-9A-Z]+$/i,
  'el-GR': /^[0-9-]+$/i,
  'es-ES': /^[0-9A-Z]+$/i,
  'fr-FR': /^[0-9A-Z]+$/i,
  'it-IT': /^[0-9A-Z]+$/i,
  'hu-HU': /^[0-9A-Z]+$/i,
  'nb-NO': /^[0-9A-Z]+$/i,
  'nl-NL': /^[0-9A-Z]+$/i,
  'nn-NO': /^[0-9A-Z]+$/i,
  'pl-PL': /^[0-9A-Z]+$/i,
  'pt-PT': /^[0-9A-Z]+$/i,
  'ru-RU': /^[0-9-]+$/i,
  'sl-SI': /^[0-9A-Z]+$/i,
  'sk-SK': /^[0-9A-Z]+$/i,
  'sr-RS@latin': /^[0-9A-Z]+$/i,
  'sr-RS': /^[0-9-]+$/i,
  'sv-SE': /^[0-9A-Z]+$/i,
  'tr-TR': /^[0-9A-Z]+$/i,
  'uk-UA': /^[0-9-I]+$/i,
  'ku-IQ': /^[0-9]+$/i,
  ar: /^[0-9]+$/
};
exports.alphanumeric = alphanumeric;
var decimal = {
  'en-US': '.',
  ar: ''
};
exports.decimal = decimal;
var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
exports.englishLocales = englishLocales;

for (var locale, i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha['en-US'];
  alphanumeric[locale] = alphanumeric['en-US'];
  decimal[locale] = decimal['en-US'];
} // Source: http://www.localeplanet.com/java/


var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
exports.arabicLocales = arabicLocales;

for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
} // Source: https://en.wikipedia.org/wiki/Decimal_mark


var dotDecimal = [];
exports.dotDecimal = dotDecimal;
var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
exports.commaDecimal = commaDecimal;

for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
  decimal[dotDecimal[_i2]] = decimal['en-US'];
}

for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
  decimal[commaDecimal[_i3]] = ',';
}

alpha['pt-BR'] = alpha['pt-PT'];
alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
decimal['pt-BR'] = decimal['pt-PT']; // see #862

alpha['pl-Pl'] = alpha['pl-PL'];
alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
decimal['pl-Pl'] = decimal['pl-PL'];

/***/ }),

/***/ "./node_modules/validator/lib/blacklist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/blacklist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = blacklist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function blacklist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/contains.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/contains.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = contains;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, elem) {
  (0, _assertString.default)(str);
  return str.indexOf((0, _toString.default)(elem)) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/equals.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/equals.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = equals;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function equals(str, comparison) {
  (0, _assertString.default)(str);
  return str === comparison;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/escape.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/escape.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = escape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function escape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAfter.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAfter.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAfter;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAfter(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original > comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAlpha.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAlpha.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlpha;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlpha(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alpha) {
    return _alpha.alpha[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alpha);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAlphanumeric.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isAlphanumeric.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlphanumeric;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlphanumeric(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alphanumeric);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAscii.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAscii.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAscii;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var ascii = /^[\x00-\x7F]+$/;
/* eslint-enable no-control-regex */

function isAscii(str) {
  (0, _assertString.default)(str);
  return ascii.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBase64.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBase64.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBase64;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var notBase64 = /[^A-Z0-9+\/=]/i;

function isBase64(str) {
  (0, _assertString.default)(str);
  var len = str.length;

  if (!len || len % 4 !== 0 || notBase64.test(str)) {
    return false;
  }

  var firstPaddingChar = str.indexOf('=');
  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBefore.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBefore.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBefore;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBefore(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original < comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBoolean(str) {
  (0, _assertString.default)(str);
  return ['true', 'false', '1', '0'].indexOf(str) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isByteLength.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isByteLength.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isByteLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCreditCard.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isCreditCard.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCreditCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
/* eslint-enable max-len */

function isCreditCard(str) {
  (0, _assertString.default)(str);
  var sanitized = str.replace(/[- ]+/g, '');

  if (!creditCard.test(sanitized)) {
    return false;
  }

  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble;

  for (var i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum % 10 + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return !!(sum % 10 === 0 ? sanitized : false);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCurrency.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isCurrency.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCurrency;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function currencyRegex(options) {
  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
  options.digits_after_decimal.forEach(function (digit, index) {
    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
  });
  var symbol = "(\\".concat(options.symbol.replace(/\./g, '\\.'), ")").concat(options.require_symbol ? '' : '?'),
      negative = '-?',
      whole_dollar_amount_without_sep = '[1-9]\\d*',
      whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
      valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
      whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
      decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : ''); // default is negative sign before symbol, but there are two other options (besides parens)

  if (options.allow_negatives && !options.parens_for_negatives) {
    if (options.negative_sign_after_digits) {
      pattern += negative;
    } else if (options.negative_sign_before_digits) {
      pattern = negative + pattern;
    }
  } // South African Rand, for example, uses R 123 (space) and R-123 (no space)


  if (options.allow_negative_sign_placeholder) {
    pattern = "( (?!\\-))?".concat(pattern);
  } else if (options.allow_space_after_symbol) {
    pattern = " ?".concat(pattern);
  } else if (options.allow_space_after_digits) {
    pattern += '( (?!$))?';
  }

  if (options.symbol_after_digits) {
    pattern += symbol;
  } else {
    pattern = symbol + pattern;
  }

  if (options.allow_negatives) {
    if (options.parens_for_negatives) {
      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
      pattern = negative + pattern;
    }
  } // ensure there's a dollar and/or decimal amount, and that
  // it doesn't start with a space or a negative sign followed by a space


  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
}

var default_currency_options = {
  symbol: '$',
  require_symbol: false,
  allow_space_after_symbol: false,
  symbol_after_digits: false,
  allow_negatives: true,
  parens_for_negatives: false,
  negative_sign_before_digits: false,
  negative_sign_after_digits: false,
  allow_negative_sign_placeholder: false,
  thousands_separator: ',',
  decimal_separator: '.',
  allow_decimal: true,
  require_decimal: false,
  digits_after_decimal: [2],
  allow_space_after_digits: false
};

function isCurrency(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_currency_options);
  return currencyRegex(options).test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDataURI.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDataURI.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDataURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validMediaType = /^[a-z]+\/[a-z0-9\-\+]+$/i;
var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;

function isDataURI(str) {
  (0, _assertString.default)(str);
  var data = str.split(',');

  if (data.length < 2) {
    return false;
  }

  var attributes = data.shift().trim().split(';');
  var schemeAndMediaType = attributes.shift();

  if (schemeAndMediaType.substr(0, 5) !== 'data:') {
    return false;
  }

  var mediaType = schemeAndMediaType.substr(5);

  if (mediaType !== '' && !validMediaType.test(mediaType)) {
    return false;
  }

  for (var i = 0; i < attributes.length; i++) {
    if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {// ok
    } else if (!validAttribute.test(attributes[i])) {
      return false;
    }
  }

  for (var _i = 0; _i < data.length; _i++) {
    if (!validData.test(data[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDecimal.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDecimal.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDecimal;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function decimalRegExp(options) {
  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
  return regExp;
}

var default_decimal_options = {
  force_decimal: false,
  decimal_digits: '1,',
  locale: 'en-US'
};
var blacklist = ['', '-', '+'];

function isDecimal(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_decimal_options);

  if (options.locale in _alpha.decimal) {
    return !(0, _includes.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
  }

  throw new Error("Invalid locale '".concat(options.locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDivisibleBy.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isDivisibleBy.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDivisibleBy;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./toFloat */ "./node_modules/validator/lib/toFloat.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isDivisibleBy(str, num) {
  (0, _assertString.default)(str);
  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmail.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmail.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmail;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};
/* eslint-disable max-len */

/* eslint-disable no-control-regex */

var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */

/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);

    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');
  var lower_domain = domain.toLowerCase();

  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
    /*
      Previously we removed dots for gmail addresses before validating.
      This was removed because it allows `multiple..dots@gmail.com`
      to be reported as valid, but it is not.
      Gmail only normalizes single dots, removing them from here is pointless,
      should be done in normalizeEmail
    */
    user = user.toLowerCase(); // Removing sub-address from username before gmail validation

    var username = user.split('+')[0]; // Dots are not included in gmail length restriction

    if (!(0, _isByteLength.default)(username.replace('.', ''), {
      min: 6,
      max: 30
    })) {
      return false;
    }

    var _user_parts = username.split('.');

    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }

  if (!(0, _isByteLength.default)(user, {
    max: 64
  }) || !(0, _isByteLength.default)(domain, {
    max: 254
  })) {
    return false;
  }

  if (!(0, _isFQDN.default)(domain, {
    require_tld: options.require_tld
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }

    if (!(0, _isIP.default)(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }

      var noBracketdomain = domain.substr(1, domain.length - 2);

      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
        return false;
      }
    }
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  var user_parts = user.split('.');

  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmpty.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmpty.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmpty;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_is_empty_options = {
  ignore_whitespace: false
};

function isEmpty(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_is_empty_options);
  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFQDN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isFQDN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFQDN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFQDN(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_fqdn_options);
  /* Remove the optional trailing dot before checking validity */

  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }

  var parts = str.split('.');

  for (var i = 0; i < parts.length; i++) {
    if (parts[i].length > 63) {
      return false;
    }
  }

  if (options.require_tld) {
    var tld = parts.pop();

    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    } // disallow spaces


    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }

  for (var part, _i = 0; _i < parts.length; _i++) {
    part = parts[_i];

    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }

    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    } // disallow full-width chars


    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }

    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isFloat.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFloat;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFloat(str, options) {
  (0, _assertString.default)(str);
  options = options || {};
  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));

  if (str === '' || str === '.' || str === '-' || str === '+') {
    return false;
  }

  var value = parseFloat(str.replace(',', '.'));
  return float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);
}

var locales = Object.keys(_alpha.decimal);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isFullWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isFullWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFullWidth;
exports.fullWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.fullWidth = fullWidth;

function isFullWidth(str) {
  (0, _assertString.default)(str);
  return fullWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHalfWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isHalfWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHalfWidth;
exports.halfWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.halfWidth = halfWidth;

function isHalfWidth(str) {
  (0, _assertString.default)(str);
  return halfWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHash.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isHash.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHash;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengths = {
  md5: 32,
  md4: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8
};

function isHash(str, algorithm) {
  (0, _assertString.default)(str);
  var hash = new RegExp("^[a-f0-9]{".concat(lengths[algorithm], "}$"));
  return hash.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexColor.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isHexColor.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexColor;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

function isHexColor(str) {
  (0, _assertString.default)(str);
  return hexcolor.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexadecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isHexadecimal.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexadecimal;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexadecimal = /^[0-9A-F]+$/i;

function isHexadecimal(str) {
  (0, _assertString.default)(str);
  return hexadecimal.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIP.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIP.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIP;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  } else if (version === '4') {
    if (!ipv4Maybe.test(str)) {
      return false;
    }

    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  } else if (version === '6') {
    var blocks = str.split(':');
    var foundOmissionBlock = false; // marker to indicate ::
    // At least some OS accept the last 32 bits of an IPv6 address
    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
    // and '::a.b.c.d' is deprecated, but also valid.

    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

    if (blocks.length > expectedNumberOfBlocks) {
      return false;
    } // initial or final ::


    if (str === '::') {
      return true;
    } else if (str.substr(0, 2) === '::') {
      blocks.shift();
      blocks.shift();
      foundOmissionBlock = true;
    } else if (str.substr(str.length - 2) === '::') {
      blocks.pop();
      blocks.pop();
      foundOmissionBlock = true;
    }

    for (var i = 0; i < blocks.length; ++i) {
      // test for a :: which can not be at the string start/end
      // since those cases have been handled above
      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
        if (foundOmissionBlock) {
          return false; // multiple :: in address
        }

        foundOmissionBlock = true;
      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last
        // block is a valid IPv4 address
      } else if (!ipv6Block.test(blocks[i])) {
        return false;
      }
    }

    if (foundOmissionBlock) {
      return blocks.length >= 1;
    }

    return blocks.length === expectedNumberOfBlocks;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIPRange.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isIPRange.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIPRange;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subnetMaybe = /^\d{1,2}$/;

function isIPRange(str) {
  (0, _assertString.default)(str);
  var parts = str.split('/'); // parts[0] -> ip, parts[1] -> subnet

  if (parts.length !== 2) {
    return false;
  }

  if (!subnetMaybe.test(parts[1])) {
    return false;
  } // Disallow preceding 0 i.e. 01, 02, ...


  if (parts[1].length > 1 && parts[1].startsWith('0')) {
    return false;
  }

  return (0, _isIP.default)(parts[0], 4) && parts[1] <= 32 && parts[1] >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISBN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISBN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISBN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
var isbn13Maybe = /^(?:[0-9]{13})$/;
var factor = [1, 3];

function isISBN(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isISBN(str, 10) || isISBN(str, 13);
  }

  var sanitized = str.replace(/[\s-]+/g, '');
  var checksum = 0;
  var i;

  if (version === '10') {
    if (!isbn10Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 9; i++) {
      checksum += (i + 1) * sanitized.charAt(i);
    }

    if (sanitized.charAt(9) === 'X') {
      checksum += 10 * 10;
    } else {
      checksum += 10 * sanitized.charAt(9);
    }

    if (checksum % 11 === 0) {
      return !!sanitized;
    }
  } else if (version === '13') {
    if (!isbn13Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 12; i++) {
      checksum += factor[i % 2] * sanitized.charAt(i);
    }

    if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
      return !!sanitized;
    }
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISIN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISIN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISIN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

function isISIN(str) {
  (0, _assertString.default)(str);

  if (!isin.test(str)) {
    return false;
  }

  var checksumStr = str.replace(/[A-Z]/g, function (character) {
    return parseInt(character, 36);
  });
  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble = true;

  for (var i = checksumStr.length - 2; i >= 0; i--) {
    digit = checksumStr.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha2.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha2.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha2;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
var validISO31661Alpha2CountriesCodes = ['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW'];

function isISO31661Alpha2(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha2CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha3.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha3.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha3;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
var validISO31661Alpha3CountriesCodes = ['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE'];

function isISO31661Alpha3(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha3CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO8601.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isISO8601.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO8601;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */

var isValidDate = function isValidDate(str) {
  // str must have passed the ISO8601 check
  // this check is meant to catch invalid dates
  // like 2009-02-31
  // first check for ordinal dates
  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

  if (ordinalMatch) {
    var oYear = Number(ordinalMatch[1]);
    var oDay = Number(ordinalMatch[2]); // if is leap year

    if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
    return oDay <= 365;
  }

  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
  var year = match[1];
  var month = match[2];
  var day = match[3];
  var monthString = month ? "0".concat(month).slice(-2) : month;
  var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
  if (isNaN(d.getUTCFullYear())) return false;

  if (month && day) {
    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
  }

  return true;
};

function isISO8601(str, options) {
  (0, _assertString.default)(str);
  var check = iso8601.test(str);
  if (!options) return check;
  if (check && options.strict) return isValidDate(str);
  return check;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISRC.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISRC.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISRC;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;

function isISRC(str) {
  (0, _assertString.default)(str);
  return isrc.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISSN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISSN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISSN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var issn = '^\\d{4}-?\\d{3}[\\dX]$';

function isISSN(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString.default)(str);
  var testIssn = issn;
  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');

  if (!testIssn.test(str)) {
    return false;
  }

  var digits = str.replace('-', '').toUpperCase();
  var checksum = 0;

  for (var i = 0; i < digits.length; i++) {
    var digit = digits[i];
    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
  }

  return checksum % 11 === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIdentityCard.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isIdentityCard.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIdentityCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validators = {
  ES: function ES(str) {
    (0, _assertString.default)(str);
    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
    var charsValue = {
      X: 0,
      Y: 1,
      Z: 2
    };
    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E']; // sanitize user input

    var sanitized = str.trim().toUpperCase(); // validate the data structure

    if (!DNI.test(sanitized)) {
      return false;
    } // validate the control digit


    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {
      return charsValue[char];
    });
    return sanitized.endsWith(controlDigits[number % 23]);
  }
};

function isIdentityCard(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
  (0, _assertString.default)(str);

  if (locale in validators) {
    return validators[locale](str);
  } else if (locale === 'any') {
    for (var key in validators) {
      if (validators.hasOwnProperty(key)) {
        var validator = validators[key];

        if (validator(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIn.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIn.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIn;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isIn(str, options) {
  (0, _assertString.default)(str);
  var i;

  if (Object.prototype.toString.call(options) === '[object Array]') {
    var array = [];

    for (i in options) {
      if ({}.hasOwnProperty.call(options, i)) {
        array[i] = (0, _toString.default)(options[i]);
      }
    }

    return array.indexOf(str) >= 0;
  } else if (_typeof(options) === 'object') {
    return options.hasOwnProperty(str);
  } else if (options && typeof options.indexOf === 'function') {
    return options.indexOf(str) >= 0;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
var intLeadingZeroes = /^[-+]?[0-9]+$/;

function isInt(str, options) {
  (0, _assertString.default)(str);
  options = options || {}; // Get the regex to use for testing, based on whether
  // leading zeroes are allowed or not.

  var regex = options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ? int : intLeadingZeroes; // Check min/max/lt/gt

  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isJSON.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJSON;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isJSON(str) {
  (0, _assertString.default)(str);

  try {
    var obj = JSON.parse(str);
    return !!obj && _typeof(obj) === 'object';
  } catch (e) {
    /* ignore */
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJWT.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isJWT.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJWT;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jwt = /^([A-Za-z0-9\-_~+\/]+[=]{0,2})\.([A-Za-z0-9\-_~+\/]+[=]{0,2})(?:\.([A-Za-z0-9\-_~+\/]+[=]{0,2}))?$/;

function isJWT(str) {
  (0, _assertString.default)(str);
  return jwt.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLatLong.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isLatLong.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;

function _default(str) {
  (0, _assertString.default)(str);
  if (!str.includes(',')) return false;
  var pair = str.split(',');
  return lat.test(pair[0]) && long.test(pair[1]);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLength.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isLength.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  var len = str.length - surrogatePairs.length;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLowercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isLowercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLowercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isLowercase(str) {
  (0, _assertString.default)(str);
  return str === str.toLowerCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMACAddress.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isMACAddress.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMACAddress;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
var macAddressNoColons = /^([0-9a-fA-F]){12}$/;

function isMACAddress(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_colons) {
    return macAddressNoColons.test(str);
  }

  return macAddress.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMD5.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isMD5.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMD5;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md5 = /^[a-f0-9]{32}$/;

function isMD5(str) {
  (0, _assertString.default)(str);
  return md5.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMagnetURI.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMagnetURI.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMagnetURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var magnetURI = /^magnet:\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;

function isMagnetURI(url) {
  (0, _assertString.default)(url);
  return magnetURI.test(url.trim());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMimeType.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isMimeType.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMimeType;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/
// Match simple MIME types
// NB :
//   Subtype length must not exceed 100 characters.
//   This rule does not comply to the RFC specs (what is the max length ?).
var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i; // eslint-disable-line max-len
// Handle "charset" in "text/*"

var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len
// Handle "boundary" in "multipart/*"

var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

function isMimeType(str) {
  (0, _assertString.default)(str);
  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMobilePhone.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isMobilePhone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMobilePhone;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var phones = {
  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
  'ar-EG': /^((\+?20)|0)?1[012]\d{8}$/,
  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
  'ar-KW': /^(\+?965)[569]\d{7}$/,
  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
  'bn-BD': /\+?(88)?0?1[356789][0-9]{8}\b/,
  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'de-DE': /^(\+49)?0?1(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7}$/,
  'el-GR': /^(\+?30|0)?(69\d{8})$/,
  'en-AU': /^(\+?61|0)4\d{8}$/,
  'en-GB': /^(\+?44|0)7\d{9}$/,
  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28)\d{7}$/,
  'en-HK': /^(\+?852\-?)?[456789]\d{3}\-?\d{4}$/,
  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
  'en-KE': /^(\+?254|0)?[7]\d{8}$/,
  'en-MU': /^(\+?230|0)?\d{8}$/,
  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
  'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
  'en-SG': /^(\+65)?[89]\d{7}$/,
  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  'en-ZA': /^(\+?27|0)\d{9}$/,
  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
  'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  'ja-JP': /^(\+?81|0)[789]0[ \-]?[1-9]\d{2}[ \-]?\d{5}$/,
  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  'lt-LT': /^(\+370|8)\d{8}$/,
  'ms-MY': /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
  'nb-NO': /^(\+?47)?[49]\d{7}$/,
  'nl-BE': /^(\+?32|0)4?\d{8}$/,
  'nn-NO': /^(\+?47)?[49]\d{7}$/,
  'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
  'pt-BR': /(?=^(\+?5{2}\-?|0)[1-9]{2}\-?\d{4}\-?\d{4}$)(^(\+?5{2}\-?|0)[1-9]{2}\-?[6-9]{1}\d{3}\-?\d{4}$)|(^(\+?5{2}\-?|0)[1-9]{2}\-?9[6-9]{1}\d{3}\-?\d{4}$)/,
  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
  'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
  'ru-RU': /^(\+?7|8)?9\d{9}$/,
  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  'th-TH': /^(\+66|66|0)\d{9}$/,
  'tr-TR': /^(\+?90|0)?5\d{9}$/,
  'uk-UA': /^(\+?38|8)?0\d{9}$/,
  'vi-VN': /^(\+?84|0)((3([2-9]))|(5([689]))|(7([0|6-9]))|(8([1-5]))|(9([0-9])))([0-9]{7})$/,
  'zh-CN': /^((\+|00)86)?1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$/,
  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
};
/* eslint-enable max-len */
// aliases

phones['en-CA'] = phones['en-US'];
phones['fr-BE'] = phones['nl-BE'];
phones['zh-HK'] = phones['en-HK'];

function isMobilePhone(str, locale, options) {
  (0, _assertString.default)(str);

  if (options && options.strictMode && !str.startsWith('+')) {
    return false;
  }

  if (Array.isArray(locale)) {
    return locale.some(function (key) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }

      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str); // alias falsey locale as 'any'
  } else if (!locale || locale === 'any') {
    for (var key in phones) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(phones);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isMongoId.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isMongoId.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMongoId;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isMongoId(str) {
  (0, _assertString.default)(str);
  return (0, _isHexadecimal.default)(str) && str.length === 24;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMultibyte.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMultibyte.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMultibyte;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var multibyte = /[^\x00-\x7F]/;
/* eslint-enable no-control-regex */

function isMultibyte(str) {
  (0, _assertString.default)(str);
  return multibyte.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isNumeric.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isNumeric.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isNumeric;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;
var numericNoSymbols = /^[0-9]+$/;

function isNumeric(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }

  return numeric.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPort.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isPort.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isPort;

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./isInt */ "./node_modules/validator/lib/isInt.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPort(str) {
  return (0, _isInt.default)(str, {
    min: 0,
    max: 65535
  });
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPostalCode.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isPostalCode.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// common patterns
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  BE: fourDigit,
  BG: fourDigit,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: fiveDigit,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HU: fourDigit,
  IL: fiveDigit,
  IN: sixDigit,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  MX: fiveDigit,
  NL: /^\d{4}\s?[a-z]{2}$/i,
  NO: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^\d{3}\s?\d{2}$/,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales = Object.keys(patterns);
exports.locales = locales;

function _default(str, locale) {
  (0, _assertString.default)(str);

  if (locale in patterns) {
    return patterns[locale].test(str);
  } else if (locale === 'any') {
    for (var key in patterns) {
      if (patterns.hasOwnProperty(key)) {
        var pattern = patterns[key];

        if (pattern.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

/***/ }),

/***/ "./node_modules/validator/lib/isRFC3339.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isRFC3339.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isRFC3339;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */
var dateFullYear = /[0-9]{4}/;
var dateMonth = /(0[1-9]|1[0-2])/;
var dateMDay = /([12]\d|0[1-9]|3[01])/;
var timeHour = /([01][0-9]|2[0-3])/;
var timeMinute = /[0-5][0-9]/;
var timeSecond = /([0-5][0-9]|60)/;
var timeSecFrac = /(\.[0-9]+)?/;
var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
var rfc3339 = new RegExp("".concat(fullDate.source, "[ tT]").concat(fullTime.source));

function isRFC3339(str) {
  (0, _assertString.default)(str);
  return rfc3339.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isSurrogatePair.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isSurrogatePair.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isSurrogatePair;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

function isSurrogatePair(str) {
  (0, _assertString.default)(str);
  return surrogatePair.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isURL.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isURL.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isURL;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];

    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }

  return false;
}

function isURL(url, options) {
  (0, _assertString.default)(url);

  if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
    return false;
  }

  if (url.indexOf('mailto:') === 0) {
    return false;
  }

  options = (0, _merge.default)(options, default_url_options);
  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');

  if (split.length > 1) {
    protocol = split.shift().toLowerCase();

    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.substr(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }

    split[0] = url.substr(2);
  }

  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');

  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }

    auth = split.shift();

    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
  }

  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);

  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();

    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null) {
    port = parseInt(port_str, 10);

    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  }

  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
    return false;
  }

  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUUID.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isUUID.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUUID;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuid = {
  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};

function isUUID(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
  (0, _assertString.default)(str);
  var pattern = uuid[version];
  return pattern && pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUppercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isUppercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUppercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isUppercase(str) {
  (0, _assertString.default)(str);
  return str === str.toUpperCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isVariableWidth.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isVariableWidth.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isVariableWidth;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFullWidth = __webpack_require__(/*! ./isFullWidth */ "./node_modules/validator/lib/isFullWidth.js");

var _isHalfWidth = __webpack_require__(/*! ./isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isVariableWidth(str) {
  (0, _assertString.default)(str);
  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isWhitelisted.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isWhitelisted.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isWhitelisted;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isWhitelisted(str, chars) {
  (0, _assertString.default)(str);

  for (var i = str.length - 1; i >= 0; i--) {
    if (chars.indexOf(str[i]) === -1) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/ltrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/ltrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = ltrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ltrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("^[".concat(chars, "]+"), 'g') : /^\s+/g;
  return str.replace(pattern, '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/matches.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/matches.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = matches;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matches(str, pattern, modifiers) {
  (0, _assertString.default)(str);

  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
    pattern = new RegExp(pattern, modifiers);
  }

  return pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/normalizeEmail.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/normalizeEmail.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeEmail;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_normalize_email_options = {
  // The following options apply to all email addresses
  // Lowercases the local part of the email address.
  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
  // The domain is always lowercased, as per RFC 1035
  all_lowercase: true,
  // The following conversions are specific to GMail
  // Lowercases the local part of the GMail address (known to be case-insensitive)
  gmail_lowercase: true,
  // Removes dots from the local part of the email address, as that's ignored by GMail
  gmail_remove_dots: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  gmail_remove_subaddress: true,
  // Conversts the googlemail.com domain to gmail.com
  gmail_convert_googlemaildotcom: true,
  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
  outlookdotcom_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  outlookdotcom_remove_subaddress: true,
  // The following conversions are specific to Yahoo
  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
  yahoo_lowercase: true,
  // Removes the subaddress (e.g. "-foo") from the email address
  yahoo_remove_subaddress: true,
  // The following conversions are specific to Yandex
  // Lowercases the local part of the Yandex address (known to be case-insensitive)
  yandex_lowercase: true,
  // The following conversions are specific to iCloud
  // Lowercases the local part of the iCloud address (known to be case-insensitive)
  icloud_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  icloud_remove_subaddress: true
}; // List of domains used by iCloud

var icloud_domains = ['icloud.com', 'me.com']; // List of domains used by Outlook.com and its predecessors
// This list is likely incomplete.
// Partial reference:
// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/

var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com']; // List of domains used by Yahoo Mail
// This list is likely incomplete

var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com']; // List of domains used by yandex.ru

var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru']; // replace single dots, but not multiple consecutive dots

function dotsReplacer(match) {
  if (match.length > 1) {
    return match;
  }

  return '';
}

function normalizeEmail(email, options) {
  options = (0, _merge.default)(options, default_normalize_email_options);
  var raw_parts = email.split('@');
  var domain = raw_parts.pop();
  var user = raw_parts.join('@');
  var parts = [user, domain]; // The domain is always lowercased, as it's case-insensitive per RFC 1035

  parts[1] = parts[1].toLowerCase();

  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
    // Address is GMail
    if (options.gmail_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (options.gmail_remove_dots) {
      // this does not replace consecutive dots like example..email@gmail.com
      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.gmail_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
    // Address is iCloud
    if (options.icloud_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.icloud_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
    // Address is Outlook.com
    if (options.outlookdotcom_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.outlookdotcom_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
    // Address is Yahoo
    if (options.yahoo_remove_subaddress) {
      var components = parts[0].split('-');
      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.yahoo_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
    if (options.all_lowercase || options.yandex_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = 'yandex.ru'; // all yandex domains are equal, 1st preffered
  } else if (options.all_lowercase) {
    // Any other address
    parts[0] = parts[0].toLowerCase();
  }

  return parts.join('@');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/rtrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/rtrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = rtrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rtrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("[".concat(chars, "]")) : /\s/;
  var idx = str.length - 1;

  for (; idx >= 0 && pattern.test(str[idx]); idx--) {
    ;
  }

  return idx < str.length ? str.substr(0, idx + 1) : str;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/stripLow.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/stripLow.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = stripLow;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./blacklist */ "./node_modules/validator/lib/blacklist.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stripLow(str, keep_new_lines) {
  (0, _assertString.default)(str);
  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
  return (0, _blacklist.default)(str, chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/toBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBoolean(str, strict) {
  (0, _assertString.default)(str);

  if (strict) {
    return str === '1' || str === 'true';
  }

  return str !== '0' && str !== 'false' && str !== '';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toDate.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/toDate.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toDate;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toDate(date) {
  (0, _assertString.default)(date);
  date = Date.parse(date);
  return !isNaN(date) ? new Date(date) : null;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/toFloat.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toFloat;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toFloat(str) {
  (0, _assertString.default)(str);
  return parseFloat(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/toInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toInt(str, radix) {
  (0, _assertString.default)(str);
  return parseInt(str, radix || 10);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/trim.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/trim.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = trim;

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./ltrim */ "./node_modules/validator/lib/ltrim.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trim(str, chars) {
  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/unescape.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/unescape.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = unescape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unescape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/assertString.js":
/*!*********************************************************!*\
  !*** ./node_modules/validator/lib/util/assertString.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = assertString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    var invalidType;

    if (input === null) {
      invalidType = 'null';
    } else {
      invalidType = _typeof(input);

      if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
        invalidType = input.constructor.name;
      } else {
        invalidType = "a ".concat(invalidType);
      }
    }

    throw new TypeError("Expected string but received ".concat(invalidType, "."));
  }
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/includes.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/includes.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var includes = function includes(arr, val) {
  return arr.some(function (arrVal) {
    return val === arrVal;
  });
};

var _default = includes;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = merge;

function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }

  return obj;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/toString.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/toString.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function toString(input) {
  if (_typeof(input) === 'object' && input !== null) {
    if (typeof input.toString === 'function') {
      input = input.toString();
    } else {
      input = '[object Object]';
    }
  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
    input = '';
  }

  return String(input);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/whitelist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/whitelist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = whitelist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function whitelist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function (updatedModules, renewedModules) {
	var unacceptedModules = updatedModules.filter(function (moduleId) {
		return renewedModules && renewedModules.indexOf(moduleId) < 0;
	});
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	if (unacceptedModules.length > 0) {
		log(
			"warning",
			"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)"
		);
		unacceptedModules.forEach(function (moduleId) {
			log("warning", "[HMR]  - " + moduleId);
		});
	}

	if (!renewedModules || renewedModules.length === 0) {
		log("info", "[HMR] Nothing hot updated.");
	} else {
		log("info", "[HMR] Updated modules:");
		renewedModules.forEach(function (moduleId) {
			if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
				var parts = moduleId.split("!");
				log.groupCollapsed("info", "[HMR]  - " + parts.pop());
				log("info", "[HMR]  - " + moduleId);
				log.groupEnd("info");
			} else {
				log("info", "[HMR]  - " + moduleId);
			}
		});
		var numberIds = renewedModules.every(function (moduleId) {
			return typeof moduleId === "number";
		});
		if (numberIds)
			log(
				"info",
				'[HMR] Consider using the optimization.moduleIds: "named" for module names.'
			);
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function (level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function (level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function (level) {
	logLevel = level;
};

module.exports.formatError = function (err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot/poll.js?1000":
/*!***********************************************!*\
  !*** ./node_modules/webpack/hot/poll.js?1000 ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __resourceQuery = "?1000";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*globals __resourceQuery */
if (true) {
	var hotPollInterval = +__resourceQuery.substr(1) || 0;
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	var checkForUpdate = function checkForUpdate(fromUpdate) {
		if (module.hot.status() === "idle") {
			module.hot
				.check(true)
				.then(function (updatedModules) {
					if (!updatedModules) {
						if (fromUpdate) log("info", "[HMR] Update applied.");
						return;
					}
					__webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);
					checkForUpdate(true);
				})
				.catch(function (err) {
					var status = module.hot.status();
					if (["abort", "fail"].indexOf(status) >= 0) {
						log("warning", "[HMR] Cannot apply update.");
						log("warning", "[HMR] " + log.formatError(err));
						log("warning", "[HMR] You need to restart the application!");
					} else {
						log("warning", "[HMR] Update failed: " + log.formatError(err));
					}
				});
		}
	};
	setInterval(checkForUpdate, hotPollInterval);
} else {}


/***/ }),

/***/ "./node_modules/wkx/lib/binaryreader.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binaryreader.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryReader;

function BinaryReader(buffer, isBigEndian) {
    this.buffer = buffer;
    this.position = 0;
    this.isBigEndian = isBigEndian || false;
}

function _read(readLE, readBE, size) {
    return function () {
        var value;

        if (this.isBigEndian)
            value = readBE.call(this.buffer, this.position);
        else
            value = readLE.call(this.buffer, this.position);

        this.position += size;

        return value;
    };
}

BinaryReader.prototype.readUInt8 = _read(Buffer.prototype.readUInt8, Buffer.prototype.readUInt8, 1);
BinaryReader.prototype.readUInt16 = _read(Buffer.prototype.readUInt16LE, Buffer.prototype.readUInt16BE, 2);
BinaryReader.prototype.readUInt32 = _read(Buffer.prototype.readUInt32LE, Buffer.prototype.readUInt32BE, 4);
BinaryReader.prototype.readInt8 = _read(Buffer.prototype.readInt8, Buffer.prototype.readInt8, 1);
BinaryReader.prototype.readInt16 = _read(Buffer.prototype.readInt16LE, Buffer.prototype.readInt16BE, 2);
BinaryReader.prototype.readInt32 = _read(Buffer.prototype.readInt32LE, Buffer.prototype.readInt32BE, 4);
BinaryReader.prototype.readFloat = _read(Buffer.prototype.readFloatLE, Buffer.prototype.readFloatBE, 4);
BinaryReader.prototype.readDouble = _read(Buffer.prototype.readDoubleLE, Buffer.prototype.readDoubleBE, 8);

BinaryReader.prototype.readVarInt = function () {
    var nextByte,
        result = 0,
        bytesRead = 0;

    do {
        nextByte = this.buffer[this.position + bytesRead];
        result += (nextByte & 0x7F) << (7 * bytesRead);
        bytesRead++;
    } while (nextByte >= 0x80);

    this.position += bytesRead;

    return result;
};


/***/ }),

/***/ "./node_modules/wkx/lib/binarywriter.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binarywriter.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryWriter;

function BinaryWriter(size, allowResize) {
    this.buffer = new Buffer(size);
    this.position = 0;
    this.allowResize = allowResize;
}

function _write(write, size) {
    return function (value, noAssert) {
        this.ensureSize(size);

        write.call(this.buffer, value, this.position, noAssert);
        this.position += size;
    };
}

BinaryWriter.prototype.writeUInt8 = _write(Buffer.prototype.writeUInt8, 1);
BinaryWriter.prototype.writeUInt16LE = _write(Buffer.prototype.writeUInt16LE, 2);
BinaryWriter.prototype.writeUInt16BE = _write(Buffer.prototype.writeUInt16BE, 2);
BinaryWriter.prototype.writeUInt32LE = _write(Buffer.prototype.writeUInt32LE, 4);
BinaryWriter.prototype.writeUInt32BE = _write(Buffer.prototype.writeUInt32BE, 4);
BinaryWriter.prototype.writeInt8 = _write(Buffer.prototype.writeInt8, 1);
BinaryWriter.prototype.writeInt16LE = _write(Buffer.prototype.writeInt16LE, 2);
BinaryWriter.prototype.writeInt16BE = _write(Buffer.prototype.writeInt16BE, 2);
BinaryWriter.prototype.writeInt32LE = _write(Buffer.prototype.writeInt32LE, 4);
BinaryWriter.prototype.writeInt32BE = _write(Buffer.prototype.writeInt32BE, 4);
BinaryWriter.prototype.writeFloatLE = _write(Buffer.prototype.writeFloatLE, 4);
BinaryWriter.prototype.writeFloatBE = _write(Buffer.prototype.writeFloatBE, 4);
BinaryWriter.prototype.writeDoubleLE = _write(Buffer.prototype.writeDoubleLE, 8);
BinaryWriter.prototype.writeDoubleBE = _write(Buffer.prototype.writeDoubleBE, 8);

BinaryWriter.prototype.writeBuffer = function (buffer) {
    this.ensureSize(buffer.length);

    buffer.copy(this.buffer, this.position, 0, buffer.length);
    this.position += buffer.length;
};

BinaryWriter.prototype.writeVarInt = function (value) {
    var length = 1;

    while ((value & 0xFFFFFF80) !== 0) {
        this.writeUInt8((value & 0x7F) | 0x80);
        value >>>= 7;
        length++;
    }

    this.writeUInt8(value & 0x7F);

    return length;
};

BinaryWriter.prototype.ensureSize = function (size) {
    if (this.buffer.length < this.position + size) {
        if (this.allowResize) {
            var tempBuffer = new Buffer(this.position + size);
            this.buffer.copy(tempBuffer, 0, 0, this.buffer.length);
            this.buffer = tempBuffer;
        }
        else {
            throw new RangeError('index out of range');
        }
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometry.js":
/*!******************************************!*\
  !*** ./node_modules/wkx/lib/geometry.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Geometry;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
var MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
var MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
var GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");
var BinaryReader = __webpack_require__(/*! ./binaryreader */ "./node_modules/wkx/lib/binaryreader.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var WktParser = __webpack_require__(/*! ./wktparser */ "./node_modules/wkx/lib/wktparser.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Geometry() {
    this.srid = undefined;
    this.hasZ = false;
    this.hasM = false;
}

Geometry.parse = function (value, options) {
    var valueType = typeof value;

    if (valueType === 'string' || value instanceof WktParser)
        return Geometry._parseWkt(value);
    else if (Buffer.isBuffer(value) || value instanceof BinaryReader)
        return Geometry._parseWkb(value, options);
    else
        throw new Error('first argument must be a string or Buffer');
};

Geometry._parseWkt = function (value) {
    var wktParser,
        srid;

    if (value instanceof WktParser)
        wktParser = value;
    else
        wktParser = new WktParser(value);

    var match = wktParser.matchRegex([/^SRID=(\d+);/]);
    if (match)
        srid = parseInt(match[1], 10);

    var geometryType = wktParser.matchType();
    var dimension = wktParser.matchDimension();

    var options = {
        srid: srid,
        hasZ: dimension.hasZ,
        hasM: dimension.hasM
    };

    switch (geometryType) {
        case Types.wkt.Point:
            return Point._parseWkt(wktParser, options);
        case Types.wkt.LineString:
            return LineString._parseWkt(wktParser, options);
        case Types.wkt.Polygon:
            return Polygon._parseWkt(wktParser, options);
        case Types.wkt.MultiPoint:
            return MultiPoint._parseWkt(wktParser, options);
        case Types.wkt.MultiLineString:
            return MultiLineString._parseWkt(wktParser, options);
        case Types.wkt.MultiPolygon:
            return MultiPolygon._parseWkt(wktParser, options);
        case Types.wkt.GeometryCollection:
            return GeometryCollection._parseWkt(wktParser, options);
    }
};

Geometry._parseWkb = function (value, parentOptions) {
    var binaryReader,
        wkbType,
        geometryType,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    binaryReader.isBigEndian = !binaryReader.readInt8();

    wkbType = binaryReader.readUInt32();

    options.hasSrid = (wkbType & 0x20000000) === 0x20000000;
    options.isEwkb = (wkbType & 0x20000000) || (wkbType & 0x40000000) || (wkbType & 0x80000000);

    if (options.hasSrid)
        options.srid = binaryReader.readUInt32();

    options.hasZ = false;
    options.hasM = false;

    if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {
        if (wkbType >= 1000 && wkbType < 2000) {
            options.hasZ = true;
            geometryType = wkbType - 1000;
        }
        else if (wkbType >= 2000 && wkbType < 3000) {
            options.hasM = true;
            geometryType = wkbType - 2000;
        }
        else if (wkbType >= 3000 && wkbType < 4000) {
            options.hasZ = true;
            options.hasM = true;
            geometryType = wkbType - 3000;
        }
        else {
            geometryType = wkbType;
        }
    }
    else {
        if (wkbType & 0x80000000)
            options.hasZ = true;
        if (wkbType & 0x40000000)
            options.hasM = true;

        geometryType = wkbType & 0xF;
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseWkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseWkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseWkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseWkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseWkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseWkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseWkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseTwkb = function (value) {
    var binaryReader,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    var type = binaryReader.readUInt8();
    var metadataHeader = binaryReader.readUInt8();

    var geometryType = type & 0x0F;
    options.precision = ZigZag.decode(type >> 4);
    options.precisionFactor = Math.pow(10, options.precision);

    options.hasBoundingBox = metadataHeader >> 0 & 1;
    options.hasSizeAttribute = metadataHeader >> 1 & 1;
    options.hasIdList = metadataHeader >> 2 & 1;
    options.hasExtendedPrecision = metadataHeader >> 3 & 1;
    options.isEmpty = metadataHeader >> 4 & 1;

    if (options.hasExtendedPrecision) {
        var extendedPrecision = binaryReader.readUInt8();
        options.hasZ = (extendedPrecision & 0x01) === 0x01;
        options.hasM = (extendedPrecision & 0x02) === 0x02;

        options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);
        options.zPrecisionFactor = Math.pow(10, options.zPrecision);

        options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);
        options.mPrecisionFactor = Math.pow(10, options.mPrecision);
    }
    else {
        options.hasZ = false;
        options.hasM = false;
    }

    if (options.hasSizeAttribute)
        binaryReader.readVarInt();
    if (options.hasBoundingBox) {
        var dimensions = 2;

        if (options.hasZ)
            dimensions++;
        if (options.hasM)
            dimensions++;

        for (var i = 0; i < dimensions; i++) {
            binaryReader.readVarInt();
            binaryReader.readVarInt();
        }
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseTwkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseTwkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseTwkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseTwkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseTwkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseGeoJSON = function (value) {
    return Geometry._parseGeoJSON(value);
};

Geometry._parseGeoJSON = function (value, isSubGeometry) {
    var geometry;

    switch (value.type) {
        case Types.geoJSON.Point:
            geometry = Point._parseGeoJSON(value); break;
        case Types.geoJSON.LineString:
            geometry = LineString._parseGeoJSON(value); break;
        case Types.geoJSON.Polygon:
            geometry = Polygon._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPoint:
            geometry = MultiPoint._parseGeoJSON(value); break;
        case Types.geoJSON.MultiLineString:
            geometry = MultiLineString._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPolygon:
            geometry = MultiPolygon._parseGeoJSON(value); break;
        case Types.geoJSON.GeometryCollection:
            geometry = GeometryCollection._parseGeoJSON(value); break;
        default:
            throw new Error('GeometryType ' + value.type + ' not supported');
    }

    if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {
        var crs = value.crs.properties.name;

        if (crs.indexOf('EPSG:') === 0)
            geometry.srid = parseInt(crs.substring(5));
        else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0)
            geometry.srid = parseInt(crs.substring(22));
        else
            throw new Error('Unsupported crs: ' + crs);
    }
    else if (!isSubGeometry) {
        geometry.srid = 4326;
    }

    return geometry;
};

Geometry.prototype.toEwkt = function () {
    return 'SRID=' + this.srid + ';' + this.toWkt();
};

Geometry.prototype.toEwkb = function () {
    var ewkb = new BinaryWriter(this._getWkbSize() + 4);
    var wkb = this.toWkb();

    ewkb.writeInt8(1);
    ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);
    ewkb.writeUInt32LE(this.srid);

    ewkb.writeBuffer(wkb.slice(5));

    return ewkb.buffer;
};

Geometry.prototype._getWktType = function (wktType, isEmpty) {
    var wkt = wktType;

    if (this.hasZ && this.hasM)
        wkt += ' ZM ';
    else if (this.hasZ)
        wkt += ' Z ';
    else if (this.hasM)
        wkt += ' M ';

    if (isEmpty && !this.hasZ && !this.hasM)
        wkt += ' ';

    if (isEmpty)
        wkt += 'EMPTY';

    return wkt;
};

Geometry.prototype._getWktCoordinate = function (point) {
    var coordinates = point.x + ' ' + point.y;

    if (this.hasZ)
        coordinates += ' ' + point.z;
    if (this.hasM)
        coordinates += ' ' + point.m;

    return coordinates;
};

Geometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {
    var dimensionType = 0;

    if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {
        if (this.hasZ && this.hasM)
            dimensionType += 3000;
        else if (this.hasZ)
            dimensionType += 1000;
        else if (this.hasM)
            dimensionType += 2000;
    }
    else {
        if (this.hasZ)
            dimensionType |= 0x80000000;
        if (this.hasM)
            dimensionType |= 0x40000000;
    }

    wkb.writeUInt32LE((dimensionType + geometryType) >>> 0, true);
};

Geometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {
    return {
        xy: xyPrecision,
        z: zPrecision,
        m: mPrecision,
        xyFactor: Math.pow(10, xyPrecision),
        zFactor: Math.pow(10, zPrecision),
        mFactor: Math.pow(10, mPrecision)
    };
};

Geometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {
    var type = (ZigZag.encode(precision.xy) << 4) + geometryType;
    var metadataHeader = (this.hasZ || this.hasM) << 3;
    metadataHeader += isEmpty << 4;

    twkb.writeUInt8(type);
    twkb.writeUInt8(metadataHeader);

    if (this.hasZ || this.hasM) {
        var extendedPrecision = 0;
        if (this.hasZ)
            extendedPrecision |= 0x1;
        if (this.hasM)
            extendedPrecision |= 0x2;

        twkb.writeUInt8(extendedPrecision);
    }
};

Geometry.prototype.toGeoJSON = function (options) {
    var geoJSON = {};

    if (this.srid) {
        if (options) {
            if (options.shortCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'EPSG:' + this.srid
                    }
                };
            }
            else if (options.longCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'urn:ogc:def:crs:EPSG::' + this.srid
                    }
                };
            }
        }
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometrycollection.js":
/*!****************************************************!*\
  !*** ./node_modules/wkx/lib/geometrycollection.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = GeometryCollection;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function GeometryCollection(geometries, srid) {
    Geometry.call(this);

    this.geometries = geometries || [];
	this.srid = srid;

    if (this.geometries.length > 0) {
        this.hasZ = this.geometries[0].hasZ;
        this.hasM = this.geometries[0].hasM;
    }
}

util.inherits(GeometryCollection, Geometry);

GeometryCollection.Z = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    return geometryCollection;
};

GeometryCollection.M = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection.ZM = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection._parseWkt = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return geometryCollection;

    value.expectGroupStart();

    do {
        geometryCollection.geometries.push(Geometry.parse(value));
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return geometryCollection;
};

GeometryCollection._parseWkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    var geometryCount = value.readUInt32();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parse(value, options));

    return geometryCollection;
};

GeometryCollection._parseTwkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (options.isEmpty)
        return geometryCollection;

    var geometryCount = value.readVarInt();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parseTwkb(value));

    return geometryCollection;
};

GeometryCollection._parseGeoJSON = function (value) {
    var geometryCollection = new GeometryCollection();

    for (var i = 0; i < value.geometries.length; i++)
        geometryCollection.geometries.push(Geometry._parseGeoJSON(value.geometries[i], true));

    if (geometryCollection.geometries.length > 0)
        geometryCollection.hasZ = geometryCollection.geometries[0].hasZ;

    return geometryCollection;
};

GeometryCollection.prototype.toWkt = function () {
    if (this.geometries.length === 0)
        return this._getWktType(Types.wkt.GeometryCollection, true);

    var wkt = this._getWktType(Types.wkt.GeometryCollection, false) + '(';

    for (var i = 0; i < this.geometries.length; i++)
        wkt += this.geometries[i].toWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

GeometryCollection.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.GeometryCollection);
    wkb.writeUInt32LE(this.geometries.length);

    for (var i = 0; i < this.geometries.length; i++)
        wkb.writeBuffer(this.geometries[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

GeometryCollection.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.geometries.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.GeometryCollection, precision, isEmpty);

    if (this.geometries.length > 0) {
        twkb.writeVarInt(this.geometries.length);

        for (var i = 0; i < this.geometries.length; i++)
            twkb.writeBuffer(this.geometries[i].toTwkb());
    }

    return twkb.buffer;
};

GeometryCollection.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.geometries.length; i++)
        size += this.geometries[i]._getWkbSize();

    return size;
};

GeometryCollection.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.GeometryCollection;
    geoJSON.geometries = [];

    for (var i = 0; i < this.geometries.length; i++)
        geoJSON.geometries.push(this.geometries[i].toGeoJSON());

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/linestring.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/linestring.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = LineString;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function LineString(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;

    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(LineString, Geometry);

LineString.Z = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    return lineString;
};

LineString.M = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasM = true;
    return lineString;
};

LineString.ZM = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    lineString.hasM = true;
    return lineString;
};

LineString._parseWkt = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return lineString;

    value.expectGroupStart();
    lineString.points.push.apply(lineString.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return lineString;
};

LineString._parseWkb = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readWkbPoint(value, options));

    return lineString;
};

LineString._parseTwkb = function (value, options) {
    var lineString = new LineString();
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (options.isEmpty)
        return lineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return lineString;
};

LineString._parseGeoJSON = function (value) {
    var lineString = new LineString();

    if (value.coordinates.length > 0)
        lineString.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        lineString.points.push(Point._readGeoJSONPoint(value.coordinates[i]));

    return lineString;
};

LineString.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.LineString, true);

    return this._getWktType(Types.wkt.LineString, false) + this._toInnerWkt();
};

LineString.prototype._toInnerWkt = function () {
    var innerWkt = '(';

    for (var i = 0; i < this.points.length; i++)
        innerWkt += this._getWktCoordinate(this.points[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    return innerWkt;
};

LineString.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.LineString, parentOptions);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        this.points[i]._writeWkbPoint(wkb);

    return wkb.buffer;
};

LineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.LineString, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

LineString.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

LineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.LineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++) {
        if (this.hasZ)
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y, this.points[i].z]);
        else
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y]);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multilinestring.js":
/*!*************************************************!*\
  !*** ./node_modules/wkx/lib/multilinestring.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiLineString;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiLineString(lineStrings, srid) {
    Geometry.call(this);

    this.lineStrings = lineStrings || [];
	this.srid = srid;

    if (this.lineStrings.length > 0) {
        this.hasZ = this.lineStrings[0].hasZ;
        this.hasM = this.lineStrings[0].hasM;
    }
}

util.inherits(MultiLineString, Geometry);

MultiLineString.Z = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    return multiLineString;
};

MultiLineString.M = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString.ZM = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString._parseWkt = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiLineString;

    value.expectGroupStart();

    do {
        value.expectGroupStart();
        multiLineString.lineStrings.push(new LineString(value.matchCoordinates(options)));
        value.expectGroupEnd();
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiLineString;
};

MultiLineString._parseWkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    var lineStringCount = value.readUInt32();

    for (var i = 0; i < lineStringCount; i++)
        multiLineString.lineStrings.push(Geometry.parse(value, options));

    return multiLineString;
};

MultiLineString._parseTwkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (options.isEmpty)
        return multiLineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var lineStringCount = value.readVarInt();

    for (var i = 0; i < lineStringCount; i++) {
        var lineString = new LineString();
        lineString.hasZ = options.hasZ;
        lineString.hasM = options.hasM;

        var pointCount = value.readVarInt();

        for (var j = 0; j < pointCount; j++)
            lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

        multiLineString.lineStrings.push(lineString);
    }

    return multiLineString;
};

MultiLineString._parseGeoJSON = function (value) {
    var multiLineString = new MultiLineString();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        multiLineString.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiLineString.lineStrings.push(LineString._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiLineString;
};

MultiLineString.prototype.toWkt = function () {
    if (this.lineStrings.length === 0)
        return this._getWktType(Types.wkt.MultiLineString, true);

    var wkt = this._getWktType(Types.wkt.MultiLineString, false) + '(';

    for (var i = 0; i < this.lineStrings.length; i++)
        wkt += this.lineStrings[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiLineString.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiLineString);
    wkb.writeUInt32LE(this.lineStrings.length);

    for (var i = 0; i < this.lineStrings.length; i++)
        wkb.writeBuffer(this.lineStrings[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiLineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.lineStrings.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiLineString, precision, isEmpty);

    if (this.lineStrings.length > 0) {
        twkb.writeVarInt(this.lineStrings.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.lineStrings.length; i++) {
            twkb.writeVarInt(this.lineStrings[i].points.length);

            for (var j = 0; j < this.lineStrings[i].points.length; j++)
                this.lineStrings[i].points[j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

MultiLineString.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.lineStrings.length; i++)
        size += this.lineStrings[i]._getWkbSize();

    return size;
};

MultiLineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiLineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.lineStrings.length; i++)
        geoJSON.coordinates.push(this.lineStrings[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipoint.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/multipoint.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPoint;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPoint(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;
	
    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(MultiPoint, Geometry);

MultiPoint.Z = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    return multiPoint;
};

MultiPoint.M = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint.ZM = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint._parseWkt = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPoint;

    value.expectGroupStart();
    multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return multiPoint;
};

MultiPoint._parseWkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Geometry.parse(value, options));

    return multiPoint;
};

MultiPoint._parseTwkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (options.isEmpty)
        return multiPoint;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return multiPoint;
};

MultiPoint._parseGeoJSON = function (value) {
    var multiPoint = new MultiPoint();

    if (value.coordinates.length > 0)
        multiPoint.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPoint.points.push(Point._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPoint;
};

MultiPoint.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.MultiPoint, true);

    var wkt = this._getWktType(Types.wkt.MultiPoint, false) + '(';

    for (var i = 0; i < this.points.length; i++)
        wkt += this._getWktCoordinate(this.points[i]) + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPoint.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPoint);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        wkb.writeBuffer(this.points[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPoint.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPoint, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

MultiPoint.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    coordinateSize += 5;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

MultiPoint.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPoint;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++)
        geoJSON.coordinates.push(this.points[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/multipolygon.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPolygon;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPolygon(polygons, srid) {
    Geometry.call(this);

    this.polygons = polygons || [];
	this.srid = srid;

    if (this.polygons.length > 0) {
        this.hasZ = this.polygons[0].hasZ;
        this.hasM = this.polygons[0].hasM;
    }
}

util.inherits(MultiPolygon, Geometry);

MultiPolygon.Z = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    return multiPolygon;
};

MultiPolygon.M = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon.ZM = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon._parseWkt = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPolygon;

    value.expectGroupStart();

    do {
        value.expectGroupStart();

        var exteriorRing = [];
        var interiorRings = [];

        value.expectGroupStart();
        exteriorRing.push.apply(exteriorRing, value.matchCoordinates(options));
        value.expectGroupEnd();

        while (value.isMatch([','])) {
            value.expectGroupStart();
            interiorRings.push(value.matchCoordinates(options));
            value.expectGroupEnd();
        }

        multiPolygon.polygons.push(new Polygon(exteriorRing, interiorRings));

        value.expectGroupEnd();

    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiPolygon;
};

MultiPolygon._parseWkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    var polygonCount = value.readUInt32();

    for (var i = 0; i < polygonCount; i++)
        multiPolygon.polygons.push(Geometry.parse(value, options));

    return multiPolygon;
};

MultiPolygon._parseTwkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (options.isEmpty)
        return multiPolygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var polygonCount = value.readVarInt();

    for (var i = 0; i < polygonCount; i++) {
        var polygon = new Polygon();
        polygon.hasZ = options.hasZ;
        polygon.hasM = options.hasM;

        var ringCount = value.readVarInt();
        var exteriorRingCount = value.readVarInt();

        for (var j = 0; j < exteriorRingCount; j++)
            polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        for (j = 1; j < ringCount; j++) {
            var interiorRing = [];

            var interiorRingCount = value.readVarInt();

            for (var k = 0; k < interiorRingCount; k++)
                interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

            polygon.interiorRings.push(interiorRing);
        }

        multiPolygon.polygons.push(polygon);
    }

    return multiPolygon;
};

MultiPolygon._parseGeoJSON = function (value) {
    var multiPolygon = new MultiPolygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0 && value.coordinates[0][0].length > 0)
        multiPolygon.hasZ = value.coordinates[0][0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPolygon.polygons.push(Polygon._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPolygon;
};

MultiPolygon.prototype.toWkt = function () {
    if (this.polygons.length === 0)
        return this._getWktType(Types.wkt.MultiPolygon, true);

    var wkt = this._getWktType(Types.wkt.MultiPolygon, false) + '(';

    for (var i = 0; i < this.polygons.length; i++)
        wkt += this.polygons[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPolygon.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPolygon);
    wkb.writeUInt32LE(this.polygons.length);

    for (var i = 0; i < this.polygons.length; i++)
        wkb.writeBuffer(this.polygons[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPolygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.polygons.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPolygon, precision, isEmpty);

    if (this.polygons.length > 0) {
        twkb.writeVarInt(this.polygons.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.polygons.length; i++) {
            twkb.writeVarInt(1 + this.polygons[i].interiorRings.length);

            twkb.writeVarInt(this.polygons[i].exteriorRing.length);

            for (var j = 0; j < this.polygons[i].exteriorRing.length; j++)
                this.polygons[i].exteriorRing[j]._writeTwkbPoint(twkb, precision, previousPoint);

            for (j = 0; j < this.polygons[i].interiorRings.length; j++) {
                twkb.writeVarInt(this.polygons[i].interiorRings[j].length);

                for (var k = 0; k < this.polygons[i].interiorRings[j].length; k++)
                    this.polygons[i].interiorRings[j][k]._writeTwkbPoint(twkb, precision, previousPoint);
            }
        }
    }

    return twkb.buffer;
};

MultiPolygon.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.polygons.length; i++)
        size += this.polygons[i]._getWkbSize();

    return size;
};

MultiPolygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPolygon;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.polygons.length; i++)
        geoJSON.coordinates.push(this.polygons[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/point.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/point.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Point;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Point(x, y, z, m, srid) {
    Geometry.call(this);

    this.x = x;
    this.y = y;
    this.z = z;
    this.m = m;
	this.srid = srid;

    this.hasZ = typeof this.z !== 'undefined';
    this.hasM = typeof this.m !== 'undefined';
}

util.inherits(Point, Geometry);

Point.Z = function (x, y, z, srid) {
    var point = new Point(x, y, z, undefined, srid);
    point.hasZ = true;
    return point;
};

Point.M = function (x, y, m, srid) {
    var point = new Point(x, y, undefined, m, srid);
    point.hasM = true;
    return point;
};

Point.ZM = function (x, y, z, m, srid) {
    var point = new Point(x, y, z, m, srid);
    point.hasZ = true;
    point.hasM = true;
    return point;
};

Point._parseWkt = function (value, options) {
    var point = new Point();
    point.srid = options.srid;
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return point;

    value.expectGroupStart();

    var coordinate = value.matchCoordinate(options);

    point.x = coordinate.x;
    point.y = coordinate.y;
    point.z = coordinate.z;
    point.m = coordinate.m;

    value.expectGroupEnd();

    return point;
};

Point._parseWkb = function (value, options) {
    var point = Point._readWkbPoint(value, options);
    point.srid = options.srid;
    return point;
};

Point._readWkbPoint = function (value, options) {
    return new Point(value.readDouble(), value.readDouble(),
        options.hasZ ? value.readDouble() : undefined,
        options.hasM ? value.readDouble() : undefined);
};

Point._parseTwkb = function (value, options) {
    var point = new Point();
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (options.isEmpty)
        return point;

    point.x = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.y = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.z = options.hasZ ? ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor : undefined;
    point.m = options.hasM ? ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor : undefined;

    return point;
};

Point._readTwkbPoint = function (value, options, previousPoint) {
    previousPoint.x += ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    previousPoint.y += ZigZag.decode(value.readVarInt()) / options.precisionFactor;

    if (options.hasZ)
        previousPoint.z += ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor;
    if (options.hasM)
        previousPoint.m += ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor;

    return new Point(previousPoint.x, previousPoint.y, previousPoint.z, previousPoint.m);
};

Point._parseGeoJSON = function (value) {
    return Point._readGeoJSONPoint(value.coordinates);
};

Point._readGeoJSONPoint = function (coordinates) {
    if (coordinates.length === 0)
        return new Point();

    if (coordinates.length > 2)
        return new Point(coordinates[0], coordinates[1], coordinates[2]);

    return new Point(coordinates[0], coordinates[1]);
};

Point.prototype.toWkt = function () {
    if (typeof this.x === 'undefined' && typeof this.y === 'undefined' &&
        typeof this.z === 'undefined' && typeof this.m === 'undefined')
        return this._getWktType(Types.wkt.Point, true);

    return this._getWktType(Types.wkt.Point, false) + '(' + this._getWktCoordinate(this) + ')';
};

Point.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);
    this._writeWkbType(wkb, Types.wkb.Point, parentOptions);

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined') {
        wkb.writeDoubleLE(NaN);
        wkb.writeDoubleLE(NaN);

        if (this.hasZ)
            wkb.writeDoubleLE(NaN);
        if (this.hasM)
            wkb.writeDoubleLE(NaN);
    }
    else {
        this._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Point.prototype._writeWkbPoint = function (wkb) {
    wkb.writeDoubleLE(this.x);
    wkb.writeDoubleLE(this.y);

    if (this.hasZ)
        wkb.writeDoubleLE(this.z);
    if (this.hasM)
        wkb.writeDoubleLE(this.m);
};

Point.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = typeof this.x === 'undefined' && typeof this.y === 'undefined';

    this._writeTwkbHeader(twkb, Types.wkb.Point, precision, isEmpty);

    if (!isEmpty)
        this._writeTwkbPoint(twkb, precision, new Point(0, 0, 0, 0));

    return twkb.buffer;
};

Point.prototype._writeTwkbPoint = function (twkb, precision, previousPoint) {
    var x = this.x * precision.xyFactor;
    var y = this.y * precision.xyFactor;
    var z = this.z * precision.zFactor;
    var m = this.m * precision.mFactor;

    twkb.writeVarInt(ZigZag.encode(x - previousPoint.x));
    twkb.writeVarInt(ZigZag.encode(y - previousPoint.y));
    if (this.hasZ)
        twkb.writeVarInt(ZigZag.encode(z - previousPoint.z));
    if (this.hasM)
        twkb.writeVarInt(ZigZag.encode(m - previousPoint.m));

    previousPoint.x = x;
    previousPoint.y = y;
    previousPoint.z = z;
    previousPoint.m = m;
};

Point.prototype._getWkbSize = function () {
    var size = 1 + 4 + 8 + 8;

    if (this.hasZ)
        size += 8;
    if (this.hasM)
        size += 8;

    return size;
};

Point.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Point;

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined')
        geoJSON.coordinates = [];
    else if (typeof this.z !== 'undefined')
        geoJSON.coordinates = [this.x, this.y, this.z];
    else
        geoJSON.coordinates = [this.x, this.y];

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/wkx/lib/polygon.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Polygon;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function Polygon(exteriorRing, interiorRings, srid) {
    Geometry.call(this);

    this.exteriorRing = exteriorRing || [];
    this.interiorRings = interiorRings || [];
	this.srid = srid;

    if (this.exteriorRing.length > 0) {
        this.hasZ = this.exteriorRing[0].hasZ;
        this.hasM = this.exteriorRing[0].hasM;
    }
}

util.inherits(Polygon, Geometry);

Polygon.Z = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    return polygon;
};

Polygon.M = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasM = true;
    return polygon;
};

Polygon.ZM = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    polygon.hasM = true;
    return polygon;
};

Polygon._parseWkt = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return polygon;

    value.expectGroupStart();

    value.expectGroupStart();
    polygon.exteriorRing.push.apply(polygon.exteriorRing, value.matchCoordinates(options));
    value.expectGroupEnd();

    while (value.isMatch([','])) {
        value.expectGroupStart();
        polygon.interiorRings.push(value.matchCoordinates(options));
        value.expectGroupEnd();
    }

    value.expectGroupEnd();

    return polygon;
};

Polygon._parseWkb = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    var ringCount = value.readUInt32();

    if (ringCount > 0) {
        var exteriorRingCount = value.readUInt32();

        for (var i = 0; i < exteriorRingCount; i++)
            polygon.exteriorRing.push(Point._readWkbPoint(value, options));

        for (i = 1; i < ringCount; i++) {
            var interiorRing = [];

            var interiorRingCount = value.readUInt32();

            for (var j = 0; j < interiorRingCount; j++)
                interiorRing.push(Point._readWkbPoint(value, options));

            polygon.interiorRings.push(interiorRing);
        }
    }

    return polygon;
};

Polygon._parseTwkb = function (value, options) {
    var polygon = new Polygon();
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (options.isEmpty)
        return polygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var ringCount = value.readVarInt();
    var exteriorRingCount = value.readVarInt();

    for (var i = 0; i < exteriorRingCount; i++)
        polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

    for (i = 1; i < ringCount; i++) {
        var interiorRing = [];

        var interiorRingCount = value.readVarInt();

        for (var j = 0; j < interiorRingCount; j++)
            interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        polygon.interiorRings.push(interiorRing);
    }

    return polygon;
};

Polygon._parseGeoJSON = function (value) {
    var polygon = new Polygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        polygon.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++) {
        if (i > 0)
            polygon.interiorRings.push([]);

        for (var j = 0; j  < value.coordinates[i].length; j++) {
            if (i === 0)
                polygon.exteriorRing.push(Point._readGeoJSONPoint(value.coordinates[i][j]));
            else
                polygon.interiorRings[i - 1].push(Point._readGeoJSONPoint(value.coordinates[i][j]));
        }
    }

    return polygon;
};

Polygon.prototype.toWkt = function () {
    if (this.exteriorRing.length === 0)
        return this._getWktType(Types.wkt.Polygon, true);

    return this._getWktType(Types.wkt.Polygon, false) + this._toInnerWkt();
};

Polygon.prototype._toInnerWkt = function () {
    var innerWkt = '((';

    for (var i = 0; i < this.exteriorRing.length; i++)
        innerWkt += this._getWktCoordinate(this.exteriorRing[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    for (i = 0; i < this.interiorRings.length; i++) {
        innerWkt += ',(';

        for (var j = 0; j < this.interiorRings[i].length; j++) {
            innerWkt += this._getWktCoordinate(this.interiorRings[i][j]) + ',';
        }

        innerWkt = innerWkt.slice(0, -1);
        innerWkt += ')';
    }

    innerWkt += ')';

    return innerWkt;
};

Polygon.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.Polygon, parentOptions);

    if (this.exteriorRing.length > 0) {
        wkb.writeUInt32LE(1 + this.interiorRings.length);
        wkb.writeUInt32LE(this.exteriorRing.length);
    }
    else {
        wkb.writeUInt32LE(0);
    }

    for (var i = 0; i < this.exteriorRing.length; i++)
        this.exteriorRing[i]._writeWkbPoint(wkb);

    for (i = 0; i < this.interiorRings.length; i++) {
        wkb.writeUInt32LE(this.interiorRings[i].length);

        for (var j = 0; j < this.interiorRings[i].length; j++)
            this.interiorRings[i][j]._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Polygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.exteriorRing.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.Polygon, precision, isEmpty);

    if (this.exteriorRing.length > 0) {
        twkb.writeVarInt(1 + this.interiorRings.length);

        twkb.writeVarInt(this.exteriorRing.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.exteriorRing.length; i++)
            this.exteriorRing[i]._writeTwkbPoint(twkb, precision, previousPoint);

        for (i = 0; i < this.interiorRings.length; i++) {
            twkb.writeVarInt(this.interiorRings[i].length);

            for (var j = 0; j < this.interiorRings[i].length; j++)
                this.interiorRings[i][j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

Polygon.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    var size = 1 + 4 + 4;

    if (this.exteriorRing.length > 0)
        size += 4 + (this.exteriorRing.length * coordinateSize);

    for (var i = 0; i < this.interiorRings.length; i++)
        size += 4 + (this.interiorRings[i].length * coordinateSize);

    return size;
};

Polygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Polygon;
    geoJSON.coordinates = [];

    if (this.exteriorRing.length > 0) {
        var exteriorRing = [];

        for (var i = 0; i < this.exteriorRing.length; i++) {
            if (this.hasZ)
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y, this.exteriorRing[i].z]);
            else
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y]);
        }

        geoJSON.coordinates.push(exteriorRing);
    }

    for (var j = 0; j < this.interiorRings.length; j++) {
        var interiorRing = [];

        for (var k = 0; k < this.interiorRings[j].length; k++) {
            if (this.hasZ)
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y, this.interiorRings[j][k].z]);
            else
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y]);
        }

        geoJSON.coordinates.push(interiorRing);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/types.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = {
    wkt: {
        Point: 'POINT',
        LineString: 'LINESTRING',
        Polygon: 'POLYGON',
        MultiPoint: 'MULTIPOINT',
        MultiLineString: 'MULTILINESTRING',
        MultiPolygon: 'MULTIPOLYGON',
        GeometryCollection: 'GEOMETRYCOLLECTION'
    },
    wkb: {
        Point: 1,
        LineString: 2,
        Polygon: 3,
        MultiPoint: 4,
        MultiLineString: 5,
        MultiPolygon: 6,
        GeometryCollection: 7
    },
    geoJSON: {
        Point: 'Point',
        LineString: 'LineString',
        Polygon: 'Polygon',
        MultiPoint: 'MultiPoint',
        MultiLineString: 'MultiLineString',
        MultiPolygon: 'MultiPolygon',
        GeometryCollection: 'GeometryCollection'
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/wktparser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkx/lib/wktparser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = WktParser;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");

function WktParser(value) {
    this.value = value;
    this.position = 0;
}

WktParser.prototype.match = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return tokens[i];
        }
    }

    return null;
};

WktParser.prototype.matchRegex = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        var match = this.value.substring(this.position).match(tokens[i]);

        if (match) {
            this.position += match[0].length;
            return match;
        }
    }

    return null;
};

WktParser.prototype.isMatch = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return true;
        }
    }

    return false;
};

WktParser.prototype.matchType = function () {
    var geometryType = this.match([Types.wkt.Point, Types.wkt.LineString, Types.wkt.Polygon, Types.wkt.MultiPoint,
    Types.wkt.MultiLineString, Types.wkt.MultiPolygon, Types.wkt.GeometryCollection]);

    if (!geometryType)
        throw new Error('Expected geometry type');

    return geometryType;
};

WktParser.prototype.matchDimension = function () {
    var dimension = this.match(['ZM', 'Z', 'M']);

    switch (dimension) {
        case 'ZM': return { hasZ: true, hasM: true };
        case 'Z': return { hasZ: true, hasM: false };
        case 'M': return { hasZ: false, hasM: true };
        default: return { hasZ: false, hasM: false };
    }
};

WktParser.prototype.expectGroupStart = function () {
    if (!this.isMatch(['(']))
        throw new Error('Expected group start');
};

WktParser.prototype.expectGroupEnd = function () {
    if (!this.isMatch([')']))
        throw new Error('Expected group end');
};

WktParser.prototype.matchCoordinate = function (options) {
    var match;

    if (options.hasZ && options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else if (options.hasZ || options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else
        match = this.matchRegex([/^(\S*)\s+([^\s,)]*)/]);

    if (!match)
        throw new Error('Expected coordinates');

    if (options.hasZ && options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4]));
    else if (options.hasZ)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]));
    else if (options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), undefined, parseFloat(match[3]));
    else
        return new Point(parseFloat(match[1]), parseFloat(match[2]));
};

WktParser.prototype.matchCoordinates = function (options) {
    var coordinates = [];

    do {
        var startsWithBracket = this.isMatch(['(']);

        coordinates.push(this.matchCoordinate(options));

        if (startsWithBracket)
            this.expectGroupEnd();
    } while (this.isMatch([',']));

    return coordinates;
};

WktParser.prototype.skipWhitespaces = function () {
    while (this.position < this.value.length && this.value[this.position] === ' ')
        this.position++;
};


/***/ }),

/***/ "./node_modules/wkx/lib/wkx.js":
/*!*************************************!*\
  !*** ./node_modules/wkx/lib/wkx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
exports.Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
exports.Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
exports.LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
exports.Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
exports.MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
exports.MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
exports.MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
exports.GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");

/***/ }),

/***/ "./node_modules/wkx/lib/zigzag.js":
/*!****************************************!*\
  !*** ./node_modules/wkx/lib/zigzag.js ***!
  \****************************************/
/***/ ((module) => {

module.exports = {
    encode: function (value) {
        return (value << 1) ^ (value >> 31);
    },
    decode: function (value) {
        return (value >> 1) ^ (-(value & 1));
    }
};


/***/ }),

/***/ "apollo-server":
/*!********************************!*\
  !*** external "apollo-server" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("apollo-server");;

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("debug");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("glob");;

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash");;

/***/ }),

/***/ "lodash/_baseIsNative":
/*!***************************************!*\
  !*** external "lodash/_baseIsNative" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/_baseIsNative");;

/***/ }),

/***/ "lru-cache":
/*!****************************!*\
  !*** external "lru-cache" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("lru-cache");;

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment");;

/***/ }),

/***/ "moment-timezone":
/*!**********************************!*\
  !*** external "moment-timezone" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment-timezone");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("1c6abb03a8f4affb4a6d")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises;
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: currentChildModule !== moduleId,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				registeredStatusHandlers[i].call(null, newStatus);
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 					blockingPromises.push(promise);
/******/ 					waitForBlockingPromises(function () {
/******/ 						setStatus("ready");
/******/ 					});
/******/ 					return promise;
/******/ 				case "prepare":
/******/ 					blockingPromises.push(promise);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises.length === 0) return fn();
/******/ 			var blocker = blockingPromises;
/******/ 			blockingPromises = [];
/******/ 			return Promise.all(blocker).then(function () {
/******/ 				return waitForBlockingPromises(fn);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			setStatus("check");
/******/ 			return __webpack_require__.hmrM().then(function (update) {
/******/ 				if (!update) {
/******/ 					setStatus(applyInvalidatedModules() ? "ready" : "idle");
/******/ 					return null;
/******/ 				}
/******/ 		
/******/ 				setStatus("prepare");
/******/ 		
/******/ 				var updatedModules = [];
/******/ 				blockingPromises = [];
/******/ 				currentUpdateApplyHandlers = [];
/******/ 		
/******/ 				return Promise.all(
/******/ 					Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 						promises,
/******/ 						key
/******/ 					) {
/******/ 						__webpack_require__.hmrC[key](
/******/ 							update.c,
/******/ 							update.r,
/******/ 							update.m,
/******/ 							promises,
/******/ 							currentUpdateApplyHandlers,
/******/ 							updatedModules
/******/ 						);
/******/ 						return promises;
/******/ 					},
/******/ 					[])
/******/ 				).then(function () {
/******/ 					return waitForBlockingPromises(function () {
/******/ 						if (applyOnUpdate) {
/******/ 							return internalApply(applyOnUpdate);
/******/ 						} else {
/******/ 							setStatus("ready");
/******/ 		
/******/ 							return updatedModules;
/******/ 						}
/******/ 					});
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error("apply() is only allowed in ready status");
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				setStatus("abort");
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			// handle errors in accept handlers and self accepted module load
/******/ 			if (error) {
/******/ 				setStatus("fail");
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw error;
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			if (queuedInvalidatedModules) {
/******/ 				return internalApply(options).then(function (list) {
/******/ 					outdatedModules.forEach(function (moduleId) {
/******/ 						if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 					});
/******/ 					return list;
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			setStatus("idle");
/******/ 			return Promise.resolve(outdatedModules);
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var update = require("./" + __webpack_require__.hu(chunkId));
/******/ 			var updatedModules = update.modules;
/******/ 			var runtime = update.runtime;
/******/ 			for(var moduleId in updatedModules) {
/******/ 				if(__webpack_require__.o(updatedModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = updatedModules[moduleId];
/******/ 					if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.requireHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					module.hot._selfAccepted &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.require = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.require = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.requireHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						!__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						__webpack_require__.o(installedChunks, chunkId) &&
/******/ 						installedChunks[chunkId] !== undefined
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			return Promise.resolve().then(function() {
/******/ 				return require("./" + __webpack_require__.hmrF());
/******/ 			}).catch(function(err) { if(err.code !== "MODULE_NOT_FOUND") throw err; });
/******/ 		}
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack/hot/poll.js?1000");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2UvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2V8c3luYyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9kb3R0aWUvZG90dGllLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2luZmxlY3Rpb24vbGliL2luZmxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JldHJ5LWFzLXByb21pc2VkL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS1wb29sL2xpYi9BZ2dyZWdhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvRGVmZXJyZWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1Bvb2wuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1RpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYWxpYXMtaW5mZXJlbmNlL2FsaWFzLWluZmVyZW5jZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by9iZWxvbmdzLXRvLWFzc29jaWF0aW9uLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8vYmVsb25ncy10by5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvaGFzL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtb25lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvdW5pb24tYXNzb2NpYXRpb24tb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy90aHJvdWdoL3Rocm91Z2gtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXJlc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1zeW5jLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL2hvb2stb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NoYXJlZC9ob29rcy1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL3ZhbGlkYXRpb24tZmFpbGVkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWNvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1kZXN0cm95LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWZpbmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItaW5pdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXNhdmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItc3luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdXBzZXJ0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXZhbGlkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY29ubmVjdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNvdW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVmaW5lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmQtYWZ0ZXItZXhwYW5kLWluY2x1ZGUtYWxsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC1hZnRlci1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWluaXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtc2F2ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cHNlcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS12YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2FsbG93LW51bGwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvY29tbWVudC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9kZWZhdWx0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL3VuaXF1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvYXV0by1pbmNyZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvcHJpbWFyeS1rZXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy9jcmVhdGVkLWF0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvZGVsZXRlZC1hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL3VwZGF0ZWQtYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9pbmRleC9jcmVhdGUtaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWFjdGlvbi1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tY291bnQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWdldC1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9zaGFyZWQvbW9kZWwtY2xhc3MtZ2V0dGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvdGFibGUvdGFibGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3RhYmxlL3RhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL2RlZmF1bHQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3Njb3Blcy9zY29wZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL3Njb3BlLXRhYmxlLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3JlcG9zaXRvcnkvcmVwb3NpdG9yeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplfHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvdmFsaWRhdGlvbi1vbmx5L2RiLWRpYWxlY3QtZHVtbXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvb2JqZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2hhcmVkL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtYWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1hbHBoYW51bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFycmF5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1iZWZvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWNyZWRpdC1jYXJkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1lbWFpbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWlwLXY0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pcC12Ni5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtaXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWxvd2VyY2FzZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVtZXJpYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtdXBwZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy11cmwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLXV1aWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL21heC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL25vdC1lbXB0eS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vdmFsaWRhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1vbmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9taXhpbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvaGVscGVycy9xdW90ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0fHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktaW50ZXJmYWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9hZ2dyZWdhdGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9idWxrLXJlY29yZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2VhZ2VyLWxvYWRpbmctZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luc3RhbmNlLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL29wdGltaXN0aWMtbG9jay1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9xdWVyeS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9zZXF1ZWxpemUtc2NvcGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaG9va3MuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luc3RhbmNlLXZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL21vZGVsLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL29wZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3F1ZXJ5LXR5cGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc2VxdWVsaXplLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc3FsLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3RhYmxlLWhpbnRzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2RlcHJlY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvYnVpbGQvdG9wb3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvY29uZmlncy9zZXF1YWxpemUudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvZGF0YWJhc2UvbW9kZWwvUGV0Lm1vZGVsLnRzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vc3JjL2RhdGFiYXNlL21vZGVsL1VzZXIubW9kZWwudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvcmVzb2x2ZXJzL1BldC5yZXNvbHZlci50cyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL3NyYy9yZXNvbHZlcnMvVXNlci5yZXNvbHZlci50cyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL3NyYy9yZXNvbHZlcnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvc2VydmVyLnRzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vc3JjL3R5cGVEZWZzL1BldC50eXBlLnRzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vc3JjL3R5cGVEZWZzL1VzZXIudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvdHlwZURlZnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvYWxwaGEuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9ibGFja2xpc3QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0FscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNBbHBoYW51bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0FzY2lpLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNCYXNlNjQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0JlZm9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQnl0ZUxlbmd0aC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQ3JlZGl0Q2FyZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQ3VycmVuY3kuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0RhdGFVUkkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0RlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0RpdmlzaWJsZUJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNFbWFpbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0ZRRE4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0Zsb2F0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGdWxsV2lkdGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hhbGZXaWR0aC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSGFzaC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSGV4Q29sb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hleGFkZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJUC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVBSYW5nZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNCTi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNJTi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNPMzE2NjFBbHBoYTIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTTzMxNjYxQWxwaGEzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJU084NjAxLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJU1JDLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJU1NOLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJZGVudGl0eUNhcmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0luLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0pTT04uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0pXVC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTGF0TG9uZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNMb3dlcmNhc2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01BQ0FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01ENS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTWFnbmV0VVJJLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNaW1lVHlwZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTW9iaWxlUGhvbmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01vbmdvSWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc011bHRpYnl0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTnVtZXJpYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzUG9ydC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzUG9zdGFsQ29kZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzUkZDMzMzOS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzU3Vycm9nYXRlUGFpci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzVVJMLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNVVUlELmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNVcHBlcmNhc2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1ZhcmlhYmxlV2lkdGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1doaXRlbGlzdGVkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvbHRyaW0uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9tYXRjaGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvbm9ybWFsaXplRW1haWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9ydHJpbS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3N0cmlwTG93LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdG9Cb29sZWFuLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdG9EYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdG9GbG9hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvSW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdHJpbS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3VuZXNjYXBlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9hc3NlcnRTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91dGlsL2luY2x1ZGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi93aGl0ZWxpc3QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvcG9sbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL2JpbmFyeXJlYWRlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL2JpbmFyeXdyaXRlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL2dlb21ldHJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvZ2VvbWV0cnljb2xsZWN0aW9uLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvbGluZXN0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL211bHRpbGluZXN0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL211bHRpcG9pbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9tdWx0aXBvbHlnb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9wb2ludC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi90eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3drdHBhcnNlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3dreC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3ppZ3phZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImFwb2xsby1zZXJ2ZXJcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImFzc2VydFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiY3J5cHRvXCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImdsb2JcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImxvZGFzaFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibG9kYXNoL19iYXNlSXNOYXRpdmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImxydS1jYWNoZVwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibW9tZW50XCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJtb21lbnQtdGltZXpvbmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXRpbFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXVpZFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCB1cGRhdGUgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dldCB1cGRhdGUgbWFuaWZlc3QgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2hvdCBtb2R1bGUgcmVwbGFjZW1lbnQiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL3JlcXVpcmUgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS93ZWJwYWNrL3N0YXJ0dXAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsaUJBQWlCLG1CQUFPLENBQUMsMERBQVk7Ozs7Ozs7Ozs7OztBQ0F6QjtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDOVJBLGNBQWMsbUJBQU8sQ0FBQyx5REFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsZ0JBQWdCLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCLG1CQUFtQjtBQUMxRDtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQXlEO0FBQ3BGO0FBQ0E7QUFDQSwyQkFBMkIsNERBQTREO0FBQ3ZGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQXlEO0FBQ3BGO0FBQ0E7QUFDQSwyQkFBMkIsNERBQTREO0FBQ3ZGO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFnQztBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsa0dBQStCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGdHQUE4QjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBNkI7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BqQ2E7O0FBRWIsT0FBTyxtQkFBbUIsR0FBRyxtQkFBTyxDQUFDLHNEQUFTOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDeEdhOztBQUViLE9BQU8scUJBQXFCLEdBQUcsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDdkQsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyw4Q0FBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsa0VBQWM7QUFDckMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsb0ZBQTBCO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1FQUFtRSxhQUFhLGNBQWMsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUZBQVEsdUNBQXVDLENBQUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFGQUFRLFVBQVUsQ0FBQzs7QUFFaEMsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsMENBQTBDLGdCQUFnQixHQUFHLGdCQUFnQjs7QUFFN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsd0NBQXdDLGdCQUFnQixHQUFHLGdCQUFnQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUM7QUFDbEc7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsc0JBQXNCOzs7Ozs7Ozs7Ozs7QUNqV1Q7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixzQkFBc0I7Ozs7Ozs7Ozs7OztBQ3hFVDs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGVBQWUsMENBQWtCOztBQUVqQyxjQUFjLG1CQUFPLENBQUMsMERBQWE7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLG9FQUFrQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDBEQUFhO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBK0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsd0dBQW9DO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLDBGQUE2QjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsa0VBQWlCO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLGtFQUFjO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFtQjs7QUFFOUMsb0JBQW9CLG1CQUFPLENBQUMsd0hBQWlDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCOztBQUVBO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRDs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0IsYUFBYSx3QkFBd0I7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNHQUFzRyxvQkFBb0I7QUFDMUgsV0FBVztBQUNYLHNHQUFzRyxvQkFBb0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBLG9FQUFvRSwyQkFBMkIsWUFBWSwyQkFBMkI7QUFDdEksZ0RBQWdELHVCQUF1QixrQkFBa0IscUJBQXFCO0FBQzlHLE9BQU87QUFDUCxtRUFBbUUsMkJBQTJCLFVBQVUsMkJBQTJCO0FBQ25JLG1DQUFtQyxpREFBaUQsR0FBRyxvQkFBb0I7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTLFFBQVEsOEJBQThCLFFBQVEsWUFBWSxJQUFJLHdCQUF3QixHQUFHLG9CQUFvQixXQUFXLG9CQUFvQixHQUFHLHFCQUFxQixFQUFFLGlDQUFpQyxFQUFFLFdBQVc7QUFDalAsb0JBQW9CLFNBQVMsUUFBUSw4QkFBOEIsUUFBUSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUsaUNBQWlDLEVBQUUsV0FBVzs7QUFFcEw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQywyQkFBMkI7QUFDNUQsd0RBQXdELHdEQUF3RCw4REFBOEQ7O0FBRTlLLCtIQUErSDtBQUMvSCwrRUFBK0UsWUFBWSwyREFBMkQsVUFBVSxTQUFTLFdBQVcsMkJBQTJCLGFBQWEsa0JBQWtCLE9BQU8sVUFBVSxrQkFBa0IsR0FBRyxZQUFZLEdBQUcsYUFBYTtBQUNoVCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGVBQWUsMERBQTBEO0FBQ3pFO0FBQ0EscUNBQXFDLFlBQVksSUFBSSxHQUFHLE1BQU0sdUJBQXVCLFlBQVksS0FBSztBQUN0Rzs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkUsb0JBQW9CO0FBQ2pHLE9BQU87O0FBRVAsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0Esb0VBQW9FLDJCQUEyQixZQUFZLDJCQUEyQjtBQUN0SSxnREFBZ0QsdUJBQXVCLGtCQUFrQixxQkFBcUI7QUFDOUcsT0FBTyxPQUFPO0FBQ2QsbUVBQW1FLDJCQUEyQixVQUFVLDJCQUEyQjtBQUNuSSxrQ0FBa0MsaURBQWlELEdBQUcsb0JBQW9CO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPLHFDQUFxQyxZQUFZO0FBQ3JFLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCLEdBQUcsOEVBQThFLG9CQUFvQixFQUFFO0FBQ3hKLE9BQU87QUFDUCx1QkFBdUIsMEJBQTBCLEdBQUcsOEVBQThFLG9CQUFvQixhQUFhO0FBQ25LO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVMsU0FBUywyQkFBMkIsT0FBTyxpQkFBaUIsRUFBRSxlQUFlLEdBQUcscUNBQXFDLEVBQUUsT0FBTztBQUM1SjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPLG1FQUFtRSxZQUFZO0FBQ25HLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxHQUFHLFlBQVksRUFBRSxTQUFTLEdBQUcsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVksR0FBRyxhQUFhO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQzs7QUFFQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RixvREFBb0QsVUFBVTtBQUM5RCwyRUFBMkUsY0FBYztBQUN6RixVQUFVLHFCQUFxQjtBQUMvQiw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZUFBZSxXQUFXLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZUFBZSxVQUFVLGNBQWM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFLFVBQVUsR0FBRyxnQkFBZ0I7QUFDOUYsMENBQTBDLGVBQWUsWUFBWSxrQ0FBa0MsUUFBUSxhQUFhO0FBQzVIO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZUFBZSxnQkFBZ0Isc0JBQXNCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQyxJQUFJLGlCQUFpQjtBQUM1RiwwQ0FBMEMsZUFBZTtBQUN6RCw2Q0FBNkMsc0JBQXNCLGVBQWUsa0JBQWtCO0FBQ3BHO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7O0FBRUE7QUFDQSwrQkFBK0Isb0NBQW9DO0FBQ25FOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQixHQUFHLGdEQUFnRDs7QUFFbEk7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkUsT0FBTztBQUNQLGtCQUFrQixrQ0FBa0M7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDLEdBQUcsMkNBQTJDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0Esa0VBQWtFLHlCQUF5QjtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLDZGQUE2Rjs7QUFFNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxzR0FBc0c7QUFDcEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTs7QUFFcEU7QUFDQSxpQ0FBaUMsYUFBYSxHQUFHLFFBQVE7QUFDekQ7O0FBRUEsNENBQTRDLGFBQWEsR0FBRyxRQUFROztBQUVwRTtBQUNBLGdDQUFnQyxFQUFFLGlCQUFpQjtBQUNuRCxtQkFBbUIsYUFBYSxLQUFLLFFBQVE7O0FBRTdDO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLGFBQWE7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFEQUFxRDs7QUFFaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxFQUFFO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxvQkFBb0IsUUFBUSxVQUFVO0FBQ3RDLHVFQUF1RSxRQUFRO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQsU0FBUztBQUNULHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELE9BQU87QUFDUCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCxTQUFTO0FBQ1QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0Esd0NBQXdDLGdDQUFnQztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELG1EQUFtRDtBQUN4Ryx3QkFBd0IsMkJBQTJCLFNBQVMsdUJBQXVCLE9BQU8sYUFBYSxFQUFFLHlCQUF5QixFQUFFLHdCQUF3QjtBQUM1SixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QixPQUFPO0FBQ1AscUJBQXFCLGdDQUFnQztBQUNyRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZLEdBQUcsS0FBSztBQUN0Qzs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLDJCQUEyQixJQUFJLFdBQVc7QUFDMUUsZ0NBQWdDLDJCQUEyQixHQUFHLFdBQVc7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1QiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDaEcsU0FBUztBQUNULG1FQUFtRSwyQ0FBMkM7QUFDOUcsU0FBUztBQUNULHNCQUFzQiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDL0Y7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcsT0FBTzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWUsS0FBSyxlQUFlLEVBQUUsMEJBQTBCLFFBQVEsb0JBQW9CO0FBQ2pJLE9BQU87QUFDUCxzQ0FBc0MsZUFBZSxHQUFHLGVBQWUsTUFBTSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxlQUFlLEtBQUssZUFBZSxFQUFFLDJCQUEyQixRQUFRLG9CQUFvQjtBQUNuSSxPQUFPO0FBQ1AsdUNBQXVDLGVBQWUsR0FBRyxlQUFlLE1BQU0sb0JBQW9CO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEVBQUUsTUFBTTtBQUNwRCx1Q0FBdUMsVUFBVSxFQUFFLE1BQU07QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLDRCQUE0Qjs7QUFFMUQ7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLE1BQU07O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxVQUFVLEVBQUUsTUFBTTtBQUN0RCx5Q0FBeUMsVUFBVSxFQUFFLE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXLElBQUksT0FBTztBQUMxQyxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU8sSUFBSSxRQUFROztBQUV6QyxvQkFBb0Isd0JBQXdCLEdBQUcsZ0NBQWdDO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGLFVBQVUsR0FBRywrQkFBK0I7O0FBRXJJO0FBQ0EscUNBQXFDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbEY7QUFDQSxPQUFPO0FBQ1AsOEJBQThCLDJCQUEyQixHQUFHLFNBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw4QkFBOEIsR0FBRyxpQ0FBaUM7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxTQUFTO0FBQ1QsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlDQUF5Qzs7QUFFakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRCxLQUFLO0FBQ0wsa0NBQWtDLHNDQUFzQyxNQUFNLGFBQWE7O0FBRTNGO0FBQ0E7QUFDQSw2REFBNkQsTUFBTSxHQUFHLHVCQUF1Qjs7QUFFN0YsMENBQTBDLHFCQUFxQixFQUFFO0FBQ2pFO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsSUFBSSxXQUFXO0FBQzdELGlDQUFpQyxxQkFBcUIsR0FBRyxXQUFXO0FBQ3BFO0FBQ0EscUJBQXFCLGtCQUFrQixHQUFHLHFDQUFxQzs7QUFFL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0MsR0FBRywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZLEdBQUcsV0FBVywrQkFBK0IsWUFBWSxHQUFHLFdBQVc7O0FBRW5KLHdCQUF3QixpQ0FBaUM7QUFDekQsS0FBSztBQUNMO0FBQ0E7O0FBRUEsd0JBQXdCLDZCQUE2QixHQUFHLG9DQUFvQztBQUM1RjtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxrQ0FBa0M7O0FBRTVGO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDLEdBQUcsaUNBQWlDO0FBQzVGLHVCQUF1QixnQ0FBZ0MsR0FBRyxrQ0FBa0M7O0FBRTVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHlDQUF5QyxjQUFjLG9FQUFvRSxNQUFNLGFBQWE7QUFDcEs7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IseUNBQXlDLE1BQU0sYUFBYSxHQUFHLFNBQVMsR0FBRyxvRUFBb0U7QUFDbks7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG9EQUFvRDtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0MsR0FBRyxzREFBc0Q7QUFDaEgsaUJBQWlCLG9EQUFvRCxHQUFHLHFEQUFxRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvQ0FBb0MsR0FBRyxrQ0FBa0M7QUFDcEYsV0FBVyxzREFBc0QsR0FBRyxrQ0FBa0M7QUFDdEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBLHlDQUF5QyxhQUFhO0FBQ3RELDBEQUEwRCxvQkFBb0I7QUFDOUUsZ0RBQWdELFNBQVMsR0FBRyxPQUFPO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsa0RBQWtEOztBQUVoRyw2QkFBNkIsc0JBQXNCLFFBQVEsT0FBTzs7QUFFbEU7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCLFVBQVUseUVBQXlFO0FBQ25JO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUIsMkNBQTJDLEdBQUcsdUVBQXVFO0FBQ3RJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLE9BQU8sc0JBQXNCO0FBQ3RFLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHFCQUFxQixPQUFPLE1BQU0sd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsb0JBQW9CO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixhQUFhLEdBQUcsTUFBTTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hELE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsb0JBQW9CO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLEdBQUcsUUFBUTtBQUMzRSxPQUFPO0FBQ1AscUJBQXFCLGdDQUFnQyxHQUFHLFFBQVE7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYztBQUMzRixPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSxnQkFBZ0I7QUFDeEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLE9BQU8sTUFBTTtBQUMxQztBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHVEQUF1RDtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QixHQUFHLFdBQVc7QUFDOUQ7QUFDQSxvREFBb0QsaUNBQWlDLGtCQUFrQixlQUFlO0FBQ3RIOztBQUVBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkIsT0FBTyw2QkFBNkI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsTUFBTTs7QUFFL0IsZ0RBQWdELE1BQU07QUFDdEQsaURBQWlELE1BQU07O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpREFBaUQsT0FBTyxXQUFXLEdBQUcseUJBQXlCO0FBQzFJO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpREFBaUQsT0FBTyxXQUFXLEdBQUcseUJBQXlCO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLG1CQUFPLENBQUMsZ0hBQTZCO0FBQzdFLHdDQUF3QyxtQkFBTyxDQUFDLG9IQUErQjs7QUFFL0U7Ozs7Ozs7Ozs7OztBQ3ZyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGdFQUFtQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQ0FBbUM7O0FBRXBEO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0EsaUNBQWlDOzs7Ozs7Ozs7Ozs7QUN0RnBCOztBQUViLFVBQVUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMscUVBQW9CO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDcEZhOztBQUViLGVBQWUsMENBQWtCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7O0FBRUEsOEJBQThCO0FBQzlCLEdBQUc7O0FBRUgsNEJBQTRCOztBQUU1Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDL0VhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFMUIsY0FBYyxtQkFBTyxDQUFDLDBEQUFhO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFrQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsc0VBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxrRUFBa0UsMkNBQTJDO0FBQzdHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCLEdBQUcsb0JBQW9CO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUseUNBQXlDO0FBQ3hHOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFELFVBQVUseUNBQXlDO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSwyQkFBMkIsV0FBVztBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdDQUF3QztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJDQUEyQztBQUN2Rjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsK0NBQStDO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZELDhEQUE4RCw2QkFBNkI7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7O0FBRXpFLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7Ozs7Ozs7Ozs7OztBQ3p1Q1Q7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFrQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLCtDQUFRO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLG9GQUEwQjtBQUN2RCxhQUFhLDBDQUFrQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixNQUFNOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGtDQUFrQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDBEQUEwRCx1Q0FBdUM7QUFDakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSxLQUFLLFVBQVU7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3REFBd0QsdUNBQXVDO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csRUFBRTtBQUMxRyx3R0FBd0csRUFBRTs7QUFFMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsNENBQTRDO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsV0FBVyxTQUFTLEVBQUU7QUFDckY7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbmxCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw4REFBVTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBMkI7QUFDckQsa0JBQWtCLHVIQUE2QztBQUMvRCxPQUFPLFlBQVksR0FBRyxtQkFBTyxDQUFDLGtCQUFNOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUSxzQkFBc0IsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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cmVnaXN0ZXInKSgpLlByb21pc2VcbiIsIlwidXNlIHN0cmljdFwiXG4gICAgLy8gZ2xvYmFsIGtleSBmb3IgdXNlciBwcmVmZXJyZWQgcmVnaXN0cmF0aW9uXG52YXIgUkVHSVNUUkFUSU9OX0tFWSA9ICdAQGFueS1wcm9taXNlL1JFR0lTVFJBVElPTicsXG4gICAgLy8gUHJpb3IgcmVnaXN0cmF0aW9uIChwcmVmZXJyZWQgb3IgZGV0ZWN0ZWQpXG4gICAgcmVnaXN0ZXJlZCA9IG51bGxcblxuLyoqXG4gKiBSZWdpc3RlcnMgdGhlIGdpdmVuIGltcGxlbWVudGF0aW9uLiAgQW4gaW1wbGVtZW50YXRpb24gbXVzdFxuICogYmUgcmVnaXN0ZXJlZCBwcmlvciB0byBhbnkgY2FsbCB0byBgcmVxdWlyZShcImFueS1wcm9taXNlXCIpYCxcbiAqIHR5cGljYWxseSBvbiBhcHBsaWNhdGlvbiBsb2FkLlxuICpcbiAqIElmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgd2lsbCByZXR1cm4gcmVnaXN0cmF0aW9uIGluXG4gKiBmb2xsb3dpbmcgcHJpb3JpdHk6XG4gKlxuICogRm9yIE5vZGUuanM6XG4gKlxuICogMS4gUHJldmlvdXMgcmVnaXN0cmF0aW9uXG4gKiAyLiBnbG9iYWwuUHJvbWlzZSBpZiBub2RlLmpzIHZlcnNpb24gPj0gMC4xMlxuICogMy4gQXV0byBkZXRlY3RlZCBwcm9taXNlIGJhc2VkIG9uIGZpcnN0IHN1Y2Vzc2Z1bCByZXF1aXJlIG9mXG4gKiAgICBrbm93biBwcm9taXNlIGxpYnJhcmllcy4gTm90ZSB0aGlzIGlzIGEgbGFzdCByZXNvcnQsIGFzIHRoZVxuICogICAgbG9hZGVkIGxpYnJhcnkgaXMgbm9uLWRldGVybWluaXN0aWMuIG5vZGUuanMgPj0gMC4xMiB3aWxsXG4gKiAgICBhbHdheXMgdXNlIGdsb2JhbC5Qcm9taXNlIG92ZXIgdGhpcyBwcmlvcml0eSBsaXN0LlxuICogNC4gVGhyb3dzIGVycm9yLlxuICpcbiAqIEZvciBCcm93c2VyOlxuICpcbiAqIDEuIFByZXZpb3VzIHJlZ2lzdHJhdGlvblxuICogMi4gd2luZG93LlByb21pc2VcbiAqIDMuIFRocm93cyBlcnJvci5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqIFByb21pc2U6IERlc2lyZWQgUHJvbWlzZSBjb25zdHJ1Y3RvclxuICogZ2xvYmFsOiBCb29sZWFuIC0gU2hvdWxkIHRoZSByZWdpc3RyYXRpb24gYmUgY2FjaGVkIGluIGEgZ2xvYmFsIHZhcmlhYmxlIHRvXG4gKiBhbGxvdyBjcm9zcyBkZXBlbmRlbmN5L2J1bmRsZSByZWdpc3RyYXRpb24/ICAoZGVmYXVsdCB0cnVlKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJvb3QsIGxvYWRJbXBsZW1lbnRhdGlvbil7XG4gIHJldHVybiBmdW5jdGlvbiByZWdpc3RlcihpbXBsZW1lbnRhdGlvbiwgb3B0cyl7XG4gICAgaW1wbGVtZW50YXRpb24gPSBpbXBsZW1lbnRhdGlvbiB8fCBudWxsXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uIHVubGVzcyBleHBsaWNpdGx5ICB7Z2xvYmFsOiBmYWxzZX0gaW4gb3B0aW9ucyAoZGVmYXVsdCB0cnVlKVxuICAgIHZhciByZWdpc3Rlckdsb2JhbCA9IG9wdHMuZ2xvYmFsICE9PSBmYWxzZTtcblxuICAgIC8vIGxvYWQgYW55IHByZXZpb3VzIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICBpZihyZWdpc3RlcmVkID09PSBudWxsICYmIHJlZ2lzdGVyR2xvYmFsKXtcbiAgICAgIHJlZ2lzdGVyZWQgPSByb290W1JFR0lTVFJBVElPTl9LRVldIHx8IG51bGxcbiAgICB9XG5cbiAgICBpZihyZWdpc3RlcmVkICE9PSBudWxsXG4gICAgICAgICYmIGltcGxlbWVudGF0aW9uICE9PSBudWxsXG4gICAgICAgICYmIHJlZ2lzdGVyZWQuaW1wbGVtZW50YXRpb24gIT09IGltcGxlbWVudGF0aW9uKXtcbiAgICAgIC8vIFRocm93IGVycm9yIGlmIGF0dGVtcHRpbmcgdG8gcmVkZWZpbmUgaW1wbGVtZW50YXRpb25cbiAgICAgIHRocm93IG5ldyBFcnJvcignYW55LXByb21pc2UgYWxyZWFkeSBkZWZpbmVkIGFzIFwiJytyZWdpc3RlcmVkLmltcGxlbWVudGF0aW9uK1xuICAgICAgICAnXCIuICBZb3UgY2FuIG9ubHkgcmVnaXN0ZXIgYW4gaW1wbGVtZW50YXRpb24gYmVmb3JlIHRoZSBmaXJzdCAnK1xuICAgICAgICAnIGNhbGwgdG8gcmVxdWlyZShcImFueS1wcm9taXNlXCIpIGFuZCBhbiBpbXBsZW1lbnRhdGlvbiBjYW5ub3QgYmUgY2hhbmdlZCcpXG4gICAgfVxuXG4gICAgaWYocmVnaXN0ZXJlZCA9PT0gbnVsbCl7XG4gICAgICAvLyB1c2UgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25cbiAgICAgIGlmKGltcGxlbWVudGF0aW9uICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLlByb21pc2UgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgcmVnaXN0ZXJlZCA9IHtcbiAgICAgICAgICBQcm9taXNlOiBvcHRzLlByb21pc2UsXG4gICAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlcXVpcmUgaW1wbGVtZW50YXRpb24gaWYgaW1wbGVtZW50YXRpb24gaXMgc3BlY2lmaWVkIGJ1dCBub3QgcHJvdmlkZWRcbiAgICAgICAgcmVnaXN0ZXJlZCA9IGxvYWRJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbilcbiAgICAgIH1cblxuICAgICAgaWYocmVnaXN0ZXJHbG9iYWwpe1xuICAgICAgICAvLyByZWdpc3RlciBwcmVmZXJlbmNlIGdsb2JhbGx5IGluIGNhc2UgbXVsdGlwbGUgaW5zdGFsbGF0aW9uc1xuICAgICAgICByb290W1JFR0lTVFJBVElPTl9LRVldID0gcmVnaXN0ZXJlZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWdpc3RlcmVkXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbG9hZGVyJykoZ2xvYmFsLCBsb2FkSW1wbGVtZW50YXRpb24pO1xuXG4vKipcbiAqIE5vZGUuanMgdmVyc2lvbiBvZiBsb2FkSW1wbGVtZW50YXRpb24uXG4gKlxuICogUmVxdWlyZXMgdGhlIGdpdmVuIGltcGxlbWVudGF0aW9uIGFuZCByZXR1cm5zIHRoZSByZWdpc3RyYXRpb25cbiAqIGNvbnRhaW5pbmcge1Byb21pc2UsIGltcGxlbWVudGF0aW9ufVxuICpcbiAqIElmIGltcGxlbWVudGF0aW9uIGlzIHVuZGVmaW5lZCBvciBnbG9iYWwuUHJvbWlzZSwgbG9hZHMgaXRcbiAqIE90aGVyd2lzZSB1c2VzIHJlcXVpcmVcbiAqL1xuZnVuY3Rpb24gbG9hZEltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKXtcbiAgdmFyIGltcGwgPSBudWxsXG5cbiAgaWYoc2hvdWxkUHJlZmVyR2xvYmFsUHJvbWlzZShpbXBsZW1lbnRhdGlvbikpe1xuICAgIC8vIGlmIG5vIGltcGxlbWVudGF0aW9uIG9yIGVudiBzcGVjaWZpZWQgdXNlIGdsb2JhbC5Qcm9taXNlXG4gICAgaW1wbCA9IHtcbiAgICAgIFByb21pc2U6IGdsb2JhbC5Qcm9taXNlLFxuICAgICAgaW1wbGVtZW50YXRpb246ICdnbG9iYWwuUHJvbWlzZSdcbiAgICB9XG4gIH0gZWxzZSBpZihpbXBsZW1lbnRhdGlvbil7XG4gICAgLy8gaWYgaW1wbGVtZW50YXRpb24gc3BlY2lmaWVkLCByZXF1aXJlIGl0XG4gICAgdmFyIGxpYiA9IHJlcXVpcmUoaW1wbGVtZW50YXRpb24pXG4gICAgaW1wbCA9IHtcbiAgICAgIFByb21pc2U6IGxpYi5Qcm9taXNlIHx8IGxpYixcbiAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0cnkgdG8gYXV0byBkZXRlY3QgaW1wbGVtZW50YXRpb24uIFRoaXMgaXMgbm9uLWRldGVybWluaXN0aWNcbiAgICAvLyBhbmQgc2hvdWxkIHByZWZlciBvdGhlciBicmFuY2hlcywgYnV0IHRoaXMgaXMgb3VyIGxhc3QgY2hhbmNlXG4gICAgLy8gdG8gbG9hZCBzb21ldGhpbmcgd2l0aG91dCB0aHJvd2luZyBlcnJvclxuICAgIGltcGwgPSB0cnlBdXRvRGV0ZWN0KClcbiAgfVxuXG4gIGlmKGltcGwgPT09IG51bGwpe1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYW55LXByb21pc2UgaW1wbGVtZW50YXRpb24gbm9yJytcbiAgICAgICcgZ2xvYmFsLlByb21pc2UuIFlvdSBtdXN0IGluc3RhbGwgcG9seWZpbGwgb3IgY2FsbCcrXG4gICAgICAnIHJlcXVpcmUoXCJhbnktcHJvbWlzZS9yZWdpc3RlclwiKSB3aXRoIHlvdXIgcHJlZmVycmVkJytcbiAgICAgICcgaW1wbGVtZW50YXRpb24sIGUuZy4gcmVxdWlyZShcImFueS1wcm9taXNlL3JlZ2lzdGVyL2JsdWViaXJkXCIpJytcbiAgICAgICcgb24gYXBwbGljYXRpb24gbG9hZCBwcmlvciB0byBhbnkgcmVxdWlyZShcImFueS1wcm9taXNlXCIpLicpXG4gIH1cblxuICByZXR1cm4gaW1wbFxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdsb2JhbC5Qcm9taXNlIHNob3VsZCBiZSBwcmVmZXJyZWQgaWYgYW4gaW1wbGVtZW50YXRpb25cbiAqIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcmVmZXJHbG9iYWxQcm9taXNlKGltcGxlbWVudGF0aW9uKXtcbiAgaWYoaW1wbGVtZW50YXRpb24pe1xuICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbiA9PT0gJ2dsb2JhbC5Qcm9taXNlJ1xuICB9IGVsc2UgaWYodHlwZW9mIGdsb2JhbC5Qcm9taXNlICE9PSAndW5kZWZpbmVkJyl7XG4gICAgLy8gTG9hZCBnbG9iYWwgcHJvbWlzZSBpZiBpbXBsZW1lbnRhdGlvbiBub3Qgc3BlY2lmaWVkXG4gICAgLy8gVmVyc2lvbnMgPCAwLjExIGRpZCBub3QgaGF2ZSBnbG9iYWwgUHJvbWlzZVxuICAgIC8vIERvIG5vdCB1c2UgZm9yIHZlcnNpb24gPCAwLjEyIGFzIHZlcnNpb24gMC4xMSBjb250YWluZWQgYnVnZ3kgdmVyc2lvbnNcbiAgICB2YXIgdmVyc2lvbiA9ICgvdihcXGQrKVxcLihcXGQrKVxcLihcXGQrKS8pLmV4ZWMocHJvY2Vzcy52ZXJzaW9uKVxuICAgIHJldHVybiAhKHZlcnNpb24gJiYgK3ZlcnNpb25bMV0gPT0gMCAmJiArdmVyc2lvblsyXSA8IDEyKVxuICB9XG5cbiAgLy8gZG8gbm90IGhhdmUgZ2xvYmFsLlByb21pc2Ugb3IgYW5vdGhlciBpbXBsZW1lbnRhdGlvbiB3YXMgc3BlY2lmaWVkXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIExvb2sgZm9yIGNvbW1vbiBsaWJzIGFzIGxhc3QgcmVzb3J0IHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0XG4gKiB0aGlzIHdpbGwgcmV0dXJuIGEgZGVzaXJlZCBpbXBsZW1lbnRhdGlvbiBvciBldmVuIGJlIGRldGVybWluaXN0aWMuXG4gKiBUaGUgcHJpb3JpdHkgaXMgYWxzbyBuZWFybHkgYXJiaXRyYXJ5LiBXZSBhcmUgb25seSBkb2luZyB0aGlzXG4gKiBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyA8MC4xMiB0aGF0IGRvIG5vdCBoYXZlIGEgcmVhc29uYWJsZVxuICogZ2xvYmFsLlByb21pc2UgaW1wbGVtZW50YXRpb24gYW5kIHdlIHRoZSB1c2VyIGhhcyBub3QgcmVnaXN0ZXJlZFxuICogdGhlIHByZWZlcmVuY2UuIFRoaXMgcHJlc2VydmVzIHRoZSBiZWhhdmlvciBvZiBhbnktcHJvbWlzZSA8PSAwLjFcbiAqIGFuZCBtYXkgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGluIHRoZSBmdXR1cmVcbiAqL1xuZnVuY3Rpb24gdHJ5QXV0b0RldGVjdCgpe1xuICB2YXIgbGlicyA9IFtcbiAgICAgIFwiZXM2LXByb21pc2VcIixcbiAgICAgIFwicHJvbWlzZVwiLFxuICAgICAgXCJuYXRpdmUtcHJvbWlzZS1vbmx5XCIsXG4gICAgICBcImJsdWViaXJkXCIsXG4gICAgICBcInJzdnBcIixcbiAgICAgIFwid2hlblwiLFxuICAgICAgXCJxXCIsXG4gICAgICBcInBpbmtpZVwiLFxuICAgICAgXCJsaWVcIixcbiAgICAgIFwidm93XCJdXG4gIHZhciBpID0gMCwgbGVuID0gbGlicy5sZW5ndGhcbiAgZm9yKDsgaSA8IGxlbjsgaSsrKXtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvYWRJbXBsZW1lbnRhdGlvbihsaWJzW2ldKVxuICAgIH0gY2F0Y2goZSl7fVxuICB9XG4gIHJldHVybiBudWxsXG59XG4iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9ICgpID0+IChbXSk7XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2Ugc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCIoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBXZWlyZCBJRSBzaGl0LCBvYmplY3RzIGRvIG5vdCBoYXZlIGhhc093biwgYnV0IHRoZSBwcm90b3R5cGUgZG9lcy4uLlxuICB2YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgdmFyIHJldmVyc2VEdXBBcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBhcnJheU1heEluZGV4ID0gaW5kZXggLSAxO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHJlc3VsdFthcnJheU1heEluZGV4IC0gaW5kZXhdID0gYXJyYXlbaW5kZXhdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIERvdHRpZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICByZXR1cm4gRG90dGllLmZpbmQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBEb3R0aWUudHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIExlZ2FjeSBzeW50YXgsIGNoYW5nZWQgc3ludGF4IHRvIGhhdmUgZ2V0L3NldCBiZSBzaW1pbGFyIGluIGFyZyBvcmRlclxuICBEb3R0aWUuZmluZCA9IGZ1bmN0aW9uKHBhdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBEb3R0aWUuZ2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG5cbiAgLy8gRG90dGllIG1lbW9pemF0aW9uIGZsYWdcbiAgRG90dGllLm1lbW9pemVQYXRoID0gdHJ1ZTtcbiAgdmFyIG1lbW9pemVkID0ge307XG5cbiAgLy8gVHJhdmVyc2Ugb2JqZWN0IGFjY29yZGluZyB0byBwYXRoLCByZXR1cm4gdmFsdWUgaWYgZm91bmQgLSBSZXR1cm4gdW5kZWZpbmVkIGlmIGRlc3RpbmF0aW9uIGlzIHVucmVhY2hhYmxlXG4gIERvdHRpZS5nZXQgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWwpIHtcbiAgICBpZiAoKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB8fCAob2JqZWN0ID09PSBudWxsKSB8fCAocGF0aCA9PT0gdW5kZWZpbmVkKSB8fCAocGF0aCA9PT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWw7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzO1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoRG90dGllLm1lbW9pemVQYXRoKSB7XG4gICAgICAgIGlmIChtZW1vaXplZFtwYXRoXSkge1xuICAgICAgICAgIG5hbWVzID0gbWVtb2l6ZWRbcGF0aF0uc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZXMgPSBwYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpO1xuICAgICAgICAgIG1lbW9pemVkW3BhdGhdID0gbmFtZXMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVzID0gcGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIG5hbWVzID0gcmV2ZXJzZUR1cEFycmF5KHBhdGgpO1xuICAgIH1cblxuICAgIHdoaWxlIChuYW1lcy5sZW5ndGggJiYgKG9iamVjdCA9IG9iamVjdFtuYW1lcy5wb3AoKV0pICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0ICE9PSBudWxsKTtcblxuICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSBhY2Nlc3NpbmcgYSBjaGlsZHByb3Agb2YgYSBudWxsIHZhbHVlXG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCAmJiBuYW1lcy5sZW5ndGgpIG9iamVjdCA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiAob2JqZWN0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsIDogb2JqZWN0KTtcbiAgfTtcblxuICBEb3R0aWUuZXhpc3RzID0gZnVuY3Rpb24ob2JqZWN0LCBwYXRoKSB7XG4gICAgcmV0dXJuIERvdHRpZS5nZXQob2JqZWN0LCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8vIFNldCBuZXN0ZWQgdmFsdWVcbiAgRG90dGllLnNldCA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGllY2VzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyksIGN1cnJlbnQgPSBvYmplY3QsIHBpZWNlLCBsZW5ndGggPSBwaWVjZXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBpcyBub3QgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHBpZWNlID0gcGllY2VzW2luZGV4XTtcblxuICAgICAgLy8gQ3JlYXRlIG5hbWVzcGFjZSAob2JqZWN0KSB3aGVyZSBub25lIGV4aXN0cy5cbiAgICAgIC8vIElmIGBmb3JjZSA9PT0gdHJ1ZWAsIGJydXRlZm9yY2UgdGhlIHBhdGggd2l0aG91dCB0aHJvd2luZyBlcnJvcnMuXG4gICAgICBpZiAoIWhhc093blByb3AuY2FsbChjdXJyZW50LCBwaWVjZSkgfHwgY3VycmVudFtwaWVjZV0gPT09IHVuZGVmaW5lZCB8fCAodHlwZW9mIGN1cnJlbnRbcGllY2VdICE9PSAnb2JqZWN0JyAmJiBvcHRpb25zICYmIG9wdGlvbnMuZm9yY2UgPT09IHRydWUpKSB7XG4gICAgICAgIGN1cnJlbnRbcGllY2VdID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PSAobGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgLy8gU2V0IGZpbmFsIHZhbHVlXG4gICAgICAgIGN1cnJlbnRbcGllY2VdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBkbyBub3Qgb3ZlcndyaXRlIGV4aXN0aW5nIHBhdGggcGllY2VzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50W3BpZWNlXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBrZXkgXCInICsgcGllY2UgKyAnXCIgaXMgbm90IHN1aXRhYmxlIGZvciBhIG5lc3RlZCB2YWx1ZS4gKEl0IGlzIGluIHVzZSBhcyBub24tb2JqZWN0LiBTZXQgYGZvcmNlYCB0byBgdHJ1ZWAgdG8gb3ZlcnJpZGUuKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgbmV4dCBpbiBwYXRoXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BpZWNlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJcyB0aGVyZSBhbnkgY2FzZSB3aGVuIHRoaXMgaXMgcmVsZXZhbnQ/IEl0J3MgYWxzbyB0aGUgbGFzdCBsaW5lIGluIHRoZSBhYm92ZSBmb3ItbG9vcFxuICAgIGN1cnJlbnRbcGllY2VdID0gdmFsdWU7XG4gIH07XG5cbiAgLy8gU2V0IGRlZmF1bHQgbmVzdGVkIHZhbHVlXG4gIERvdHRpZVsnZGVmYXVsdCddID0gZnVuY3Rpb24ob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGlmIChEb3R0aWUuZ2V0KG9iamVjdCwgcGF0aCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgRG90dGllLnNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVHJhbnNmb3JtIHVubmVzdGVkIG9iamVjdCB3aXRoIC4tc2VwZXJhdGVkIGtleXMgaW50byBhIG5lc3RlZCBvYmplY3QuXG4gIERvdHRpZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiBEb3R0aWUkdHJhbnNmb3JtZnVuY3Rpb24ob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG9iamVjdC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICByZXR1cm4gRG90dGllLnRyYW5zZm9ybShvLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy4nO1xuXG4gICAgdmFyIHBpZWNlc1xuICAgICAgLCBwaWVjZXNMZW5ndGhcbiAgICAgICwgcGllY2VcbiAgICAgICwgY3VycmVudFxuICAgICAgLCB0cmFuc2Zvcm1lZCA9IHt9XG4gICAgICAsIGtleVxuICAgICAgLCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LmluZGV4T2Yob3B0aW9ucy5kZWxpbWl0ZXIpICE9PSAtMSkge1xuICAgICAgICBwaWVjZXMgPSBrZXkuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgICAgICBwaWVjZXNMZW5ndGggPSBwaWVjZXMubGVuZ3RoO1xuICAgICAgICBjdXJyZW50ID0gdHJhbnNmb3JtZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBpZWNlc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHBpZWNlID0gcGllY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoaW5kZXggIT0gKHBpZWNlc0xlbmd0aCAtIDEpICYmICFjdXJyZW50Lmhhc093blByb3BlcnR5KHBpZWNlKSkge1xuICAgICAgICAgICAgY3VycmVudFtwaWVjZV0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT0gKHBpZWNlc0xlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICBjdXJyZW50W3BpZWNlXSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BpZWNlXTtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1lZFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9O1xuXG4gIERvdHRpZS5mbGF0dGVuID0gZnVuY3Rpb24ob2JqZWN0LCBzZXBlcmF0b3IpIHtcbiAgICBpZiAodHlwZW9mIHNlcGVyYXRvciA9PT0gXCJ1bmRlZmluZWRcIikgc2VwZXJhdG9yID0gJy4nO1xuICAgIHZhciBmbGF0dGVuZWQgPSB7fVxuICAgICAgLCBjdXJyZW50XG4gICAgICAsIG5lc3RlZDtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjdXJyZW50KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgIG5lc3RlZCA9IERvdHRpZS5mbGF0dGVuKGN1cnJlbnQsIHNlcGVyYXRvcik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIG5lc3RlZCkge1xuICAgICAgICAgICAgZmxhdHRlbmVkW2tleStzZXBlcmF0b3IrX2tleV0gPSBuZXN0ZWRbX2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXR0ZW5lZFtrZXldID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH07XG5cbiAgRG90dGllLnBhdGhzID0gZnVuY3Rpb24ob2JqZWN0LCBwcmVmaXhlcykge1xuICAgIHZhciBwYXRocyA9IFtdO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIga2V5O1xuXG4gICAgcHJlZml4ZXMgPSBwcmVmaXhlcyB8fCBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXRocyA9IHBhdGhzLmNvbmNhdChEb3R0aWUucGF0aHModmFsdWUsIHByZWZpeGVzLmNvbmNhdChba2V5XSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRocy5wdXNoKHByZWZpeGVzLmNvbmNhdChrZXkpLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRocyB3YXMgY2FsbGVkIHdpdGggbm9uLW9iamVjdCBhcmd1bWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG90dGllO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ0RvdHRpZSddID0gRG90dGllO1xuICAgIHJvb3RbJ0RvdCddID0gRG90dGllOyAvL0JDXG5cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIERvdHRpZTsgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIiwiLyohXG4gKiBpbmZsZWN0aW9uXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBCZW4gTGluIDxiZW5AZHJlYW1lcnNsYWIuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKlxuICogQGZpbGVvdmVydmlld1xuICogQSBwb3J0IG9mIGluZmxlY3Rpb24tanMgdG8gbm9kZS5qcyBtb2R1bGUuXG4gKi9cblxuKCBmdW5jdGlvbiAoIHJvb3QsIGZhY3RvcnkgKXtcbiAgaWYoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApe1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSApO1xuICB9ZWxzZSBpZiggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICl7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1lbHNle1xuICAgIHJvb3QuaW5mbGVjdGlvbiA9IGZhY3RvcnkoKTtcbiAgfVxufSggdGhpcywgZnVuY3Rpb24gKCl7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiBub3VucyB0aGF0IHVzZSB0aGUgc2FtZSBmb3JtIGZvciBib3RoIHNpbmd1bGFyIGFuZCBwbHVyYWwuXG4gICAqICAgICAgICAgICAgICBUaGlzIGxpc3Qgc2hvdWxkIHJlbWFpbiBlbnRpcmVseSBpbiBsb3dlciBjYXNlIHRvIGNvcnJlY3RseSBtYXRjaCBTdHJpbmdzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHVuY291bnRhYmxlX3dvcmRzID0gW1xuICAgIC8vICdhY2Nlc3MnLFxuICAgICdhY2NvbW1vZGF0aW9uJyxcbiAgICAnYWR1bHRob29kJyxcbiAgICAnYWR2ZXJ0aXNpbmcnLFxuICAgICdhZHZpY2UnLFxuICAgICdhZ2dyZXNzaW9uJyxcbiAgICAnYWlkJyxcbiAgICAnYWlyJyxcbiAgICAnYWlyY3JhZnQnLFxuICAgICdhbGNvaG9sJyxcbiAgICAnYW5nZXInLFxuICAgICdhcHBsYXVzZScsXG4gICAgJ2FyaXRobWV0aWMnLFxuICAgIC8vICdhcnQnLFxuICAgICdhc3Npc3RhbmNlJyxcbiAgICAnYXRobGV0aWNzJyxcbiAgICAvLyAnYXR0ZW50aW9uJyxcblxuICAgICdiYWNvbicsXG4gICAgJ2JhZ2dhZ2UnLFxuICAgIC8vICdiYWxsZXQnLFxuICAgIC8vICdiZWF1dHknLFxuICAgICdiZWVmJyxcbiAgICAvLyAnYmVlcicsXG4gICAgLy8gJ2JlaGF2aW9yJyxcbiAgICAnYmlvbG9neScsXG4gICAgLy8gJ2JpbGxpYXJkcycsXG4gICAgJ2Jsb29kJyxcbiAgICAnYm90YW55JyxcbiAgICAvLyAnYm93ZWxzJyxcbiAgICAnYnJlYWQnLFxuICAgIC8vICdidXNpbmVzcycsXG4gICAgJ2J1dHRlcicsXG5cbiAgICAnY2FyYm9uJyxcbiAgICAnY2FyZGJvYXJkJyxcbiAgICAnY2FzaCcsXG4gICAgJ2NoYWxrJyxcbiAgICAnY2hhb3MnLFxuICAgICdjaGVzcycsXG4gICAgJ2Nyb3Nzcm9hZHMnLFxuICAgICdjb3VudHJ5c2lkZScsXG5cbiAgICAvLyAnZGFtYWdlJyxcbiAgICAnZGFuY2luZycsXG4gICAgLy8gJ2RhbmdlcicsXG4gICAgJ2RlZXInLFxuICAgIC8vICdkZWxpZ2h0JyxcbiAgICAvLyAnZGVzc2VydCcsXG4gICAgJ2RpZ25pdHknLFxuICAgICdkaXJ0JyxcbiAgICAvLyAnZGlzdHJpYnV0aW9uJyxcbiAgICAnZHVzdCcsXG5cbiAgICAnZWNvbm9taWNzJyxcbiAgICAnZWR1Y2F0aW9uJyxcbiAgICAnZWxlY3RyaWNpdHknLFxuICAgIC8vICdlbXBsb3ltZW50JyxcbiAgICAvLyAnZW5lcmd5JyxcbiAgICAnZW5naW5lZXJpbmcnLFxuICAgICdlbmpveW1lbnQnLFxuICAgIC8vICdlbnRlcnRhaW5tZW50JyxcbiAgICAnZW52eScsXG4gICAgJ2VxdWlwbWVudCcsXG4gICAgJ2V0aGljcycsXG4gICAgJ2V2aWRlbmNlJyxcbiAgICAnZXZvbHV0aW9uJyxcblxuICAgIC8vICdmYWlsdXJlJyxcbiAgICAvLyAnZmFpdGgnLFxuICAgICdmYW1lJyxcbiAgICAnZmljdGlvbicsXG4gICAgLy8gJ2Zpc2gnLFxuICAgICdmbG91cicsXG4gICAgJ2ZsdScsXG4gICAgJ2Zvb2QnLFxuICAgIC8vICdmcmVlZG9tJyxcbiAgICAvLyAnZnJ1aXQnLFxuICAgICdmdWVsJyxcbiAgICAnZnVuJyxcbiAgICAvLyAnZnVuZXJhbCcsXG4gICAgJ2Z1cm5pdHVyZScsXG5cbiAgICAnZ2FsbG93cycsXG4gICAgJ2dhcmJhZ2UnLFxuICAgICdnYXJsaWMnLFxuICAgIC8vICdnYXMnLFxuICAgICdnZW5ldGljcycsXG4gICAgLy8gJ2dsYXNzJyxcbiAgICAnZ29sZCcsXG4gICAgJ2dvbGYnLFxuICAgICdnb3NzaXAnLFxuICAgICdncmFtbWFyJyxcbiAgICAvLyAnZ3Jhc3MnLFxuICAgICdncmF0aXR1ZGUnLFxuICAgICdncmllZicsXG4gICAgLy8gJ2dyb3VuZCcsXG4gICAgJ2d1aWx0JyxcbiAgICAnZ3ltbmFzdGljcycsXG5cbiAgICAvLyAnaGFpcicsXG4gICAgJ2hhcHBpbmVzcycsXG4gICAgJ2hhcmR3YXJlJyxcbiAgICAnaGFybScsXG4gICAgJ2hhdGUnLFxuICAgICdoYXRyZWQnLFxuICAgICdoZWFsdGgnLFxuICAgICdoZWF0JyxcbiAgICAvLyAnaGVpZ2h0JyxcbiAgICAnaGVscCcsXG4gICAgJ2hvbWV3b3JrJyxcbiAgICAnaG9uZXN0eScsXG4gICAgJ2hvbmV5JyxcbiAgICAnaG9zcGl0YWxpdHknLFxuICAgICdob3VzZXdvcmsnLFxuICAgICdodW1vdXInLFxuICAgICdodW5nZXInLFxuICAgICdoeWRyb2dlbicsXG5cbiAgICAnaWNlJyxcbiAgICAnaW1wb3J0YW5jZScsXG4gICAgJ2luZmxhdGlvbicsXG4gICAgJ2luZm9ybWF0aW9uJyxcbiAgICAvLyAnaW5qdXN0aWNlJyxcbiAgICAnaW5ub2NlbmNlJyxcbiAgICAvLyAnaW50ZWxsaWdlbmNlJyxcbiAgICAnaXJvbicsXG4gICAgJ2lyb255JyxcblxuICAgICdqYW0nLFxuICAgIC8vICdqZWFsb3VzeScsXG4gICAgLy8gJ2plbGx5JyxcbiAgICAnamV3ZWxyeScsXG4gICAgLy8gJ2pveScsXG4gICAgJ2p1ZG8nLFxuICAgIC8vICdqdWljZScsXG4gICAgLy8gJ2p1c3RpY2UnLFxuXG4gICAgJ2thcmF0ZScsXG4gICAgLy8gJ2tpbmRuZXNzJyxcbiAgICAna25vd2xlZGdlJyxcblxuICAgIC8vICdsYWJvdXInLFxuICAgICdsYWNrJyxcbiAgICAvLyAnbGFuZCcsXG4gICAgJ2xhdWdodGVyJyxcbiAgICAnbGF2YScsXG4gICAgJ2xlYXRoZXInLFxuICAgICdsZWlzdXJlJyxcbiAgICAnbGlnaHRuaW5nJyxcbiAgICAnbGluZ3VpbmUnLFxuICAgICdsaW5ndWluaScsXG4gICAgJ2xpbmd1aXN0aWNzJyxcbiAgICAnbGl0ZXJhdHVyZScsXG4gICAgJ2xpdHRlcicsXG4gICAgJ2xpdmVzdG9jaycsXG4gICAgJ2xvZ2ljJyxcbiAgICAnbG9uZWxpbmVzcycsXG4gICAgLy8gJ2xvdmUnLFxuICAgICdsdWNrJyxcbiAgICAnbHVnZ2FnZScsXG5cbiAgICAnbWFjYXJvbmknLFxuICAgICdtYWNoaW5lcnknLFxuICAgICdtYWdpYycsXG4gICAgLy8gJ21haWwnLFxuICAgICdtYW5hZ2VtZW50JyxcbiAgICAnbWFua2luZCcsXG4gICAgJ21hcmJsZScsXG4gICAgJ21hdGhlbWF0aWNzJyxcbiAgICAnbWF5b25uYWlzZScsXG4gICAgJ21lYXNsZXMnLFxuICAgIC8vICdtZWF0JyxcbiAgICAvLyAnbWV0YWwnLFxuICAgICdtZXRoYW5lJyxcbiAgICAnbWlsaycsXG4gICAgJ21pbnVzJyxcbiAgICAnbW9uZXknLFxuICAgIC8vICdtb29zZScsXG4gICAgJ211ZCcsXG4gICAgJ211c2ljJyxcbiAgICAnbXVtcHMnLFxuXG4gICAgJ25hdHVyZScsXG4gICAgJ25ld3MnLFxuICAgICduaXRyb2dlbicsXG4gICAgJ25vbnNlbnNlJyxcbiAgICAnbnVydHVyZScsXG4gICAgJ251dHJpdGlvbicsXG5cbiAgICAnb2JlZGllbmNlJyxcbiAgICAnb2Jlc2l0eScsXG4gICAgLy8gJ29pbCcsXG4gICAgJ294eWdlbicsXG5cbiAgICAvLyAncGFwZXInLFxuICAgIC8vICdwYXNzaW9uJyxcbiAgICAncGFzdGEnLFxuICAgICdwYXRpZW5jZScsXG4gICAgLy8gJ3Blcm1pc3Npb24nLFxuICAgICdwaHlzaWNzJyxcbiAgICAncG9ldHJ5JyxcbiAgICAncG9sbHV0aW9uJyxcbiAgICAncG92ZXJ0eScsXG4gICAgLy8gJ3Bvd2VyJyxcbiAgICAncHJpZGUnLFxuICAgIC8vICdwcm9kdWN0aW9uJyxcbiAgICAvLyAncHJvZ3Jlc3MnLFxuICAgIC8vICdwcm9udW5jaWF0aW9uJyxcbiAgICAncHN5Y2hvbG9neScsXG4gICAgJ3B1YmxpY2l0eScsXG4gICAgJ3B1bmN0dWF0aW9uJyxcblxuICAgIC8vICdxdWFsaXR5JyxcbiAgICAvLyAncXVhbnRpdHknLFxuICAgICdxdWFydHonLFxuXG4gICAgJ3JhY2lzbScsXG4gICAgLy8gJ3JhaW4nLFxuICAgIC8vICdyZWNyZWF0aW9uJyxcbiAgICAncmVsYXhhdGlvbicsXG4gICAgJ3JlbGlhYmlsaXR5JyxcbiAgICAncmVzZWFyY2gnLFxuICAgICdyZXNwZWN0JyxcbiAgICAncmV2ZW5nZScsXG4gICAgJ3JpY2UnLFxuICAgICdydWJiaXNoJyxcbiAgICAncnVtJyxcblxuICAgICdzYWZldHknLFxuICAgIC8vICdzYWxhZCcsXG4gICAgLy8gJ3NhbHQnLFxuICAgIC8vICdzYW5kJyxcbiAgICAvLyAnc2F0aXJlJyxcbiAgICAnc2NlbmVyeScsXG4gICAgJ3NlYWZvb2QnLFxuICAgICdzZWFzaWRlJyxcbiAgICAnc2VyaWVzJyxcbiAgICAnc2hhbWUnLFxuICAgICdzaGVlcCcsXG4gICAgJ3Nob3BwaW5nJyxcbiAgICAvLyAnc2lsZW5jZScsXG4gICAgJ3NsZWVwJyxcbiAgICAvLyAnc2xhbmcnXG4gICAgJ3Ntb2tlJyxcbiAgICAnc21va2luZycsXG4gICAgJ3Nub3cnLFxuICAgICdzb2FwJyxcbiAgICAnc29mdHdhcmUnLFxuICAgICdzb2lsJyxcbiAgICAvLyAnc29ycm93JyxcbiAgICAvLyAnc291cCcsXG4gICAgJ3NwYWdoZXR0aScsXG4gICAgLy8gJ3NwZWVkJyxcbiAgICAnc3BlY2llcycsXG4gICAgLy8gJ3NwZWxsaW5nJyxcbiAgICAvLyAnc3BvcnQnLFxuICAgICdzdGVhbScsXG4gICAgLy8gJ3N0cmVuZ3RoJyxcbiAgICAnc3R1ZmYnLFxuICAgICdzdHVwaWRpdHknLFxuICAgIC8vICdzdWNjZXNzJyxcbiAgICAvLyAnc3VnYXInLFxuICAgICdzdW5zaGluZScsXG4gICAgJ3N5bW1ldHJ5JyxcblxuICAgIC8vICd0ZWEnLFxuICAgICd0ZW5uaXMnLFxuICAgICd0aGlyc3QnLFxuICAgICd0aHVuZGVyJyxcbiAgICAndGltYmVyJyxcbiAgICAvLyAndGltZScsXG4gICAgLy8gJ3RvYXN0JyxcbiAgICAvLyAndG9sZXJhbmNlJyxcbiAgICAvLyAndHJhZGUnLFxuICAgICd0cmFmZmljJyxcbiAgICAndHJhbnNwb3J0YXRpb24nLFxuICAgIC8vICd0cmF2ZWwnLFxuICAgICd0cnVzdCcsXG5cbiAgICAvLyAndW5kZXJzdGFuZGluZycsXG4gICAgJ3VuZGVyd2VhcicsXG4gICAgJ3VuZW1wbG95bWVudCcsXG4gICAgJ3VuaXR5JyxcbiAgICAvLyAndXNhZ2UnLFxuXG4gICAgJ3ZhbGlkaXR5JyxcbiAgICAndmVhbCcsXG4gICAgJ3ZlZ2V0YXRpb24nLFxuICAgICd2ZWdldGFyaWFuaXNtJyxcbiAgICAndmVuZ2VhbmNlJyxcbiAgICAndmlvbGVuY2UnLFxuICAgIC8vICd2aXNpb24nLFxuICAgICd2aXRhbGl0eScsXG5cbiAgICAnd2FybXRoJyxcbiAgICAvLyAnd2F0ZXInLFxuICAgICd3ZWFsdGgnLFxuICAgICd3ZWF0aGVyJyxcbiAgICAvLyAnd2VpZ2h0JyxcbiAgICAnd2VsZmFyZScsXG4gICAgJ3doZWF0JyxcbiAgICAvLyAnd2hpc2tleScsXG4gICAgLy8gJ3dpZHRoJyxcbiAgICAnd2lsZGxpZmUnLFxuICAgIC8vICd3aW5lJyxcbiAgICAnd2lzZG9tJyxcbiAgICAvLyAnd29vZCcsXG4gICAgLy8gJ3dvb2wnLFxuICAgIC8vICd3b3JrJyxcblxuICAgIC8vICd5ZWFzdCcsXG4gICAgJ3lvZ2EnLFxuXG4gICAgJ3ppbmMnLFxuICAgICd6b29sb2d5J1xuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHNpbmd1bGFyIGZvcm0gb2YgYSBub3VuIHRvIGl0cyBwbHVyYWwgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIHJlZ2V4ID0ge1xuICAgIHBsdXJhbCA6IHtcbiAgICAgIG1lbiAgICAgICA6IG5ldyBSZWdFeHAoICdeKG18d29tKWVuJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcGVvcGxlICAgIDogbmV3IFJlZ0V4cCggJyhwZSlvcGxlJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjaGlsZHJlbiAgOiBuZXcgUmVnRXhwKCAnKGNoaWxkKXJlbiQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHRpYSAgICAgICA6IG5ldyBSZWdFeHAoICcoW3RpXSlhJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYW5hbHlzZXMgIDogbmV3IFJlZ0V4cCggJygoYSluYWx5fChiKWF8KGQpaWFnbm98KHApYXJlbnRoZXwocClyb2dub3wocyl5bm9wfCh0KWhlKXNlcyQnLCdnaScgKSxcbiAgICAgIGhpdmVzICAgICA6IG5ldyBSZWdFeHAoICcoaGl8dGkpdmVzJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY3VydmVzICAgIDogbmV3IFJlZ0V4cCggJyhjdXJ2ZSlzJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBscnZlcyAgICAgOiBuZXcgUmVnRXhwKCAnKFtscl0pdmVzJCcgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGF2ZXMgICAgICA6IG5ldyBSZWdFeHAoICcoW2FdKXZlcyQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZm92ZXMgICAgIDogbmV3IFJlZ0V4cCggJyhbXmZvXSl2ZXMkJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBtb3ZpZXMgICAgOiBuZXcgUmVnRXhwKCAnKG0pb3ZpZXMkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGFlaW91eWllcyA6IG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KWllcyQnICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgc2VyaWVzICAgIDogbmV3IFJlZ0V4cCggJyhzKWVyaWVzJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB4ZXMgICAgICAgOiBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpZXMkJyAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG1pY2UgICAgICA6IG5ldyBSZWdFeHAoICcoW218bF0paWNlJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYnVzZXMgICAgIDogbmV3IFJlZ0V4cCggJyhidXMpZXMkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBvZXMgICAgICAgOiBuZXcgUmVnRXhwKCAnKG8pZXMkJyAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHNob2VzICAgICA6IG5ldyBSZWdFeHAoICcoc2hvZSlzJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY3Jpc2VzICAgIDogbmV3IFJlZ0V4cCggJyhjcmlzfGF4fHRlc3QpZXMkJyAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBvY3RvcGkgICAgOiBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcilpJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGFsaWFzZXMgICA6IG5ldyBSZWdFeHAoICcoYWxpYXN8Y2FudmFzfHN0YXR1c3xjYW1wdXMpZXMkJywgJ2dpJyApLFxuICAgICAgc3VtbW9uc2VzIDogbmV3IFJlZ0V4cCggJ14oc3VtbW9ucyllcyQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBveGVuICAgICAgOiBuZXcgUmVnRXhwKCAnXihveCllbicgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG1hdHJpY2VzICA6IG5ldyBSZWdFeHAoICcobWF0cilpY2VzJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgdmVydGljZXMgIDogbmV3IFJlZ0V4cCggJyh2ZXJ0fGluZClpY2VzJCcgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBmZWV0ICAgICAgOiBuZXcgUmVnRXhwKCAnXmZlZXQkJyAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHRlZXRoICAgICA6IG5ldyBSZWdFeHAoICdedGVldGgkJyAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZ2Vlc2UgICAgIDogbmV3IFJlZ0V4cCggJ15nZWVzZSQnICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBxdWl6emVzICAgOiBuZXcgUmVnRXhwKCAnKHF1aXopemVzJCcgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHdoZXJlYXNlcyA6IG5ldyBSZWdFeHAoICdeKHdoZXJlYXMpZXMkJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY3JpdGVyaWEgIDogbmV3IFJlZ0V4cCggJ14oY3JpdGVyaSlhJCcgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBnZW5lcmEgICAgOiBuZXcgUmVnRXhwKCAnXmdlbmVyYSQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHNzICAgICAgICA6IG5ldyBSZWdFeHAoICdzcyQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcyAgICAgICAgIDogbmV3IFJlZ0V4cCggJ3MkJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knIClcbiAgICB9LFxuXG4gICAgc2luZ3VsYXIgOiB7XG4gICAgICBtYW4gICAgICAgOiBuZXcgUmVnRXhwKCAnXihtfHdvbSlhbiQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBwZXJzb24gICAgOiBuZXcgUmVnRXhwKCAnKHBlKXJzb24kJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjaGlsZCAgICAgOiBuZXcgUmVnRXhwKCAnKGNoaWxkKSQnICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBveCAgICAgICAgOiBuZXcgUmVnRXhwKCAnXihveCkkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBheGlzICAgICAgOiBuZXcgUmVnRXhwKCAnKGF4fHRlc3QpaXMkJyAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBvY3RvcHVzICAgOiBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcil1cyQnICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhbGlhcyAgICAgOiBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1c3xjYW52YXN8Y2FtcHVzKSQnLCAnZ2knICksXG4gICAgICBzdW1tb25zICAgOiBuZXcgUmVnRXhwKCAnXihzdW1tb25zKSQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBidXMgICAgICAgOiBuZXcgUmVnRXhwKCAnKGJ1KXMkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBidWZmYWxvICAgOiBuZXcgUmVnRXhwKCAnKGJ1ZmZhbHx0b21hdHxwb3RhdClvJCcgICAgICAgLCAnZ2knICksXG4gICAgICB0aXVtICAgICAgOiBuZXcgUmVnRXhwKCAnKFt0aV0pdW0kJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzaXMgICAgICAgOiBuZXcgUmVnRXhwKCAnc2lzJCcgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBmZmUgICAgICAgOiBuZXcgUmVnRXhwKCAnKD86KFteZl0pZmV8KFtscl0pZikkJyAgICAgICAgLCAnZ2knICksXG4gICAgICBoaXZlICAgICAgOiBuZXcgUmVnRXhwKCAnKGhpfHRpKXZlJCcgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhZWlvdXl5ICAgOiBuZXcgUmVnRXhwKCAnKFteYWVpb3V5XXxxdSl5JCcgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB4ICAgICAgICAgOiBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpJCcgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBtYXRyaXggICAgOiBuZXcgUmVnRXhwKCAnKG1hdHIpaXgkJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB2ZXJ0ZXggICAgOiBuZXcgUmVnRXhwKCAnKHZlcnR8aW5kKWV4JCcgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBtb3VzZSAgICAgOiBuZXcgUmVnRXhwKCAnKFttfGxdKW91c2UkJyAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBmb290ICAgICAgOiBuZXcgUmVnRXhwKCAnXmZvb3QkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB0b290aCAgICAgOiBuZXcgUmVnRXhwKCAnXnRvb3RoJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBnb29zZSAgICAgOiBuZXcgUmVnRXhwKCAnXmdvb3NlJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBxdWl6ICAgICAgOiBuZXcgUmVnRXhwKCAnKHF1aXopJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB3aGVyZWFzICAgOiBuZXcgUmVnRXhwKCAnXih3aGVyZWFzKSQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjcml0ZXJpb24gOiBuZXcgUmVnRXhwKCAnXihjcml0ZXJpKW9uJCcgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBnZW51cyAgICAgOiBuZXcgUmVnRXhwKCAnXmdlbnVzJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzICAgICAgICAgOiBuZXcgUmVnRXhwKCAncyQnICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjb21tb24gICAgOiBuZXcgUmVnRXhwKCAnJCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knIClcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsdXJhbF9ydWxlcyA9IFtcblxuICAgIC8vIGRvIG5vdCByZXBsYWNlIGlmIGl0cyBhbHJlYWR5IGEgcGx1cmFsIHdvcmRcbiAgICBbIHJlZ2V4LnBsdXJhbC5tZW4gICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5wZW9wbGUgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jaGlsZHJlbiAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC50aWEgICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hbmFseXNlcyAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5oaXZlcyAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jdXJ2ZXMgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5scnZlcyAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5mb3ZlcyAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hZWlvdXlpZXMgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zZXJpZXMgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5tb3ZpZXMgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC54ZXMgICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5taWNlICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5idXNlcyAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5vZXMgICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zaG9lcyAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jcmlzZXMgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5vY3RvcGkgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hbGlhc2VzICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zdW1tb25zZXMgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5veGVuICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5tYXRyaWNlcyAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5mZWV0ICAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC50ZWV0aCAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5nZWVzZSAgICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5xdWl6emVzICAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC53aGVyZWFzZXMgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jcml0ZXJpYSAgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5nZW5lcmEgICAgXSxcblxuICAgIC8vIG9yaWdpbmFsIHJ1bGVcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1hbiAgICAgICwgJyQxZW4nIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5wZXJzb24gICAsICckMW9wbGUnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5jaGlsZCAgICAsICckMXJlbicgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm94ICAgICAgICwgJyQxZW4nIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5heGlzICAgICAsICckMWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIub2N0b3B1cyAgLCAnJDFpJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYWxpYXMgICAgLCAnJDFlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnN1bW1vbnMgICwgJyQxZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5idXMgICAgICAsICckMXNlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmJ1ZmZhbG8gICwgJyQxb2VzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIudGl1bSAgICAgLCAnJDFhJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuc2lzICAgICAgLCAnc2VzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZmZlICAgICAgLCAnJDEkMnZlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmhpdmUgICAgICwgJyQxdmVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYWVpb3V5eSAgLCAnJDFpZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5tYXRyaXggICAsICckMWljZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci52ZXJ0ZXggICAsICckMWljZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci54ICAgICAgICAsICckMWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIubW91c2UgICAgLCAnJDFpY2UnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5mb290ICAgICAsICdmZWV0JyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIudG9vdGggICAgLCAndGVldGgnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5nb29zZSAgICAsICdnZWVzZScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnF1aXogICAgICwgJyQxemVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIud2hlcmVhcyAgLCAnJDFlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmNyaXRlcmlvbiwgJyQxYScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmdlbnVzICAgICwgJ2dlbmVyYScgXSxcblxuICAgIFsgcmVnZXguc2luZ3VsYXIucyAgICAgLCAncycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmNvbW1vbiwgJ3MnIF1cbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoZXNlIHJ1bGVzIHRyYW5zbGF0ZSBmcm9tIHRoZSBwbHVyYWwgZm9ybSBvZiBhIG5vdW4gdG8gaXRzIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgc2luZ3VsYXJfcnVsZXMgPSBbXG5cbiAgICAvLyBkbyBub3QgcmVwbGFjZSBpZiBpdHMgYWxyZWFkeSBhIHNpbmd1bGFyIHdvcmRcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1hbiAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnBlcnNvbiAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmNoaWxkICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm94ICAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmF4aXMgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm9jdG9wdXMgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmFsaWFzICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnN1bW1vbnMgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmJ1cyAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmJ1ZmZhbG8gXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnRpdW0gICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnNpcyAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmZmZSAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmhpdmUgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmFlaW91eXkgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnggICAgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1hdHJpeCAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1vdXNlICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmZvb3QgICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnRvb3RoICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmdvb3NlICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnF1aXogICAgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLndoZXJlYXMgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmNyaXRlcmlvbiBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZ2VudXMgXSxcblxuICAgIC8vIG9yaWdpbmFsIHJ1bGVcbiAgICBbIHJlZ2V4LnBsdXJhbC5tZW4gICAgICAsICckMWFuJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnBlb3BsZSAgICwgJyQxcnNvbicgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jaGlsZHJlbiAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5nZW5lcmEgICAsICdnZW51cyddLFxuICAgIFsgcmVnZXgucGx1cmFsLmNyaXRlcmlhICwgJyQxb24nXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC50aWEgICAgICAsICckMXVtJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFuYWx5c2VzICwgJyQxJDJzaXMnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuaGl2ZXMgICAgLCAnJDF2ZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jdXJ2ZXMgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5scnZlcyAgICAsICckMWYnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYXZlcyAgICAgLCAnJDF2ZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5mb3ZlcyAgICAsICckMWZlJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1vdmllcyAgICwgJyQxb3ZpZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hZWlvdXlpZXMsICckMXknIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc2VyaWVzICAgLCAnJDFlcmllcycgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC54ZXMgICAgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5taWNlICAgICAsICckMW91c2UnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYnVzZXMgICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwub2VzICAgICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc2hvZXMgICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY3Jpc2VzICAgLCAnJDFpcycgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5vY3RvcGkgICAsICckMXVzJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFsaWFzZXMgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnN1bW1vbnNlcywgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm94ZW4gICAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1hdHJpY2VzICwgJyQxaXgnIF0sXG4gICAgWyByZWdleC5wbHVyYWwudmVydGljZXMgLCAnJDFleCcgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5mZWV0ICAgICAsICdmb290JyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnRlZXRoICAgICwgJ3Rvb3RoJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmdlZXNlICAgICwgJ2dvb3NlJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnF1aXp6ZXMgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLndoZXJlYXNlcywgJyQxJyBdLFxuXG4gICAgWyByZWdleC5wbHVyYWwuc3MsICdzcycgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zICwgJycgXVxuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBhIGxpc3Qgb2Ygd29yZHMgdGhhdCBzaG91bGQgbm90IGJlIGNhcGl0YWxpemVkIGZvciB0aXRsZSBjYXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIG5vbl90aXRsZWNhc2VkX3dvcmRzID0gW1xuICAgICdhbmQnLCAnb3InLCAnbm9yJywgJ2EnLCAnYW4nLCAndGhlJywgJ3NvJywgJ2J1dCcsICd0bycsICdvZicsICdhdCcsJ2J5JyxcbiAgICAnZnJvbScsICdpbnRvJywgJ29uJywgJ29udG8nLCAnb2ZmJywgJ291dCcsICdpbicsICdvdmVyJywgJ3dpdGgnLCAnZm9yJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgY29udmVydGluZyBiZXR3ZWVuIFN0cmluZyBmb3JtYXRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIGlkX3N1ZmZpeCAgICAgICAgID0gbmV3IFJlZ0V4cCggJyhfaWRzfF9pZCkkJywgJ2cnICk7XG4gIHZhciB1bmRlcmJhciAgICAgICAgICA9IG5ldyBSZWdFeHAoICdfJywgJ2cnICk7XG4gIHZhciBzcGFjZV9vcl91bmRlcmJhciA9IG5ldyBSZWdFeHAoICdbXFwgX10nLCAnZycgKTtcbiAgdmFyIHVwcGVyY2FzZSAgICAgICAgID0gbmV3IFJlZ0V4cCggJyhbQS1aXSknLCAnZycgKTtcbiAgdmFyIHVuZGVyYmFyX3ByZWZpeCAgID0gbmV3IFJlZ0V4cCggJ15fJyApO1xuXG4gIHZhciBpbmZsZWN0b3IgPSB7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGFwcGxpZXMgcnVsZXMgYmFzZWQgcmVwbGFjZW1lbnQgdG8gYSBTdHJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBtb2RpZnkgYW5kIHJldHVybiBiYXNlZCBvbiB0aGUgcGFzc2VkIHJ1bGVzLlxuICAgKiBAcGFyYW0ge0FycmF5OiBbUmVnRXhwLCBTdHJpbmddfSBydWxlcyBSZWdleHAgdG8gbWF0Y2ggcGFpcmVkIHdpdGggU3RyaW5nIHRvIHVzZSBmb3IgcmVwbGFjZW1lbnRcbiAgICogQHBhcmFtIHtBcnJheTogW1N0cmluZ119IHNraXAgU3RyaW5ncyB0byBza2lwIGlmIHRoZXkgbWF0Y2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IG92ZXJyaWRlIFN0cmluZyB0byByZXR1cm4gYXMgdGhvdWdoIHRoaXMgbWV0aG9kIHN1Y2NlZWRlZCAodXNlZCB0byBjb25mb3JtIHRvIEFQSXMpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybiBwYXNzZWQgU3RyaW5nIG1vZGlmaWVkIGJ5IHBhc3NlZCBydWxlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHRoaXMuX2FwcGx5X3J1bGVzKCAnY293cycsIHNpbmd1bGFyX3J1bGVzICk7IC8vID09PSAnY293J1xuICAgKi9cbiAgICBfYXBwbHlfcnVsZXMgOiBmdW5jdGlvbiAoIHN0ciwgcnVsZXMsIHNraXAsIG92ZXJyaWRlICl7XG4gICAgICBpZiggb3ZlcnJpZGUgKXtcbiAgICAgICAgc3RyID0gb3ZlcnJpZGU7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdmFyIGlnbm9yZSA9ICggaW5mbGVjdG9yLmluZGV4T2YoIHNraXAsIHN0ci50b0xvd2VyQ2FzZSgpKSA+IC0xICk7XG5cbiAgICAgICAgaWYoICFpZ25vcmUgKXtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdmFyIGogPSBydWxlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICAgICAgaWYoIHN0ci5tYXRjaCggcnVsZXNbIGkgXVsgMCBdKSl7XG4gICAgICAgICAgICAgIGlmKCBydWxlc1sgaSBdWyAxIF0gIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCBydWxlc1sgaSBdWyAwIF0sIHJ1bGVzWyBpIF1bIDEgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbGV0cyB1cyBkZXRlY3QgaWYgYW4gQXJyYXkgY29udGFpbnMgYSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIHN1YmplY3QgYXJyYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIE9iamVjdCB0byBsb2NhdGUgaW4gdGhlIEFycmF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbV9pbmRleCBTdGFydHMgY2hlY2tpbmcgZnJvbSB0aGlzIHBvc2l0aW9uIGluIHRoZSBBcnJheS4ob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVfZnVuYyBGdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgQXJyYXkgaXRlbSB2cyBwYXNzZWQgaXRlbS4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybiBpbmRleCBwb3NpdGlvbiBpbiB0aGUgQXJyYXkgb2YgdGhlIHBhc3NlZCBpdGVtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uaW5kZXhPZihbICdoaScsJ3RoZXJlJyBdLCAnZ3V5cycgKTsgLy8gPT09IC0xXG4gICAqICAgICBpbmZsZWN0aW9uLmluZGV4T2YoWyAnaGknLCd0aGVyZScgXSwgJ2hpJyApOyAvLyA9PT0gMFxuICAgKi9cbiAgICBpbmRleE9mIDogZnVuY3Rpb24gKCBhcnIsIGl0ZW0sIGZyb21faW5kZXgsIGNvbXBhcmVfZnVuYyApe1xuICAgICAgaWYoICFmcm9tX2luZGV4ICl7XG4gICAgICAgIGZyb21faW5kZXggPSAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgaSAgICAgPSBmcm9tX2luZGV4O1xuICAgICAgdmFyIGogICAgID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgaWYoIGFyclsgaSBdICA9PT0gaXRlbSB8fCBjb21wYXJlX2Z1bmMgJiYgY29tcGFyZV9mdW5jKCBhcnJbIGkgXSwgaXRlbSApKXtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgcGx1cmFsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1cmFsIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTaW5ndWxhciBFbmdsaXNoIGxhbmd1YWdlIG5vdW5zIGFyZSByZXR1cm5lZCBpbiBwbHVyYWwgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ3BlcnNvbicgKTsgLy8gPT09ICdwZW9wbGUnXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ29jdG9wdXMnICk7IC8vID09PSAnb2N0b3BpJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdIYXQnICk7IC8vID09PSAnSGF0cydcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAncGVyc29uJywgJ2d1eXMnICk7IC8vID09PSAnZ3V5cydcbiAgICovXG4gICAgcGx1cmFsaXplIDogZnVuY3Rpb24gKCBzdHIsIHBsdXJhbCApe1xuICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgcGx1cmFsX3J1bGVzLCB1bmNvdW50YWJsZV93b3JkcywgcGx1cmFsICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBzaW5ndWxhcml6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpbmd1bGFyIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQbHVyYWwgRW5nbGlzaCBsYW5ndWFnZSBub3VucyBhcmUgcmV0dXJuZWQgaW4gc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAncGVvcGxlJyApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdvY3RvcGknICk7IC8vID09PSAnb2N0b3B1cydcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdIYXRzJyApOyAvLyA9PT0gJ0hhdCdcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdndXlzJywgJ3BlcnNvbicgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqL1xuICAgIHNpbmd1bGFyaXplIDogZnVuY3Rpb24gKCBzdHIsIHNpbmd1bGFyICl7XG4gICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBzaW5ndWxhcl9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHNpbmd1bGFyICk7XG4gICAgfSxcblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGx1cmFsaXplIG9yIHNpbmd1bGFybGl6ZSBhIFN0cmluZyBhcHByb3ByaWF0ZWx5IGJhc2VkIG9uIGFuIGludGVnZXIgdmFsdWVcbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIHRvIGJhc2UgcGx1cmFsaXphdGlvbiBvZmYgb2YuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaW5ndWxhciBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdXJhbCBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gRW5nbGlzaCBsYW5ndWFnZSBub3VucyBhcmUgcmV0dXJuZWQgaW4gdGhlIHBsdXJhbCBvciBzaW5ndWxhciBmb3JtIGJhc2VkIG9uIHRoZSBjb3VudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdwZW9wbGUnIDEgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdvY3RvcGknIDEgKTsgLy8gPT09ICdvY3RvcHVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAnSGF0cycgMSApOyAvLyA9PT0gJ0hhdCdcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ2d1eXMnLCAxICwgJ3BlcnNvbicgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdwZXJzb24nLCAyICk7IC8vID09PSAncGVvcGxlJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAnb2N0b3B1cycsIDIgKTsgLy8gPT09ICdvY3RvcGknXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdIYXQnLCAyICk7IC8vID09PSAnSGF0cydcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ3BlcnNvbicsIDIsIG51bGwsICdndXlzJyApOyAvLyA9PT0gJ2d1eXMnXG4gICAqL1xuICAgIGluZmxlY3QgOiBmdW5jdGlvbiAoIHN0ciwgY291bnQsIHNpbmd1bGFyLCBwbHVyYWwgKXtcbiAgICAgIGNvdW50ID0gcGFyc2VJbnQoIGNvdW50LCAxMCApO1xuXG4gICAgICBpZiggaXNOYU4oIGNvdW50ICkpIHJldHVybiBzdHI7XG5cbiAgICAgIGlmKCBjb3VudCA9PT0gMCB8fCBjb3VudCA+IDEgKXtcbiAgICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgcGx1cmFsX3J1bGVzLCB1bmNvdW50YWJsZV93b3JkcywgcGx1cmFsICk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgc2luZ3VsYXJfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBzaW5ndWxhciApO1xuICAgICAgfVxuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgY2FtZWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG93X2ZpcnN0X2xldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gY2FtZWwgY2FzZS5cbiAgICogICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsbHkgJy8nIGlzIHRyYW5zbGF0ZWQgdG8gJzo6J1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FtZWxpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZVByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhbWVsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2VQcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYW1lbGl6ZSA6IGZ1bmN0aW9uICggc3RyLCBsb3dfZmlyc3RfbGV0dGVyICl7XG4gICAgICB2YXIgc3RyX3BhdGggPSBzdHIuc3BsaXQoICcvJyApO1xuICAgICAgdmFyIGkgICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgICA9IHN0cl9wYXRoLmxlbmd0aDtcbiAgICAgIHZhciBzdHJfYXJyLCBpbml0X3gsIGssIGwsIGZpcnN0O1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBzdHJfYXJyID0gc3RyX3BhdGhbIGkgXS5zcGxpdCggJ18nICk7XG4gICAgICAgIGsgICAgICAgPSAwO1xuICAgICAgICBsICAgICAgID0gc3RyX2Fyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yKCA7IGsgPCBsOyBrKysgKXtcbiAgICAgICAgICBpZiggayAhPT0gMCApe1xuICAgICAgICAgICAgc3RyX2FyclsgayBdID0gc3RyX2FyclsgayBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlyc3QgPSBzdHJfYXJyWyBrIF0uY2hhckF0KCAwICk7XG4gICAgICAgICAgZmlyc3QgPSBsb3dfZmlyc3RfbGV0dGVyICYmIGkgPT09IDAgJiYgayA9PT0gMFxuICAgICAgICAgICAgPyBmaXJzdC50b0xvd2VyQ2FzZSgpIDogZmlyc3QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBzdHJfYXJyWyBrIF0gPSBmaXJzdCArIHN0cl9hcnJbIGsgXS5zdWJzdHJpbmcoIDEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfYXJyLmpvaW4oICcnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfcGF0aC5qb2luKCAnOjonICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB1bmRlcnNjb3JlIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsX3VwcGVyX2Nhc2UgRGVmYXVsdCBpcyB0byBsb3dlcmNhc2UgYW5kIGFkZCB1bmRlcnNjb3JlIHByZWZpeC4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgcmV0dXJuIGFzIGVudGVyZWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENhbWVsIGNhc2VkIHdvcmRzIGFyZSByZXR1cm5lZCBhcyBsb3dlciBjYXNlZCBhbmQgdW5kZXJzY29yZWQuXG4gICAqICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbGx5ICc6OicgaXMgdHJhbnNsYXRlZCB0byAnLycuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnbWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTVAnLCB0cnVlICk7IC8vID09PSAnTVAnXG4gICAqL1xuICAgIHVuZGVyc2NvcmUgOiBmdW5jdGlvbiAoIHN0ciwgYWxsX3VwcGVyX2Nhc2UgKXtcbiAgICAgIGlmKCBhbGxfdXBwZXJfY2FzZSAmJiBzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpKSByZXR1cm4gc3RyO1xuXG4gICAgICB2YXIgc3RyX3BhdGggPSBzdHIuc3BsaXQoICc6OicgKTtcbiAgICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICAgPSBzdHJfcGF0aC5sZW5ndGg7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfcGF0aFsgaSBdLnJlcGxhY2UoIHVwcGVyY2FzZSwgJ18kMScgKTtcbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9wYXRoWyBpIF0ucmVwbGFjZSggdW5kZXJiYXJfcHJlZml4LCAnJyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyX3BhdGguam9pbiggJy8nICkudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGh1bWFuaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG93X2ZpcnN0X2xldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gaHVtYW5pemVkIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5odW1hbml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmh1bWFuaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2UgcHJvcGVydGllcydcbiAgICovXG4gICAgaHVtYW5pemUgOiBmdW5jdGlvbiAoIHN0ciwgbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSggaWRfc3VmZml4LCAnJyApO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIHVuZGVyYmFyLCAnICcgKTtcblxuICAgICAgaWYoICFsb3dfZmlyc3RfbGV0dGVyICl7XG4gICAgICAgIHN0ciA9IGluZmxlY3Rvci5jYXBpdGFsaXplKCBzdHIgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNhcGl0YWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEFsbCBjaGFyYWN0ZXJzIHdpbGwgYmUgbG93ZXIgY2FzZSBhbmQgdGhlIGZpcnN0IHdpbGwgYmUgdXBwZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jYXBpdGFsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uY2FwaXRhbGl6ZSggJ21lc3NhZ2UgcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdNZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqL1xuICAgIGNhcGl0YWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKCAwLCAxICkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoIDEgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXBsYWNlcyB1bmRlcnNjb3JlcyB3aXRoIGRhc2hlcyBpbiB0aGUgc3RyaW5nLlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmVwbGFjZXMgYWxsIHNwYWNlcyBvciB1bmRlcnNjb3JlcyB3aXRoIGRhc2hlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmRhc2hlcml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdtZXNzYWdlLXByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmRhc2hlcml6ZSggJ01lc3NhZ2UgUHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlLVByb3BlcnRpZXMnXG4gICAqL1xuICAgIGRhc2hlcml6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoIHNwYWNlX29yX3VuZGVyYmFyLCAnLScgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHRpdGxlaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENhcGl0YWxpemVzIHdvcmRzIGFzIHlvdSB3b3VsZCBmb3IgYSBib29rIHRpdGxlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udGl0bGVpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZSBQcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi50aXRsZWl6ZSggJ21lc3NhZ2UgcHJvcGVydGllcyB0byBrZWVwJyApOyAvLyA9PT0gJ01lc3NhZ2UgUHJvcGVydGllcyB0byBLZWVwJ1xuICAgKi9cbiAgICB0aXRsZWl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgICAgICAgICA9IHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoIHVuZGVyYmFyLCAnICcgKTtcbiAgICAgIHZhciBzdHJfYXJyID0gc3RyLnNwbGl0KCAnICcgKTtcbiAgICAgIHZhciBpICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgID0gc3RyX2Fyci5sZW5ndGg7XG4gICAgICB2YXIgZCwgaywgbDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgZCA9IHN0cl9hcnJbIGkgXS5zcGxpdCggJy0nICk7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBsID0gZC5sZW5ndGg7XG5cbiAgICAgICAgZm9yKCA7IGsgPCBsOyBrKyspe1xuICAgICAgICAgIGlmKCBpbmZsZWN0b3IuaW5kZXhPZiggbm9uX3RpdGxlY2FzZWRfd29yZHMsIGRbIGsgXS50b0xvd2VyQ2FzZSgpKSA8IDAgKXtcbiAgICAgICAgICAgIGRbIGsgXSA9IGluZmxlY3Rvci5jYXBpdGFsaXplKCBkWyBrIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cl9hcnJbIGkgXSA9IGQuam9pbiggJy0nICk7XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IHN0cl9hcnIuam9pbiggJyAnICk7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCAxICkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoIDEgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGRlbW9kdWxpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmVtb3ZlcyBtb2R1bGUgbmFtZXMgbGVhdmluZyBvbmx5IGNsYXNzIG5hbWVzLihSdWJ5IHN0eWxlKVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZGVtb2R1bGl6ZSggJ01lc3NhZ2U6OkJ1czo6UHJvcGVydGllcycgKTsgLy8gPT09ICdQcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBkZW1vZHVsaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHZhciBzdHJfYXJyID0gc3RyLnNwbGl0KCAnOjonICk7XG5cbiAgICAgIHJldHVybiBzdHJfYXJyWyBzdHJfYXJyLmxlbmd0aCAtIDEgXTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHRhYmxlaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybiBjYW1lbCBjYXNlZCB3b3JkcyBpbnRvIHRoZWlyIHVuZGVyc2NvcmVkIHBsdXJhbCBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udGFibGVpemUoICdNZXNzYWdlQnVzUHJvcGVydHknICk7IC8vID09PSAnbWVzc2FnZV9idXNfcHJvcGVydGllcydcbiAgICovXG4gICAgdGFibGVpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnVuZGVyc2NvcmUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnBsdXJhbGl6ZSggc3RyICk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjbGFzc2lmaWNhdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVbmRlcnNjb3JlZCBwbHVyYWwgbm91bnMgYmVjb21lIHRoZSBjYW1lbCBjYXNlZCBzaW5ndWxhciBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2xhc3NpZnkoICdtZXNzYWdlX2J1c19wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2VCdXNQcm9wZXJ0eSdcbiAgICovXG4gICAgY2xhc3NpZnkgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyID0gaW5mbGVjdG9yLmNhbWVsaXplKCBzdHIgKTtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5zaW5ndWxhcml6ZSggc3RyICk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBmb3JlaWduIGtleSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRyb3BfaWRfdWJhciBEZWZhdWx0IGlzIHRvIHNlcGVyYXRlIGlkIHdpdGggYW4gdW5kZXJiYXIgYXQgdGhlIGVuZCBvZiB0aGUgY2xhc3MgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlvdSBjYW4gcGFzcyB0cnVlIHRvIHNraXAgaXQuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVbmRlcnNjb3JlZCBwbHVyYWwgbm91bnMgYmVjb21lIHRoZSBjYW1lbCBjYXNlZCBzaW5ndWxhciBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZm9yZWlnbl9rZXkoICdNZXNzYWdlQnVzUHJvcGVydHknICk7IC8vID09PSAnbWVzc2FnZV9idXNfcHJvcGVydHlfaWQnXG4gICAqICAgICBpbmZsZWN0aW9uLmZvcmVpZ25fa2V5KCAnTWVzc2FnZUJ1c1Byb3BlcnR5JywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnR5aWQnXG4gICAqL1xuICAgIGZvcmVpZ25fa2V5IDogZnVuY3Rpb24gKCBzdHIsIGRyb3BfaWRfdWJhciApe1xuICAgICAgc3RyID0gaW5mbGVjdG9yLmRlbW9kdWxpemUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnVuZGVyc2NvcmUoIHN0ciApICsgKCggZHJvcF9pZF91YmFyICkgPyAoICcnICkgOiAoICdfJyApKSArICdpZCc7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBvcmRpbmFsaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybiBhbGwgZm91bmQgbnVtYmVycyB0aGVpciBzZXF1ZW5jZSBsaWtlICcyMm5kJy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLm9yZGluYWxpemUoICd0aGUgMSBwaXRjaCcgKTsgLy8gPT09ICd0aGUgMXN0IHBpdGNoJ1xuICAgKi9cbiAgICBvcmRpbmFsaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHZhciBzdHJfYXJyID0gc3RyLnNwbGl0KCAnICcgKTtcbiAgICAgIHZhciBpICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgID0gc3RyX2Fyci5sZW5ndGg7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoIHN0cl9hcnJbIGkgXSwgMTAgKTtcblxuICAgICAgICBpZiggIWlzTmFOKCBrICkpe1xuICAgICAgICAgIHZhciBsdGQgPSBzdHJfYXJyWyBpIF0uc3Vic3RyaW5nKCBzdHJfYXJyWyBpIF0ubGVuZ3RoIC0gMiApO1xuICAgICAgICAgIHZhciBsZCAgPSBzdHJfYXJyWyBpIF0uc3Vic3RyaW5nKCBzdHJfYXJyWyBpIF0ubGVuZ3RoIC0gMSApO1xuICAgICAgICAgIHZhciBzdWYgPSAndGgnO1xuXG4gICAgICAgICAgaWYoIGx0ZCAhPSAnMTEnICYmIGx0ZCAhPSAnMTInICYmIGx0ZCAhPSAnMTMnICl7XG4gICAgICAgICAgICBpZiggbGQgPT09ICcxJyApe1xuICAgICAgICAgICAgICBzdWYgPSAnc3QnO1xuICAgICAgICAgICAgfWVsc2UgaWYoIGxkID09PSAnMicgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ25kJztcbiAgICAgICAgICAgIH1lbHNlIGlmKCBsZCA9PT0gJzMnICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICdyZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyX2FyclsgaSBdICs9IHN1ZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyX2Fyci5qb2luKCAnICcgKTtcbiAgICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIG11bHRpcGxlIGluZmxlY3Rpb24gbWV0aG9kcyBvbiBhIHN0cmluZ1xuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIEFuIGFycmF5IG9mIGluZmxlY3Rpb24gbWV0aG9kcy5cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnRyYW5zZm9ybSggJ2FsbCBqb2InLCBbICdwbHVyYWxpemUnLCAnY2FwaXRhbGl6ZScsICdkYXNoZXJpemUnIF0pOyAvLyA9PT0gJ0FsbC1qb2JzJ1xuICAgKi9cbiAgICB0cmFuc2Zvcm0gOiBmdW5jdGlvbiAoIHN0ciwgYXJyICl7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgaiA9IGFyci5sZW5ndGg7XG5cbiAgICAgIGZvciggO2kgPCBqOyBpKysgKXtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGFyclsgaSBdO1xuXG4gICAgICAgIGlmKCBpbmZsZWN0b3IuaGFzT3duUHJvcGVydHkoIG1ldGhvZCApKXtcbiAgICAgICAgICBzdHIgPSBpbmZsZWN0b3JbIG1ldGhvZCBdKCBzdHIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbiAgaW5mbGVjdG9yLnZlcnNpb24gPSAnMS4xMi4wJztcblxuICByZXR1cm4gaW5mbGVjdG9yO1xufSkpO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKEMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxuXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgUmVmbGVjdDtcbihmdW5jdGlvbiAoUmVmbGVjdCkge1xuICAgIC8vIE1ldGFkYXRhIFByb3Bvc2FsXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cbiAgICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDpcbiAgICAgICAgICAgICAgICAgICAgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKTtcbiAgICAgICAgdmFyIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKFJlZmxlY3QpO1xuICAgICAgICBpZiAodHlwZW9mIHJvb3QuUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcm9vdC5SZWZsZWN0ID0gUmVmbGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKHJvb3QuUmVmbGVjdCwgZXhwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0ZXIpO1xuICAgICAgICBmdW5jdGlvbiBtYWtlRXhwb3J0ZXIodGFyZ2V0LCBwcmV2aW91cykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cylcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoZnVuY3Rpb24gKGV4cG9ydGVyKSB7XG4gICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICAvLyBmZWF0dXJlIHRlc3QgZm9yIFN5bWJvbCBzdXBwb3J0XG4gICAgICAgIHZhciBzdXBwb3J0c1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xuICAgICAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLml0ZXJhdG9yIDogXCJAQGl0ZXJhdG9yXCI7XG4gICAgICAgIHZhciBzdXBwb3J0c0NyZWF0ZSA9IHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCI7IC8vIGZlYXR1cmUgdGVzdCBmb3IgT2JqZWN0LmNyZWF0ZSBzdXBwb3J0XG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxuICAgICAgICB2YXIgZG93bkxldmVsID0gIXN1cHBvcnRzQ3JlYXRlICYmICFzdXBwb3J0c1Byb3RvO1xuICAgICAgICB2YXIgSGFzaE1hcCA9IHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgaW4gZGljdGlvbmFyeSBtb2RlIChhLmsuYS4gXCJzbG93XCIgbW9kZSBpbiB2OClcbiAgICAgICAgICAgIGNyZWF0ZTogc3VwcG9ydHNDcmVhdGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KE9iamVjdC5jcmVhdGUobnVsbCkpOyB9XG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1Byb3RvXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoeyBfX3Byb3RvX186IG51bGwgfSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7fSk7IH0sXG4gICAgICAgICAgICBoYXM6IGRvd25MZXZlbFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSk7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4ga2V5IGluIG1hcDsgfSxcbiAgICAgICAgICAgIGdldDogZG93bkxldmVsXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KSA/IG1hcFtrZXldIDogdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIG1hcFtrZXldOyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBMb2FkIGdsb2JhbCBvciBzaGltIHZlcnNpb25zIG9mIE1hcCwgU2V0LCBhbmQgV2Vha01hcFxuICAgICAgICB2YXIgZnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb24pO1xuICAgICAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHZhciBfTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBNYXAgOiBDcmVhdGVNYXBQb2x5ZmlsbCgpO1xuICAgICAgICB2YXIgX1NldCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgU2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gU2V0IDogQ3JlYXRlU2V0UG9seWZpbGwoKTtcbiAgICAgICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XG4gICAgICAgIC8vIFtbTWV0YWRhdGFdXSBpbnRlcm5hbCBzbG90XG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90c1xuICAgICAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgYSBzZXQgb2YgZGVjb3JhdG9ycyB0byBhIHByb3BlcnR5IG9mIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIGRlY29yYXRvcnMgQW4gYXJyYXkgb2YgZGVjb3JhdG9ycy5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSB0byBkZWNvcmF0ZS5cbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIHRhcmdldCBrZXkuXG4gICAgICAgICAqIEByZW1hcmtzIERlY29yYXRvcnMgYXJlIGFwcGxpZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgRXhhbXBsZSA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcbiAgICAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcbiAgICAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKSkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKSkpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGF0dHJpYnV0ZXMpICYmICFJc1VuZGVmaW5lZChhdHRyaWJ1dGVzKSAmJiAhSXNOdWxsKGF0dHJpYnV0ZXMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKElzTnVsbChhdHRyaWJ1dGVzKSlcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZGVjb3JhdGVcIiwgZGVjb3JhdGUpO1xuICAgICAgICAvLyA0LjEuMiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRlZmF1bHQgbWV0YWRhdGEgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCBvbiBhIGNsYXNzLCBjbGFzcyBtZW1iZXIsIG9yIHBhcmFtZXRlci5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IFRoZSBrZXkgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgVGhlIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXG4gICAgICAgICAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcmVtYXJrc1xuICAgICAgICAgKiBJZiBgbWV0YWRhdGFLZXlgIGlzIGFscmVhZHkgZGVmaW5lZCBmb3IgdGhlIHRhcmdldCBhbmQgdGFyZ2V0IGtleSwgdGhlXG4gICAgICAgICAqIG1ldGFkYXRhVmFsdWUgZm9yIHRoYXQga2V5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yLCBUeXBlU2NyaXB0IG9ubHkpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUsIFR5cGVTY3JpcHQgb25seSlcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJtZXRhZGF0YVwiLCBtZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgYSB1bmlxdWUgbWV0YWRhdGEgZW50cnkgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBBIHZhbHVlIHRoYXQgY29udGFpbnMgYXR0YWNoZWQgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gZGVjb3JhdG9yIGZhY3RvcnkgYXMgbWV0YWRhdGEtcHJvZHVjaW5nIGFubm90YXRpb24uXG4gICAgICAgICAqICAgICBmdW5jdGlvbiBNeUFubm90YXRpb24ob3B0aW9ucyk6IERlY29yYXRvciB7XG4gICAgICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJkZWZpbmVNZXRhZGF0YVwiLCBkZWZpbmVNZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4gaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGtleSB3YXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluOyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNNZXRhZGF0YVwiLCBoYXNNZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0YXJnZXQgb2JqZWN0IGhhcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Q7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImhhc093bk1ldGFkYXRhXCIsIGhhc093bk1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEga2V5IGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFcIiwgZ2V0TWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEga2V5IGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFcIiwgZ2V0T3duTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHVuaXF1ZSBtZXRhZGF0YSBrZXlzLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeU1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhS2V5c1wiLCBnZXRNZXRhZGF0YUtleXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFLZXlzXCIsIGdldE93bk1ldGFkYXRhS2V5cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIHRoZSBtZXRhZGF0YSBlbnRyeSBmcm9tIHRoZSB0YXJnZXQgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGtleS5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGVudHJ5IHdhcyBmb3VuZCBhbmQgZGVsZXRlZDsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghbWV0YWRhdGFNYXAuZGVsZXRlKG1ldGFkYXRhS2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFNYXAuc2l6ZSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLmRlbGV0ZShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TWV0YWRhdGEuc2l6ZSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWxldGUodGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZGVsZXRlTWV0YWRhdGFcIiwgZGVsZXRlTWV0YWRhdGEpO1xuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChkZWNvcmF0ZWQpICYmICFJc051bGwoZGVjb3JhdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZGVjb3JhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChkZWNvcmF0ZWQpICYmICFJc051bGwoZGVjb3JhdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBkZWNvcmF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBDcmVhdGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IE1ldGFkYXRhLmdldChPKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuc2V0KE8sIHRhcmdldE1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcCA9IG5ldyBfTWFwKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEuc2V0KFAsIG1ldGFkYXRhTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YU1hcDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzbWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgaWYgKGhhc093bilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMi4xIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFRvQm9vbGVhbihtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMy4xIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0bWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgaWYgKGhhc093bilcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRvd25tZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjUuMSBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyB0cnVlKTtcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjYuMSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeU1ldGFkYXRhS2V5cyhPLCBQKSB7XG4gICAgICAgICAgICB2YXIgb3duS2V5cyA9IE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xuICAgICAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICAgICAgICAgICAgaWYgKHBhcmVudEtleXMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XG4gICAgICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50S2V5cztcbiAgICAgICAgICAgIHZhciBzZXQgPSBuZXcgX1NldCgpO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgb3duS2V5c18xID0gb3duS2V5czsgX2kgPCBvd25LZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG93bktleXNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleSkge1xuICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHBhcmVudEtleXNfMVtfYV07XG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleSkge1xuICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS43LjEgT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlvd25tZXRhZGF0YWtleXNcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICAgICAgdmFyIGtleXNPYmogPSBtZXRhZGF0YU1hcC5rZXlzKCk7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IGs7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzW2tdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgSXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA2IEVDTUFTY3JpcHQgRGF0YSBUeXAwZXMgYW5kIFZhbHVlc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xuICAgICAgICBmdW5jdGlvbiBUeXBlKHgpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOiByZXR1cm4gMCAvKiBVbmRlZmluZWQgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiAzIC8qIFN0cmluZyAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6IHJldHVybiA0IC8qIFN5bWJvbCAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHJldHVybiB4ID09PSBudWxsID8gMSAvKiBOdWxsICovIDogNiAvKiBPYmplY3QgKi87XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYgLyogT2JqZWN0ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS4xIFRoZSBVbmRlZmluZWQgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzVW5kZWZpbmVkKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjIgVGhlIE51bGwgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLW51bGwtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc051bGwoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtc3ltYm9sLXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNTeW1ib2woeCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS43IFRoZSBPYmplY3QgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc09iamVjdCh4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgPyB4ICE9PSBudWxsIDogdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEgVHlwZSBDb252ZXJzaW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGUtY29udmVyc2lvblxuICAgICAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbiAgICAgICAgZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogVW5kZWZpbmVkICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIE51bGwgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhpbnQgPSBQcmVmZXJyZWRUeXBlID09PSAzIC8qIFN0cmluZyAqLyA/IFwic3RyaW5nXCIgOiBQcmVmZXJyZWRUeXBlID09PSA1IC8qIE51bWJlciAqLyA/IFwibnVtYmVyXCIgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChleG90aWNUb1ByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG4gICAgICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09IFwiZGVmYXVsdFwiID8gXCJudW1iZXJcIiA6IGhpbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludCkge1xuICAgICAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMSA9IE8udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSBPLnZhbHVlT2Y7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzIuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLXRvYm9vbGVhblxuICAgICAgICBmdW5jdGlvbiBUb0Jvb2xlYW4oYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xMiBUb1N0cmluZyhhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcbiAgICAgICAgZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgYXJndW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjE0IFRvUHJvcGVydHlLZXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbiAgICAgICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IFRvUHJpbWl0aXZlKGFyZ3VtZW50LCAzIC8qIFN0cmluZyAqLyk7XG4gICAgICAgICAgICBpZiAoSXNTeW1ib2woa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIFRvU3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZXN0aW5nLWFuZC1jb21wYXJpc29uLW9wZXJhdGlvbnNcbiAgICAgICAgLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxuICAgICAgICBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50IGluc3RhbmNlb2YgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuMyBJc0NhbGxhYmxlKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG4gICAgICAgIGZ1bmN0aW9uIElzQ2FsbGFibGUoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuNCBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG4gICAgICAgIGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMi43IElzUHJvcGVydHlLZXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcbiAgICAgICAgZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChUeXBlKGFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA3LjMgT3BlcmF0aW9ucyBvbiBPYmplY3RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xuICAgICAgICAvLyA3LjMuOSBHZXRNZXRob2QoViwgUClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IFZbUF07XG4gICAgICAgICAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkIHx8IGZ1bmMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghSXNDYWxsYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQgT3BlcmF0aW9ucyBvbiBJdGVyYXRvciBPYmplY3RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xuICAgICAgICBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmopIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCBpdGVyYXRvclN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIGZyb20gQ2FsbFxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbWV0aG9kLmNhbGwob2JqKTtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNCBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtaXRlcmF0b3J2YWx1ZVxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JzdGVwXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU3RlcChpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IGZhbHNlIDogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yY2xvc2VcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JDbG9zZShpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgIGYuY2FsbChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOS4xIE9yZGluYXJ5IE9iamVjdCBJbnRlcm5hbCBNZXRob2RzIGFuZCBJbnRlcm5hbCBTbG90c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcbiAgICAgICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5Z2V0cHJvdG90eXBlb2ZcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIE8gIT09IFwiZnVuY3Rpb25cIiB8fCBPID09PSBmdW5jdGlvblByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxuICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3Rvci4gQ29tcGF0aWJsZSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgIC8vIG11c3QgZWl0aGVyIHNldCBfX3Byb3RvX18gb24gYSBzdWJjbGFzcyBjb25zdHJ1Y3RvciB0byB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XG4gICAgICAgICAgICAvLyBwb2ludHMgYmFjayB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBGdW5jdGlvbi5bW1Byb3RvdHlwZV1dLCB0aGVuIHRoaXMgaXMgZGVmaW5hdGVseSBpbmhlcml0ZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKHByb3RvICE9PSBmdW5jdGlvblByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBPLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGVQcm90byA9IHByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKTtcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25zdHJ1Y3RvciB3YXMgbm90IGEgZnVuY3Rpb24sIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTylcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5haXZlIE1hcCBzaGltXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZU1hcFBvbHlmaWxsKCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlU2VudGluZWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XG4gICAgICAgICAgICB2YXIgTWFwSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTWFwSXRlcmF0b3Ioa2V5cywgdmFsdWVzLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKHRoaXMuX2tleXNbaW5kZXhdLCB0aGlzLl92YWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTWFwKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7IH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpID49IDA7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2tleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXNbaSAtIDFdID0gdGhpcy5fa2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaSAtIDFdID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHRoaXMuX2NhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0S2V5KTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldFZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRFbnRyeSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAoa2V5LCBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlS2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2YodGhpcy5fY2FjaGVLZXkgPSBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUluZGV4IDwgMCAmJiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXA7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0S2V5KGtleSwgXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShfLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEVudHJ5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5haXZlIFNldCBzaGltXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVNldFBvbHlmaWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBfTWFwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5zaXplOyB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5zZXQodmFsdWUsIHZhbHVlKSwgdGhpczsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZSh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC52YWx1ZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCkge1xuICAgICAgICAgICAgdmFyIFVVSURfU0laRSA9IDE2O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJvb3RLZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcbiAgICAgICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmhhcyh0YWJsZSwgdGhpcy5fa2V5KSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuZ2V0KHRhYmxlLCB0aGlzLl9rZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZVt0aGlzLl9rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IGRlbGV0ZSB0YWJsZVt0aGlzLl9rZXldIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbm90IGEgcmVhbCBjbGVhciwganVzdCBtYWtlcyB0aGUgcHJldmlvdXMgZGF0YSB1bnJlYWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBXZWFrTWFwO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVuaXF1ZUtleSgpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFwiQEBXZWFrTWFwQEBcIiArIENyZWF0ZVVVSUQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoSGFzaE1hcC5oYXMoa2V5cywga2V5KSk7XG4gICAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRhcmdldCwgcm9vdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCByb290S2V5LCB7IHZhbHVlOiBIYXNoTWFwLmNyZWF0ZSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Jvb3RLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gRmlsbFJhbmRvbUJ5dGVzKGJ1ZmZlciwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMHhmZiB8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEdlblJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc0NyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHNpemUpLCBzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgQXJyYXkoc2l6ZSksIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVVVJRCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEdlblJhbmRvbUJ5dGVzKFVVSURfU0laRSk7XG4gICAgICAgICAgICAgICAgLy8gbWFyayBhcyByYW5kb20gLSBSRkMgNDEyMiDCpyA0LjRcbiAgICAgICAgICAgICAgICBkYXRhWzZdID0gZGF0YVs2XSAmIDB4NGYgfCAweDQwO1xuICAgICAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdICYgMHhiZiB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgVVVJRF9TSVpFOyArK29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gNCB8fCBvZmZzZXQgPT09IDYgfHwgb2Zmc2V0ID09PSA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYnl0ZS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1c2VzIGEgaGV1cmlzdGljIHVzZWQgYnkgdjggYW5kIGNoYWtyYSB0byBmb3JjZSBhbiBvYmplY3QgaW50byBkaWN0aW9uYXJ5IG1vZGUuXG4gICAgICAgIGZ1bmN0aW9uIE1ha2VEaWN0aW9uYXJ5KG9iaikge1xuICAgICAgICAgICAgb2JqLl9fID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGVsZXRlIG9iai5fXztcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKFJlZmxlY3QgfHwgKFJlZmxlY3QgPSB7fSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2FueS1wcm9taXNlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBmb3JtYXQgPSB1dGlsLmZvcm1hdDtcblxuZnVuY3Rpb24gVGltZW91dEVycm9yKG1lc3NhZ2UsIGVycikge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBUaW1lb3V0RXJyb3IpO1xuICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5wcmV2aW91cyA9IGVycjtcbn1cblxudXRpbC5pbmhlcml0cyhUaW1lb3V0RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhtYXRjaCwgZXJyKSB7XG4gIGlmIChtYXRjaCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIG1hdGNoKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gISFtYXRjaChlcnIpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2ggPT09IGVyci50b1N0cmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG1hdGNoID09PSBlcnIubWVzc2FnZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICYmIChtYXRjaC50ZXN0KGVyci5tZXNzYWdlKSB8fCBtYXRjaC50ZXN0KGVyci50b1N0cmluZygpKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmV0cnlBc1Byb21pc2VkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAncmV0cnktYXMtcHJvbWlzZWQgbXVzdCBiZSBwYXNzZWQgYSBjYWxsYmFjayBhbmQgYSBvcHRpb25zIHNldCBvciBhIG51bWJlcidcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtYXg6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLy8gU3VwZXIgY2hlYXAgY2xvbmVcbiAgb3B0aW9ucyA9IHtcbiAgICAkY3VycmVudDogb3B0aW9ucy4kY3VycmVudCB8fCAxLFxuICAgIG1heDogb3B0aW9ucy5tYXgsXG4gICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IHVuZGVmaW5lZCxcbiAgICBtYXRjaDogb3B0aW9ucy5tYXRjaCB8fCBbXSxcbiAgICBiYWNrb2ZmQmFzZTogb3B0aW9ucy5iYWNrb2ZmQmFzZSA9PT0gdW5kZWZpbmVkID8gMTAwIDogb3B0aW9ucy5iYWNrb2ZmQmFzZSxcbiAgICBiYWNrb2ZmRXhwb25lbnQ6IG9wdGlvbnMuYmFja29mZkV4cG9uZW50IHx8IDEuMSxcbiAgICByZXBvcnQ6IG9wdGlvbnMucmVwb3J0IHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgIG5hbWU6IG9wdGlvbnMubmFtZSB8fCBjYWxsYmFjay5uYW1lIHx8ICd1bmtub3duJ1xuICB9O1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLm1hdGNoKSkgb3B0aW9ucy5tYXRjaCA9IFtvcHRpb25zLm1hdGNoXTtcbiAgb3B0aW9ucy5yZXBvcnQoJ1RyeWluZyAnICsgb3B0aW9ucy5uYW1lICsgJyAjJyArIG9wdGlvbnMuJGN1cnJlbnQgKyAnIGF0ICcgKyBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpLCBvcHRpb25zKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRpbWVvdXQsIGJhY2tvZmZUaW1lb3V0LCBsYXN0RXJyb3I7XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJhY2tvZmZUaW1lb3V0KSBjbGVhclRpbWVvdXQoYmFja29mZlRpbWVvdXQpO1xuICAgICAgICByZWplY3QobmV3IFRpbWVvdXRFcnJvcihvcHRpb25zLm5hbWUgKyAnIHRpbWVkIG91dCcsIGxhc3RFcnJvcikpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICB9XG5cbiAgICBQcm9taXNlLnJlc29sdmUoY2FsbGJhY2soeyBjdXJyZW50OiBvcHRpb25zLiRjdXJyZW50IH0pKVxuICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBpZiAoYmFja29mZlRpbWVvdXQpIGNsZWFyVGltZW91dChiYWNrb2ZmVGltZW91dCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBpZiAoYmFja29mZlRpbWVvdXQpIGNsZWFyVGltZW91dChiYWNrb2ZmVGltZW91dCk7XG5cbiAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICBvcHRpb25zLnJlcG9ydCgoZXJyICYmIGVyci50b1N0cmluZygpKSB8fCBlcnIsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNob3VsZCBub3QgcmV0cnkgaWYgbWF4IGhhcyBiZWVuIHJlYWNoZWRcbiAgICAgICAgdmFyIHNob3VsZFJldHJ5ID0gb3B0aW9ucy4kY3VycmVudCA8IG9wdGlvbnMubWF4O1xuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIHNob3VsZFJldHJ5ID0gb3B0aW9ucy5tYXRjaC5sZW5ndGggPT09IDAgfHwgb3B0aW9ucy5tYXRjaC5zb21lKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVzKG1hdGNoLCBlcnIpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KSByZXR1cm4gcmVqZWN0KGVycik7XG5cbiAgICAgICAgdmFyIHJldHJ5RGVsYXkgPSBNYXRoLnBvdyhcbiAgICAgICAgICBvcHRpb25zLmJhY2tvZmZCYXNlLFxuICAgICAgICAgIE1hdGgucG93KG9wdGlvbnMuYmFja29mZkV4cG9uZW50LCBvcHRpb25zLiRjdXJyZW50IC0gMSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEbyBzb21lIGFjY291bnRpbmdcbiAgICAgICAgb3B0aW9ucy4kY3VycmVudCsrO1xuICAgICAgICBvcHRpb25zLnJlcG9ydChmb3JtYXQoJ1JldHJ5aW5nICVzICglcyknLCBvcHRpb25zLm5hbWUsIG9wdGlvbnMuJGN1cnJlbnQpLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAocmV0cnlEZWxheSkge1xuICAgICAgICAgIC8vIFVzZSBiYWNrb2ZmIGZ1bmN0aW9uIHRvIGVhc2UgcmV0cnkgcmF0ZVxuICAgICAgICAgIG9wdGlvbnMucmVwb3J0KGZvcm1hdCgnRGVsYXlpbmcgcmV0cnkgb2YgJXMgYnkgJXMnLCBvcHRpb25zLm5hbWUsIHJldHJ5RGVsYXkpLCBvcHRpb25zKTtcbiAgICAgICAgICBiYWNrb2ZmVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXRyeUFzUHJvbWlzZWQoY2FsbGJhY2ssIG9wdGlvbnMpXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0sIHJldHJ5RGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHJ5QXNQcm9taXNlZChjYWxsYmFjaywgb3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuIiwiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gICAgY29uc3QgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcblxuICAgIHJldHVybiAoXG4gICAgICBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fFxuICAgICAgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAocmFuZ2UgPT4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWRcblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBjb25zdCBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2UgPyBjb21wID0+ICEhY29tcC5tYXRjaChjb21wUmUpIDogKCkgPT4gdHJ1ZSlcbiAgICAgIC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGwgPSByYW5nZUxpc3QubGVuZ3RoXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcmFuZ2VMaXN0KSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKVxuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpXG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2Vcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKVxuICAgICAgICBwciA9ICctMCdcblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgaW5jIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQoKVxuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUxvb3NlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PlxuICBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSlcbiAgICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yKVxuICAgIGNvbnN0IGhhc1ByZSA9IHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgY29uc3QgcHJlZml4ID0gaGFzUHJlID8gJ3ByZScgOiAnJ1xuICAgIGNvbnN0IGRlZmF1bHRSZXN1bHQgPSBoYXNQcmUgPyAncHJlcmVsZWFzZScgOiAnJ1xuICAgIGZvciAoY29uc3Qga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsga2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQgLy8gbWF5IGJlIHVuZGVmaW5lZFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iLCJjb25zdCB7TUFYX0xFTkdUSH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXVxuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXRjaCA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGIsIGEsIGxvb3NlKVxubW9kdWxlLmV4cG9ydHMgPSByY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSBzb3J0XG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKS5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBTZW1WZXI6IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKSxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykucmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcGFyc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJyksXG4gIHZhbGlkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpLFxuICBjbGVhbjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKSxcbiAgaW5jOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKSxcbiAgZGlmZjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpLFxuICBtYWpvcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKSxcbiAgbWlub3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJyksXG4gIHBhdGNoOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpLFxuICBwcmVyZWxlYXNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJyksXG4gIGNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKSxcbiAgcmNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJyksXG4gIGNvbXBhcmVMb29zZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpLFxuICBjb21wYXJlQnVpbGQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpLFxuICByc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JyksXG4gIGx0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpLFxuICBlcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKSxcbiAgbmVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKSxcbiAgbHRlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKSxcbiAgY21wOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKSxcbiAgY29lcmNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKSxcbiAgQ29tcGFyYXRvcjogcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKSxcbiAgUmFuZ2U6IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpLFxuICBzYXRpc2ZpZXM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpLFxuICB0b0NvbXBhcmF0b3JzOiByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpLFxuICBtYXhTYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpLFxuICBtaW5TYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpLFxuICBtaW5WZXJzaW9uOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpLFxuICB2YWxpZFJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpLFxuICBvdXRzaWRlOiByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJyksXG4gIGd0cjogcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJyksXG4gIGx0cjogcmVxdWlyZSgnLi9yYW5nZXMvbHRyJyksXG4gIGludGVyc2VjdHM6IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKSxcbiAgc2ltcGxpZnlSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKSxcbiAgc3Vic2V0OiByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKSxcbn1cbiIsIi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTZcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyc1xufVxuIiwiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dCBzbyB3ZSBhbHdheXMgZ2V0IGEgY29uc2lzdGVudFxuLy8gb2JqIHdpdGgga2V5cyBpbiBhIGNvbnNpc3RlbnQgb3JkZXIuXG5jb25zdCBvcHRzID0gWydpbmNsdWRlUHJlcmVsZWFzZScsICdsb29zZScsICdydGwnXVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PlxuICAhb3B0aW9ucyA/IHt9XG4gIDogdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnID8geyBsb29zZTogdHJ1ZSB9XG4gIDogb3B0cy5maWx0ZXIoayA9PiBvcHRpb25zW2tdKS5yZWR1Y2UoKG9wdGlvbnMsIGspID0+IHtcbiAgICBvcHRpb25zW2tdID0gdHJ1ZVxuICAgIHJldHVybiBvcHRpb25zXG4gIH0sIHt9KVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpXG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7QU5ZfSA9IENvbXBhcmF0b3JcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0ZScpXG5cbmNvbnN0IG91dHNpZGUgPSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpID0+IHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgbGV0IGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzZmllcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IGhpZ2ggPSBudWxsXG4gICAgbGV0IGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRzaWRlXG4iLCIvLyBnaXZlbiBhIHNldCBvZiB2ZXJzaW9ucyBhbmQgYSByYW5nZSwgY3JlYXRlIGEgXCJzaW1wbGlmaWVkXCIgcmFuZ2Vcbi8vIHRoYXQgaW5jbHVkZXMgdGhlIHNhbWUgdmVyc2lvbnMgdGhhdCB0aGUgb3JpZ2luYWwgcmFuZ2UgZG9lc1xuLy8gSWYgdGhlIG9yaWdpbmFsIHJhbmdlIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2ltcGxpZmllZCBvbmUsIHJldHVybiB0aGF0LlxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxubW9kdWxlLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNldCA9IFtdXG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIW1pbilcbiAgICAgICAgbWluID0gdmVyc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbbWluLCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBtaW4gPSBudWxsXG4gICAgfVxuICB9XG4gIGlmIChtaW4pXG4gICAgc2V0LnB1c2goW21pbiwgbnVsbF0pXG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heClcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICBlbHNlIGlmICghbWF4KVxuICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YClcbiAgICBlbHNlIGlmIChtaW4gPT09IHZbMF0pXG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIGVsc2VcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICB9XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSByYW5nZXMuam9pbignIHx8ICcpXG4gIGNvbnN0IG9yaWdpbmFsID0gdHlwZW9mIHJhbmdlLnJhdyA9PT0gJ3N0cmluZycgPyByYW5nZS5yYXcgOiBTdHJpbmcocmFuZ2UpXG4gIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZVxufVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlLmpzJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3IuanMnKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcblxuLy8gQ29tcGxleCByYW5nZSBgcjEgfHwgcjIgfHwgLi4uYCBpcyBhIHN1YnNldCBvZiBgUjEgfHwgUjIgfHwgLi4uYCBpZmY6XG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIGlzIGEgbnVsbCBzZXQsIE9SXG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIHdoaWNoIGlzIG5vdCBhIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mXG4vLyAgIHNvbWUgYFIxLCBSMiwgLi4uYFxuLy9cbi8vIFNpbXBsZSByYW5nZSBgYzEgYzIgLi4uYCBpcyBhIHN1YnNldCBvZiBzaW1wbGUgcmFuZ2UgYEMxIEMyIC4uLmAgaWZmOlxuLy8gLSBJZiBjIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvciwgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIGZhbHNlXG4vLyAgIC0gZWxzZSByZXBsYWNlIGMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gdHJ1ZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBDIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gTGV0IEVRIGJlIHRoZSBzZXQgb2YgPSBjb21wYXJhdG9ycyBpbiBjXG4vLyAtIElmIEVRIGlzIG1vcmUgdGhhbiBvbmUsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gTGV0IEdUIGJlIHRoZSBoaWdoZXN0ID4gb3IgPj0gY29tcGFyYXRvciBpbiBjXG4vLyAtIExldCBMVCBiZSB0aGUgbG93ZXN0IDwgb3IgPD0gY29tcGFyYXRvciBpbiBjXG4vLyAtIElmIEdUIGFuZCBMVCwgYW5kIEdULnNlbXZlciA+IExULnNlbXZlciwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBJZiBhbnkgQyBpcyBhID0gcmFuZ2UsIGFuZCBHVCBvciBMVCBhcmUgc2V0LCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgRVFcbi8vICAgLSBJZiBHVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgR1QsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBMVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgTFQsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBFUSBzYXRpc2ZpZXMgZXZlcnkgQywgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIHJldHVybiBmYWxzZVxuLy8gLSBJZiBHVFxuLy8gICAtIElmIEdULnNlbXZlciBpcyBsb3dlciB0aGFuIGFueSA+IG9yID49IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1QgaXMgPj0sIGFuZCBHVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIEdULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIExUXG4vLyAgIC0gSWYgTFQuc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBhbnkgPCBvciA8PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIExUIGlzIDw9LCBhbmQgTFQuc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBMVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBFbHNlIHJldHVybiB0cnVlXG5cbmNvbnN0IHN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1YilcbiAgICAgICAgY29udGludWUgT1VURVJcbiAgICB9XG4gICAgLy8gdGhlIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mIGV2ZXJ5dGhpbmcsIGJ1dCBudWxsIHNpbXBsZSByYW5nZXMgaW5cbiAgICAvLyBhIGNvbXBsZXggcmFuZ2Ugc2hvdWxkIGJlIGlnbm9yZWQuICBzbyBpZiB3ZSBzYXcgYSBub24tbnVsbCByYW5nZSxcbiAgICAvLyB0aGVuIHdlIGtub3cgdGhpcyBpc24ndCBhIHN1YnNldCwgYnV0IGlmIEVWRVJZIHNpbXBsZSByYW5nZSB3YXMgbnVsbCxcbiAgICAvLyB0aGVuIGl0IGlzIGEgc3Vic2V0LlxuICAgIGlmIChzYXdOb25OdWxsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpIF1cbiAgICBlbHNlXG4gICAgICBzdWIgPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJykgXVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGRvbSA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpXG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKVxuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIGVsc2VcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSlcbiAgICByZXR1cm4gbnVsbFxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMClcbiAgICAgIHJldHVybiBudWxsXG4gICAgZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSlcbiAgICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKVxuICAgIHJldHVybiBiXG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWdncmVnYXRlRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBBZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBZ2dyZWdhdGVFcnJvcic7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEFnZ3JlZ2F0ZUVycm9yIG9mOlxcbiR7dGhpcy5lcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKGVycm9yKSA9PiBlcnJvciA9PT0gdGhpc1xuICAgICAgICAgICAgPyAnW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXSdcbiAgICAgICAgICAgIDogZXJyb3IgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9cXG4kLywgJycpLnJlcGxhY2UoL14vZ20sICcgICcpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL14vZ20sICcgICAgJykuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpfVxcbmA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydHMuQWdncmVnYXRlRXJyb3IgPSBBZ2dyZWdhdGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFnZ3JlZ2F0ZUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZlcnJlZCA9IHZvaWQgMDtcbmNvbnN0IFRpbWVvdXRFcnJvcl8xID0gcmVxdWlyZShcIi4vVGltZW91dEVycm9yXCIpO1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdpc3RlclRpbWVvdXQodGltZW91dEluTWlsbGlzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fdGltZW91dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBUaW1lb3V0RXJyb3JfMS5UaW1lb3V0RXJyb3IoJ09wZXJhdGlvbiB0aW1lb3V0JykpO1xuICAgICAgICB9LCB0aW1lb3V0SW5NaWxsaXMpO1xuICAgIH1cbiAgICBfY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB9XG4gICAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJlamVjdChlcnJvcikge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZlcnJlZCA9IERlZmVycmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9vbCA9IHZvaWQgMDtcbmNvbnN0IERlZmVycmVkXzEgPSByZXF1aXJlKFwiLi9EZWZlcnJlZFwiKTtcbmNvbnN0IEFnZ3JlZ2F0ZUVycm9yXzEgPSByZXF1aXJlKFwiLi9BZ2dyZWdhdGVFcnJvclwiKTtcbmNsYXNzIFBvb2wge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5sb2cgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFmYWN0b3J5LmNyZWF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGUgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZhY3RvcnkuZGVzdHJveSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0cm95IGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmYWN0b3J5LnZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRlIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5Lm1pbiAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIGZhY3RvcnkubWluIDwgMCB8fFxuICAgICAgICAgICAgZmFjdG9yeS5taW4gIT09IE1hdGgucm91bmQoZmFjdG9yeS5taW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbiBtdXN0IGJlIGFuIGludGVnZXIgPj0gMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeS5tYXggIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBmYWN0b3J5Lm1heCA8PSAwIHx8XG4gICAgICAgICAgICBmYWN0b3J5Lm1heCAhPT0gTWF0aC5yb3VuZChmYWN0b3J5Lm1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IG11c3QgYmUgYW4gaW50ZWdlciA+IDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFjdG9yeS5taW4gPiBmYWN0b3J5Lm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXggaXMgc21hbGxlciB0aGFuIG1pbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWN0b3J5Lm1heFVzZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKHR5cGVvZiBmYWN0b3J5Lm1heFVzZXMgIT09ICdudW1iZXInIHx8IGZhY3RvcnkubWF4VXNlcyA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFVzZXMgbXVzdCBiZSBhbiBpbnRlZ2VyID49IDAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TWlsbGlzID0gZmFjdG9yeS5pZGxlVGltZW91dE1pbGxpcyB8fCAzMDAwMDtcbiAgICAgICAgdGhpcy5hY3F1aXJlVGltZW91dE1pbGxpcyA9IGZhY3RvcnkuYWNxdWlyZVRpbWVvdXRNaWxsaXMgfHwgMzAwMDA7XG4gICAgICAgIHRoaXMucmVhcEludGVydmFsTWlsbGlzID0gZmFjdG9yeS5yZWFwSW50ZXJ2YWxNaWxsaXMgfHwgMTAwMDtcbiAgICAgICAgdGhpcy5tYXhVc2VzUGVyUmVzb3VyY2UgPSBmYWN0b3J5Lm1heFVzZXMgfHwgSW5maW5pdHk7XG4gICAgICAgIHRoaXMubG9nID0gZmFjdG9yeS5sb2cgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdBY3F1aXJlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pblVzZU9iamVjdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlT2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLl9yZW1vdmVJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5uYW1lO1xuICAgIH1cbiAgICBnZXQgYXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCB1c2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luVXNlT2JqZWN0cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCB3YWl0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5Lm1heDtcbiAgICB9XG4gICAgZ2V0IG1pblNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5Lm1pbjtcbiAgICB9XG4gICAgX2xvZyhtZXNzYWdlLCBsZXZlbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhtZXNzYWdlLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sb2cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2xldmVsLnRvVXBwZXJDYXNlKCl9IHBvb2wgJHt0aGlzLm5hbWUgfHwgJyd9IC0gJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1vdmVJZGxlKCkge1xuICAgICAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZSA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhSZW1vdmFibGUgPSB0aGlzLnNpemUgLSB0aGlzLm1pblNpemU7XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9yZW1vdmVJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdmFpbGFibGUgJiYgbWF4UmVtb3ZhYmxlID4gdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzW2ldLnRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAobm93ID49IHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ3JlbW92ZUlkbGUoKSBkZXN0cm95aW5nIG9iaiAtIG5vdzonICsgbm93ICsgJyB0aW1lb3V0OicgKyB0aW1lb3V0LCAndmVyYm9zZScpO1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2godGhpcy5fYXZhaWxhYmxlT2JqZWN0c1tpXS5yZXNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaCh0aGlzLmRlc3Ryb3ksIHRoaXMpO1xuICAgICAgICBhdmFpbGFibGUgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgaWYgKGF2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygndGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGg9JyArIGF2YWlsYWJsZSwgJ3ZlcmJvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVtb3ZlSWRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdyZW1vdmVJZGxlKCkgYWxsIG9iamVjdHMgcmVtb3ZlZCcsICd2ZXJib3NlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NjaGVkdWxlUmVtb3ZlSWRsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW1vdmVJZGxlU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGUoKTtcbiAgICAgICAgICAgIH0sIHRoaXMucmVhcEludGVydmFsTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGlzcGVuc2UoKSB7XG4gICAgICAgIGxldCB3cmFwcGVkUmVzb3VyY2UgPSBudWxsO1xuICAgICAgICBjb25zdCB3YWl0aW5nQ291bnQgPSB0aGlzLl9wZW5kaW5nQWNxdWlyZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9sb2coYGRpc3BlbnNlKCkgY2xpZW50cz0ke3dhaXRpbmdDb3VudH0gYXZhaWxhYmxlPSR7dGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGh9YCwgJ2luZm8nKTtcbiAgICAgICAgaWYgKHdhaXRpbmdDb3VudCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ2Rpc3BlbnNlKCkgLSByZXVzaW5nIG9iaicsICd2ZXJib3NlJyk7XG4gICAgICAgICAgICB3cmFwcGVkUmVzb3VyY2UgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzW3RoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZhY3RvcnkudmFsaWRhdGUod3JhcHBlZFJlc291cmNlLnJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJlc291cmNlVG9JblVzZU9iamVjdHMod3JhcHBlZFJlc291cmNlLnJlc291cmNlLCB3cmFwcGVkUmVzb3VyY2UudXNlQ291bnQpO1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9wZW5kaW5nQWNxdWlyZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA8IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVzb3VyY2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlUmVzb3VyY2UoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ICs9IDE7XG4gICAgICAgIHRoaXMuX2xvZyhgY3JlYXRlUmVzb3VyY2UoKSAtIGNyZWF0aW5nIG9iaiAtIGNvdW50PSR7dGhpcy5zaXplfSBtaW49JHt0aGlzLm1pblNpemV9IG1heD0ke3RoaXMubWF4U2l6ZX1gLCAndmVyYm9zZScpO1xuICAgICAgICB0aGlzLl9mYWN0b3J5XG4gICAgICAgICAgICAuY3JlYXRlKClcbiAgICAgICAgICAgIC50aGVuKChyZXNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9wZW5kaW5nQWNxdWlyZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJlc291cmNlVG9JblVzZU9iamVjdHMocmVzb3VyY2UsIDApO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmVzb3VyY2VUb0F2YWlsYWJsZU9iamVjdHMocmVzb3VyY2UsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9wZW5kaW5nQWNxdWlyZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnQgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwZW5zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkUmVzb3VyY2VUb0F2YWlsYWJsZU9iamVjdHMocmVzb3VyY2UsIHVzZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRSZXNvdXJjZSA9IHtcbiAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgIHVzZUNvdW50OiB1c2VDb3VudCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IERhdGUubm93KCkgKyB0aGlzLmlkbGVUaW1lb3V0TWlsbGlzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVPYmplY3RzLnB1c2god3JhcHBlZFJlc291cmNlKTtcbiAgICAgICAgdGhpcy5fZGlzcGVuc2UoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZW1vdmVJZGxlKCk7XG4gICAgfVxuICAgIF9hZGRSZXNvdXJjZVRvSW5Vc2VPYmplY3RzKHJlc291cmNlLCB1c2VDb3VudCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkUmVzb3VyY2UgPSB7XG4gICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICAgICAgICB1c2VDb3VudDogdXNlQ291bnQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luVXNlT2JqZWN0cy5wdXNoKHdyYXBwZWRSZXNvdXJjZSk7XG4gICAgfVxuICAgIF9lbnN1cmVNaW5pbXVtKCkge1xuICAgICAgICBsZXQgaSwgZGlmZjtcbiAgICAgICAgaWYgKCF0aGlzLl9kcmFpbmluZyAmJiB0aGlzLnNpemUgPCB0aGlzLm1pblNpemUpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLm1pblNpemUgLSB0aGlzLnNpemU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVzb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fZHJhaW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3Bvb2wgaXMgZHJhaW5pbmcgYW5kIGNhbm5vdCBhY2NlcHQgd29yaycpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZF8xLkRlZmVycmVkKCk7XG4gICAgICAgIGRlZmVycmVkLnJlZ2lzdGVyVGltZW91dCh0aGlzLmFjcXVpcmVUaW1lb3V0TWlsbGlzLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQWNxdWlyZXMgPSB0aGlzLl9wZW5kaW5nQWNxdWlyZXMuZmlsdGVyKChwZW5kaW5nKSA9PiBwZW5kaW5nICE9PSBkZWZlcnJlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWNxdWlyZXMucHVzaChkZWZlcnJlZCk7XG4gICAgICAgIHRoaXMuX2Rpc3BlbnNlKCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgfVxuICAgIHJlbGVhc2UocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F2YWlsYWJsZU9iamVjdHMuc29tZSgocmVzb3VyY2VXaXRoVGltZW91dCkgPT4gcmVzb3VyY2VXaXRoVGltZW91dC5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ3JlbGVhc2UgY2FsbGVkIHR3aWNlIGZvciB0aGUgc2FtZSByZXNvdXJjZTogJyArIG5ldyBFcnJvcigpLnN0YWNrLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luVXNlT2JqZWN0cy5maW5kSW5kZXgoKHdyYXBwZWRSZXNvdXJjZSkgPT4gd3JhcHBlZFJlc291cmNlLnJlc291cmNlID09PSByZXNvdXJjZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnYXR0ZW1wdCB0byByZWxlYXNlIGFuIGludmFsaWQgcmVzb3VyY2U6ICcgKyBuZXcgRXJyb3IoKS5zdGFjaywgJ2Vycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZFJlc291cmNlID0gdGhpcy5faW5Vc2VPYmplY3RzW2luZGV4XTtcbiAgICAgICAgd3JhcHBlZFJlc291cmNlLnVzZUNvdW50ICs9IDE7XG4gICAgICAgIGlmICh3cmFwcGVkUmVzb3VyY2UudXNlQ291bnQgPj0gdGhpcy5tYXhVc2VzUGVyUmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygncmVsZWFzZSgpIGRlc3Ryb3lpbmcgb2JqIC0gdXNlQ291bnQ6JyArXG4gICAgICAgICAgICAgICAgd3JhcHBlZFJlc291cmNlLnVzZUNvdW50ICtcbiAgICAgICAgICAgICAgICAnIG1heFVzZXNQZXJSZXNvdXJjZTonICtcbiAgICAgICAgICAgICAgICB0aGlzLm1heFVzZXNQZXJSZXNvdXJjZSwgJ3ZlcmJvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGVuc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luVXNlT2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5fYWRkUmVzb3VyY2VUb0F2YWlsYWJsZU9iamVjdHMod3JhcHBlZFJlc291cmNlLnJlc291cmNlLCB3cmFwcGVkUmVzb3VyY2UudXNlQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3kocmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdXNpbmcgPSB0aGlzLl9pblVzZU9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlT2JqZWN0cyA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMuZmlsdGVyKChvYmplY3QpID0+IG9iamVjdC5yZXNvdXJjZSAhPT0gcmVzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5faW5Vc2VPYmplY3RzID0gdGhpcy5faW5Vc2VPYmplY3RzLmZpbHRlcigob2JqZWN0KSA9PiBvYmplY3QucmVzb3VyY2UgIT09IHJlc291cmNlKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGUgPT09IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdXNpbmcgPT09IHRoaXMuX2luVXNlT2JqZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVNaW5pbXVtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudCA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9mYWN0b3J5LmRlc3Ryb3kocmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlTWluaW11bSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIHRoaXMuX2xvZygnZHJhaW5pbmcnLCAnaW5mbycpO1xuICAgICAgICB0aGlzLl9kcmFpbmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0FjcXVpcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwZW5zZSgpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGVjayhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGggIT09IHRoaXMuX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gY2hlY2socmVzb2x2ZSkpO1xuICAgIH1cbiAgICBkZXN0cm95QWxsTm93KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdmb3JjZSBkZXN0cm95aW5nIGFsbCBvYmplY3RzJywgJ2luZm8nKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVJZGxlVGltZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5tYXAoKHJlc291cmNlKSA9PiByZXNvdXJjZS5yZXNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kZXN0cm95KHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnRXJyb3IgZGVzdHJveWluZyByZXNvdXJjZTogJyArIGV4LnN0YWNrLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcl8xLkFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9vbCA9IFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVvdXRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUaW1lb3V0RXJyb3JfMSA9IHJlcXVpcmUoXCIuL1RpbWVvdXRFcnJvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVvdXRFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVGltZW91dEVycm9yXzEuVGltZW91dEVycm9yOyB9IH0pO1xudmFyIFBvb2xfMSA9IHJlcXVpcmUoXCIuL1Bvb2xcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb29sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQb29sXzEuUG9vbDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmZlckFsaWFzID0gdm9pZCAwO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBQcmUgY29uZm9ybSBpbmNsdWRlcywgc28gdGhhdCBcImFzXCIgdmFsdWUgY2FuIGJlIGluZmVycmVkIGZyb20gc291cmNlXG4gKi9cbmZ1bmN0aW9uIGluZmVyQWxpYXMob3B0aW9ucywgc291cmNlKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvLyBpZiBpbmNsdWRlIGlzIG5vdCBhbiBhcnJheSwgd3JhcCBpbiBhbiBhcnJheVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGUpKSB7XG4gICAgICAgIG9wdGlvbnMuaW5jbHVkZSA9IFtvcHRpb25zLmluY2x1ZGVdO1xuICAgIH1cbiAgICBlbHNlIGlmICghb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbmNsdWRlO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLy8gY29udmVydCBhbGwgaW5jbHVkZWQgZWxlbWVudHMgdG8geyBtb2RlbDogTW9kZWwgfSBmb3JtXG4gICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlLm1hcCgoaW5jbHVkZSkgPT4ge1xuICAgICAgICBpbmNsdWRlID0gaW5mZXJBbGlhc0ZvckluY2x1ZGUoaW5jbHVkZSwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLmluZmVyQWxpYXMgPSBpbmZlckFsaWFzO1xuLyoqXG4gKiBQcmUgY29uZm9ybSBpbmNsdWRlLCBzbyB0aGF0IGFsaWFzIChcImFzXCIpIHZhbHVlIGNhbiBiZSBpbmZlcnJlZCBmcm9tIHNvdXJjZSBjbGFzc1xuICovXG5mdW5jdGlvbiBpbmZlckFsaWFzRm9ySW5jbHVkZShpbmNsdWRlLCBzb3VyY2UpIHtcbiAgICBjb25zdCBoYXNNb2RlbE9wdGlvbldpdGhvdXRBc09wdGlvbiA9ICEhKGluY2x1ZGUubW9kZWwgJiYgIWluY2x1ZGUuYXMpO1xuICAgIGNvbnN0IGhhc0luY2x1ZGVPcHRpb25zID0gISFpbmNsdWRlLmluY2x1ZGU7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvckZuID0gaW5jbHVkZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgIGlmIChpc0NvbnN0cnVjdG9yRm4gfHwgaGFzTW9kZWxPcHRpb25XaXRob3V0QXNPcHRpb24pIHtcbiAgICAgICAgaWYgKGlzQ29uc3RydWN0b3JGbikge1xuICAgICAgICAgICAgaW5jbHVkZSA9IHsgbW9kZWw6IGluY2x1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRQcm90b3R5cGUgPSBzb3VyY2UucHJvdG90eXBlIHx8IHNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVsYXRlZENsYXNzID0gaW5jbHVkZS5tb2RlbDtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25zID0gYXNzb2NpYXRpb25fc2VydmljZV8xLmdldEFzc29jaWF0aW9uc0J5UmVsYXRpb24odGFyZ2V0UHJvdG90eXBlLCByZWxhdGVkQ2xhc3MpO1xuICAgICAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxpYXMgY2Fubm90IGJlIGluZmVycmVkOiBcIiR7c291cmNlLm5hbWV9XCIgaGFzIG11bHRpcGxlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcmVsYXRpb25zIHdpdGggXCIke2luY2x1ZGUubW9kZWwubmFtZX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5jbHVkZS5hcyA9IGFzc29jaWF0aW9uc1swXS5nZXRBcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNDb25zdHJ1Y3RvckZuICYmIGhhc0luY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIGluY2x1ZGUgPSBpbmZlckFsaWFzKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5jbHVkZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsaWFzLWluZmVyZW5jZS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWxvbmdzVG9NYW55QXNzb2NpYXRpb24gPSB2b2lkIDA7XG5jb25zdCBiYXNlX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Jhc2UtYXNzb2NpYXRpb25cIik7XG5jb25zdCBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9zaGFyZWQvbW9kZWwtbm90LWluaXRpYWxpemVkLWVycm9yXCIpO1xuY29uc3QgZm9yZWlnbl9rZXlfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LXNlcnZpY2VcIik7XG5jb25zdCBhc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvblwiKTtcbmNsYXNzIEJlbG9uZ3NUb01hbnlBc3NvY2lhdGlvbiBleHRlbmRzIGJhc2VfYXNzb2NpYXRpb25fMS5CYXNlQXNzb2NpYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRBc3NvY2lhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uXzEuQXNzb2NpYXRpb24uQmVsb25nc1RvTWFueTtcbiAgICB9XG4gICAgZ2V0U2VxdWVsaXplT3B0aW9ucyhtb2RlbCwgc2VxdWVsaXplKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGVkQ2xhc3MgPSB0aGlzLmdldEFzc29jaWF0ZWRDbGFzcygpO1xuICAgICAgICBjb25zdCB0aHJvdWdoT3B0aW9ucyA9IHRoaXMuZ2V0VGhyb3VnaE9wdGlvbnMoc2VxdWVsaXplKTtcbiAgICAgICAgY29uc3QgdGhyb3VnaE1vZGVsID0gdHlwZW9mIHRocm91Z2hPcHRpb25zID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhyb3VnaE9wdGlvbnMubW9kZWwgIT09IFwic3RyaW5nXCIgPyB0aHJvdWdoT3B0aW9ucy5tb2RlbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucy50aHJvdWdoID0gdGhyb3VnaE9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMuZm9yZWlnbktleSA9IGZvcmVpZ25fa2V5X3NlcnZpY2VfMS5nZXRGb3JlaWduS2V5T3B0aW9ucyhtb2RlbCwgdGhyb3VnaE1vZGVsLCB0aGlzLm9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIG9wdGlvbnMub3RoZXJLZXkgPSBmb3JlaWduX2tleV9zZXJ2aWNlXzEuZ2V0Rm9yZWlnbktleU9wdGlvbnMoYXNzb2NpYXRlZENsYXNzLCB0aHJvdWdoTW9kZWwsIHRoaXMub3B0aW9ucy5vdGhlcktleSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRUaHJvdWdoT3B0aW9ucyhzZXF1ZWxpemUpIHtcbiAgICAgICAgY29uc3QgdGhyb3VnaCA9IHRoaXMub3B0aW9ucy50aHJvdWdoO1xuICAgICAgICBjb25zdCB0aHJvdWdoTW9kZWwgPSB0eXBlb2YgdGhyb3VnaCA9PT0gJ29iamVjdCcgPyB0aHJvdWdoLm1vZGVsIDogdGhyb3VnaDtcbiAgICAgICAgY29uc3QgdGhyb3VnaE9wdGlvbnMgPSB0eXBlb2YgdGhyb3VnaCA9PT0gJ29iamVjdCcgPyBPYmplY3QuYXNzaWduKHt9LCB0aHJvdWdoKSA6IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRocm91Z2hNb2RlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGhyb3VnaE1vZGVsQ2xhc3MgPSBzZXF1ZWxpemUubW9kZWwodGhyb3VnaE1vZGVsKCkpO1xuICAgICAgICAgICAgaWYgKCF0aHJvdWdoTW9kZWxDbGFzcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvcih0aHJvdWdoTW9kZWxDbGFzcywgJ0Fzc29jaWF0aW9uIGNhbm5vdCBiZSByZXNvbHZlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm91Z2hPcHRpb25zLm1vZGVsID0gdGhyb3VnaE1vZGVsQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3VnaE1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJvdWdoT3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkJlbG9uZ3NUb01hbnlBc3NvY2lhdGlvbiA9IEJlbG9uZ3NUb01hbnlBc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8tbWFueS1hc3NvY2lhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8tbWFueS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWxvbmdzVG9NYW55ID0gdm9pZCAwO1xuY29uc3QgYmVsb25nc190b19tYW55X2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb25cIik7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWxvbmdzVG9NYW55KGFzc29jaWF0ZWRDbGFzc0dldHRlciwgdGhyb3VnaE9yT3B0aW9ucywgZm9yZWlnbktleSwgb3RoZXJLZXkpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGxldCBvcHRpb25zID0geyBmb3JlaWduS2V5LCBvdGhlcktleSB9O1xuICAgICAgICBpZiAodHlwZW9mIHRocm91Z2hPck9wdGlvbnMgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhyb3VnaE9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy50aHJvdWdoID0gdGhyb3VnaE9yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aHJvdWdoT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuYXMpXG4gICAgICAgICAgICBvcHRpb25zLmFzID0gcHJvcGVydHlOYW1lO1xuICAgICAgICBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuYWRkQXNzb2NpYXRpb24odGFyZ2V0LCBuZXcgYmVsb25nc190b19tYW55X2Fzc29jaWF0aW9uXzEuQmVsb25nc1RvTWFueUFzc29jaWF0aW9uKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucykpO1xuICAgIH07XG59XG5leHBvcnRzLkJlbG9uZ3NUb01hbnkgPSBCZWxvbmdzVG9NYW55O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by1tYW55LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWxvbmdzVG9Bc3NvY2lhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGZvcmVpZ25fa2V5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb25cIik7XG5jbGFzcyBCZWxvbmdzVG9Bc3NvY2lhdGlvbiBleHRlbmRzIGJhc2VfYXNzb2NpYXRpb25fMS5CYXNlQXNzb2NpYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRBc3NvY2lhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uXzEuQXNzb2NpYXRpb24uQmVsb25nc1RvO1xuICAgIH1cbiAgICBnZXRTZXF1ZWxpemVPcHRpb25zKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0ZWRDbGFzcyA9IHRoaXMuZ2V0QXNzb2NpYXRlZENsYXNzKCk7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25LZXkgPSBmb3JlaWduX2tleV9zZXJ2aWNlXzEuZ2V0Rm9yZWlnbktleU9wdGlvbnMoYXNzb2NpYXRlZENsYXNzLCBtb2RlbCwgdGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IGZvcmVpZ25LZXkgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CZWxvbmdzVG9Bc3NvY2lhdGlvbiA9IEJlbG9uZ3NUb0Fzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by1hc3NvY2lhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVsb25nc1RvID0gdm9pZCAwO1xuY29uc3QgYmVsb25nc190b19hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4vYmVsb25ncy10by1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlbG9uZ3NUbyhhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnNPckZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMob3B0aW9uc09yRm9yZWlnbktleSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcylcbiAgICAgICAgICAgIG9wdGlvbnMuYXMgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIGFzc29jaWF0aW9uX3NlcnZpY2VfMS5hZGRBc3NvY2lhdGlvbih0YXJnZXQsIG5ldyBiZWxvbmdzX3RvX2Fzc29jaWF0aW9uXzEuQmVsb25nc1RvQXNzb2NpYXRpb24oYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuQmVsb25nc1RvID0gQmVsb25nc1RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Rm9yZWlnbktleXMgPSBleHBvcnRzLmFkZEZvcmVpZ25LZXkgPSBleHBvcnRzLmdldEZvcmVpZ25LZXlPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgRk9SRUlHTl9LRVlTX0tFWSA9ICdzZXF1ZWxpemU6Zm9yZWlnbktleXMnO1xuZnVuY3Rpb24gZ2V0Rm9yZWlnbktleU9wdGlvbnMocmVsYXRlZENsYXNzLCBjbGFzc1dpdGhGb3JlaWduS2V5LCBmb3JlaWduS2V5KSB7XG4gICAgbGV0IGZvcmVpZ25LZXlPcHRpb25zID0ge307XG4gICAgaWYgKHR5cGVvZiBmb3JlaWduS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JlaWduS2V5T3B0aW9ucy5uYW1lID0gZm9yZWlnbktleTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9yZWlnbktleSAmJiB0eXBlb2YgZm9yZWlnbktleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yZWlnbktleU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBmb3JlaWduS2V5KTtcbiAgICB9XG4gICAgaWYgKCFmb3JlaWduS2V5T3B0aW9ucy5uYW1lICYmIGNsYXNzV2l0aEZvcmVpZ25LZXkpIHtcbiAgICAgICAgY29uc3QgZm9yZWlnbktleXMgPSBnZXRGb3JlaWduS2V5cyhjbGFzc1dpdGhGb3JlaWduS2V5LnByb3RvdHlwZSkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZvcmVpZ25LZXlzKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnJlbGF0ZWRDbGFzc0dldHRlcigpID09PSByZWxhdGVkQ2xhc3MgfHxcbiAgICAgICAgICAgICAgICByZWxhdGVkQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2Yga2V5LnJlbGF0ZWRDbGFzc0dldHRlcigpKSB7XG4gICAgICAgICAgICAgICAgZm9yZWlnbktleU9wdGlvbnMubmFtZSA9IGtleS5mb3JlaWduS2V5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZm9yZWlnbktleU9wdGlvbnMubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcmVpZ24ga2V5IGZvciBcIiR7cmVsYXRlZENsYXNzLm5hbWV9XCIgaXMgbWlzc2luZyBgICtcbiAgICAgICAgICAgIGBvbiBcIiR7Y2xhc3NXaXRoRm9yZWlnbktleS5uYW1lfVwiLmApO1xuICAgIH1cbiAgICByZXR1cm4gZm9yZWlnbktleU9wdGlvbnM7XG59XG5leHBvcnRzLmdldEZvcmVpZ25LZXlPcHRpb25zID0gZ2V0Rm9yZWlnbktleU9wdGlvbnM7XG4vKipcbiAqIEFkZHMgZm9yZWlnbiBrZXkgbWV0YSBkYXRhIGZvciBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gYWRkRm9yZWlnbktleSh0YXJnZXQsIHJlbGF0ZWRDbGFzc0dldHRlciwgZm9yZWlnbktleSkge1xuICAgIGxldCBmb3JlaWduS2V5cyA9IGdldEZvcmVpZ25LZXlzKHRhcmdldCk7XG4gICAgaWYgKCFmb3JlaWduS2V5cykge1xuICAgICAgICBmb3JlaWduS2V5cyA9IFtdO1xuICAgIH1cbiAgICBmb3JlaWduS2V5cy5wdXNoKHtcbiAgICAgICAgcmVsYXRlZENsYXNzR2V0dGVyLFxuICAgICAgICBmb3JlaWduS2V5LFxuICAgIH0pO1xuICAgIHNldEZvcmVpZ25LZXlzKHRhcmdldCwgZm9yZWlnbktleXMpO1xufVxuZXhwb3J0cy5hZGRGb3JlaWduS2V5ID0gYWRkRm9yZWlnbktleTtcbi8qKlxuICogUmV0dXJucyBmb3JlaWduIGtleSBtZXRhIGRhdGEgZnJvbSBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gZ2V0Rm9yZWlnbktleXModGFyZ2V0KSB7XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKEZPUkVJR05fS0VZU19LRVksIHRhcmdldCk7XG4gICAgaWYgKGZvcmVpZ25LZXlzKSB7XG4gICAgICAgIHJldHVybiBbLi4uZm9yZWlnbktleXNdO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Rm9yZWlnbktleXMgPSBnZXRGb3JlaWduS2V5cztcbi8qKlxuICogU2V0cyBmb3JlaWduIGtleSBtZXRhIGRhdGFcbiAqL1xuZnVuY3Rpb24gc2V0Rm9yZWlnbktleXModGFyZ2V0LCBmb3JlaWduS2V5cykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoRk9SRUlHTl9LRVlTX0tFWSwgZm9yZWlnbktleXMsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JlaWduLWtleS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JlaWduS2V5ID0gdm9pZCAwO1xuY29uc3QgZm9yZWlnbl9rZXlfc2VydmljZV8xID0gcmVxdWlyZShcIi4vZm9yZWlnbi1rZXktc2VydmljZVwiKTtcbmZ1bmN0aW9uIEZvcmVpZ25LZXkocmVsYXRlZENsYXNzR2V0dGVyKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBmb3JlaWduX2tleV9zZXJ2aWNlXzEuYWRkRm9yZWlnbktleSh0YXJnZXQsIHJlbGF0ZWRDbGFzc0dldHRlciwgcHJvcGVydHlOYW1lKTtcbiAgICB9O1xufVxuZXhwb3J0cy5Gb3JlaWduS2V5ID0gRm9yZWlnbktleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcmVpZ24ta2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNBc3NvY2lhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGZvcmVpZ25fa2V5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlXCIpO1xuY2xhc3MgSGFzQXNzb2NpYXRpb24gZXh0ZW5kcyBiYXNlX2Fzc29jaWF0aW9uXzEuQmFzZUFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMsIGFzc29jaWF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb24gPSBhc3NvY2lhdGlvbjtcbiAgICB9XG4gICAgZ2V0QXNzb2NpYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc29jaWF0aW9uO1xuICAgIH1cbiAgICBnZXRTZXF1ZWxpemVPcHRpb25zKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGVkQ2xhc3MgPSB0aGlzLmdldEFzc29jaWF0ZWRDbGFzcygpO1xuICAgICAgICBvcHRpb25zLmZvcmVpZ25LZXkgPSBmb3JlaWduX2tleV9zZXJ2aWNlXzEuZ2V0Rm9yZWlnbktleU9wdGlvbnMobW9kZWwsIGFzc29jaWF0ZWRDbGFzcywgb3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNBc3NvY2lhdGlvbiA9IEhhc0Fzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWFzc29jaWF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNNYW55ID0gdm9pZCAwO1xuY29uc3QgaGFzX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi9oYXMtYXNzb2NpYXRpb25cIik7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG5jb25zdCBhc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvblwiKTtcbmZ1bmN0aW9uIEhhc01hbnkoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zT3JGb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXNzb2NpYXRpb25fc2VydmljZV8xLmdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zKG9wdGlvbnNPckZvcmVpZ25LZXkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXMpXG4gICAgICAgICAgICBvcHRpb25zLmFzID0gcHJvcGVydHlOYW1lO1xuICAgICAgICBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuYWRkQXNzb2NpYXRpb24odGFyZ2V0LCBuZXcgaGFzX2Fzc29jaWF0aW9uXzEuSGFzQXNzb2NpYXRpb24oYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zLCBhc3NvY2lhdGlvbl8xLkFzc29jaWF0aW9uLkhhc01hbnkpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5IYXNNYW55ID0gSGFzTWFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1tYW55LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNPbmUgPSB2b2lkIDA7XG5jb25zdCBoYXNfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuL2hhcy1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbmNvbnN0IGFzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uXCIpO1xuZnVuY3Rpb24gSGFzT25lKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9uc09yRm9yZWlnbktleSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFzc29jaWF0aW9uX3NlcnZpY2VfMS5nZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyhvcHRpb25zT3JGb3JlaWduS2V5KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFzKVxuICAgICAgICAgICAgb3B0aW9ucy5hcyA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgYXNzb2NpYXRpb25fc2VydmljZV8xLmFkZEFzc29jaWF0aW9uKHRhcmdldCwgbmV3IGhhc19hc3NvY2lhdGlvbl8xLkhhc0Fzc29jaWF0aW9uKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucywgYXNzb2NpYXRpb25fMS5Bc3NvY2lhdGlvbi5IYXNPbmUpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5IYXNPbmUgPSBIYXNPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtb25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBc3NvY2lhdGlvbnNCeVJlbGF0aW9uID0gZXhwb3J0cy5zZXRBc3NvY2lhdGlvbnMgPSBleHBvcnRzLmdldEFzc29jaWF0aW9ucyA9IGV4cG9ydHMuYWRkQXNzb2NpYXRpb24gPSBleHBvcnRzLmdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zID0gdm9pZCAwO1xucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XG5jb25zdCBBU1NPQ0lBVElPTlNfS0VZID0gJ3NlcXVlbGl6ZTphc3NvY2lhdGlvbnMnO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXG5mdW5jdGlvbiBnZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyhvcHRpb25zT3JGb3JlaWduS2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9uc09yRm9yZWlnbktleSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckZvcmVpZ25LZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZvcmVpZ25LZXkgPSBvcHRpb25zT3JGb3JlaWduS2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnNPckZvcmVpZ25LZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5nZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyA9IGdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zO1xuLyoqXG4gKiBTdG9yZXMgYXNzb2NpYXRpb24gbWV0YSBkYXRhIGZvciBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gYWRkQXNzb2NpYXRpb24odGFyZ2V0LCBhc3NvY2lhdGlvbikge1xuICAgIGxldCBhc3NvY2lhdGlvbnMgPSBnZXRBc3NvY2lhdGlvbnModGFyZ2V0KTtcbiAgICBpZiAoIWFzc29jaWF0aW9ucykge1xuICAgICAgICBhc3NvY2lhdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgYXNzb2NpYXRpb25zLnB1c2goYXNzb2NpYXRpb24pO1xuICAgIHNldEFzc29jaWF0aW9ucyh0YXJnZXQsIGFzc29jaWF0aW9ucyk7XG59XG5leHBvcnRzLmFkZEFzc29jaWF0aW9uID0gYWRkQXNzb2NpYXRpb247XG4vKipcbiAqIFJldHVybnMgYXNzb2NpYXRpb24gbWV0YSBkYXRhIGZyb20gc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGdldEFzc29jaWF0aW9ucyh0YXJnZXQpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKEFTU09DSUFUSU9OU19LRVksIHRhcmdldCk7XG4gICAgaWYgKGFzc29jaWF0aW9ucykge1xuICAgICAgICByZXR1cm4gWy4uLmFzc29jaWF0aW9uc107XG4gICAgfVxufVxuZXhwb3J0cy5nZXRBc3NvY2lhdGlvbnMgPSBnZXRBc3NvY2lhdGlvbnM7XG5mdW5jdGlvbiBzZXRBc3NvY2lhdGlvbnModGFyZ2V0LCBhc3NvY2lhdGlvbnMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKEFTU09DSUFUSU9OU19LRVksIGFzc29jaWF0aW9ucywgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0QXNzb2NpYXRpb25zID0gc2V0QXNzb2NpYXRpb25zO1xuZnVuY3Rpb24gZ2V0QXNzb2NpYXRpb25zQnlSZWxhdGlvbih0YXJnZXQsIHJlbGF0ZWRDbGFzcykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IGdldEFzc29jaWF0aW9ucyh0YXJnZXQpO1xuICAgIHJldHVybiAoYXNzb2NpYXRpb25zIHx8IFtdKS5maWx0ZXIoYXNzb2NpYXRpb24gPT4ge1xuICAgICAgICBjb25zdCBfcmVsYXRlZENsYXNzID0gYXNzb2NpYXRpb24uZ2V0QXNzb2NpYXRlZENsYXNzKCk7XG4gICAgICAgIHJldHVybiAoX3JlbGF0ZWRDbGFzcy5wcm90b3R5cGUgPT09IHJlbGF0ZWRDbGFzcy5wcm90b3R5cGUgfHxcbiAgICAgICAgICAgIHJlbGF0ZWRDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBfcmVsYXRlZENsYXNzKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0QXNzb2NpYXRpb25zQnlSZWxhdGlvbiA9IGdldEFzc29jaWF0aW9uc0J5UmVsYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NvY2lhdGlvbiA9IHZvaWQgMDtcbnZhciBBc3NvY2lhdGlvbjtcbihmdW5jdGlvbiAoQXNzb2NpYXRpb24pIHtcbiAgICBBc3NvY2lhdGlvbltcIkJlbG9uZ3NUb01hbnlcIl0gPSBcImJlbG9uZ3NUb01hbnlcIjtcbiAgICBBc3NvY2lhdGlvbltcIkJlbG9uZ3NUb1wiXSA9IFwiYmVsb25nc1RvXCI7XG4gICAgQXNzb2NpYXRpb25bXCJIYXNNYW55XCJdID0gXCJoYXNNYW55XCI7XG4gICAgQXNzb2NpYXRpb25bXCJIYXNPbmVcIl0gPSBcImhhc09uZVwiO1xufSkoQXNzb2NpYXRpb24gPSBleHBvcnRzLkFzc29jaWF0aW9uIHx8IChleHBvcnRzLkFzc29jaWF0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQXNzb2NpYXRpb24gPSB2b2lkIDA7XG5jbGFzcyBCYXNlQXNzb2NpYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFzc29jaWF0ZWRDbGFzc0dldHRlciA9IGFzc29jaWF0ZWRDbGFzc0dldHRlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0QXNzb2NpYXRlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NvY2lhdGVkQ2xhc3NHZXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0QXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXM7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQXNzb2NpYXRpb24gPSBCYXNlQXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLWFzc29jaWF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pb24tYXNzb2NpYXRpb24tb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm91Z2gtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJCdWxrQ3JlYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJCdWxrQ3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQnVsa0NyZWF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckJ1bGtDcmVhdGUgPSBBZnRlckJ1bGtDcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1idWxrLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJCdWxrRGVzdHJveSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQnVsa0Rlc3Ryb3koLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJCdWxrRGVzdHJveScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckJ1bGtEZXN0cm95ID0gQWZ0ZXJCdWxrRGVzdHJveTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWJ1bGstZGVzdHJveS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJCdWxrUmVzdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQnVsa1Jlc3RvcmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJCdWxrUmVzdG9yZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckJ1bGtSZXN0b3JlID0gQWZ0ZXJCdWxrUmVzdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWJ1bGstcmVzdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJCdWxrU3luYyA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQnVsa1N5bmMoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJCdWxrU3luYycsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckJ1bGtTeW5jID0gQWZ0ZXJCdWxrU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWJ1bGstc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJCdWxrVXBkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJCdWxrVXBkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQnVsa1VwZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckJ1bGtVcGRhdGUgPSBBZnRlckJ1bGtVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1idWxrLXVwZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQnVsa0NyZWF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUJ1bGtDcmVhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQnVsa0NyZWF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVCdWxrQ3JlYXRlID0gQmVmb3JlQnVsa0NyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1idWxrLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQnVsa0Rlc3Ryb3kgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVCdWxrRGVzdHJveSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVCdWxrRGVzdHJveScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVCdWxrRGVzdHJveSA9IEJlZm9yZUJ1bGtEZXN0cm95O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWJ1bGstZGVzdHJveS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQnVsa1Jlc3RvcmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVCdWxrUmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVCdWxrUmVzdG9yZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVCdWxrUmVzdG9yZSA9IEJlZm9yZUJ1bGtSZXN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWJ1bGstcmVzdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQnVsa1N5bmMgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVCdWxrU3luYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVCdWxrU3luYycsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVCdWxrU3luYyA9IEJlZm9yZUJ1bGtTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWJ1bGstc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQnVsa1VwZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUJ1bGtVcGRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQnVsa1VwZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVCdWxrVXBkYXRlID0gQmVmb3JlQnVsa1VwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1idWxrLXVwZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2stb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0SG9va3MgPSBleHBvcnRzLmdldEhvb2tzID0gZXhwb3J0cy5hZGRIb29rID0gZXhwb3J0cy5pbXBsZW1lbnRIb29rRGVjb3JhdG9yID0gZXhwb3J0cy5pbnN0YWxsSG9va3MgPSB2b2lkIDA7XG5yZXF1aXJlKFwicmVmbGVjdC1tZXRhZGF0YVwiKTtcbmNvbnN0IEhPT0tTX0tFWSA9ICdzZXF1ZWxpemU6aG9va3MnO1xuLyoqXG4gKiBJbnN0YWxscyBob29rcyBvbiB0aGUgc3BlY2lmaWVkIG1vZGVsc1xuICovXG5mdW5jdGlvbiBpbnN0YWxsSG9va3MobW9kZWxzKSB7XG4gICAgbW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgICBjb25zdCBob29rcyA9IGdldEhvb2tzKG1vZGVsKTtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICBob29rcy5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgICAgICAgICAgIGluc3RhbGxIb29rKG1vZGVsLCBob29rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmluc3RhbGxIb29rcyA9IGluc3RhbGxIb29rcztcbi8qKlxuICogSW1wbGVtZW50YXRpb24gZm9yIGhvb2sgZGVjb3JhdG9yIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHBvbHltb3JwaGljLiBXaGVuXG4gKiBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCAoSUhvb2tPcHRpb25zKSB0aGV5IHJldHVybiBhIGRlY29yYXRvclxuICogZmFjdG9yeSBmdW5jdGlvbi4gV2hlbiBjYWxsZWQgd2l0aCBtdWx0aXBsZSBhcmd1bWVudHMsIHRoZXkgYWRkIHRoZSBob29rXG4gKiB0byB0aGUgbW9kZWzigJlzIG1ldGFkYXRhLlxuICovXG5mdW5jdGlvbiBpbXBsZW1lbnRIb29rRGVjb3JhdG9yKGhvb2tUeXBlLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhZGRIb29rKHRhcmdldCwgaG9va1R5cGUsIHByb3BlcnR5TmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhcmdzWzFdO1xuICAgICAgICBhZGRIb29rKHRhcmdldCwgaG9va1R5cGUsIHByb3BlcnR5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5pbXBsZW1lbnRIb29rRGVjb3JhdG9yID0gaW1wbGVtZW50SG9va0RlY29yYXRvcjtcbi8qKlxuICogQWRkcyBob29rIG1ldGEgZGF0YSBmb3Igc3BlY2lmaWVkIG1vZGVsXG4gKiBAdGhyb3dzIGlmIGFwcGxpZWQgdG8gYSBub24tc3RhdGljIG1ldGhvZFxuICogQHRocm93cyBpZiB0aGUgaG9vayBtZXRob2QgbmFtZSBpcyByZXNlcnZlZFxuICovXG5mdW5jdGlvbiBhZGRIb29rKHRhcmdldCwgaG9va1R5cGUsIG1ldGhvZE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9vayBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGlzIG5vdCBhIHN0YXRpYyBtZXRob2QuIGAgK1xuICAgICAgICAgICAgYE9ubHkgc3RhdGljIG1ldGhvZHMgY2FuIGJlIHVzZWQgZm9yIGhvb2tzYCk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgaG9vayBuYW1lIGRvZXNu4oCZdCBjb25mbGljdCB3aXRoIFNlcXVlbGl6ZeKAmXMgZXhpc3RpbmcgbWV0aG9kc1xuICAgIGlmIChtZXRob2ROYW1lID09PSBob29rVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvb2sgbWV0aG9kIGNhbm5vdCBiZSBuYW1lZCAnJHttZXRob2ROYW1lfScuIFRoYXQgbmFtZSBpcyBgICtcbiAgICAgICAgICAgIGByZXNlcnZlZCBieSBTZXF1ZWxpemVgKTtcbiAgICB9XG4gICAgY29uc3QgaG9va3MgPSBnZXRIb29rcyh0YXJnZXQpIHx8IFtdO1xuICAgIGhvb2tzLnB1c2goe1xuICAgICAgICBob29rVHlwZSxcbiAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHNldEhvb2tzKHRhcmdldCwgaG9va3MpO1xufVxuZXhwb3J0cy5hZGRIb29rID0gYWRkSG9vaztcbi8qKlxuICogSW5zdGFsbCBhIGhvb2tcbiAqL1xuZnVuY3Rpb24gaW5zdGFsbEhvb2sobW9kZWwsIGhvb2spIHtcbiAgICBpZiAoaG9vay5vcHRpb25zICYmIGhvb2sub3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG1vZGVsLmFkZEhvb2soaG9vay5ob29rVHlwZSwgaG9vay5vcHRpb25zLm5hbWUsIG1vZGVsW2hvb2subWV0aG9kTmFtZV0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vZGVsLmFkZEhvb2soaG9vay5ob29rVHlwZSwgbW9kZWxbaG9vay5tZXRob2ROYW1lXSk7XG59XG4vKipcbiAqIFJldHVybnMgaG9va3MgbWV0YSBkYXRhIGZyb20gc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tzKHRhcmdldCkge1xuICAgIGNvbnN0IGhvb2tzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShIT09LU19LRVksIHRhcmdldCk7XG4gICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHJldHVybiBbLi4uaG9va3NdO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0SG9va3MgPSBnZXRIb29rcztcbi8qKlxuICogU2F2ZXMgaG9va3MgbWV0YSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIHNldEhvb2tzKHRhcmdldCwgaG9va3MpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKEhPT0tTX0tFWSwgaG9va3MsIHRhcmdldCk7XG59XG5leHBvcnRzLnNldEhvb2tzID0gc2V0SG9va3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0aW9uRmFpbGVkID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4vaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIFZhbGlkYXRpb25GYWlsZWQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcigndmFsaWRhdGlvbkZhaWxlZCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5WYWxpZGF0aW9uRmFpbGVkID0gVmFsaWRhdGlvbkZhaWxlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24tZmFpbGVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckNvbm5lY3QgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckNvbm5lY3QoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJDb25uZWN0JywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQ29ubmVjdCA9IEFmdGVyQ29ubmVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWNvbm5lY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQ3JlYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJDcmVhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJDcmVhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJDcmVhdGUgPSBBZnRlckNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJEZWZpbmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckRlZmluZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckRlZmluZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckRlZmluZSA9IEFmdGVyRGVmaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItZGVmaW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckRlc3Ryb3kgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckRlc3Ryb3koLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJEZXN0cm95JywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyRGVzdHJveSA9IEFmdGVyRGVzdHJveTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWRlc3Ryb3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyRmluZCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyRmluZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckZpbmQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJGaW5kID0gQWZ0ZXJGaW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItZmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJJbml0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJJbml0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVySW5pdCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckluaXQgPSBBZnRlckluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1pbml0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclJlc3RvcmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclJlc3RvcmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJSZXN0b3JlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyUmVzdG9yZSA9IEFmdGVyUmVzdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXJlc3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyU2F2ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyU2F2ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclNhdmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJTYXZlID0gQWZ0ZXJTYXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItc2F2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJTeW5jID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJTeW5jKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyU3luYycsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclN5bmMgPSBBZnRlclN5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1zeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclVwZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyVXBkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyVXBkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyVXBkYXRlID0gQWZ0ZXJVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci11cGRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyVXBzZXJ0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJVcHNlcnQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJVcHNlcnQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJVcHNlcnQgPSBBZnRlclVwc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXVwc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyVmFsaWRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJWYWxpZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclZhbGlkYXRlID0gQWZ0ZXJWYWxpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXZhbGlkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVDb25uZWN0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQ29ubmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVDb25uZWN0JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUNvbm5lY3QgPSBCZWZvcmVDb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWNvbm5lY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUNvdW50ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQ291bnQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQ291bnQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQ291bnQgPSBCZWZvcmVDb3VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1jb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQ3JlYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQ3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUNyZWF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVDcmVhdGUgPSBCZWZvcmVDcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtY3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVEZWZpbmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVEZWZpbmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlRGVmaW5lJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZURlZmluZSA9IEJlZm9yZURlZmluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1kZWZpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZURlc3Ryb3kgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVEZXN0cm95KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZURlc3Ryb3knLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlRGVzdHJveSA9IEJlZm9yZURlc3Ryb3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtZGVzdHJveS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGwoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsID0gQmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1maW5kLWFmdGVyLWV4cGFuZC1pbmNsdWRlLWFsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlRmluZEFmdGVyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUZpbmRBZnRlck9wdGlvbnMoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlRmluZEFmdGVyT3B0aW9ucycsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVGaW5kQWZ0ZXJPcHRpb25zID0gQmVmb3JlRmluZEFmdGVyT3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1maW5kLWFmdGVyLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUZpbmQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVGaW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUZpbmQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlRmluZCA9IEJlZm9yZUZpbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtZmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlSW5pdCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUluaXQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlSW5pdCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVJbml0ID0gQmVmb3JlSW5pdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1pbml0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVSZXN0b3JlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlUmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVSZXN0b3JlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVJlc3RvcmUgPSBCZWZvcmVSZXN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXJlc3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVNhdmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVTYXZlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVNhdmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlU2F2ZSA9IEJlZm9yZVNhdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtc2F2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlU3luYyA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVN5bmMoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlU3luYycsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVTeW5jID0gQmVmb3JlU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1zeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVVcGRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVVcGRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlVXBkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVVwZGF0ZSA9IEJlZm9yZVVwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS11cGRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVVwc2VydCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVVwc2VydCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVVcHNlcnQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlVXBzZXJ0ID0gQmVmb3JlVXBzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXVwc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlVmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVWYWxpZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVWYWxpZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVWYWxpZGF0ZSA9IEJlZm9yZVZhbGlkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXZhbGlkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8vYmVsb25ncy10b1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8vYmVsb25ncy10by1hc3NvY2lhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnkvYmVsb25ncy10by1tYW55LWFzc29jaWF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueS1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvZm9yZWlnbi1rZXkvZm9yZWlnbi1rZXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMvaGFzLWFzc29jaWF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzL2hhcy1vbmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMvaGFzLW1hbnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9zaGFyZWQvYXNzb2NpYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tYWN0aW9uLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9zaGFyZWQvdW5pb24tYXNzb2NpYXRpb24tb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvdGhyb3VnaC90aHJvdWdoLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1jcmVhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1kZXN0cm95XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstcmVzdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXN5bmNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay11cGRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLWNyZWF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstZGVzdHJveVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstcmVzdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstc3luY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstdXBkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItY29ubmVjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWNyZWF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWRlZmluZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWRlc3Ryb3lcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1maW5kXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItaW5pdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXJlc3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1zYXZlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItc3luY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXVwZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXVwc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXZhbGlkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1jb25uZWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1jb3VudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY3JlYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1kZWZpbmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWRlc3Ryb3lcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmQtYWZ0ZXItZXhwYW5kLWluY2x1ZGUtYWxsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1maW5kLWFmdGVyLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWluaXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXJlc3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXNhdmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXN5bmNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXVwZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtdXBzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS12YWxpZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2hhcmVkL2hvb2stb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2hhcmVkL2hvb2tzLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NoYXJlZC92YWxpZGF0aW9uLWZhaWxlZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2FsbG93LW51bGxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9jb21tZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL3VuaXF1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL3ByaW1hcnkta2V5L2F1dG8taW5jcmVtZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvcHJpbWFyeS1rZXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL2NyZWF0ZWQtYXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL2RlbGV0ZWQtYXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL3VwZGF0ZWQtYXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2NvbHVtblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tY291bnQtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tZ2V0LW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL21vZGVsL21vZGVsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9zaGFyZWQvbW9kZWwtY2xhc3MtZ2V0dGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9zaGFyZWQvbW9kZWwtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvdGFibGUvdGFibGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL3RhYmxlL3RhYmxlLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2luZGV4L2NyZWF0ZS1pbmRleC1kZWNvcmF0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2luZGV4L2luZGV4LWRlY29yYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvaW5kZXgvaW5kZXgtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NvcGVzL2RlZmF1bHQtc2NvcGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Njb3Blcy9zY29wZS1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY29wZXMvc2NvcGUtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NvcGVzL3Njb3BlLXRhYmxlLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Njb3Blcy9zY29wZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvZGF0YS10eXBlL2RhdGEtdHlwZS1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZS1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvdmFsaWRhdGlvbi1vbmx5L2RiLWRpYWxlY3QtZHVtbXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZS1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvcmVwb3NpdG9yeS9yZXBvc2l0b3J5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2NvbnRhaW5zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2VxdWFsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1hZnRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1hbHBoYVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1hbHBoYW51bWVyaWNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtYmVmb3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWNyZWRpdC1jYXJkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtZGVjaW1hbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1lbWFpbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1mbG9hdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1pblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1pbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtaXBcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtaXAtdjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtYXJyYXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtaXAtdjZcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtbG93ZXJjYXNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLW51bGxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtbnVtZXJpY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy11cHBlcmNhc2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtdXJsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLXV1aWRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbGVuZ3RoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL21heFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9taW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbm90XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL25vdC1jb250YWluc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9ub3QtZW1wdHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbm90LWluXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL25vdC1udWxsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL3ZhbGlkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL3ZhbGlkYXRvclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQXR0cmlidXRlT3B0aW9ucyA9IGV4cG9ydHMuYWRkQXR0cmlidXRlID0gZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gZXhwb3J0cy5nZXRBdHRyaWJ1dGVzID0gdm9pZCAwO1xuY29uc3Qgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL29iamVjdFwiKTtcbmNvbnN0IEFUVFJJQlVURVNfS0VZID0gJ3NlcXVlbGl6ZTphdHRyaWJ1dGVzJztcbi8qKlxuICogUmV0dXJucyBtb2RlbCBhdHRyaWJ1dGVzIGZyb20gY2xhc3MgYnkgcmVzdG9yaW5nIHRoaXNcbiAqIGluZm9ybWF0aW9uIGZyb20gcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKHRhcmdldCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKEFUVFJJQlVURVNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RcbiAgICAgICAgICAgIC5rZXlzKGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAucmVkdWNlKChjb3B5LCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXM7XG4vKipcbiAqIFNldHMgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKHRhcmdldCwgYXR0cmlidXRlcykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoQVRUUklCVVRFU19LRVksIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbi8qKlxuICogQWRkcyBtb2RlbCBhdHRyaWJ1dGUgYnkgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgYW5kXG4gKiBzZXF1ZWxpemUgYXR0cmlidXRlIG9wdGlvbnMgYW5kIHN0b3JlcyB0aGlzIGluZm9ybWF0aW9uXG4gKiB0aHJvdWdoIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gYWRkQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyh0YXJnZXQpO1xuICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgfVxuICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKHRhcmdldCwgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmFkZEF0dHJpYnV0ZSA9IGFkZEF0dHJpYnV0ZTtcbi8qKlxuICogQWRkcyBhdHRyaWJ1dGUgb3B0aW9ucyBmb3Igc3BlY2lmaWMgYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyh0YXJnZXQpO1xuICAgIGlmICghYXR0cmlidXRlcyB8fCAhYXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQENvbHVtbiBhbm5vdGF0aW9uIGlzIG1pc3NpbmcgZm9yIFwiJHtwcm9wZXJ0eU5hbWV9XCIgb2YgY2xhc3MgXCIke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfVwiYCArXG4gICAgICAgICAgICBgIG9yIGFubm90YXRpb24gb3JkZXIgaXMgd3JvbmcuYCk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXNbcHJvcGVydHlOYW1lXSA9IG9iamVjdF8xLmRlZXBBc3NpZ24oYXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdLCBvcHRpb25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKHRhcmdldCwgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmFkZEF0dHJpYnV0ZU9wdGlvbnMgPSBhZGRBdHRyaWJ1dGVPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFsbG93TnVsbCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBbGxvd051bGwoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBhbGxvd051bGwgPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHsgYWxsb3dOdWxsIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gYXJnc1sxXTtcbiAgICAgICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICBhbGxvd051bGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BbGxvd051bGwgPSBBbGxvd051bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxvdy1udWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tZW50ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIGNvbW1lbnQgdmFsdWUgZm9yIHRoZSBhbm5vdGF0ZWQgZmllbGRcbiAqL1xuZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICBjb21tZW50OiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5Db21tZW50ID0gQ29tbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGFubm90YXRlZCBmaWVsZFxuICovXG5mdW5jdGlvbiBEZWZhdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuRGVmYXVsdCA9IERlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmlxdWUgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gVW5pcXVlKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgW29wdGlvbnNdID0gYXJncztcbiAgICAgICAgcmV0dXJuIChfdGFyZ2V0LCBfcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBhbm5vdGF0ZShfdGFyZ2V0LCBfcHJvcGVydHlOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgW3RhcmdldCwgcHJvcGVydHlOYW1lXSA9IGFyZ3M7XG4gICAgYW5ub3RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xufVxuZXhwb3J0cy5VbmlxdWUgPSBVbmlxdWU7XG5mdW5jdGlvbiBhbm5vdGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgb3B0aW9uID0gdHJ1ZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB1bmlxdWU6IG9wdGlvbixcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sdW1uID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuY29uc3QgZGF0YV90eXBlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZXF1ZWxpemUvZGF0YS10eXBlL2RhdGEtdHlwZS1zZXJ2aWNlXCIpO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQ29sdW1uKC4uLmFyZ3MpIHtcbiAgICAvLyBJbiBjYXNlIG9mIG5vIHNwZWNpZmllZCBvcHRpb25zLCB3ZSBpbmZlciB0aGVcbiAgICAvLyBzZXF1ZWxpemUgZGF0YSB0eXBlIGJ5IHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eVxuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGFyZ3NbMV07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGFyZ3NbMl07XG4gICAgICAgIGFubm90YXRlKHRhcmdldCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgICAgICBhbm5vdGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlEZXNjcmlwdG9yLCBhcmdzWzBdKTtcbiAgICB9O1xufVxuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG5mdW5jdGlvbiBhbm5vdGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlEZXNjcmlwdG9yLCBvcHRpb25zT3JEYXRhVHlwZSA9IHt9KSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGRhdGFfdHlwZV9zZXJ2aWNlXzEuaXNEYXRhVHlwZShvcHRpb25zT3JEYXRhVHlwZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnNPckRhdGFUeXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uc09yRGF0YVR5cGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gbW9kZWxfc2VydmljZV8xLmdldFNlcXVlbGl6ZVR5cGVCeURlc2lnblR5cGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZ2V0ID0gcHJvcGVydHlEZXNjcmlwdG9yLmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZXQgPSBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHlOYW1lLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHVtbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXV0b0luY3JlbWVudCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFNldHMgYXV0byBpbmNyZW1lbnQgdHJ1ZSBmb3IgYW5ub3RhdGVkIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIEF1dG9JbmNyZW1lbnQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xufVxuZXhwb3J0cy5BdXRvSW5jcmVtZW50ID0gQXV0b0luY3JlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG8taW5jcmVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmltYXJ5S2V5ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogU2V0cyBwcmltYXJ5IGtleSBvcHRpb24gdHJ1ZSBmb3IgYW5ub3RhdGVkIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBQcmltYXJ5S2V5KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHByaW1hcnlLZXk6IHRydWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuUHJpbWFyeUtleSA9IFByaW1hcnlLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmltYXJ5LWtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3JlYXRlZEF0ID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQ3JlYXRlZEF0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgbW9kZWxfc2VydmljZV8xLmFkZE9wdGlvbnModGFyZ2V0LCB7XG4gICAgICAgIGNyZWF0ZWRBdDogcHJvcGVydHlOYW1lLFxuICAgICAgICB0aW1lc3RhbXBzOiB0cnVlXG4gICAgfSk7XG59XG5leHBvcnRzLkNyZWF0ZWRBdCA9IENyZWF0ZWRBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZWQtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlbGV0ZWRBdCA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmZ1bmN0aW9uIERlbGV0ZWRBdCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIG1vZGVsX3NlcnZpY2VfMS5hZGRPcHRpb25zKHRhcmdldCwge1xuICAgICAgICBkZWxldGVkQXQ6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgcGFyYW5vaWQ6IHRydWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuRGVsZXRlZEF0ID0gRGVsZXRlZEF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsZXRlZC1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXBkYXRlZEF0ID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gVXBkYXRlZEF0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgbW9kZWxfc2VydmljZV8xLmFkZE9wdGlvbnModGFyZ2V0LCB7XG4gICAgICAgIHVwZGF0ZWRBdDogcHJvcGVydHlOYW1lLFxuICAgICAgICB0aW1lc3RhbXBzOiB0cnVlXG4gICAgfSk7XG59XG5leHBvcnRzLlVwZGF0ZWRBdCA9IFVwZGF0ZWRBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZWQtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZGV4RGVjb3JhdG9yID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfc2VydmljZV8xID0gcmVxdWlyZShcIi4vaW5kZXgtc2VydmljZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4RGVjb3JhdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBpbmRleElkO1xuICAgIHJldHVybiAoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IFt0YXJnZXQsIHByb3BlcnR5TmFtZV0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgZmllbGRPcHRpb25zID0geyBuYW1lOiBwcm9wZXJ0eU5hbWUgfTtcbiAgICAgICAgICAgIGluZGV4SWQgPSBpbmRleF9zZXJ2aWNlXzEuYWRkRmllbGRUb0luZGV4KHRhcmdldCwgZmllbGRPcHRpb25zLCBvcHRpb25zLCBpbmRleElkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogcHJvcGVydHlOYW1lIH0sIGFyZ3NbMF0pO1xuICAgICAgICAgICAgaW5kZXhJZCA9IGluZGV4X3NlcnZpY2VfMS5hZGRGaWVsZFRvSW5kZXgodGFyZ2V0LCBmaWVsZE9wdGlvbnMsIG9wdGlvbnMsIGluZGV4SWQpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVJbmRleERlY29yYXRvciA9IGNyZWF0ZUluZGV4RGVjb3JhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWluZGV4LWRlY29yYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYW5ub3RhdGVNb2RlbFdpdGhJbmRleCA9IGV4cG9ydHMuSW5kZXggPSB2b2lkIDA7XG5jb25zdCBpbmRleF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9pbmRleC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gSW5kZXgoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IFt0YXJnZXQsIHByb3BlcnR5TmFtZV0gPSBhcmdzO1xuICAgICAgICBhbm5vdGF0ZU1vZGVsV2l0aEluZGV4KHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGFubm90YXRlTW9kZWxXaXRoSW5kZXgodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIGFyZ3NbMF0pO1xuICAgIH07XG59XG5leHBvcnRzLkluZGV4ID0gSW5kZXg7XG5mdW5jdGlvbiBhbm5vdGF0ZU1vZGVsV2l0aEluZGV4KHRhcmdldCwgcHJvcGVydHlOYW1lLCBvcHRpb25zT3JOYW1lID0ge30sIGluZGV4SWQpIHtcbiAgICBsZXQgaW5kZXhPcHRpb25zO1xuICAgIGxldCBmaWVsZE9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRleE9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnNPck5hbWUgfTtcbiAgICAgICAgZmllbGRPcHRpb25zID0geyBuYW1lOiBwcm9wZXJ0eU5hbWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoLCBvcmRlciwgY29sbGF0ZSB9ID0gb3B0aW9uc09yTmFtZSwgcmVzdCA9IF9fcmVzdChvcHRpb25zT3JOYW1lLCBbXCJsZW5ndGhcIiwgXCJvcmRlclwiLCBcImNvbGxhdGVcIl0pO1xuICAgICAgICBpbmRleE9wdGlvbnMgPSByZXN0O1xuICAgICAgICBmaWVsZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBvcmRlcixcbiAgICAgICAgICAgIGNvbGxhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpbmRleF9zZXJ2aWNlXzEuYWRkRmllbGRUb0luZGV4KHRhcmdldCwgZmllbGRPcHRpb25zLCBpbmRleE9wdGlvbnMsIGluZGV4SWQpO1xufVxuZXhwb3J0cy5hbm5vdGF0ZU1vZGVsV2l0aEluZGV4ID0gYW5ub3RhdGVNb2RlbFdpdGhJbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWRlY29yYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkRmllbGRUb0luZGV4ID0gZXhwb3J0cy5zZXRJbmRleGVzID0gZXhwb3J0cy5nZXRJbmRleGVzID0gdm9pZCAwO1xucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XG5jb25zdCBJTkRFWEVTX0tFWSA9ICdzZXF1ZWxpemU6aW5kZXhlcyc7XG4vKipcbiAqIFJldHVybnMgbW9kZWwgaW5kZXhlcyBmcm9tIGNsYXNzIGJ5IHJlc3RvcmluZyB0aGlzXG4gKiBpbmZvcm1hdGlvbiBmcm9tIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0SW5kZXhlcyh0YXJnZXQpIHtcbiAgICBjb25zdCB7IG5hbWVkID0ge30sIHVubmFtZWQgPSBbXSB9ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShJTkRFWEVTX0tFWSwgdGFyZ2V0KSB8fCB7fTtcbiAgICByZXR1cm4geyBuYW1lZDogT2JqZWN0LmFzc2lnbih7fSwgbmFtZWQpLCB1bm5hbWVkOiBbLi4udW5uYW1lZF0gfTtcbn1cbmV4cG9ydHMuZ2V0SW5kZXhlcyA9IGdldEluZGV4ZXM7XG4vKipcbiAqIFNldHMgaW5kZXhlc1xuICovXG5mdW5jdGlvbiBzZXRJbmRleGVzKHRhcmdldCwgaW5kZXhlcykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoSU5ERVhFU19LRVksIGluZGV4ZXMsIHRhcmdldCk7XG59XG5leHBvcnRzLnNldEluZGV4ZXMgPSBzZXRJbmRleGVzO1xuLyoqXG4gKiBBZGRzIGZpZWxkIHRvIGluZGV4IGJ5IHNlcXVlbGl6ZSBpbmRleCBhbmQgaW5kZXggZmllbGQgb3B0aW9ucyxcbiAqIGFuZCBzdG9yZXMgdGhpcyBpbmZvcm1hdGlvbiB0aHJvdWdoIHJlZmxlY3QgbWV0YWRhdGEuIFJldHVybnMgaW5kZXggSUQuXG4gKi9cbmZ1bmN0aW9uIGFkZEZpZWxkVG9JbmRleCh0YXJnZXQsIGZpZWxkT3B0aW9ucywgaW5kZXhPcHRpb25zLCBpbmRleElkKSB7XG4gICAgY29uc3QgaW5kZXhlcyA9IGdldEluZGV4ZXModGFyZ2V0KTtcbiAgICBjb25zdCBjaG9zZW5JZCA9IHR5cGVvZiBpbmRleElkICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGluZGV4SWRcbiAgICAgICAgOiBpbmRleE9wdGlvbnMubmFtZSB8fCBpbmRleGVzLnVubmFtZWQubGVuZ3RoO1xuICAgIGNvbnN0IGluZGV4U3RvcmUgPSB0eXBlb2YgY2hvc2VuSWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gaW5kZXhlcy5uYW1lZFxuICAgICAgICA6IGluZGV4ZXMudW5uYW1lZDtcbiAgICBpZiAoIWluZGV4U3RvcmVbY2hvc2VuSWRdKVxuICAgICAgICBpbmRleFN0b3JlW2Nob3NlbklkXSA9IE9iamVjdC5hc3NpZ24oe30sIGluZGV4T3B0aW9ucyk7XG4gICAgY29uc3QgaW5kZXggPSBpbmRleFN0b3JlW2Nob3NlbklkXTtcbiAgICBpZiAoIWluZGV4LmZpZWxkcylcbiAgICAgICAgaW5kZXguZmllbGRzID0gW107XG4gICAgaW5kZXguZmllbGRzLnB1c2goZmllbGRPcHRpb25zKTtcbiAgICBzZXRJbmRleGVzKHRhcmdldCwgaW5kZXhlcyk7XG4gICAgcmV0dXJuIGNob3NlbklkO1xufVxuZXhwb3J0cy5hZGRGaWVsZFRvSW5kZXggPSBhZGRGaWVsZFRvSW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24tYWN0aW9uLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi1jb3VudC1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24tZ2V0LW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklORkVSX0FMSUFTX01BUCA9IGV4cG9ydHMuTW9kZWwgPSB2b2lkIDA7XG5jb25zdCBzZXF1ZWxpemVfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemVcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvc3RyaW5nXCIpO1xuY29uc3QgYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvYWxpYXMtaW5mZXJlbmNlL2FsaWFzLWluZmVyZW5jZS1zZXJ2aWNlXCIpO1xuY29uc3QgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvclwiKTtcbmNvbnN0IG9iamVjdF8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9vYmplY3RcIik7XG5jbGFzcyBNb2RlbCBleHRlbmRzIHNlcXVlbGl6ZV8xLk1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFuZXcudGFyZ2V0LmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMS5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IobmV3LnRhcmdldCwgYCR7bmV3LnRhcmdldC5uYW1lfSBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHZhbHVlcywgYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKG9wdGlvbnMsIG5ldy50YXJnZXQpKTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBzdXBlci5pbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHJlbGF0aW9uIGJldHdlZW4gc3BlY2lmaWVkIGluc3RhbmNlcyBhbmQgc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJGFkZChwcm9wZXJ0eUtleSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydhZGQnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgcmVsYXRpb24gYmV0d2VlbiBzcGVjaWZpZWQgaW5zdGFuY2VzIGFuZCBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKiAocmVwbGFjZXMgb2xkIHJlbGF0aW9ucylcbiAgICAgKi9cbiAgICAkc2V0KHByb3BlcnR5S2V5LCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ3NldCcgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0oaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByZWxhdGVkIGluc3RhbmNlIChzcGVjaWZpZWQgYnkgcHJvcGVydHlLZXkpIG9mIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRnZXQocHJvcGVydHlLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2dldCcgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50cyByZWxhdGVkIGluc3RhbmNlcyAoc3BlY2lmaWVkIGJ5IHByb3BlcnR5S2V5KSBvZiBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkY291bnQocHJvcGVydHlLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2NvdW50JyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBpbnN0YW5jZXMgYW5kIHJlbGF0ZSB0aGVtIHRvIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRjcmVhdGUocHJvcGVydHlLZXksIHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snY3JlYXRlJyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIGluc3RhbmNlcyBpcyByZWxhdGVkIHRvIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRoYXMocHJvcGVydHlLZXksIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snaGFzJyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHNwZWNpZmllZCBpbnN0YW5jZXMgZnJvbSBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkcmVtb3ZlKHByb3BlcnR5S2V5LCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ3JlbW92ZScgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0oaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVsb2FkKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbG9hZChhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMob3B0aW9ucywgdGhpcykpO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcbk1vZGVsLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbi8qKlxuICogSW5kaWNhdGVzIHdoaWNoIHN0YXRpYyBtZXRob2RzIG9mIE1vZGVsIGhhcyB0byBiZSBwcm94aWVkLFxuICogdG8gcHJlcGFyZSBpbmNsdWRlIG9wdGlvbiB0byBhdXRvbWF0aWNhbGx5IHJlc29sdmUgYWxpYXM7XG4gKiBUaGUgaW5kZXggcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIG9wdGlvbnMgb2YgdGhlXG4gKiBjb3JyZXNwb25kaW5nIG1ldGhvZCBwYXJhbWV0ZXJcbiAqL1xuZXhwb3J0cy5JTkZFUl9BTElBU19NQVAgPSB7XG4gICAgYnVsa0J1aWxkOiAxLFxuICAgIGJ1aWxkOiAxLFxuICAgIGNyZWF0ZTogMSxcbiAgICBhZ2dyZWdhdGU6IDIsXG4gICAgYWxsOiAwLFxuICAgIGZpbmQ6IDAsXG4gICAgZmluZEFsbDogMCxcbiAgICBmaW5kQW5kQ291bnQ6IDAsXG4gICAgZmluZEFuZENvdW50QWxsOiAwLFxuICAgIGZpbmRCeUlkOiAxLFxuICAgIGZpbmRCeVByaW1hcnk6IDEsXG4gICAgZmluZENyZWF0ZUZpbmQ6IDAsXG4gICAgZmluZE9uZTogMCxcbiAgICBmaW5kT3JCdWlsZDogMCxcbiAgICBmaW5kT3JDcmVhdGU6IDAsXG4gICAgZmluZE9ySW5pdGlhbGl6ZTogMCxcbiAgICByZWxvYWQ6IDAsXG59O1xuY29uc3Qgc3RhdGljTW9kZWxGdW5jdGlvblByb3BlcnRpZXMgPSBvYmplY3RfMS5nZXRBbGxQcm9wZXJ0eU5hbWVzKHNlcXVlbGl6ZV8xLk1vZGVsKVxuICAgIC5maWx0ZXIoa2V5ID0+ICFpc0ZvcmJpZGRlbk1lbWJlcihrZXkpICYmXG4gICAgaXNGdW5jdGlvbk1lbWJlcihrZXksIHNlcXVlbGl6ZV8xLk1vZGVsKSAmJlxuICAgICFpc1ByaXZhdGVNZW1iZXIoa2V5KSk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uTWVtYmVyKHByb3BlcnR5S2V5LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRhcmdldFtwcm9wZXJ0eUtleV0gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc0ZvcmJpZGRlbk1lbWJlcihwcm9wZXJ0eUtleSkge1xuICAgIGNvbnN0IEZPUkJJRERFTl9LRVlTID0gWyduYW1lJywgJ2NvbnN0cnVjdG9yJywgJ2xlbmd0aCcsICdwcm90b3R5cGUnLCAnY2FsbGVyJywgJ2FyZ3VtZW50cycsICdhcHBseScsXG4gICAgICAgICdxdWVyeUludGVyZmFjZScsICdxdWVyeUdlbmVyYXRvcicsICdpbml0JywgJ3JlcGxhY2VIb29rQWxpYXNlcycsICdyZWZyZXNoQXR0cmlidXRlcycsICdpbnNwZWN0J107XG4gICAgcmV0dXJuIEZPUkJJRERFTl9LRVlTLmluZGV4T2YocHJvcGVydHlLZXkpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGlzUHJpdmF0ZU1lbWJlcihwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiAocHJvcGVydHlLZXkuY2hhckF0KDApID09PSAnXycpO1xufVxuZnVuY3Rpb24gYWRkVGhyb3dOb3RJbml0aWFsaXplZFByb3h5KCkge1xuICAgIHN0YXRpY01vZGVsRnVuY3Rpb25Qcm9wZXJ0aWVzXG4gICAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHN1cGVyRm4gPSBNb2RlbFtrZXldO1xuICAgICAgICBNb2RlbFtrZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvcih0aGlzLCBgTWVtYmVyIFwiJHtrZXl9XCIgY2Fubm90IGJlIGNhbGxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBlckZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRJbmZlckFsaWFzT3ZlcnJpZGVzKCkge1xuICAgIE9iamVjdFxuICAgICAgICAua2V5cyhleHBvcnRzLklORkVSX0FMSUFTX01BUClcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uSW5kZXggPSBleHBvcnRzLklORkVSX0FMSUFTX01BUFtrZXldO1xuICAgICAgICBjb25zdCBzdXBlckZuID0gTW9kZWxba2V5XTtcbiAgICAgICAgTW9kZWxba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBhcmdzW29wdGlvbkluZGV4XSA9IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhhcmdzW29wdGlvbkluZGV4XSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXJGbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuYWRkVGhyb3dOb3RJbml0aWFsaXplZFByb3h5KCk7XG5hZGRJbmZlckFsaWFzT3ZlcnJpZGVzKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLWNsYXNzLWdldHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yID0gdm9pZCAwO1xuY2xhc3MgTW9kZWxOb3RJbml0aWFsaXplZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsQ2xhc3MsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBNb2RlbCBub3QgaW5pdGlhbGl6ZWQ6ICR7YWRkaXRpb25hbE1lc3NhZ2V9IFwiJHttb2RlbENsYXNzLm5hbWV9XCIgYCArXG4gICAgICAgICAgICBgbmVlZHMgdG8gYmUgYWRkZWQgdG8gYSBTZXF1ZWxpemUgaW5zdGFuY2UuYDtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvciA9IE1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZU1vZGVsR2V0dGVyID0gZXhwb3J0cy5nZXRTZXF1ZWxpemVUeXBlQnlEZXNpZ25UeXBlID0gZXhwb3J0cy5hZGRPcHRpb25zID0gZXhwb3J0cy5zZXRPcHRpb25zID0gZXhwb3J0cy5nZXRPcHRpb25zID0gZXhwb3J0cy5nZXRNb2RlbE5hbWUgPSBleHBvcnRzLnNldE1vZGVsTmFtZSA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvbW9kZWxcIik7XG5jb25zdCBkYXRhX3R5cGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLXNlcnZpY2VcIik7XG5jb25zdCBNT0RFTF9OQU1FX0tFWSA9ICdzZXF1ZWxpemU6bW9kZWxOYW1lJztcbmNvbnN0IE9QVElPTlNfS0VZID0gJ3NlcXVlbGl6ZTpvcHRpb25zJztcbi8qKlxuICogU2V0cyBtb2RlbCBuYW1lIGZyb20gY2xhc3MgYnkgc3RvcmluZyB0aGlzXG4gKiBpbmZvcm1hdGlvbiB0aHJvdWdoIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZWxOYW1lKHRhcmdldCwgbW9kZWxOYW1lKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShNT0RFTF9OQU1FX0tFWSwgbW9kZWxOYW1lLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRNb2RlbE5hbWUgPSBzZXRNb2RlbE5hbWU7XG4vKipcbiAqIFJldHVybnMgbW9kZWwgbmFtZSBmcm9tIGNsYXNzIGJ5IHJlc3RvcmluZyB0aGlzXG4gKiBpbmZvcm1hdGlvbiBmcm9tIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZWxOYW1lKHRhcmdldCkge1xuICAgIHJldHVybiBSZWZsZWN0LmdldE1ldGFkYXRhKE1PREVMX05BTUVfS0VZLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5nZXRNb2RlbE5hbWUgPSBnZXRNb2RlbE5hbWU7XG4vKipcbiAqIFJldHVybnMgc2VxdWVsaXplIGRlZmluZSBvcHRpb25zIGZyb20gY2xhc3MgcHJvdG90eXBlXG4gKiBieSByZXN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyh0YXJnZXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gUmVmbGVjdC5nZXRNZXRhZGF0YShPUFRJT05TX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRPcHRpb25zID0gZ2V0T3B0aW9ucztcbi8qKlxuICogU2V0cyBzZXVxbGl6ZSBkZWZpbmUgb3B0aW9ucyB0byBjbGFzcyBwcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gc2V0T3B0aW9ucyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKE9QVElPTlNfS0VZLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4vKipcbiAqIEFkZHMgb3B0aW9ucyBiZSBhc3NpZ25pbmcgbmV3IG9wdGlvbnMgdG8gb2xkIG9uZVxuICovXG5mdW5jdGlvbiBhZGRPcHRpb25zKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGxldCBfb3B0aW9ucyA9IGdldE9wdGlvbnModGFyZ2V0KTtcbiAgICBpZiAoIV9vcHRpb25zKSB7XG4gICAgICAgIF9vcHRpb25zID0ge307XG4gICAgfVxuICAgIHNldE9wdGlvbnModGFyZ2V0LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX29wdGlvbnMpLCBvcHRpb25zKSwgeyB2YWxpZGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX29wdGlvbnMudmFsaWRhdGUgfHwge30pKSwgKG9wdGlvbnMudmFsaWRhdGUgfHwge30pKSB9KSk7XG59XG5leHBvcnRzLmFkZE9wdGlvbnMgPSBhZGRPcHRpb25zO1xuLyoqXG4gKiBNYXBzIGRlc2lnbiB0eXBlcyB0byBzZXF1ZWxpemUgZGF0YSB0eXBlcztcbiAqIEB0aHJvd3MgaWYgZGVzaWduIHR5cGUgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgbWFwcGVkIHRvXG4gKiBhIHNlcXVlbGl6ZSBkYXRhIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VxdWVsaXplVHlwZUJ5RGVzaWduVHlwZSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IHR5cGUgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246dHlwZScsIHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGRhdGFfdHlwZV9zZXJ2aWNlXzEuaW5mZXJEYXRhVHlwZSh0eXBlKTtcbiAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFUeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNwZWNpZmllZCB0eXBlIG9mIHByb3BlcnR5ICcke3Byb3BlcnR5TmFtZX0nXG4gICAgICAgICAgICBjYW5ub3QgYmUgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhIHNlcXVlbGl6ZSBkYXRhIHR5cGUuIFBsZWFzZVxuICAgICAgICAgICAgZGVmaW5lIHRoZSBkYXRhIHR5cGUgbWFudWFsbHlgKTtcbn1cbmV4cG9ydHMuZ2V0U2VxdWVsaXplVHlwZUJ5RGVzaWduVHlwZSA9IGdldFNlcXVlbGl6ZVR5cGVCeURlc2lnblR5cGU7XG4vKipcbiAqIFJlc29sdmVzIGFsbCBtb2RlbCBnZXR0ZXJzIG9mIHNwZWNpZmllZCBvcHRpb25zIG9iamVjdFxuICogcmVjdXJzaXZlbHkuXG4gKiBTbyB0aGF0IHttb2RlbDogKCkgPT4gUGVyc29ufSB3aWxsIGJlIGNvbnZlcnRlZCB0b1xuICoge21vZGVsOiBQZXJzb259XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNb2RlbEdldHRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgbWF5YmVNb2RlbEdldHRlciA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgaXNNb2RlbCA9IHZhbHVlID0+IHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSAmJiB2YWx1ZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBtb2RlbF8xLk1vZGVsO1xuICAgIGNvbnN0IGlzT3B0aW9uT2JqZWN0T3JBcnJheSA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgcmV0dXJuIE9iamVjdFxuICAgICAgICAua2V5cyhvcHRpb25zKVxuICAgICAgICAucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKG1heWJlTW9kZWxHZXR0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXliZU1vZGVsID0gdmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChpc01vZGVsKG1heWJlTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBtYXliZU1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uT2JqZWN0T3JBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gcmVzb2x2ZU1vZGVsR2V0dGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBbLi4ub3B0aW9uc10gOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG59XG5leHBvcnRzLnJlc29sdmVNb2RlbEdldHRlciA9IHJlc29sdmVNb2RlbEdldHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJsZSA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmZ1bmN0aW9uIFRhYmxlKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFubm90YXRlKGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXJnKTtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQpID0+IGFubm90YXRlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuZnVuY3Rpb24gYW5ub3RhdGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuc2V0TW9kZWxOYW1lKHRhcmdldC5wcm90b3R5cGUsIG9wdGlvbnMubW9kZWxOYW1lIHx8IHRhcmdldC5uYW1lKTtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuYWRkT3B0aW9ucyh0YXJnZXQucHJvdG90eXBlLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0U2NvcGUgPSB2b2lkIDA7XG5jb25zdCBzY29wZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zY29wZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIGRlZmluaW5nIGRlZmF1bHQgTW9kZWwgc2NvcGVcbiAqL1xuZnVuY3Rpb24gRGVmYXVsdFNjb3BlKHNjb3BlT3JTc29wZUdldHRlcikge1xuICAgIHJldHVybiAodGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVPclNzb3BlR2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzY29wZV9zZXJ2aWNlXzEuYWRkU2NvcGVPcHRpb25zR2V0dGVyKHRhcmdldC5wcm90b3R5cGUsIHsgZ2V0RGVmYXVsdFNjb3BlOiBzY29wZU9yU3NvcGVHZXR0ZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY29wZV9zZXJ2aWNlXzEuYWRkU2NvcGVPcHRpb25zKHRhcmdldC5wcm90b3R5cGUsIHsgZGVmYXVsdFNjb3BlOiBzY29wZU9yU3NvcGVHZXR0ZXIgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5EZWZhdWx0U2NvcGUgPSBEZWZhdWx0U2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zID0gZXhwb3J0cy5hZGRTY29wZU9wdGlvbnMgPSBleHBvcnRzLnJlc29sdmVzRGVwcmVjYXRlZFNjb3BlcyA9IGV4cG9ydHMuc2V0U2NvcGVPcHRpb25zR2V0dGVycyA9IGV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zR2V0dGVycyA9IGV4cG9ydHMuYWRkU2NvcGVPcHRpb25zR2V0dGVyID0gZXhwb3J0cy5yZXNvbHZlU2NvcGUgPSBleHBvcnRzLnJlc29sdmVTY29wZXMgPSB2b2lkIDA7XG5jb25zdCBvYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvb2JqZWN0XCIpO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuY29uc3QgYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hc3NvY2lhdGlvbnMvYWxpYXMtaW5mZXJlbmNlL2FsaWFzLWluZmVyZW5jZS1zZXJ2aWNlXCIpO1xuY29uc3QgU0NPUEVTX0tFWSA9ICdzZXF1ZWxpemU6c2NvcGVzJztcbmNvbnN0IFNDT1BFU19PUFRJT05TX0tFWSA9ICdzZXF1ZWxpemU6c2NvcGVzLW9wdGlvbnMnO1xuLyoqXG4gKiBSZXNvbHZlcyBzY29wZXMgYW5kIGFkZHMgdGhlbSB0byB0aGUgc3BlY2lmaWVkIG1vZGVsc1xuICovXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVzKG1vZGVscykge1xuICAgIG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcbiAgICAgICAgZXhwb3J0cy5yZXNvbHZlc0RlcHJlY2F0ZWRTY29wZXMobW9kZWwpO1xuICAgICAgICBjb25zdCB7IGdldERlZmF1bHRTY29wZSwgZ2V0U2NvcGVzIH0gPSBleHBvcnRzLmdldFNjb3BlT3B0aW9uc0dldHRlcnMobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGdldERlZmF1bHRTY29wZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZGVmYXVsdFNjb3BlOiBnZXREZWZhdWx0U2NvcGUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0U2NvcGVzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgZ2V0U2NvcGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgICAgLmtleXMob3B0aW9ucylcbiAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiBleHBvcnRzLnJlc29sdmVTY29wZShrZXksIG1vZGVsLCBvcHRpb25zW2tleV0pKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVzb2x2ZVNjb3BlcyA9IHJlc29sdmVTY29wZXM7XG5jb25zdCByZXNvbHZlU2NvcGUgPSAoc2NvcGVOYW1lLCBtb2RlbCwgb3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBmbiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSAoLi4uYXJncykgPT4gYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKGZuKC4uLmFyZ3MpLCBtb2RlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKG9wdGlvbnMsIG1vZGVsKTtcbiAgICB9XG4gICAgbW9kZWwuYWRkU2NvcGUoc2NvcGVOYW1lLCBvcHRpb25zLCB7IG92ZXJyaWRlOiB0cnVlIH0pO1xufTtcbmV4cG9ydHMucmVzb2x2ZVNjb3BlID0gcmVzb2x2ZVNjb3BlO1xuY29uc3QgYWRkU2NvcGVPcHRpb25zR2V0dGVyID0gKHRhcmdldCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRPcHRpb25zID0gZXhwb3J0cy5nZXRTY29wZU9wdGlvbnNHZXR0ZXJzKHRhcmdldCkgfHwge307XG4gICAgZXhwb3J0cy5zZXRTY29wZU9wdGlvbnNHZXR0ZXJzKHRhcmdldCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50T3B0aW9ucyksIG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmFkZFNjb3BlT3B0aW9uc0dldHRlciA9IGFkZFNjb3BlT3B0aW9uc0dldHRlcjtcbmNvbnN0IGdldFNjb3BlT3B0aW9uc0dldHRlcnMgPSAodGFyZ2V0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoU0NPUEVTX09QVElPTlNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zR2V0dGVycyA9IGdldFNjb3BlT3B0aW9uc0dldHRlcnM7XG5jb25zdCBzZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gKHRhcmdldCwgb3B0aW9ucykgPT4ge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoU0NPUEVTX09QVElPTlNfS0VZLCBvcHRpb25zLCB0YXJnZXQpO1xufTtcbmV4cG9ydHMuc2V0U2NvcGVPcHRpb25zR2V0dGVycyA9IHNldFNjb3BlT3B0aW9uc0dldHRlcnM7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IHJlc29sdmVzRGVwcmVjYXRlZFNjb3BlcyA9IChtb2RlbCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRTY29wZU9wdGlvbnMobW9kZWwucHJvdG90eXBlKSB8fCB7fTtcbiAgICBPYmplY3RcbiAgICAgICAgLmtleXMob3B0aW9ucylcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IHJlc29sdmVEZXByZWNhdGVkU2NvcGUoa2V5LCBtb2RlbCwgb3B0aW9uc1trZXldKSk7XG59O1xuZXhwb3J0cy5yZXNvbHZlc0RlcHJlY2F0ZWRTY29wZXMgPSByZXNvbHZlc0RlcHJlY2F0ZWRTY29wZXM7XG4vKipcbiAqIEFkZHMgc2NvcGUgb3B0aW9uIG1ldGEgZGF0YSBmb3Igc3BlY2lmaWVkIHByb3RvdHlwZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gYWRkU2NvcGVPcHRpb25zKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gZ2V0U2NvcGVPcHRpb25zKHRhcmdldCkgfHwge307XG4gICAgc2V0U2NvcGVPcHRpb25zKHRhcmdldCwgb2JqZWN0XzEuZGVlcEFzc2lnbih7fSwgX29wdGlvbnMsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMuYWRkU2NvcGVPcHRpb25zID0gYWRkU2NvcGVPcHRpb25zO1xuLyoqXG4gKiBSZXR1cm5zIHNjb3BlIG9wdGlvbiBtZXRhIGRhdGEgZnJvbSBzcGVjaWZpZWQgdGFyZ2V0XG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBnZXRTY29wZU9wdGlvbnModGFyZ2V0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoU0NPUEVTX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb2JqZWN0XzEuZGVlcEFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY29wZU9wdGlvbnMgPSBnZXRTY29wZU9wdGlvbnM7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEZXByZWNhdGVkU2NvcGUoc2NvcGVOYW1lLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBmbiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSAoLi4uYXJncykgPT4gYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKGZuKC4uLmFyZ3MpLCBtb2RlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKG1vZGVsX3NlcnZpY2VfMS5yZXNvbHZlTW9kZWxHZXR0ZXIob3B0aW9ucyksIG1vZGVsKTtcbiAgICB9XG4gICAgbW9kZWwuYWRkU2NvcGUoc2NvcGVOYW1lLCBvcHRpb25zLCB7IG92ZXJyaWRlOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBTZXQgc2NvcGUgb3B0aW9uIG1ldGEgZGF0YSBmb3Igc3BlY2lmaWVkIHByb3RvdHlwZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gc2V0U2NvcGVPcHRpb25zKHRhcmdldCwgb3B0aW9ucykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoU0NPUEVTX0tFWSwgb3B0aW9ucywgdGFyZ2V0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS10YWJsZS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY29wZXMgPSB2b2lkIDA7XG5jb25zdCBzY29wZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zY29wZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIGRlZmluaW5nIE1vZGVsIHNjb3Blc1xuICovXG5mdW5jdGlvbiBTY29wZXMoc2NvcGVzT3JTY29wZXNHZXR0ZXIpIHtcbiAgICByZXR1cm4gKHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNjb3Blc09yU2NvcGVzR2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzY29wZV9zZXJ2aWNlXzEuYWRkU2NvcGVPcHRpb25zR2V0dGVyKHRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBnZXRTY29wZXM6IHNjb3Blc09yU2NvcGVzR2V0dGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY29wZV9zZXJ2aWNlXzEuYWRkU2NvcGVPcHRpb25zKHRhcmdldC5wcm90b3R5cGUsIHNjb3Blc09yU2NvcGVzR2V0dGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLlNjb3BlcyA9IFNjb3Blcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3Blcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5mZXJEYXRhVHlwZSA9IGV4cG9ydHMuaXNEYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHNlcXVlbGl6ZV8xID0gcmVxdWlyZShcInNlcXVlbGl6ZVwiKTtcbi8qXG4gKiBDaGVja3MgaWYgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc2VxdWVsaXplIGRhdGEgdHlwZSAoQUJTVFJBQ1QsIFNUUklORy4uLilcbiAqL1xuZnVuY3Rpb24gaXNEYXRhVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUoe30pIGluc3RhbmNlb2Ygc2VxdWVsaXplXzEuRGF0YVR5cGVzLkFCU1RSQUNUKSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5BQlNUUkFDVDtcbn1cbmV4cG9ydHMuaXNEYXRhVHlwZSA9IGlzRGF0YVR5cGU7XG4vKipcbiAqIEluZmVycyBzZXF1ZWxpemUgZGF0YSB0eXBlIGJ5IGRlc2lnbiB0eXBlXG4gKi9cbmZ1bmN0aW9uIGluZmVyRGF0YVR5cGUoZGVzaWduVHlwZSkge1xuICAgIHN3aXRjaCAoZGVzaWduVHlwZSkge1xuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuU1RSSU5HO1xuICAgICAgICBjYXNlIEJpZ0ludDpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuQklHSU5UO1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuSU5URUdFUjtcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5CT09MRUFOO1xuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLkRBVEU7XG4gICAgICAgIGNhc2UgQnVmZmVyOlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5CTE9CO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG59XG5leHBvcnRzLmluZmVyRGF0YVR5cGUgPSBpbmZlckRhdGFUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3Qgc2VxdWVsaXplXzEgPSByZXF1aXJlKFwic2VxdWVsaXplXCIpO1xuZXhwb3J0cy5EYXRhVHlwZSA9IHNlcXVlbGl6ZV8xLkRhdGFUeXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcG9zaXRvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZWxpemUtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TW9kZWxzID0gZXhwb3J0cy5wcmVwYXJlQXJncyA9IGV4cG9ydHMucHJlcGFyZU9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBwYXRoXzEgPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGdsb2IgPSByZXF1aXJlKFwiZ2xvYlwiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2FycmF5XCIpO1xuLyoqXG4gKiBQcmVwYXJlcyBzZXF1ZWxpemUgY29uZmlnIHBhc3NlZCB0byBvcmlnaW5hbCBzZXF1ZWxpemUgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlT25seSkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsaWRhdGlvbk9ubHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnByZXBhcmVPcHRpb25zID0gcHJlcGFyZU9wdGlvbnM7XG5mdW5jdGlvbiBwcmVwYXJlQXJncyguLi5hcmdzKSB7XG4gICAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBvcHRpb25zID0gbGFzdEFyZyAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBwcmVwYXJlT3B0aW9ucyhsYXN0QXJnKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBvcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4geyBwcmVwYXJlZEFyZ3M6IGFyZ3MsIG9wdGlvbnMgfTtcbn1cbmV4cG9ydHMucHJlcGFyZUFyZ3MgPSBwcmVwYXJlQXJncztcbmZ1bmN0aW9uIGdldFZhbGlkYXRpb25Pbmx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZGlhbGVjdDogJ3NxbGl0ZScsIGRpYWxlY3RNb2R1bGVQYXRoOiBfX2Rpcm5hbWUgKyAnLy4uL3ZhbGlkYXRpb24tb25seS9kYi1kaWFsZWN0LWR1bW15JyB9KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBtb2RlbHMgZnJvbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRNb2RlbHMoYXJnLCBtb2RlbE1hdGNoKSB7XG4gICAgY29uc3QgaGFzU3VwcG9ydGVkRXh0ZW5zaW9uID0gcGF0aCA9PiBbJy50cycsICcuanMnXS5pbmRleE9mKHBhdGhfMS5leHRuYW1lKHBhdGgpKSAhPT0gLTE7XG4gICAgaWYgKGFyZyAmJiB0eXBlb2YgYXJnWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXJnLnJlZHVjZSgobW9kZWxzLCBkaXIpID0+IHtcbiAgICAgICAgICAgIGlmICghZ2xvYi5oYXNNYWdpYyhkaXIpICYmICFoYXNTdXBwb3J0ZWRFeHRlbnNpb24oZGlyKSlcbiAgICAgICAgICAgICAgICBkaXIgPSBwYXRoXzEuam9pbihkaXIsICcvKicpO1xuICAgICAgICAgICAgY29uc3QgX21vZGVscyA9IGdsb2JcbiAgICAgICAgICAgICAgICAuc3luYyhkaXIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpc0ltcG9ydGFibGUpXG4gICAgICAgICAgICAgICAgLm1hcChnZXRGdWxsZmlsZXBhdGhXaXRob3V0RXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJyYXlfMS51bmlxdWVGaWx0ZXIpXG4gICAgICAgICAgICAgICAgLm1hcChmdWxsUGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gcmVxdWlyZShmdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoXzEuYmFzZW5hbWUoZnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRNZW1iZXJLZXkgPSBPYmplY3Qua2V5cyhtb2R1bGUpLmZpbmQobSA9PiBtb2RlbE1hdGNoKGZpbGVOYW1lLCBtKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZE1lbWJlciA9IG1hdGNoZWRNZW1iZXJLZXkgPyBtb2R1bGVbbWF0Y2hlZE1lbWJlcktleV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkTWVtYmVyICYmICFtb2R1bGUuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmF1bHQgZXhwb3J0IGRlZmluZWQgZm9yIGZpbGUgXCIke2ZpbGVOYW1lfVwiIG9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cG9ydCBkb2VzIG5vdCBzYXRpc2Z5IGZpbGVuYW1lLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZE1lbWJlciB8fCBtb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kZWxzLnB1c2goLi4uX21vZGVscyk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG59XG5leHBvcnRzLmdldE1vZGVscyA9IGdldE1vZGVscztcbi8qKlxuICogQ2hlY2tzIGlmIHNwZWNpZmllZCBmaWxlbmFtZSBpcyBpbXBvcnRhYmxlIG9yIG5vdDtcbiAqIFdoaWNoIG1lYW5zIHRoYXQsIGl0IG5lZWRzIHRvIGhhdmUgYSBzcGVjaWZpYyBmaWxlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiBpc0ltcG9ydGFibGUoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVQYXJ0ID0gZmlsZS5zbGljZSgtMyk7XG4gICAgcmV0dXJuIGZpbGVQYXJ0ID09PSAnLmpzJyB8fCAoZmlsZVBhcnQgPT09ICcudHMnICYmIGZpbGUuc2xpY2UoLTUpICE9PSAnLmQudHMnKTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZnVsbCBwYXRoIHdpdGggZmlsZW5hbWUsIHdpdGhvdXQgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxmaWxlcGF0aFdpdGhvdXRFeHRlbnNpb24oZmlsZSkge1xuICAgIGNvbnN0IHBhcnNlZEZpbGUgPSBwYXRoXzEucGFyc2UoZmlsZSk7XG4gICAgcmV0dXJuIHBhdGhfMS5qb2luKHBhcnNlZEZpbGUuZGlyLCBwYXJzZWRGaWxlLm5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVsaXplLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcXVlbGl6ZSA9IHZvaWQgMDtcbmNvbnN0IHNlcXVlbGl6ZV8xID0gcmVxdWlyZShcInNlcXVlbGl6ZVwiKTtcbmNvbnN0IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL3NoYXJlZC9tb2RlbC1ub3QtaW5pdGlhbGl6ZWQtZXJyb3JcIik7XG5jb25zdCBzZXF1ZWxpemVfc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VxdWVsaXplLXNlcnZpY2VcIik7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5jb25zdCBzY29wZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NvcGVzL3Njb3BlLXNlcnZpY2VcIik7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vaG9va3Mvc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5jb25zdCBpbmRleF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvaW5kZXgvaW5kZXgtc2VydmljZVwiKTtcbmNsYXNzIFNlcXVlbGl6ZSBleHRlbmRzIHNlcXVlbGl6ZV8xLlNlcXVlbGl6ZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCB7IHByZXBhcmVkQXJncywgb3B0aW9ucyB9ID0gc2VxdWVsaXplX3NlcnZpY2VfMS5wcmVwYXJlQXJncyguLi5hcmdzKTtcbiAgICAgICAgc3VwZXIoLi4ucHJlcGFyZWRBcmdzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdG9yeU1vZGUgPSAhIW9wdGlvbnMucmVwb3NpdG9yeU1vZGU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNb2RlbHMob3B0aW9ucy5tb2RlbHMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZWxQYXRocylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1vZGVscyhvcHRpb25zLm1vZGVsUGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0b3J5TW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZGVsKG1vZGVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubW9kZWwobW9kZWxfc2VydmljZV8xLmdldE1vZGVsTmFtZShtb2RlbC5wcm90b3R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIubW9kZWwobW9kZWwpO1xuICAgIH1cbiAgICBhZGRNb2RlbHMoYXJnLCBtb2RlbE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNb2RlbE1hdGNoID0gKGZpbGVuYW1lLCBtZW1iZXIpID0+IGZpbGVuYW1lID09PSBtZW1iZXI7XG4gICAgICAgIGNvbnN0IG1vZGVscyA9IHNlcXVlbGl6ZV9zZXJ2aWNlXzEuZ2V0TW9kZWxzKGFyZywgbW9kZWxNYXRjaCB8fCB0aGlzLm9wdGlvbnMubW9kZWxNYXRjaCB8fCBkZWZhdWx0TW9kZWxNYXRjaCk7XG4gICAgICAgIGNvbnN0IGRlZmluZWRNb2RlbHMgPSB0aGlzLmRlZmluZU1vZGVscyhtb2RlbHMpO1xuICAgICAgICB0aGlzLmFzc29jaWF0ZU1vZGVscyhkZWZpbmVkTW9kZWxzKTtcbiAgICAgICAgc2NvcGVfc2VydmljZV8xLnJlc29sdmVTY29wZXMoZGVmaW5lZE1vZGVscyk7XG4gICAgICAgIGhvb2tzX3NlcnZpY2VfMS5pbnN0YWxsSG9va3MoZGVmaW5lZE1vZGVscyk7XG4gICAgfVxuICAgIGdldFJlcG9zaXRvcnkobW9kZWxDbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbChtb2RlbENsYXNzKTtcbiAgICB9XG4gICAgYXNzb2NpYXRlTW9kZWxzKG1vZGVscykge1xuICAgICAgICBtb2RlbHMuZm9yRWFjaChtb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuZ2V0QXNzb2NpYXRpb25zKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBpZiAoIWFzc29jaWF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhc3NvY2lhdGlvbnMuZm9yRWFjaChhc3NvY2lhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFzc29jaWF0aW9uLmdldFNlcXVlbGl6ZU9wdGlvbnMobW9kZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0ZWRDbGFzcyA9IHRoaXMubW9kZWwoYXNzb2NpYXRpb24uZ2V0QXNzb2NpYXRlZENsYXNzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghYXNzb2NpYXRlZENsYXNzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvcihhc3NvY2lhdGVkQ2xhc3MsIGBBc3NvY2lhdGlvbiBiZXR3ZWVuICR7YXNzb2NpYXRlZENsYXNzLm5hbWV9IGFuZCAke21vZGVsLm5hbWV9IGNhbm5vdCBiZSByZXNvbHZlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZWxbYXNzb2NpYXRpb24uZ2V0QXNzb2NpYXRpb24oKV0oYXNzb2NpYXRlZENsYXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmaW5lTW9kZWxzKG1vZGVscykge1xuICAgICAgICByZXR1cm4gbW9kZWxzLm1hcChtb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSBtb2RlbF9zZXJ2aWNlXzEuZ2V0TW9kZWxOYW1lKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlX3NlcnZpY2VfMS5nZXRBdHRyaWJ1dGVzKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhfc2VydmljZV8xLmdldEluZGV4ZXMobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3B0aW9ucyA9IG1vZGVsX3NlcnZpY2VfMS5nZXRPcHRpb25zKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsT3B0aW9ucylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBUYWJsZSBhbm5vdGF0aW9uIGlzIG1pc3Npbmcgb24gY2xhc3MgXCIke21vZGVsWyduYW1lJ119XCJgKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBPYmplY3Qua2V5cyhpbmRleGVzLm5hbWVkKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IGluZGV4ZXMubmFtZWRba2V5XSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGluZGV4ZXMudW5uYW1lZCk7XG4gICAgICAgICAgICBjb25zdCBpbml0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoaW5kZXhBcnJheS5sZW5ndGggPiAwICYmIHsgaW5kZXhlczogaW5kZXhBcnJheSB9KSksIG1vZGVsT3B0aW9ucyksIHsgbW9kZWxOYW1lLCBzZXF1ZWxpemU6IHRoaXMgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkTW9kZWwgPSB0aGlzLnJlcG9zaXRvcnlNb2RlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNyZWF0ZVJlcG9zaXRvcnlNb2RlbChtb2RlbClcbiAgICAgICAgICAgICAgICA6IG1vZGVsO1xuICAgICAgICAgICAgZGVmaW5lZE1vZGVsLmluaXQoYXR0cmlidXRlcywgaW5pdE9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRNb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVJlcG9zaXRvcnlNb2RlbChtb2RlbENsYXNzKSB7XG4gICAgICAgIHJldHVybiBjbGFzcyBleHRlbmRzIG1vZGVsQ2xhc3Mge1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VxdWVsaXplID0gU2VxdWVsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVsaXplLmpzLm1hcCIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gKCkgPT4gKFtdKTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9zZXF1ZWxpemUgc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRHVtbXkgZGF0YWJhc2UgZmlsZSwgd2hpY2ggZ2V0cyByZXF1aXJlZCBieSBzZXF1ZWxpemUsIHRvXG4gKiBtYWtlIHZhbGlkYXRpb24gb2YgbW9kZWxzIHBvc3NpYmxlIHdpdGhvdXQgdXNpbmcgdGhlXG4gKiBhY3R1YWwgT1JNIG9yIGFueSBkYXRhYmFzZSBjb25uZWN0aW9uLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmJvc2UgPSB2b2lkIDA7XG5mdW5jdGlvbiB2ZXJib3NlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMudmVyYm9zZSA9IHZlcmJvc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYi1kaWFsZWN0LWR1bW15LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmlxdWVGaWx0ZXIgPSBleHBvcnRzLnVuaXF1ZSA9IHZvaWQgMDtcbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gc3BlY2lmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihleHBvcnRzLnVuaXF1ZUZpbHRlcik7XG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGZvciBpdGVtcywgdGhhdCBvbmx5IGV4aXN0cyBvbmNlIG9uIGFuIGFycmF5XG4gKi9cbmNvbnN0IHVuaXF1ZUZpbHRlciA9IChpdGVtLCBpbmRleCwgYXJyKSA9PiBhcnIuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG5leHBvcnRzLnVuaXF1ZUZpbHRlciA9IHVuaXF1ZUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBbGxQcm9wZXJ0eU5hbWVzID0gZXhwb3J0cy5jbG9uZVJlZ0V4cCA9IGV4cG9ydHMuZGVlcEFzc2lnbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgICAgLmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IGFzc2lnbihrZXksIHRhcmdldCwgc291cmNlKSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBPYmplY3RcbiAgICAgICAgICAgICAgICAuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChrZXkgPT4gYXNzaWduKGtleSwgdGFyZ2V0LCBzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gICAgZnVuY3Rpb24gYXNzaWduKGtleSwgX3RhcmdldCwgX3NvdXJjZSkge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IF9zb3VyY2Vba2V5XTtcbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IF90YXJnZXRba2V5XTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGFyZ2V0VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLmZvckVhY2goKF8sIGluZGV4KSA9PiBhc3NpZ24obGVuZ3RoICsgaW5kZXgsIHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IGNsb25lUmVnRXhwKHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gbmV3IERhdGUoc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IE9iamVjdC5jcmVhdGUoc291cmNlVmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWVwQXNzaWduKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90YXJnZXRba2V5XSA9IHRhcmdldFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWVwQXNzaWduID0gZGVlcEFzc2lnbjtcbi8qKlxuICogSSBjbG9uZSB0aGUgZ2l2ZW4gUmVnRXhwIG9iamVjdCwgYW5kIGVuc3VyZSB0aGF0IHRoZSBnaXZlbiBmbGFncyBleGlzdCBvblxuICogdGhlIGNsb25lLiBUaGUgaW5qZWN0RmxhZ3MgcGFyYW1ldGVyIGlzIHB1cmVseSBhZGRpdGl2ZSAtIGl0IGNhbm5vdCByZW1vdmVcbiAqIGZsYWdzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiB0aGVcbiAqXG4gKiBAcGFyYW0gaW5wdXQgUmVnRXhwIC0gSSBhbSB0aGUgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBiZWluZyBjbG9uZWQuXG4gKiBAcGFyYW0gaW5qZWN0RmxhZ3MgU3RyaW5nKCBPcHRpb25hbCApIC0gSSBhbSB0aGUgZmxhZ3MgdG8gZW5mb3JjZSBvbiB0aGUgY2xvbmUuXG4gKiBAc291cmNlIGh0dHBzOi8vd3d3LmJlbm5hZGVsLmNvbS9ibG9nLzI2NjQtY2xvbmluZy1yZWdleHAtcmVndWxhci1leHByZXNzaW9uLW9iamVjdHMtaW4tamF2YXNjcmlwdC5odG1cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAoaW5wdXQsIGluamVjdEZsYWdzKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IGlucHV0LnNvdXJjZTtcbiAgICBsZXQgZmxhZ3MgPSBcIlwiO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyYW1ldGVyIGlzIGEgZGVmaW5lZCBzdHJpbmcgLSBpdCB3aWxsIG1ha2UgdGhlIGNvbmRpdGlvbmFsXG4gICAgLy8gbG9naWMgZWFzaWVyIHRvIHJlYWQuXG4gICAgaW5qZWN0RmxhZ3MgPSAoaW5qZWN0RmxhZ3MgfHwgXCJcIik7XG4gICAgLy8gVGVzdCBmb3IgZ2xvYmFsLlxuICAgIGlmIChpbnB1dC5nbG9iYWwgfHwgKC9nL2kpLnRlc3QoaW5qZWN0RmxhZ3MpKSB7XG4gICAgICAgIGZsYWdzICs9IFwiZ1wiO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBpZ25vcmVDYXNlLlxuICAgIGlmIChpbnB1dC5pZ25vcmVDYXNlIHx8ICgvaS9pKS50ZXN0KGluamVjdEZsYWdzKSkge1xuICAgICAgICBmbGFncyArPSBcImlcIjtcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgbXVsdGlsaW5lLlxuICAgIGlmIChpbnB1dC5tdWx0aWxpbmUgfHwgKC9tL2kpLnRlc3QoaW5qZWN0RmxhZ3MpKSB7XG4gICAgICAgIGZsYWdzICs9IFwibVwiO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBjbG9uZSB3aXRoIHRoZSBhZGRpdGl2ZSBmbGFncy5cbiAgICByZXR1cm4gKG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpKTtcbn1cbmV4cG9ydHMuY2xvbmVSZWdFeHAgPSBjbG9uZVJlZ0V4cDtcbmZ1bmN0aW9uIGdldEFsbFByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBjb25zdCBleGlzdHMgPSB7fTtcbiAgICBkbyB7XG4gICAgICAgIG5hbWVzLnB1c2guYXBwbHkobmFtZXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpO1xuICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICB9IHdoaWxlIChvYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHJldHVybiBuYW1lcy5maWx0ZXIobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSAhZXhpc3RzW25hbWVdICYmIG5hbWUgIT09ICdjb25zdHJ1Y3Rvcic7XG4gICAgICAgIGV4aXN0c1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRBbGxQcm9wZXJ0eU5hbWVzID0gZ2V0QWxsUHJvcGVydHlOYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IHZvaWQgMDtcbi8qKlxuICogQ2FwaXRhbGl6ZSBzcGVjaWZpZWQgc3RyaW5nIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoKTtcbn1cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRhaW5zID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIEZvcmNlIHNwZWNpZmljIHN1YnN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gQ29udGFpbnModmFsdWUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGNvbnRhaW5zOiB2YWx1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLkNvbnRhaW5zID0gQ29udGFpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXF1YWxzID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgYSBzcGVjaWZpYyB2YWx1ZVxuICovXG5mdW5jdGlvbiBFcXVhbHModmFsdWUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGVxdWFsczogdmFsdWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5FcXVhbHMgPSBFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQWZ0ZXIgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyBkYXRlIHN0cmluZ3MgYWZ0ZXIgYSBzcGVjaWZpYyBkYXRlXG4gKi9cbmZ1bmN0aW9uIElzQWZ0ZXIoZGF0ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNBZnRlcjogZGF0ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQWZ0ZXIgPSBJc0FmdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYWZ0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQWxwaGEgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV2lsbCBvbmx5IGFsbG93IGxldHRlcnNcbiAqL1xuZnVuY3Rpb24gSXNBbHBoYSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNBbHBoYTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQWxwaGEgPSBJc0FscGhhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYWxwaGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQWxwaGFudW1lcmljID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdpbGwgb25seSBhbGxvdyBhbHBoYW51bWVyaWMgY2hhcmFjdGVycywgc28gXCJfYWJjXCIgd2lsbCBmYWlsXG4gKi9cbmZ1bmN0aW9uIElzQWxwaGFudW1lcmljKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0FscGhhbnVtZXJpYzogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQWxwaGFudW1lcmljID0gSXNBbHBoYW51bWVyaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hbHBoYW51bWVyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV2lsbCBvbmx5IGFsbG93IGFycmF5c1xuICovXG5mdW5jdGlvbiBJc0FycmF5KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNBcnJheSA9IElzQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNCZWZvcmUgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyBkYXRlIHN0cmluZ3MgYmVmb3JlIGEgc3BlY2lmaWMgZGF0ZVxuICovXG5mdW5jdGlvbiBJc0JlZm9yZShkYXRlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0JlZm9yZTogZGF0ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQmVmb3JlID0gSXNCZWZvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1iZWZvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQ3JlZGl0Q2FyZCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVjayBmb3IgdmFsaWQgY3JlZGl0IGNhcmQgbnVtYmVyc1xuICovXG5mdW5jdGlvbiBJc0NyZWRpdENhcmQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQ3JlZGl0Q2FyZDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQ3JlZGl0Q2FyZCA9IElzQ3JlZGl0Q2FyZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWNyZWRpdC1jYXJkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0RhdGUgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyBkYXRlIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gSXNEYXRlKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0RhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0RhdGUgPSBJc0RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1kYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0RlY2ltYWwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBhbnkgbnVtYmVyc1xuICovXG5mdW5jdGlvbiBJc0RlY2ltYWwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzRGVjaW1hbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzRGVjaW1hbCA9IElzRGVjaW1hbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWRlY2ltYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzRW1haWwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBlbWFpbCBmb3JtYXQgKGZvb0BiYXIuY29tKVxuICovXG5mdW5jdGlvbiBJc0VtYWlsKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0VtYWlsOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNFbWFpbCA9IElzRW1haWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lbWFpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNGbG9hdCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIHZhbGlkIGZsb2F0aW5nIHBvaW50IG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gSXNGbG9hdCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNGbG9hdDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzRmxvYXQgPSBJc0Zsb2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZmxvYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzSW4gPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2sgdGhlIHZhbHVlIGlzIG9uZSBvZiB0aGVzZVxuICovXG5mdW5jdGlvbiBJc0luKGFyZykge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNJbjogYXJnXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNJbiA9IElzSW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNJbnQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciB2YWxpZCBpbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBJc0ludCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNJbnQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0ludCA9IElzSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0lQdjQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBJUHY0ICgxMjkuODkuMjMuMSlcbiAqL1xuZnVuY3Rpb24gSXNJUHY0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0lQdjQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0lQdjQgPSBJc0lQdjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pcC12NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNJUHY2ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgSVB2NiBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gSXNJUHY2KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0lQdjY6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0lQdjYgPSBJc0lQdjY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pcC12Ni5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNJUCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIElQdjQgKDEyOS44OS4yMy4xKSBvciBJUHY2IGZvcm1hdFxuICovXG5mdW5jdGlvbiBJc0lQKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0lQOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNJUCA9IElzSVA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNMb3dlcmNhc2UgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBsb3dlcmNhc2VcbiAqL1xuZnVuY3Rpb24gSXNMb3dlcmNhc2UodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzTG93ZXJjYXNlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNMb3dlcmNhc2UgPSBJc0xvd2VyY2FzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvd2VyY2FzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNOdWxsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3dzIG51bGxcbiAqL1xuZnVuY3Rpb24gSXNOdWxsKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc051bGw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc051bGwgPSBJc051bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1udWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc051bWVyaWMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV2lsbCBvbmx5IGFsbG93IG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gSXNOdW1lcmljKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc051bWVyaWM6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc051bWVyaWMgPSBJc051bWVyaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1udW1lcmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc1VwcGVyY2FzZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIHVwcGVyY2FzZVxuICovXG5mdW5jdGlvbiBJc1VwcGVyY2FzZSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNVcHBlcmNhc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc1VwcGVyY2FzZSA9IElzVXBwZXJjYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdXBwZXJjYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc1VybCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIHVybCBmb3JtYXQgKGh0dHA6Ly9mb28uY29tKVxuICovXG5mdW5jdGlvbiBJc1VybCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNVcmw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc1VybCA9IElzVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdXJsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc1VVSUQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qXG4gKiBPbmx5IGFsbG93IHV1aWRzLlxuICogVmVyc2lvbidzIHJlZ3VsYXIgZXhwcmVzc2lvbnM6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9ibG9iL2I1OTEzM2IxNzI3YjZhZjM1NWI0MDNhOWE5N2ExOTIyNmNjZWIzNGIvbGliL2lzVVVJRC5qcyNMMTQtTDE5LlxuICovXG5mdW5jdGlvbiBJc1VVSUQodmVyc2lvbikge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNVVUlEOiB2ZXJzaW9uXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNVVUlEID0gSXNVVUlEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdXVpZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmZ1bmN0aW9uIElzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgY29uc3QgYXJnSXNGdW5jdGlvbiA9IHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChhcmdJc0Z1bmN0aW9uIHx8ICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGxldCB2YWxpZGF0b3I7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBpZiAoYXJnSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFsaWRhdG9yID0gYXJnc1swXTtcbiAgICAgICAgICAgIG5hbWUgPSB2YWxpZGF0b3IubmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCB2YWxpZGF0b3IgZnVuY3Rpb24gbXVzdCBoYXZlIGEgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YWxpZGF0b3IgPSBhcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNbYGlzJHtuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGgpfWBdID0gdmFsaWRhdG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5pcyA9IGFyZ3NbMF07XG4gICAgfVxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5JcyA9IElzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IHZhbHVlcyB3aXRoIGxlbmd0aCBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gKi9cbmZ1bmN0aW9uIExlbmd0aCh7IG1zZywgbWluLCBtYXggfSkge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IGxlbmd0aCA9IFttaW4gfHwgMCwgbWF4XTtcbiAgICBvcHRpb25zID0gbXNnID8geyBhcmdzOiBsZW5ndGgsIG1zZzogbXNnIH0gOiBsZW5ndGg7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBsZW46IG9wdGlvbnNcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5MZW5ndGggPSBMZW5ndGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IHZhbHVlcyA8PSBsaW1pdFxuICovXG5mdW5jdGlvbiBNYXgobGltaXQpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG1heDogbGltaXRcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5NYXggPSBNYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pbiA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IHZhbHVlcyA+PSBsaW1pdFxuICovXG5mdW5jdGlvbiBNaW4obGltaXQpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG1pbjogbGltaXRcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5NaW4gPSBNaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdENvbnRhaW5zID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIERvbid0IGFsbG93IHNwZWNpZmljIHN1YnN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gTm90Q29udGFpbnModmFsdWUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG5vdENvbnRhaW5zOiB2YWx1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk5vdENvbnRhaW5zID0gTm90Q29udGFpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QtY29udGFpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdEVtcHR5ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBOb3RFbXB0eSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICAgICAgbm90RW1wdHk6IG9wdGlvbnMsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gYXJnc1sxXTtcbiAgICAgICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgICAgIG5vdEVtcHR5OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90RW1wdHkgPSBOb3RFbXB0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC1lbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90SW4gPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2sgdGhlIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlc2VcbiAqL1xuZnVuY3Rpb24gTm90SW4oYXJnKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBub3RJbjogYXJnXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTm90SW4gPSBOb3RJbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC1pbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90TnVsbCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXb24ndCBhbGxvdyBudWxsXG4gKi9cbmZ1bmN0aW9uIE5vdE51bGwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG5vdE51bGw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Ob3ROdWxsID0gTm90TnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC1udWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3QgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV2lsbCBub3QgYWxsb3cgdmFsdWVzLCB0aGF0IG1hdGNoIHRoZSBzdHJpbmcgcmVnZXggb3IgcmVhbCByZWdleFxuICovXG5mdW5jdGlvbiBOb3QoYXJnKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBub3Q6IGFyZ1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk5vdCA9IE5vdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogU2V0cyB2YWxpZGF0aW9uIG9wdGlvbnMgZm9yIGFubm90YXRlZCBmaWVsZFxuICovXG5mdW5jdGlvbiBWYWxpZGF0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5WYWxpZGF0ZSA9IFZhbGlkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRvciA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmNvbnN0IFZhbGlkYXRvciA9ICh0YXJnZXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIG1vZGVsX3NlcnZpY2VfMS5hZGRPcHRpb25zKHRhcmdldCwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgW3Byb3BlcnR5TmFtZV06IGRlc2NyaXB0b3IudmFsdWVcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVmFsaWRhdG9yID0gVmFsaWRhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICogVGhlIGVudHJ5IHBvaW50LlxuICAqXG4gICogQG1vZHVsZSBTZXF1ZWxpemVcbiAgKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc2VxdWVsaXplJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgQXNzb2NpYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnLi8uLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBDcmVhdGluZyBhc3NvY2lhdGlvbnMgaW4gc2VxdWVsaXplIGlzIGRvbmUgYnkgY2FsbGluZyBvbmUgb2YgdGhlIGJlbG9uZ3NUbyAvIGhhc09uZSAvIGhhc01hbnkgLyBiZWxvbmdzVG9NYW55IGZ1bmN0aW9ucyBvbiBhIG1vZGVsICh0aGUgc291cmNlKSwgYW5kIHByb3ZpZGluZyBhbm90aGVyIG1vZGVsIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24gKHRoZSB0YXJnZXQpLlxuICpcbiAqICogaGFzT25lIC0gYWRkcyBhIGZvcmVpZ24ga2V5IHRvIHRoZSB0YXJnZXQgYW5kIHNpbmd1bGFyIGFzc29jaWF0aW9uIG1peGlucyB0byB0aGUgc291cmNlLlxuICogKiBiZWxvbmdzVG8gLSBhZGQgYSBmb3JlaWduIGtleSBhbmQgc2luZ3VsYXIgYXNzb2NpYXRpb24gbWl4aW5zIHRvIHRoZSBzb3VyY2UuXG4gKiAqIGhhc01hbnkgLSBhZGRzIGEgZm9yZWlnbiBrZXkgdG8gdGFyZ2V0IGFuZCBwbHVyYWwgYXNzb2NpYXRpb24gbWl4aW5zIHRvIHRoZSBzb3VyY2UuXG4gKiAqIGJlbG9uZ3NUb01hbnkgLSBjcmVhdGVzIGFuIE46TSBhc3NvY2lhdGlvbiB3aXRoIGEgam9pbiB0YWJsZSBhbmQgYWRkcyBwbHVyYWwgYXNzb2NpYXRpb24gbWl4aW5zIHRvIHRoZSBzb3VyY2UuIFRoZSBqdW5jdGlvbiB0YWJsZSBpcyBjcmVhdGVkIHdpdGggc291cmNlSWQgYW5kIHRhcmdldElkLlxuICpcbiAqIENyZWF0aW5nIGFuIGFzc29jaWF0aW9uIHdpbGwgYWRkIGEgZm9yZWlnbiBrZXkgY29uc3RyYWludCB0byB0aGUgYXR0cmlidXRlcy4gQWxsIGFzc29jaWF0aW9ucyB1c2UgYENBU0NBREVgIG9uIHVwZGF0ZSBhbmQgYFNFVCBOVUxMYCBvbiBkZWxldGUsIGV4Y2VwdCBmb3IgbjptLCB3aGljaCBhbHNvIHVzZXMgYENBU0NBREVgIG9uIGRlbGV0ZS5cbiAqXG4gKiBXaGVuIGNyZWF0aW5nIGFzc29jaWF0aW9ucywgeW91IGNhbiBwcm92aWRlIGFuIGFsaWFzLCB2aWEgdGhlIGBhc2Agb3B0aW9uLiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgc2FtZSBtb2RlbCBpcyBhc3NvY2lhdGVkIHR3aWNlLCBvciB5b3Ugd2FudCB5b3VyIGFzc29jaWF0aW9uIHRvIGJlIGNhbGxlZCBzb21ldGhpbmcgb3RoZXIgdGhhbiB0aGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG1vZGVsLlxuICpcbiAqIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBjYXNlIHdoZXJlIHVzZXJzIGhhdmUgbWFueSBwaWN0dXJlcywgb25lIG9mIHdoaWNoIGlzIHRoZWlyIHByb2ZpbGUgcGljdHVyZS4gQWxsIHBpY3R1cmVzIGhhdmUgYSBgdXNlcklkYCwgYnV0IGluIGFkZGl0aW9uIHRoZSB1c2VyIG1vZGVsIGFsc28gaGFzIGEgYHByb2ZpbGVQaWN0dXJlSWRgLCB0byBiZSBhYmxlIHRvIGVhc2lseSBsb2FkIHRoZSB1c2VyJ3MgcHJvZmlsZSBwaWN0dXJlLlxuICpcbiAqIGBgYGpzXG4gKiBVc2VyLmhhc01hbnkoUGljdHVyZSlcbiAqIFVzZXIuYmVsb25nc1RvKFBpY3R1cmUsIHsgYXM6ICdQcm9maWxlUGljdHVyZScsIGNvbnN0cmFpbnRzOiBmYWxzZSB9KVxuICpcbiAqIHVzZXIuZ2V0UGljdHVyZXMoKSAvLyBnZXRzIHlvdSBhbGwgcGljdHVyZXNcbiAqIHVzZXIuZ2V0UHJvZmlsZVBpY3R1cmUoKSAvLyBnZXRzIHlvdSBvbmx5IHRoZSBwcm9maWxlIHBpY3R1cmVcbiAqXG4gKiBVc2VyLmZpbmRBbGwoe1xuICogICB3aGVyZTogLi4uLFxuICogICBpbmNsdWRlOiBbXG4gKiAgICAgeyBtb2RlbDogUGljdHVyZSB9LCAvLyBsb2FkIGFsbCBwaWN0dXJlc1xuICogICAgIHsgbW9kZWw6IFBpY3R1cmUsIGFzOiAnUHJvZmlsZVBpY3R1cmUnIH0sIC8vIGxvYWQgdGhlIHByb2ZpbGUgcGljdHVyZS5cbiAqICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgc3BlbGxpbmcgbXVzdCBiZSB0aGUgZXhhY3Qgc2FtZSBhcyB0aGUgb25lIGluIHRoZSBhc3NvY2lhdGlvblxuICogICBdXG4gKiB9KVxuICogYGBgXG4gKiBUbyBnZXQgZnVsbCBjb250cm9sIG92ZXIgdGhlIGZvcmVpZ24ga2V5IGNvbHVtbiBhZGRlZCBieSBzZXF1ZWxpemUsIHlvdSBjYW4gdXNlIHRoZSBgZm9yZWlnbktleWAgb3B0aW9uLiBJdCBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nLCB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSwgb3IgYW5kIG9iamVjdCB0eXBlIGRlZmluaXRpb24sXG4gKiBlcXVpdmFsZW50IHRvIHRob3NlIHBhc3NlZCB0byBgc2VxdWVsaXplLmRlZmluZWAuXG4gKlxuICogYGBganNcbiAqIFVzZXIuaGFzTWFueShQaWN0dXJlLCB7IGZvcmVpZ25LZXk6ICd1aWQnIH0pXG4gKiBgYGBcbiAqXG4gKiBUaGUgZm9yZWlnbiBrZXkgY29sdW1uIGluIFBpY3R1cmUgd2lsbCBub3cgYmUgY2FsbGVkIGB1aWRgIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYHVzZXJJZGAuXG4gKlxuICogYGBganNcbiAqIFVzZXIuaGFzTWFueShQaWN0dXJlLCB7XG4gKiAgIGZvcmVpZ25LZXk6IHtcbiAqICAgICBuYW1lOiAndWlkJyxcbiAqICAgICBhbGxvd051bGw6IGZhbHNlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBUaGlzIHNwZWNpZmllcyB0aGF0IHRoZSBgdWlkYCBjb2x1bW4gY2Fubm90IGJlIG51bGwuIEluIG1vc3QgY2FzZXMgdGhpcyB3aWxsIGFscmVhZHkgYmUgY292ZXJlZCBieSB0aGUgZm9yZWlnbiBrZXkgY29uc3RyYWludHMsIHdoaWNoIHNlcXVlbGl6ZSBjcmVhdGVzIGF1dG9tYXRpY2FsbHksIGJ1dCBjYW4gYmUgdXNlZnVsIGluIGNhc2Ugd2hlcmUgdGhlIGZvcmVpZ24ga2V5cyBhcmUgZGlzYWJsZWQsIGUuZy4gZHVlIHRvIGNpcmN1bGFyIHJlZmVyZW5jZXMgKHNlZSBgY29uc3RyYWludHM6IGZhbHNlYCBiZWxvdykuXG4gKlxuICogV2hlbiBmZXRjaGluZyBhc3NvY2lhdGVkIG1vZGVscywgeW91IGNhbiBsaW1pdCB5b3VyIHF1ZXJ5IHRvIG9ubHkgbG9hZCBzb21lIG1vZGVscy4gVGhlc2UgcXVlcmllcyBhcmUgd3JpdHRlbiBpbiB0aGUgc2FtZSB3YXkgYXMgcXVlcmllcyB0byBgZmluZGAvYGZpbmRBbGxgLiBUbyBvbmx5IGdldCBwaWN0dXJlcyBpbiBKUEcsIHlvdSBjYW4gZG86XG4gKlxuICogYGBganNcbiAqIHVzZXIuZ2V0UGljdHVyZXMoe1xuICogICB3aGVyZToge1xuICogICAgIGZvcm1hdDogJ2pwZydcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIHdheXMgdG8gdXBkYXRlIGFuZCBhZGQgbmV3IGFzc29jaWF0aW9ucy4gQ29udGludWluZyB3aXRoIG91ciBleGFtcGxlIG9mIHVzZXJzIGFuZCBwaWN0dXJlczpcbiAqIGBgYGpzXG4gKiB1c2VyLmFkZFBpY3R1cmUocCkgLy8gQWRkIGEgc2luZ2xlIHBpY3R1cmVcbiAqIHVzZXIuc2V0UGljdHVyZXMoW3AxLCBwMl0pIC8vIEFzc29jaWF0ZSB1c2VyIHdpdGggT05MWSB0aGVzZSB0d28gcGljdHVyZSwgYWxsIG90aGVyIGFzc29jaWF0aW9ucyB3aWxsIGJlIGRlbGV0ZWRcbiAqIHVzZXIuYWRkUGljdHVyZXMoW3AxLCBwMl0pIC8vIEFzc29jaWF0ZSB1c2VyIHdpdGggdGhlc2UgdHdvIHBpY3R1cmVzLCBidXQgZG9uJ3QgdG91Y2ggYW55IGN1cnJlbnQgYXNzb2NpYXRpb25zXG4gKiBgYGBcbiAqXG4gKiBZb3UgZG9uJ3QgaGF2ZSB0byBwYXNzIGluIGEgY29tcGxldGUgb2JqZWN0IHRvIHRoZSBhc3NvY2lhdGlvbiBmdW5jdGlvbnMsIGlmIHlvdXIgYXNzb2NpYXRlZCBtb2RlbCBoYXMgYSBzaW5nbGUgcHJpbWFyeSBrZXk6XG4gKlxuICogYGBganNcbiAqIHVzZXIuYWRkUGljdHVyZShyZXEucXVlcnkucGlkKSAvLyBIZXJlIHBpZCBpcyBqdXN0IGFuIGludGVnZXIsIHJlcHJlc2VudGluZyB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIHBpY3R1cmVcbiAqIGBgYFxuICpcbiAqIEluIHRoZSBleGFtcGxlIGFib3ZlIHdlIGhhdmUgc3BlY2lmaWVkIHRoYXQgYSB1c2VyIGJlbG9uZ3MgdG8gaGlzIHByb2ZpbGUgcGljdHVyZS4gQ29uY2VwdHVhbGx5LCB0aGlzIG1pZ2h0IG5vdCBtYWtlIHNlbnNlLCBidXQgc2luY2Ugd2Ugd2FudCB0byBhZGQgdGhlIGZvcmVpZ24ga2V5IHRvIHRoZSB1c2VyIG1vZGVsIHRoaXMgaXMgdGhlIHdheSB0byBkbyBpdC5cbiAqXG4gKiBOb3RlIGhvdyB3ZSBhbHNvIHNwZWNpZmllZCBgY29uc3RyYWludHM6IGZhbHNlYCBmb3IgcHJvZmlsZSBwaWN0dXJlLiBUaGlzIGlzIGJlY2F1c2Ugd2UgYWRkIGEgZm9yZWlnbiBrZXkgZnJvbSB1c2VyIHRvIHBpY3R1cmUgKHByb2ZpbGVQaWN0dXJlSWQpLCBhbmQgZnJvbSBwaWN0dXJlIHRvIHVzZXIgKHVzZXJJZCkuIElmIHdlIHdlcmUgdG8gYWRkIGZvcmVpZ24ga2V5cyB0byBib3RoLCBpdCB3b3VsZCBjcmVhdGUgYSBjeWNsaWMgZGVwZW5kZW5jeSwgYW5kIHNlcXVlbGl6ZSB3b3VsZCBub3Qga25vdyB3aGljaCB0YWJsZSB0byBjcmVhdGUgZmlyc3QsIHNpbmNlIHVzZXIgZGVwZW5kcyBvbiBwaWN0dXJlLCBhbmQgcGljdHVyZSBkZXBlbmRzIG9uIHVzZXIuIFRoZXNlIGtpbmRzIG9mIHByb2JsZW1zIGFyZSBkZXRlY3RlZCBieSBzZXF1ZWxpemUgYmVmb3JlIHRoZSBtb2RlbHMgYXJlIHN5bmNlZCB0byB0aGUgZGF0YWJhc2UsIGFuZCB5b3Ugd2lsbCBnZXQgYW4gZXJyb3IgYWxvbmcgdGhlIGxpbmVzIG9mIGBFcnJvcjogQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQuICd1c2VycycgaXMgZGVwZW5kZW50IG9mIGl0c2VsZmAuIElmIHlvdSBlbmNvdW50ZXIgdGhpcywgeW91IHNob3VsZCBlaXRoZXIgZGlzYWJsZSBzb21lIGNvbnN0cmFpbnRzLCBvciByZXRoaW5rIHlvdXIgYXNzb2NpYXRpb25zIGNvbXBsZXRlbHkuXG4gKi9cbmNsYXNzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNb2RlbH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNb2RlbH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGU7XG4gICAgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA9IHRoaXMuc291cmNlID09PSB0aGlzLnRhcmdldDtcbiAgICB0aGlzLmFzID0gb3B0aW9ucy5hcztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBhc3NvY2lhdGlvbi4gT25lIG9mIGBIYXNNYW55YCwgYEJlbG9uZ3NUb2AsIGBIYXNPbmVgLCBgQmVsb25nc1RvTWFueWBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSAnJztcblxuICAgIGlmIChzb3VyY2UuaGFzQWxpYXMob3B0aW9ucy5hcykpIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKGBZb3UgaGF2ZSB1c2VkIHRoZSBhbGlhcyAke29wdGlvbnMuYXN9IGluIHR3byBzZXBhcmF0ZSBhc3NvY2lhdGlvbnMuIGAgK1xuICAgICAgJ0FsaWFzZWQgYXNzb2NpYXRpb25zIG11c3QgaGF2ZSB1bmlxdWUgYWxpYXNlcy4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGlucHV0IGl0IG1heSBiZSBhcnJheSBvciBzaW5nbGUgb2JqLCBpbnN0YW5jZSBvciBwcmltYXJ5IGtleVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGJ1aWx0IG9iamVjdHNcbiAgICovXG4gIHRvSW5zdGFuY2VBcnJheShpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIGlucHV0ID0gW2lucHV0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkgcmV0dXJuIGVsZW1lbnQ7XG5cbiAgICAgIGNvbnN0IHRtcEluc3RhbmNlID0ge307XG4gICAgICB0bXBJbnN0YW5jZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IGVsZW1lbnQ7XG5cbiAgICAgIHJldHVybiB0aGlzLnRhcmdldC5idWlsZCh0bXBJbnN0YW5jZSwgeyBpc05ld1JlY29yZDogZmFsc2UgfSk7XG4gICAgfSk7XG4gIH1cblxuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NvY2lhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi9iZWxvbmdzLXRvJyk7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZSgnLi9oYXMtbWFueScpO1xuY29uc3QgSGFzT25lID0gcmVxdWlyZSgnLi9oYXMtb25lJyk7XG5jb25zdCBBc3NvY2lhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuQXNzb2NpYXRpb25FcnJvcjtcbmNvbnN0IEVtcHR5UmVzdWx0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5FbXB0eVJlc3VsdEVycm9yO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuLyoqXG4gKiBNYW55LXRvLW1hbnkgYXNzb2NpYXRpb24gd2l0aCBhIGpvaW4gdGFibGUuXG4gKlxuICogV2hlbiB0aGUgam9pbiB0YWJsZSBoYXMgYWRkaXRpb25hbCBhdHRyaWJ1dGVzLCB0aGVzZSBjYW4gYmUgcGFzc2VkIGluIHRoZSBvcHRpb25zIG9iamVjdDpcbiAqXG4gKiBgYGBqc1xuICogVXNlclByb2plY3QgPSBzZXF1ZWxpemUuZGVmaW5lKCd1c2VyX3Byb2plY3QnLCB7XG4gKiAgIHJvbGU6IFNlcXVlbGl6ZS5TVFJJTkdcbiAqIH0pO1xuICogVXNlci5iZWxvbmdzVG9NYW55KFByb2plY3QsIHsgdGhyb3VnaDogVXNlclByb2plY3QgfSk7XG4gKiBQcm9qZWN0LmJlbG9uZ3NUb01hbnkoVXNlciwgeyB0aHJvdWdoOiBVc2VyUHJvamVjdCB9KTtcbiAqIC8vIHRocm91Z2ggaXMgcmVxdWlyZWQhXG4gKlxuICogdXNlci5hZGRQcm9qZWN0KHByb2plY3QsIHsgdGhyb3VnaDogeyByb2xlOiAnbWFuYWdlcicgfX0pO1xuICogYGBgXG4gKlxuICogQWxsIG1ldGhvZHMgYWxsb3cgeW91IHRvIHBhc3MgZWl0aGVyIGEgcGVyc2lzdGVkIGluc3RhbmNlLCBpdHMgcHJpbWFyeSBrZXksIG9yIGEgbWl4dHVyZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHJvamVjdCA9IGF3YWl0IFByb2plY3QuY3JlYXRlKHsgaWQ6IDExIH0pO1xuICogYXdhaXQgdXNlci5hZGRQcm9qZWN0cyhbcHJvamVjdCwgMTJdKTtcbiAqIGBgYFxuICpcbiAqIElmIHlvdSB3YW50IHRvIHNldCBzZXZlcmFsIHRhcmdldCBpbnN0YW5jZXMsIGJ1dCB3aXRoIGRpZmZlcmVudCBhdHRyaWJ1dGVzIHlvdSBoYXZlIHRvIHNldCB0aGUgYXR0cmlidXRlcyBvbiB0aGUgaW5zdGFuY2UsIHVzaW5nIGEgcHJvcGVydHkgd2l0aCB0aGUgbmFtZSBvZiB0aGUgdGhyb3VnaCBtb2RlbDpcbiAqXG4gKiBgYGBqc1xuICogcDEuVXNlclByb2plY3RzID0ge1xuICogICBzdGFydGVkOiB0cnVlXG4gKiB9XG4gKiB1c2VyLnNldFByb2plY3RzKFtwMSwgcDJdLCB7IHRocm91Z2g6IHsgc3RhcnRlZDogZmFsc2UgfX0pIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLCBidXQgcDEgb3ZlcnJpZGVzIHRoYXQuXG4gKiBgYGBcbiAqXG4gKiBTaW1pbGFybHksIHdoZW4gZmV0Y2hpbmcgdGhyb3VnaCBhIGpvaW4gdGFibGUgd2l0aCBjdXN0b20gYXR0cmlidXRlcywgdGhlc2UgYXR0cmlidXRlcyB3aWxsIGJlIGF2YWlsYWJsZSBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgdGhyb3VnaCBtb2RlbC5cbiAqIGBgYGpzXG4gKiBjb25zdCBwcm9qZWN0cyA9IGF3YWl0IHVzZXIuZ2V0UHJvamVjdHMoKTtcbiAqIGNvbnN0IHAxID0gcHJvamVjdHNbMF07XG4gKiBwMS5Vc2VyUHJvamVjdHMuc3RhcnRlZCAvLyBJcyB0aGlzIHByb2plY3Qgc3RhcnRlZCB5ZXQ/XG4gKiB9KVxuICogYGBgXG4gKlxuICogSW4gdGhlIEFQSSByZWZlcmVuY2UgYmVsb3csIGFkZCB0aGUgbmFtZSBvZiB0aGUgYXNzb2NpYXRpb24gdG8gdGhlIG1ldGhvZCwgZS5nLiBmb3IgYFVzZXIuYmVsb25nc1RvTWFueShQcm9qZWN0KWAgdGhlIGdldHRlciB3aWxsIGJlIGB1c2VyLmdldFByb2plY3RzKClgLlxuICpcbiAqIEBzZWUge0BsaW5rIE1vZGVsLmJlbG9uZ3NUb01hbnl9XG4gKi9cbmNsYXNzIEJlbG9uZ3NUb01hbnkgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLnRocm91Z2ggPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnRocm91Z2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKGAke3NvdXJjZS5uYW1lfS5iZWxvbmdzVG9NYW55KCR7dGFyZ2V0Lm5hbWV9KSByZXF1aXJlcyB0aHJvdWdoIG9wdGlvbiwgcGFzcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSBtb2RlbGApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50aHJvdWdoID0ge1xuICAgICAgICBtb2RlbDogb3B0aW9ucy50aHJvdWdoXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gJ0JlbG9uZ3NUb01hbnknO1xuICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc291cmNlLnNlcXVlbGl6ZTtcbiAgICB0aGlzLnRocm91Z2ggPSB7IC4uLnRoaXMub3B0aW9ucy50aHJvdWdoIH07XG4gICAgdGhpcy5pc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZG91YmxlTGlua2VkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuYXMgJiYgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoJ1xcJ2FzXFwnIG11c3QgYmUgZGVmaW5lZCBmb3IgbWFueS10by1tYW55IHNlbGYtYXNzb2NpYXRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLmFzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMuYXM7XG4gICAgICAgIHRoaXMuYXMgPSB0aGlzLmFzLnBsdXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICAgIHBsdXJhbDogdGhpcy5hcyxcbiAgICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5wbHVyYWw7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbWJpbmVkVGFibGVOYW1lID0gVXRpbHMuY29tYmluZVRhYmxlTmFtZXMoXG4gICAgICB0aGlzLnNvdXJjZS50YWJsZU5hbWUsXG4gICAgICB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID8gdGhpcy5hcyB8fCB0aGlzLnRhcmdldC50YWJsZU5hbWUgOiB0aGlzLnRhcmdldC50YWJsZU5hbWVcbiAgICApO1xuXG4gICAgLypcbiAgICAqIElmIHNlbGYgYXNzb2NpYXRpb24sIHRoaXMgaXMgdGhlIHRhcmdldCBhc3NvY2lhdGlvbiAtIFVubGVzcyB3ZSBmaW5kIGEgcGFpcmluZyBhc3NvY2lhdGlvblxuICAgICovXG4gICAgaWYgKHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBGaW5kIHBhaXJlZCBhc3NvY2lhdGlvbiAoaWYgZXhpc3RzKVxuICAgICovXG4gICAgXy5lYWNoKHRoaXMudGFyZ2V0LmFzc29jaWF0aW9ucywgYXNzb2NpYXRpb24gPT4ge1xuICAgICAgaWYgKGFzc29jaWF0aW9uLmFzc29jaWF0aW9uVHlwZSAhPT0gJ0JlbG9uZ3NUb01hbnknKSByZXR1cm47XG4gICAgICBpZiAoYXNzb2NpYXRpb24udGFyZ2V0ICE9PSB0aGlzLnNvdXJjZSkgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2gubW9kZWwgPT09IGFzc29jaWF0aW9uLm9wdGlvbnMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgICB0aGlzLnBhaXJlZCA9IGFzc29jaWF0aW9uO1xuICAgICAgICBhc3NvY2lhdGlvbi5wYWlyZWQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAqIERlZmF1bHQvZ2VuZXJhdGVkIHNvdXJjZS90YXJnZXQga2V5c1xuICAgICovXG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRLZXkpIHtcbiAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5vcHRpb25zLnRhcmdldEtleTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRLZXlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMudGhyb3VnaC5tb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuaXNEZWZpbmVkKHRoaXMudGhyb3VnaC5tb2RlbCkpIHtcbiAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsID0gdGhpcy5zZXF1ZWxpemUuZGVmaW5lKHRoaXMudGhyb3VnaC5tb2RlbCwge30sIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgdGFibGVOYW1lOiB0aGlzLnRocm91Z2gubW9kZWwsXG4gICAgICAgICAgaW5kZXhlczogW10sIC8vd2UgZG9uJ3Qgd2FudCBpbmRleGVzIGhlcmUgKGFzIHJlZmVyZW5jZWQgaW4gIzI0MTYpXG4gICAgICAgICAgcGFyYW5vaWQ6IHRoaXMudGhyb3VnaC5wYXJhbm9pZCA/IHRoaXMudGhyb3VnaC5wYXJhbm9pZCA6IGZhbHNlLCAvLyBEZWZhdWx0IHRvIG5vbi1wYXJhbm9pZCBqb2luIChyZWZlcmVuY2VkIGluICMxMTk5MSlcbiAgICAgICAgICB2YWxpZGF0ZToge30gLy8gRG9uJ3QgcHJvcGFnYXRlIG1vZGVsLWxldmVsIHZhbGlkYXRpb25zXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbCA9IHRoaXMuc2VxdWVsaXplLm1vZGVsKHRoaXMudGhyb3VnaC5tb2RlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIF8ucGljayh0aGlzLnRocm91Z2gubW9kZWwub3B0aW9ucywgW1xuICAgICAgJ3RpbWVzdGFtcHMnLCAnY3JlYXRlZEF0JywgJ3VwZGF0ZWRBdCcsICdkZWxldGVkQXQnLCAncGFyYW5vaWQnXG4gICAgXSkpO1xuXG4gICAgaWYgKHRoaXMucGFpcmVkKSB7XG4gICAgICBsZXQgbmVlZEluamVjdFBhaXJlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy50YXJnZXRLZXlEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5wYWlyZWQuc291cmNlS2V5O1xuICAgICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy5wYWlyZWQuc291cmNlS2V5RmllbGQ7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaXJlZC50YXJnZXRLZXlEZWZhdWx0KSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSBwYWlyZWQub3RoZXJLZXkgZGVwZW5kcyBvbiBwYWlyZWQudGFyZ2V0S2V5LFxuICAgICAgICAvLyBzbyBjbGVhbnVwIHByZXZpb3VzbHkgd3JvbmcgZ2VuZXJhdGVkIG90aGVyS2V5XG4gICAgICAgIGlmICh0aGlzLnBhaXJlZC50YXJnZXRLZXkgIT09IHRoaXMuc291cmNlS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC50YXJnZXRLZXkgPSB0aGlzLnNvdXJjZUtleTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC50YXJnZXRLZXlGaWVsZCA9IHRoaXMuc291cmNlS2V5RmllbGQ7XG4gICAgICAgICAgdGhpcy5wYWlyZWQuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcbiAgICAgICAgICBuZWVkSW5qZWN0UGFpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMucGFpcmVkLmZvcmVpZ25LZXk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWlyZWQub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICAgIC8vIElmIHBhaXJlZCBvdGhlcktleSB3YXMgaW5mZXJyZWQgd2Ugc2hvdWxkIG1ha2Ugc3VyZSB0byBjbGVhbiBpdCB1cFxuICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIGEgbmV3IG9uZSB0aGF0IG1hdGNoZXMgdGhlIGZvcmVpZ25LZXlcbiAgICAgICAgaWYgKHRoaXMucGFpcmVkLm90aGVyS2V5ICE9PSB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldO1xuICAgICAgICAgIHRoaXMucGFpcmVkLm90aGVyS2V5ID0gdGhpcy5mb3JlaWduS2V5O1xuICAgICAgICAgIG5lZWRJbmplY3RQYWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkSW5qZWN0UGFpcmVkKSB7XG4gICAgICAgIHRoaXMucGFpcmVkLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGhyb3VnaCkge1xuICAgICAgdGhpcy50aHJvdWdoTW9kZWwgPSB0aGlzLnRocm91Z2gubW9kZWw7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnRhYmxlTmFtZSA9IHRoaXMuY29tYmluZWROYW1lID0gdGhpcy50aHJvdWdoLm1vZGVsID09PSBPYmplY3QodGhpcy50aHJvdWdoLm1vZGVsKSA/IHRoaXMudGhyb3VnaC5tb2RlbC50YWJsZU5hbWUgOiB0aGlzLnRocm91Z2gubW9kZWw7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuXG4gICAgLy8gR2V0IHNpbmd1bGFyIGFuZCBwbHVyYWwgbmFtZXMsIHRyeWluZyB0byB1cHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciwgdW5sZXNzIHRoZSBtb2RlbCBmb3JiaWRzIGl0XG4gICAgY29uc3QgcGx1cmFsID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnBsdXJhbCk7XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuXG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3BsdXJhbH1gLFxuICAgICAgc2V0OiBgc2V0JHtwbHVyYWx9YCxcbiAgICAgIGFkZE11bHRpcGxlOiBgYWRkJHtwbHVyYWx9YCxcbiAgICAgIGFkZDogYGFkZCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZTogYHJlbW92ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBgcmVtb3ZlJHtwbHVyYWx9YCxcbiAgICAgIGhhc1NpbmdsZTogYGhhcyR7c2luZ3VsYXJ9YCxcbiAgICAgIGhhc0FsbDogYGhhcyR7cGx1cmFsfWAsXG4gICAgICBjb3VudDogYGNvdW50JHtwbHVyYWx9YFxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpIHtcbiAgICAvKlxuICAgICogRGVmYXVsdC9nZW5lcmF0ZWQgZm9yZWlnbi9vdGhlciBrZXlzXG4gICAgKi9cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleSB8fCBVdGlscy5jYW1lbGl6ZShcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMuc291cmNlLm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgICB0aGlzLnNvdXJjZUtleVxuICAgICAgICBdLmpvaW4oJ18nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMub3RoZXJLZXkpKSB7XG4gICAgICB0aGlzLm90aGVyS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLm90aGVyS2V5O1xuICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLm90aGVyS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3RoZXJLZXkpIHtcbiAgICAgICAgdGhpcy5vdGhlcktleURlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm90aGVyS2V5QXR0cmlidXRlID0ge307XG4gICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5vcHRpb25zLm90aGVyS2V5IHx8IFV0aWxzLmNhbWVsaXplKFxuICAgICAgICBbXG4gICAgICAgICAgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA/IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpIDogdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICAgIHRoaXMudGFyZ2V0S2V5XG4gICAgICAgIF0uam9pbignXycpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBpZCBpcyBpbiB0aGUgdGFyZ2V0IHRhYmxlXG4gIC8vIG9yIGluIGFuIGV4dHJhIHRhYmxlIHdoaWNoIGNvbm5lY3RzIHR3byB0YWJsZXNcbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5pZGVudGlmaWVyID0gdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbklkZW50aWZpZXIgPSB0aGlzLm90aGVyS2V5O1xuXG4gICAgLy8gcmVtb3ZlIGFueSBQS3MgcHJldmlvdXNseSBkZWZpbmVkIGJ5IHNlcXVlbGl6ZVxuICAgIC8vIGJ1dCBpZ25vcmUgYW55IGtleXMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIGFzc29jaWF0aW9uICgjNTg2NSlcbiAgICBfLmVhY2godGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpID0+IHtcbiAgICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSA9PT0gdHJ1ZSAmJiBhdHRyaWJ1dGUuX2F1dG9HZW5lcmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IHRoaXMuZm9yZWlnbktleSB8fCBhdHRyaWJ1dGVOYW1lID09PSB0aGlzLm90aGVyS2V5KSB7XG4gICAgICAgICAgLy8gdGhpcyBrZXkgaXMgc3RpbGwgbmVlZGVkIGFzIGl0J3MgcGFydCBvZiB0aGUgYXNzb2NpYXRpb25cbiAgICAgICAgICAvLyBzbyBqdXN0IHNldCBwcmltYXJ5S2V5IHRvIGZhbHNlXG4gICAgICAgICAgYXR0cmlidXRlLnByaW1hcnlLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmltYXJ5S2V5RGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzb3VyY2VLZXkgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XTtcbiAgICBjb25zdCBzb3VyY2VLZXlUeXBlID0gc291cmNlS2V5LnR5cGU7XG4gICAgY29uc3Qgc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZUtleUZpZWxkO1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldO1xuICAgIGNvbnN0IHRhcmdldEtleVR5cGUgPSB0YXJnZXRLZXkudHlwZTtcbiAgICBjb25zdCB0YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0S2V5RmllbGQ7XG4gICAgY29uc3Qgc291cmNlQXR0cmlidXRlID0geyB0eXBlOiBzb3VyY2VLZXlUeXBlLCAuLi50aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgfTtcbiAgICBjb25zdCB0YXJnZXRBdHRyaWJ1dGUgPSB7IHR5cGU6IHRhcmdldEtleVR5cGUsIC4uLnRoaXMub3RoZXJLZXlBdHRyaWJ1dGUgfTtcblxuICAgIGlmICh0aGlzLnByaW1hcnlLZXlEZWxldGVkID09PSB0cnVlKSB7XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUucHJpbWFyeUtleSA9IHNvdXJjZUF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGhyb3VnaC51bmlxdWUgIT09IGZhbHNlKSB7XG4gICAgICBsZXQgdW5pcXVlS2V5O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudW5pcXVlS2V5ID09PSAnc3RyaW5nJyAmJiB0aGlzLm9wdGlvbnMudW5pcXVlS2V5ICE9PSAnJykge1xuICAgICAgICB1bmlxdWVLZXkgPSB0aGlzLm9wdGlvbnMudW5pcXVlS2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gW3RoaXMudGhyb3VnaC5tb2RlbC50YWJsZU5hbWUsIHRoaXMuZm9yZWlnbktleSwgdGhpcy5vdGhlcktleSwgJ3VuaXF1ZSddLmpvaW4oJ18nKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldEF0dHJpYnV0ZS51bmlxdWUgPSBzb3VyY2VBdHRyaWJ1dGUudW5pcXVlID0gdW5pcXVlS2V5O1xuICAgIH1cblxuICAgIGlmICghdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSkge1xuICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0gPSB7XG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMuc291cmNlLmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IHNvdXJjZUtleUZpZWxkXG4gICAgICB9O1xuICAgICAgLy8gRm9yIHRoZSBzb3VyY2UgYXR0cmlidXRlIHRoZSBwYXNzZWQgb3B0aW9uIGlzIHRoZSBwcmlvcml0eVxuICAgICAgc291cmNlQXR0cmlidXRlLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0ub25EZWxldGU7XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5vblVwZGF0ZTtcblxuICAgICAgaWYgKCFzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUpIHNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSA9ICdDQVNDQURFJztcbiAgICAgIGlmICghc291cmNlQXR0cmlidXRlLm9uVXBkYXRlKSBzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUgPSAnQ0FTQ0FERSc7XG5cbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogdGhpcy50YXJnZXQuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleTogdGFyZ2V0S2V5RmllbGRcbiAgICAgIH07XG4gICAgICAvLyBCdXQgdGhlIGZvciB0YXJnZXQgYXR0cmlidXRlIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgb3B0aW9uIGlzIHRoZSBwcmlvcml0eSAoc2luY2UgaXQgY291bGQndmUgYmVlbiBzZXQgYnkgYW5vdGhlciBiZWxvbmdzVG9NYW55IGNhbGwpXG4gICAgICB0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5vbkRlbGV0ZSB8fCB0aGlzLm9wdGlvbnMub25EZWxldGU7XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5vblVwZGF0ZSB8fCB0aGlzLm9wdGlvbnMub25VcGRhdGU7XG5cbiAgICAgIGlmICghdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlKSB0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUgPSAnQ0FTQ0FERSc7XG4gICAgICBpZiAoIXRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSkgdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlID0gJ0NBU0NBREUnO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgc291cmNlQXR0cmlidXRlKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLCB0YXJnZXRBdHRyaWJ1dGUpO1xuXG4gICAgdGhpcy50aHJvdWdoLm1vZGVsLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG5cbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbklkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLmZpZWxkIHx8IHRoaXMub3RoZXJLZXk7XG5cbiAgICBpZiAodGhpcy5wYWlyZWQgJiYgIXRoaXMucGFpcmVkLmZvcmVpZ25JZGVudGlmaWVyRmllbGQpIHtcbiAgICAgIHRoaXMucGFpcmVkLmZvcmVpZ25JZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV0uZmllbGQgfHwgdGhpcy5wYWlyZWQub3RoZXJLZXk7XG4gICAgfVxuXG4gICAgdGhpcy50b1NvdXJjZSA9IG5ldyBCZWxvbmdzVG8odGhpcy50aHJvdWdoLm1vZGVsLCB0aGlzLnNvdXJjZSwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5XG4gICAgfSk7XG4gICAgdGhpcy5tYW55RnJvbVNvdXJjZSA9IG5ldyBIYXNNYW55KHRoaXMuc291cmNlLCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleVxuICAgIH0pO1xuICAgIHRoaXMub25lRnJvbVNvdXJjZSA9IG5ldyBIYXNPbmUodGhpcy5zb3VyY2UsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5LFxuICAgICAgc291cmNlS2V5OiB0aGlzLnNvdXJjZUtleSxcbiAgICAgIGFzOiB0aGlzLnRocm91Z2gubW9kZWwubmFtZVxuICAgIH0pO1xuXG4gICAgdGhpcy50b1RhcmdldCA9IG5ldyBCZWxvbmdzVG8odGhpcy50aHJvdWdoLm1vZGVsLCB0aGlzLnRhcmdldCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleVxuICAgIH0pO1xuICAgIHRoaXMubWFueUZyb21UYXJnZXQgPSBuZXcgSGFzTWFueSh0aGlzLnRhcmdldCwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5XG4gICAgfSk7XG4gICAgdGhpcy5vbmVGcm9tVGFyZ2V0ID0gbmV3IEhhc09uZSh0aGlzLnRhcmdldCwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5LFxuICAgICAgc291cmNlS2V5OiB0aGlzLnRhcmdldEtleSxcbiAgICAgIGFzOiB0aGlzLnRocm91Z2gubW9kZWwubmFtZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucGFpcmVkICYmIHRoaXMucGFpcmVkLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgdGhpcy5wYWlyZWQudG9UYXJnZXQgPSBuZXcgQmVsb25nc1RvKHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwsIHRoaXMucGFpcmVkLnRhcmdldCwge1xuICAgICAgICBmb3JlaWduS2V5OiB0aGlzLnBhaXJlZC5vdGhlcktleVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucGFpcmVkLm9uZUZyb21UYXJnZXQgPSBuZXcgSGFzT25lKHRoaXMucGFpcmVkLnRhcmdldCwgdGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbCwge1xuICAgICAgICBmb3JlaWduS2V5OiB0aGlzLnBhaXJlZC5vdGhlcktleSxcbiAgICAgICAgc291cmNlS2V5OiB0aGlzLnBhaXJlZC50YXJnZXRLZXksXG4gICAgICAgIGFzOiB0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdjb3VudCcsICdoYXNTaW5nbGUnLCAnaGFzQWxsJywgJ3NldCcsICdhZGQnLCAnYWRkTXVsdGlwbGUnLCAncmVtb3ZlJywgJ3JlbW92ZU11bHRpcGxlJywgJ2NyZWF0ZSddO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB7XG4gICAgICBoYXNTaW5nbGU6ICdoYXMnLFxuICAgICAgaGFzQWxsOiAnaGFzJyxcbiAgICAgIGFkZE11bHRpcGxlOiAnYWRkJyxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiAncmVtb3ZlJ1xuICAgIH07XG5cbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBldmVyeXRoaW5nIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcywgdXNpbmcgYW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbH0gZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IGluc3RhbmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53aGVyZV0gQW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlIHRvIGxpbWl0IHRoZSBhc3NvY2lhdGVkIG1vZGVsc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNjaGVtYV0gQXBwbHkgYSBzY2hlbWEgb24gdGhlIHJlbGF0ZWQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRocm91Z2gud2hlcmVdIEFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZSBhcHBsaWVkIHRvIHRocm91Z2ggbW9kZWwgKGpvaW4gdGFibGUpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGhyb3VnaC5wYXJhbm9pZD10cnVlXSBJZiB0cnVlLCBvbmx5IG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZSBqb2luIHRhYmxlLiBJZiBmYWxzZSwgYm90aCBkZWxldGVkIGFuZCBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgcmV0dXJuZWQuIE9ubHkgYXBwbGllcyBpZiB0aHJvdWdoIG1vZGVsIGlzIHBhcmFub2lkXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1vZGVsPj59XG4gICAqL1xuICBhc3luYyBnZXQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuXG4gICAgY29uc3QgdGhyb3VnaCA9IHRoaXMudGhyb3VnaDtcbiAgICBsZXQgc2NvcGVXaGVyZTtcbiAgICBsZXQgdGhyb3VnaFdoZXJlO1xuXG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIHNjb3BlV2hlcmUgPSB7IC4uLnRoaXMuc2NvcGUgfTtcbiAgICB9XG5cbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgc2NvcGVXaGVyZSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG5cbiAgICBpZiAoT2JqZWN0KHRocm91Z2gubW9kZWwpID09PSB0aHJvdWdoLm1vZGVsKSB7XG4gICAgICB0aHJvdWdoV2hlcmUgPSB7fTtcbiAgICAgIHRocm91Z2hXaGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcblxuICAgICAgaWYgKHRocm91Z2guc2NvcGUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aHJvdWdoV2hlcmUsIHRocm91Z2guc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICAvL0lmIGEgdXNlciBwYXNzIGEgd2hlcmUgb24gdGhlIG9wdGlvbnMgdGhyb3VnaCBvcHRpb25zLCBtYWtlIGFuIFwiYW5kXCIgd2l0aCB0aGUgY3VycmVudCB0aHJvdWdoV2hlcmVcbiAgICAgIGlmIChvcHRpb25zLnRocm91Z2ggJiYgb3B0aW9ucy50aHJvdWdoLndoZXJlKSB7XG4gICAgICAgIHRocm91Z2hXaGVyZSA9IHtcbiAgICAgICAgICBbT3AuYW5kXTogW3Rocm91Z2hXaGVyZSwgb3B0aW9ucy50aHJvdWdoLndoZXJlXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUgfHwgW107XG4gICAgICBvcHRpb25zLmluY2x1ZGUucHVzaCh7XG4gICAgICAgIGFzc29jaWF0aW9uOiB0aGlzLm9uZUZyb21UYXJnZXQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuam9pblRhYmxlQXR0cmlidXRlcyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHBhcmFub2lkOiBfLmdldChvcHRpb25zLnRocm91Z2gsICdwYXJhbm9pZCcsIHRydWUpLFxuICAgICAgICB3aGVyZTogdGhyb3VnaFdoZXJlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgbW9kZWwgPSB0aGlzLnRhcmdldDtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY29wZScpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY2hlbWEnKSkge1xuICAgICAgbW9kZWwgPSBtb2RlbC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWwuZmluZEFsbChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudCBldmVyeXRoaW5nIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcywgdXNpbmcgYW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBpbnN0YW5jZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2hlcmVdIEFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZSB0byBsaW1pdCB0aGUgYXNzb2NpYXRlZCBtb2RlbHNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBjb3VudChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlcXVlbGl6ZSA9IHRoaXMudGFyZ2V0LnNlcXVlbGl6ZTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW1xuICAgICAgW3NlcXVlbGl6ZS5mbignQ09VTlQnLCBzZXF1ZWxpemUuY29sKFt0aGlzLnRhcmdldC5uYW1lLCB0aGlzLnRhcmdldEtleUZpZWxkXS5qb2luKCcuJykpKSwgJ2NvdW50J11cbiAgICBdO1xuICAgIG9wdGlvbnMuam9pblRhYmxlQXR0cmlidXRlcyA9IFtdO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGluc3RhbmNlLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQuY291bnQsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBvbmUgb3IgbW9yZSBpbnN0YW5jZShzKSBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMuIElmIGEgbGlzdCBvZiBpbnN0YW5jZXMgaXMgcGFzc2VkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIF9hbGxfIGluc3RhbmNlcyBhcmUgYXNzb2NpYXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2UgdG8gY2hlY2sgZm9yIGFuIGFzc29jaWF0aW9uIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFtpbnN0YW5jZXNdIENhbiBiZSBhbiBhcnJheSBvZiBpbnN0YW5jZXMgb3IgdGhlaXIgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gZ2V0QXNzb2NpYXRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgaGFzKHNvdXJjZUluc3RhbmNlLCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzY29wZTogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiBbdGhpcy50YXJnZXRLZXldLFxuICAgICAgam9pblRhYmxlQXR0cmlidXRlczogW11cbiAgICB9O1xuXG4gICAgY29uc3QgaW5zdGFuY2VQcmltYXJ5S2V5cyA9IGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLndoZXJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbdGhpcy50YXJnZXRLZXldOiBpbnN0YW5jZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICB7IFtPcC5vcl06IGluc3RhbmNlUHJpbWFyeUtleXMgfSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG5cbiAgICBjb25zdCBhc3NvY2lhdGVkT2JqZWN0cyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBfLmRpZmZlcmVuY2VXaXRoKGluc3RhbmNlUHJpbWFyeUtleXMsIGFzc29jaWF0ZWRPYmplY3RzLFxuICAgICAgKGEsIGIpID0+IF8uaXNFcXVhbChhW3RoaXMudGFyZ2V0S2V5XSwgYlt0aGlzLnRhcmdldEtleV0pKS5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhc3NvY2lhdGVkIG1vZGVscyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGluc3RhbmNlcyBvciB0aGVpciBwcmltYXJ5IGtleXMuXG4gICAqIEV2ZXJ5dGhpbmcgdGhhdCBpdCBub3QgaW4gdGhlIHBhc3NlZCBhcnJheSB3aWxsIGJlIHVuLWFzc29jaWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZSB0byBhc3NvY2lhdGUgbmV3IGluc3RhbmNlcyB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbbmV3QXNzb2NpYXRlZE9iamVjdHNdIEEgc2luZ2xlIGluc3RhbmNlIG9yIHByaW1hcnkga2V5LCBvciBhIG1peGVkIGFycmF5IG9mIHBlcnNpc3RlZCBpbnN0YW5jZXMgb3IgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRocm91Z2guZmluZEFsbGAsIGBidWxrQ3JlYXRlYCwgYHVwZGF0ZWAgYW5kIGBkZXN0cm95YFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudmFsaWRhdGVdIFJ1biB2YWxpZGF0aW9uIGZvciB0aGUgam9pbiBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGhyb3VnaF0gQWRkaXRpb25hbCBhdHRyaWJ1dGVzIGZvciB0aGUgam9pbiB0YWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIG5ld0Fzc29jaWF0ZWRPYmplY3RzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBzb3VyY2VLZXkgPSB0aGlzLnNvdXJjZUtleTtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLnRhcmdldEtleTtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuICAgIGNvbnN0IGZvcmVpZ25JZGVudGlmaWVyID0gdGhpcy5mb3JlaWduSWRlbnRpZmllcjtcblxuICAgIGlmIChuZXdBc3NvY2lhdGVkT2JqZWN0cyA9PT0gbnVsbCkge1xuICAgICAgbmV3QXNzb2NpYXRlZE9iamVjdHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXNzb2NpYXRlZE9iamVjdHMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheShuZXdBc3NvY2lhdGVkT2JqZWN0cyk7XG4gICAgfVxuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgIC4uLnRoaXMudGhyb3VnaC5zY29wZVxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVBc3NvY2lhdGlvbnMgPSBjdXJyZW50Um93cyA9PiB7XG4gICAgICBjb25zdCBvYnNvbGV0ZUFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0gb3B0aW9ucy50aHJvdWdoIHx8IHt9O1xuXG4gICAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gbmV3QXNzb2NpYXRlZE9iamVjdHMuZmlsdGVyKG9iaiA9PlxuICAgICAgICAhY3VycmVudFJvd3Muc29tZShjdXJyZW50Um93ID0+IGN1cnJlbnRSb3dbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpXG4gICAgICApO1xuXG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnRSb3cgb2YgY3VycmVudFJvd3MpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gbmV3QXNzb2NpYXRlZE9iamVjdHMuZmluZChvYmogPT4gY3VycmVudFJvd1tmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSk7XG5cbiAgICAgICAgaWYgKCFuZXdPYmopIHtcbiAgICAgICAgICBvYnNvbGV0ZUFzc29jaWF0aW9ucy5wdXNoKGN1cnJlbnRSb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB0aHJvdWdoQXR0cmlidXRlcyA9IG5ld09ialt0aGlzLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgLy8gUXVpY2stZml4IGZvciBzdWJ0bGUgYnVnIHdoZW4gdXNpbmcgZXhpc3Rpbmcgb2JqZWN0cyB0aGF0IG1pZ2h0IGhhdmUgdGhlIHRocm91Z2ggbW9kZWwgYXR0YWNoZWQgKG5vdCBhcyBhbiBhdHRyaWJ1dGUgb2JqZWN0KVxuICAgICAgICAgIGlmICh0aHJvdWdoQXR0cmlidXRlcyBpbnN0YW5jZW9mIHRoaXMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgICAgICAgdGhyb3VnaEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udGhyb3VnaEF0dHJpYnV0ZXMgfTtcblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC51cGRhdGUoYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBuZXdPYmouZ2V0KHRhcmdldEtleSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYnNvbGV0ZUFzc29jaWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLmRlc3Ryb3koe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG9ic29sZXRlQXNzb2NpYXRpb25zLm1hcChvYnNvbGV0ZUFzc29jaWF0aW9uID0+IG9ic29sZXRlQXNzb2NpYXRpb25bZm9yZWlnbklkZW50aWZpZXJdKSxcbiAgICAgICAgICAgICAgLi4udGhpcy50aHJvdWdoLnNjb3BlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBidWxrID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAodW5hc3NvY2lhdGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi51bmFzc29jaWF0ZWRPYmplY3RbdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVdLFxuICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGFyZ2V0S2V5KSxcbiAgICAgICAgICAgIC4uLnRoaXMudGhyb3VnaC5zY29wZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy50aHJvdWdoLm1vZGVsLmJ1bGtDcmVhdGUoYnVsaywgeyB2YWxpZGF0ZTogdHJ1ZSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93cyA9IGF3YWl0IHRoaXMudGhyb3VnaC5tb2RlbC5maW5kQWxsKHsgLi4ub3B0aW9ucywgd2hlcmUsIHJhdzogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBhd2FpdCB1cGRhdGVBc3NvY2lhdGlvbnMoY3VycmVudFJvd3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFbXB0eVJlc3VsdEVycm9yKSByZXR1cm4gdXBkYXRlQXNzb2NpYXRpb25zKFtdKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGUgb25lIG9yIHNldmVyYWwgcm93cyB3aXRoIHNvdXJjZSBpbnN0YW5jZS4gSXQgd2lsbCBub3QgdW4tYXNzb2NpYXRlIGFueSBhbHJlYWR5IGFzc29jaWF0ZWQgaW5zdGFuY2VcbiAgICogdGhhdCBtYXkgYmUgbWlzc2luZyBmcm9tIGBuZXdJbnN0YW5jZXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2UgdG8gYXNzb2NpYXRlIG5ldyBpbnN0YW5jZXMgd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW25ld0luc3RhbmNlc10gQSBzaW5nbGUgaW5zdGFuY2Ugb3IgcHJpbWFyeSBrZXksIG9yIGEgbWl4ZWQgYXJyYXkgb2YgcGVyc2lzdGVkIGluc3RhbmNlcyBvciBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGhyb3VnaC5maW5kQWxsYCwgYGJ1bGtDcmVhdGVgIGFuZCBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudmFsaWRhdGVdIFJ1biB2YWxpZGF0aW9uIGZvciB0aGUgam9pbiBtb2RlbC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRocm91Z2hdIEFkZGl0aW9uYWwgYXR0cmlidXRlcyBmb3IgdGhlIGpvaW4gdGFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWRkKHNvdXJjZUluc3RhbmNlLCBuZXdJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICAvLyBJZiBuZXdJbnN0YW5jZXMgaXMgbnVsbCBvciB1bmRlZmluZWQsIG5vLW9wXG4gICAgaWYgKCFuZXdJbnN0YW5jZXMpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcbiAgICBjb25zdCBzb3VyY2VLZXkgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gYXNzb2NpYXRpb24udGFyZ2V0S2V5O1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhc3NvY2lhdGlvbi5pZGVudGlmaWVyO1xuICAgIGNvbnN0IGZvcmVpZ25JZGVudGlmaWVyID0gYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXI7XG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSBvcHRpb25zLnRocm91Z2ggfHwge307XG5cbiAgICBuZXdJbnN0YW5jZXMgPSBhc3NvY2lhdGlvbi50b0luc3RhbmNlQXJyYXkobmV3SW5zdGFuY2VzKTtcblxuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG5ld0luc3RhbmNlcy5tYXAobmV3SW5zdGFuY2UgPT4gbmV3SW5zdGFuY2UuZ2V0KHRhcmdldEtleSkpLFxuICAgICAgLi4uYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZVxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVBc3NvY2lhdGlvbnMgPSBjdXJyZW50Um93cyA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IFtdO1xuICAgICAgY29uc3QgY2hhbmdlZEFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvYmogb2YgbmV3SW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQXNzb2NpYXRpb24gPSBjdXJyZW50Um93cyAmJiBjdXJyZW50Um93cy5maW5kKGN1cnJlbnQgPT4gY3VycmVudFtmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSk7XG5cbiAgICAgICAgaWYgKCFleGlzdGluZ0Fzc29jaWF0aW9uKSB7XG4gICAgICAgICAgdW5hc3NvY2lhdGVkT2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGhyb3VnaEF0dHJpYnV0ZXMgPSBvYmpbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udGhyb3VnaEF0dHJpYnV0ZXMgfTtcblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb21lKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gIT09IGV4aXN0aW5nQXNzb2NpYXRpb25bYXR0cmlidXRlXSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWRBc3NvY2lhdGlvbnMucHVzaChvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGJ1bGsgPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCh1bmFzc29jaWF0ZWRPYmplY3QgPT4ge1xuICAgICAgICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gdW5hc3NvY2lhdGVkT2JqZWN0W2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRocm91Z2hBdHRyaWJ1dGVzIH07XG5cbiAgICAgICAgICBhdHRyaWJ1dGVzW2lkZW50aWZpZXJdID0gc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSk7XG4gICAgICAgICAgYXR0cmlidXRlc1tmb3JlaWduSWRlbnRpZmllcl0gPSB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRhcmdldEtleSk7XG5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIGFzc29jaWF0aW9uLnRocm91Z2guc2NvcGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5idWxrQ3JlYXRlKGJ1bGssIHsgdmFsaWRhdGU6IHRydWUsIC4uLm9wdGlvbnMgfSkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGFzc29jIG9mIGNoYW5nZWRBc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgbGV0IHRocm91Z2hBdHRyaWJ1dGVzID0gYXNzb2NbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRocm91Z2hBdHRyaWJ1dGVzIH07XG4gICAgICAgIC8vIFF1aWNrLWZpeCBmb3Igc3VidGxlIGJ1ZyB3aGVuIHVzaW5nIGV4aXN0aW5nIG9iamVjdHMgdGhhdCBtaWdodCBoYXZlIHRoZSB0aHJvdWdoIG1vZGVsIGF0dGFjaGVkIChub3QgYXMgYW4gYXR0cmlidXRlIG9iamVjdClcbiAgICAgICAgaWYgKHRocm91Z2hBdHRyaWJ1dGVzIGluc3RhbmNlb2YgYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkge1xuICAgICAgICAgIHRocm91Z2hBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlcy5wdXNoKGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwudXBkYXRlKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyB3aGVyZToge1xuICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogYXNzb2MuZ2V0KHRhcmdldEtleSlcbiAgICAgICAgfSB9KSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFJvd3MgPSBhd2FpdCBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmZpbmRBbGwoeyAuLi5vcHRpb25zLCB3aGVyZSwgcmF3OiB0cnVlIH0pO1xuICAgICAgY29uc3QgW2Fzc29jaWF0aW9uc10gPSBhd2FpdCB1cGRhdGVBc3NvY2lhdGlvbnMoY3VycmVudFJvd3MpO1xuICAgICAgcmV0dXJuIGFzc29jaWF0aW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRW1wdHlSZXN1bHRFcnJvcikgcmV0dXJuIHVwZGF0ZUFzc29jaWF0aW9ucygpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuLWFzc29jaWF0ZSBvbmUgb3IgbW9yZSBpbnN0YW5jZShzKS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgaW5zdGFuY2UgdG8gdW4gYXNzb2NpYXRlIGluc3RhbmNlcyB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfSBbb2xkQXNzb2NpYXRlZE9iamVjdHNdIENhbiBiZSBhbiBJbnN0YW5jZSBvciBpdHMgcHJpbWFyeSBrZXksIG9yIGEgbWl4ZWQgYXJyYXkgb2YgaW5zdGFuY2VzIGFuZCBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGhyb3VnaC5kZXN0cm95YFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHJlbW92ZShzb3VyY2VJbnN0YW5jZSwgb2xkQXNzb2NpYXRlZE9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIG9sZEFzc29jaWF0ZWRPYmplY3RzID0gYXNzb2NpYXRpb24udG9JbnN0YW5jZUFycmF5KG9sZEFzc29jaWF0ZWRPYmplY3RzKTtcblxuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW2Fzc29jaWF0aW9uLmlkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24uc291cmNlS2V5KSxcbiAgICAgIFthc3NvY2lhdGlvbi5mb3JlaWduSWRlbnRpZmllcl06IG9sZEFzc29jaWF0ZWRPYmplY3RzLm1hcChuZXdJbnN0YW5jZSA9PiBuZXdJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24udGFyZ2V0S2V5KSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuZGVzdHJveSh7IC4uLm9wdGlvbnMsIHdoZXJlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYXNzb2NpYXRlZCBtb2RlbCBhbmQgYXNzb2NpYXRlIGl0IHdpdGggdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXSB2YWx1ZXMgZm9yIHRhcmdldCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGNyZWF0ZSBhbmQgYWRkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50aHJvdWdoXSBBZGRpdGlvbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBqb2luIHRhYmxlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZmllbGRzOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChhc3NvY2lhdGlvbi5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIGFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzLmNvbmNhdChPYmplY3Qua2V5cyhhc3NvY2lhdGlvbi5zY29wZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVsYXRlZCBtb2RlbCBpbnN0YW5jZVxuICAgIGNvbnN0IG5ld0Fzc29jaWF0ZWRPYmplY3QgPSBhd2FpdCBhc3NvY2lhdGlvbi50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG5cbiAgICBhd2FpdCBzb3VyY2VJbnN0YW5jZVthc3NvY2lhdGlvbi5hY2Nlc3NvcnMuYWRkXShuZXdBc3NvY2lhdGVkT2JqZWN0LCBfLm9taXQob3B0aW9ucywgWydmaWVsZHMnXSkpO1xuICAgIHJldHVybiBuZXdBc3NvY2lhdGVkT2JqZWN0O1xuICB9XG5cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnBsdXJhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnBsdXJhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmVsb25nc1RvTWFueTtcbm1vZHVsZS5leHBvcnRzLkJlbG9uZ3NUb01hbnkgPSBCZWxvbmdzVG9NYW55O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEJlbG9uZ3NUb01hbnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbi8qKlxuICogT25lLXRvLW9uZSBhc3NvY2lhdGlvblxuICpcbiAqIEluIHRoZSBBUEkgcmVmZXJlbmNlIGJlbG93LCBhZGQgdGhlIG5hbWUgb2YgdGhlIGFzc29jaWF0aW9uIHRvIHRoZSBtZXRob2QsIGUuZy4gZm9yIGBVc2VyLmJlbG9uZ3NUbyhQcm9qZWN0KWAgdGhlIGdldHRlciB3aWxsIGJlIGB1c2VyLmdldFByb2plY3QoKWAuXG4gKlxuICogQHNlZSB7QGxpbmsgTW9kZWwuYmVsb25nc1RvfVxuICovXG5jbGFzcyBCZWxvbmdzVG8gZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSAnQmVsb25nc1RvJztcbiAgICB0aGlzLmlzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuXG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICBzaW5ndWxhcjogdGhpcy5hc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcjtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMuYXMsXG4gICAgICAgICAgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICBdLmpvaW4oJ18nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmlkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgaWYgKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5pZGVudGlmaWVyXSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuaWRlbnRpZmllcl0uZmllbGQgfHwgdGhpcy5pZGVudGlmaWVyO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy50YXJnZXRLZXlcbiAgICAgICYmICF0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMub3B0aW9ucy50YXJnZXRLZXldXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIFwiJHt0aGlzLm9wdGlvbnMudGFyZ2V0S2V5fVwiIHBhc3NlZCBhcyB0YXJnZXRLZXksIGRlZmluZSB0aGlzIGF0dHJpYnV0ZSBvbiBtb2RlbCBcIiR7dGhpcy50YXJnZXQubmFtZX1cIiBmaXJzdGApO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5vcHRpb25zLnRhcmdldEtleSB8fCB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB0aGlzLnRhcmdldEtleUlzUHJpbWFyeSA9IHRoaXMudGFyZ2V0S2V5ID09PSB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMudGFyZ2V0SWRlbnRpZmllciA9IHRoaXMudGFyZ2V0S2V5O1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLm9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLnVzZUhvb2tzO1xuXG4gICAgLy8gR2V0IHNpbmd1bGFyIG5hbWUsIHRyeWluZyB0byB1cHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciwgdW5sZXNzIHRoZSBtb2RlbCBmb3JiaWRzIGl0XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuXG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3Npbmd1bGFyfWAsXG4gICAgICBzZXQ6IGBzZXQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWBcbiAgICB9O1xuICB9XG5cbiAgLy8gdGhlIGlkIGlzIGluIHRoZSBzb3VyY2UgdGFibGVcbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiB7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5mb3JlaWduS2V5QXR0cmlidXRlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgdGhpcy5vcHRpb25zLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8IChzb3VyY2UuYWxsb3dOdWxsID8gJ1NFVCBOVUxMJyA6ICdOTyBBQ1RJT04nKTtcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCAnQ0FTQ0FERSc7XG4gICAgfVxuXG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnRhcmdldCwgdGhpcy5zb3VyY2UsIHRoaXMub3B0aW9ucywgdGhpcy50YXJnZXRLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuc291cmNlLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG5cbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG5cbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gWydnZXQnLCAnc2V0JywgJ2NyZWF0ZSddO1xuXG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFzc29jaWF0ZWQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx8QXJyYXk8TW9kZWw+fSBpbnN0YW5jZXMgc291cmNlIGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSAgQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIFtvcHRpb25zLnNjaGVtYV0gQXBwbHkgYSBzY2hlbWEgb24gdGhlIHJlbGF0ZWQgbW9kZWxcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZE9uZX0gZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGxldCBUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NvcGUnKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NjaGVtYScpKSB7XG4gICAgICBUYXJnZXQgPSBUYXJnZXQuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHdoZXJlW3RoaXMudGFyZ2V0S2V5XSA9IHtcbiAgICAgICAgW09wLmluXTogaW5zdGFuY2VzLm1hcChfaW5zdGFuY2UgPT4gX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0S2V5SXNQcmltYXJ5ICYmICFvcHRpb25zLndoZXJlKSB7XG4gICAgICAgIHJldHVybiBUYXJnZXQuZmluZEJ5UGsoaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgd2hlcmVbdGhpcy50YXJnZXRLZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSk7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/XG4gICAgICB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOlxuICAgICAgd2hlcmU7XG5cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgVGFyZ2V0LmZpbmRBbGwob3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy50YXJnZXRLZXksIHsgcmF3OiB0cnVlIH0pXSA9IF9pbnN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gVGFyZ2V0LmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhc3NvY2lhdGVkIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7PzxNb2RlbD58c3RyaW5nfG51bWJlcn0gW2Fzc29jaWF0ZWRJbnN0YW5jZV0gQW4gcGVyc2lzdGVkIGluc3RhbmNlIG9yIHRoZSBwcmltYXJ5IGtleSBvZiBhbiBpbnN0YW5jZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzLiBQYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYCB0byByZW1vdmUgdGhlIGFzc29jaWF0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgcGFzc2VkIHRvIGB0aGlzLnNhdmVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2F2ZT10cnVlXSBTa2lwIHNhdmluZyB0aGlzIGFmdGVyIHNldHRpbmcgdGhlIGZvcmVpZ24ga2V5IGlmIGZhbHNlLlxuICAgKlxuICAgKiAgQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIGFzc29jaWF0ZWRJbnN0YW5jZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHZhbHVlID0gYXNzb2NpYXRlZEluc3RhbmNlO1xuXG4gICAgaWYgKGFzc29jaWF0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICB2YWx1ZSA9IGFzc29jaWF0ZWRJbnN0YW5jZVt0aGlzLnRhcmdldEtleV07XG4gICAgfVxuXG4gICAgc291cmNlSW5zdGFuY2Uuc2V0KHRoaXMuZm9yZWlnbktleSwgdmFsdWUpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2F2ZSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBmaWVsZHM6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgYWxsb3dOdWxsOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgIGFzc29jaWF0aW9uOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICAvLyBwYXNzZXMgdGhlIGNoYW5nZWQgZmllbGQgdG8gc2F2ZSwgc28gb25seSB0aGF0IGZpZWxkIGdldCB1cGRhdGVkLlxuICAgIHJldHVybiBhd2FpdCBzb3VyY2VJbnN0YW5jZS5zYXZlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYXNzb2NpYXRlZCBtb2RlbCBhbmQgYXNzb2NpYXRlIGl0IHdpdGggdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlcz17fV0gdmFsdWVzIHRvIGNyZWF0ZSBhc3NvY2lhdGVkIG1vZGVsIGluc3RhbmNlIHdpdGhcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LmNyZWF0ZWAgYW5kIHNldEFzc29jaWF0aW9uLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNjcmVhdGV9ICBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fSBUaGUgY3JlYXRlZCB0YXJnZXQgbW9kZWxcbiAgICovXG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgbmV3QXNzb2NpYXRlZE9iamVjdCA9IGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHNvdXJjZUluc3RhbmNlW3RoaXMuYWNjZXNzb3JzLnNldF0obmV3QXNzb2NpYXRlZE9iamVjdCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbmV3QXNzb2NpYXRlZE9iamVjdDtcbiAgfVxuXG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cblxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5zaW5ndWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnNpbmd1bGFyO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCZWxvbmdzVG87XG5tb2R1bGUuZXhwb3J0cy5CZWxvbmdzVG8gPSBCZWxvbmdzVG87XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQmVsb25nc1RvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG4vKipcbiAqIE9uZS10by1tYW55IGFzc29jaWF0aW9uXG4gKlxuICogSW4gdGhlIEFQSSByZWZlcmVuY2UgYmVsb3csIGFkZCB0aGUgbmFtZSBvZiB0aGUgYXNzb2NpYXRpb24gdG8gdGhlIG1ldGhvZCwgZS5nLiBmb3IgYFVzZXIuaGFzTWFueShQcm9qZWN0KWAgdGhlIGdldHRlciB3aWxsIGJlIGB1c2VyLmdldFByb2plY3RzKClgLlxuICogSWYgdGhlIGFzc29jaWF0aW9uIGlzIGFsaWFzZWQsIHVzZSB0aGUgYWxpYXMgaW5zdGVhZCwgZS5nLiBgVXNlci5oYXNNYW55KFByb2plY3QsIHsgYXM6ICdqb2JzJyB9KWAgd2lsbCBiZSBgdXNlci5nZXRKb2JzKClgLlxuICpcbiAqIEBzZWUge0BsaW5rIE1vZGVsLmhhc01hbnl9XG4gKi9cbmNsYXNzIEhhc01hbnkgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSAnSGFzTWFueSc7XG4gICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzb3VyY2Uuc2VxdWVsaXplO1xuICAgIHRoaXMuaXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOOk0gYXNzb2NpYXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggaGFzTWFueS4gVXNlIGJlbG9uZ3NUb01hbnkgaW5zdGVhZCcpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBJZiBzZWxmIGFzc29jaWF0aW9uLCB0aGlzIGlzIHRoZSB0YXJnZXQgYXNzb2NpYXRpb25cbiAgICAqL1xuICAgIGlmICh0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMuYXMpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy5hcztcbiAgICAgICAgdGhpcy5hcyA9IHRoaXMuYXMucGx1cmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgICAgcGx1cmFsOiB0aGlzLmFzLFxuICAgICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnBsdXJhbDtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRm9yZWlnbiBrZXkgc2V0dXBcbiAgICAgKi9cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLnNvdXJjZS5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgICAgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICBdLmpvaW4oJ18nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBTb3VyY2Uga2V5IHNldHVwXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG5cbiAgICBpZiAodGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0pIHtcbiAgICAgIHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5RmllbGQ7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNpbmd1bGFyIGFuZCBwbHVyYWwgbmFtZXNcbiAgICAvLyB0cnkgdG8gdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIsIHVubGVzcyB0aGUgbW9kZWwgZm9yYmlkcyBpdFxuICAgIGNvbnN0IHBsdXJhbCA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5wbHVyYWwpO1xuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3BsdXJhbH1gLFxuICAgICAgc2V0OiBgc2V0JHtwbHVyYWx9YCxcbiAgICAgIGFkZE11bHRpcGxlOiBgYWRkJHtwbHVyYWx9YCxcbiAgICAgIGFkZDogYGFkZCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZTogYHJlbW92ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBgcmVtb3ZlJHtwbHVyYWx9YCxcbiAgICAgIGhhc1NpbmdsZTogYGhhcyR7c2luZ3VsYXJ9YCxcbiAgICAgIGhhc0FsbDogYGhhcyR7cGx1cmFsfWAsXG4gICAgICBjb3VudDogYGNvdW50JHtwbHVyYWx9YFxuICAgIH07XG4gIH1cblxuICAvLyB0aGUgaWQgaXMgaW4gdGhlIHRhcmdldCB0YWJsZVxuICAvLyBvciBpbiBhbiBleHRyYSB0YWJsZSB3aGljaCBjb25uZWN0cyB0d28gdGFibGVzXG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XToge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5QXR0cmlidXRlXS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWUsXG4gICAgICAgIC4uLnRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3QgZm9yIHVzZSB3aXRoIGFkZEZvcmVpZ25LZXlDb25zdHJhaW50cywgdG8gYXZvaWQgcG9sbHV0aW5nIHRoaXMub3B0aW9ucyBpbiBjYXNlIGl0IGlzIGxhdGVyIHVzZWQgZm9yIGEgbjptXG4gICAgY29uc3QgY29uc3RyYWludE9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucyB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICBjb25zdHJhaW50T3B0aW9ucy5vbkRlbGV0ZSA9IGNvbnN0cmFpbnRPcHRpb25zLm9uRGVsZXRlIHx8ICh0YXJnZXQuYWxsb3dOdWxsID8gJ1NFVCBOVUxMJyA6ICdDQVNDQURFJyk7XG4gICAgICBjb25zdHJhaW50T3B0aW9ucy5vblVwZGF0ZSA9IGNvbnN0cmFpbnRPcHRpb25zLm9uVXBkYXRlIHx8ICdDQVNDQURFJztcbiAgICB9XG5cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMuc291cmNlLCB0aGlzLnRhcmdldCwgY29uc3RyYWludE9wdGlvbnMsIHRoaXMuc291cmNlS2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy50YXJnZXQucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnRhcmdldC5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuc291cmNlLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG5cbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduS2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcblxuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdjb3VudCcsICdoYXNTaW5nbGUnLCAnaGFzQWxsJywgJ3NldCcsICdhZGQnLCAnYWRkTXVsdGlwbGUnLCAncmVtb3ZlJywgJ3JlbW92ZU11bHRpcGxlJywgJ2NyZWF0ZSddO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB7XG4gICAgICBoYXNTaW5nbGU6ICdoYXMnLFxuICAgICAgaGFzQWxsOiAnaGFzJyxcbiAgICAgIGFkZE11bHRpcGxlOiAnYWRkJyxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiAncmVtb3ZlJ1xuICAgIH07XG5cbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBldmVyeXRoaW5nIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcywgdXNpbmcgYW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfEFycmF5PE1vZGVsPn0gaW5zdGFuY2VzIHNvdXJjZSBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndoZXJlXSBBbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UgdG8gbGltaXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1hXSBBcHBseSBhIHNjaGVtYSBvbiB0aGUgcmVsYXRlZCBtb2RlbFxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSAgZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1vZGVsPj59XG4gICAqL1xuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuXG4gICAgbGV0IE1vZGVsID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGxldCB2YWx1ZXM7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24od2hlcmUsIHRoaXMuc2NvcGUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHZhbHVlcyA9IGluc3RhbmNlcy5tYXAoX2luc3RhbmNlID0+IF9pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pKTtcblxuICAgICAgaWYgKG9wdGlvbnMubGltaXQgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb3B0aW9ucy5ncm91cGVkTGltaXQgPSB7XG4gICAgICAgICAgbGltaXQ6IG9wdGlvbnMubGltaXQsXG4gICAgICAgICAgb246IHRoaXMsIC8vIGFzc29jaWF0aW9uXG4gICAgICAgICAgdmFsdWVzXG4gICAgICAgIH07XG5cbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubGltaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICAgIFtPcC5pbl06IHZhbHVlc1xuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5ncm91cGVkTGltaXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID9cbiAgICAgIHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6XG4gICAgICB3aGVyZTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3Njb3BlJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBNb2RlbCA9IE1vZGVsLnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNb2RlbCA9IE1vZGVsLnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NjaGVtYScpKSB7XG4gICAgICBNb2RlbCA9IE1vZGVsLnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBNb2RlbC5maW5kQWxsKG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSkgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXS5wdXNoKF9pbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudCBldmVyeXRoaW5nIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcywgdXNpbmcgYW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgaW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICBbb3B0aW9uc10gZmluZCAmIGNvdW50IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnMud2hlcmVdIEFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZSB0byBsaW1pdCB0aGUgYXNzb2NpYXRlZCBtb2RlbHNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBjb3VudChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbXG4gICAgICBbXG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmZuKFxuICAgICAgICAgICdDT1VOVCcsXG4gICAgICAgICAgdGhpcy5zZXF1ZWxpemUuY29sKGAke3RoaXMudGFyZ2V0Lm5hbWV9LiR7dGhpcy50YXJnZXQucHJpbWFyeUtleUZpZWxkfWApXG4gICAgICAgICksXG4gICAgICAgICdjb3VudCdcbiAgICAgIF1cbiAgICBdO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGluc3RhbmNlLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQuY291bnQsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBvbmUgb3IgbW9yZSByb3dzIGFyZSBhc3NvY2lhdGVkIHdpdGggYHRoaXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbdGFyZ2V0SW5zdGFuY2VzXSBDYW4gYmUgYW4gYXJyYXkgb2YgaW5zdGFuY2VzIG9yIHRoZWlyIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGdldEFzc29jaWF0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGhhcyhzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRJbnN0YW5jZXMpKSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSBbdGFyZ2V0SW5zdGFuY2VzXTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNjb3BlOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSxcbiAgICAgIHJhdzogdHJ1ZVxuICAgIH07XG5cbiAgICB3aGVyZVtPcC5vcl0gPSB0YXJnZXRJbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS53aGVyZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBpbnN0YW5jZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICB3aGVyZSxcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgXVxuICAgIH07XG5cbiAgICBjb25zdCBhc3NvY2lhdGVkT2JqZWN0cyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBhc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPT09IHRhcmdldEluc3RhbmNlcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhc3NvY2lhdGVkIG1vZGVscyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHBlcnNpc3RlZCBpbnN0YW5jZXMgb3IgdGhlaXIgcHJpbWFyeSBrZXlzLiBFdmVyeXRoaW5nIHRoYXQgaXMgbm90IGluIHRoZSBwYXNzZWQgYXJyYXkgd2lsbCBiZSB1bi1hc3NvY2lhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZSB0byBhc3NvY2lhdGUgbmV3IGluc3RhbmNlcyB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbdGFyZ2V0SW5zdGFuY2VzXSBBbiBhcnJheSBvZiBwZXJzaXN0ZWQgaW5zdGFuY2VzIG9yIHByaW1hcnkga2V5IG9mIGluc3RhbmNlcyB0byBhc3NvY2lhdGUgd2l0aCB0aGlzLiBQYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYCB0byByZW1vdmUgYWxsIGFzc29jaWF0aW9ucy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LmZpbmRBbGxgIGFuZCBgdXBkYXRlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnZhbGlkYXRlXSBSdW4gdmFsaWRhdGlvbiBmb3IgdGhlIGpvaW4gbW9kZWxcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGlmICh0YXJnZXRJbnN0YW5jZXMgPT09IG51bGwpIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEFzc29jaWF0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCB7IC4uLm9wdGlvbnMsIHNjb3BlOiBmYWxzZSwgcmF3OiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3Qgb2Jzb2xldGVBc3NvY2lhdGlvbnMgPSBvbGRBc3NvY2lhdGlvbnMuZmlsdGVyKG9sZCA9PlxuICAgICAgIXRhcmdldEluc3RhbmNlcy5maW5kKG9iaiA9PlxuICAgICAgICBvYmpbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG9sZFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IHRhcmdldEluc3RhbmNlcy5maWx0ZXIob2JqID0+XG4gICAgICAhb2xkQXNzb2NpYXRpb25zLmZpbmQob2xkID0+XG4gICAgICAgIG9ialt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gb2xkW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICApXG4gICAgKTtcbiAgICBsZXQgdXBkYXRlV2hlcmU7XG4gICAgbGV0IHVwZGF0ZTtcblxuICAgIGlmIChvYnNvbGV0ZUFzc29jaWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB1cGRhdGUgPSB7fTtcbiAgICAgIHVwZGF0ZVt0aGlzLmZvcmVpZ25LZXldID0gbnVsbDtcblxuICAgICAgdXBkYXRlV2hlcmUgPSB7XG4gICAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogb2Jzb2xldGVBc3NvY2lhdGlvbnMubWFwKGFzc29jaWF0ZWRPYmplY3QgPT5cbiAgICAgICAgICBhc3NvY2lhdGVkT2JqZWN0W3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICAgIClcbiAgICAgIH07XG5cblxuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZShcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB3aGVyZTogdXBkYXRlV2hlcmVcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlV2hlcmUgPSB7fTtcblxuICAgICAgdXBkYXRlID0ge307XG4gICAgICB1cGRhdGVbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odXBkYXRlLCB0aGlzLnNjb3BlKTtcbiAgICAgIHVwZGF0ZVdoZXJlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAodW5hc3NvY2lhdGVkT2JqZWN0ID0+XG4gICAgICAgIHVuYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgKTtcblxuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZShcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB3aGVyZTogdXBkYXRlV2hlcmVcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgcmV0dXJuIHNvdXJjZUluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZSBvbmUgb3IgbW9yZSB0YXJnZXQgcm93cyB3aXRoIGB0aGlzYC4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIE1vZGVsIC8gc3RyaW5nIC8gbnVtYmVyIHRvIGFzc29jaWF0ZSBhIHNpbmdsZSByb3csXG4gICAqIG9yIGEgbWl4ZWQgYXJyYXkgb2YgTW9kZWwgLyBzdHJpbmcgLyBudW1iZXJzIHRvIGFzc29jaWF0ZSBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbdGFyZ2V0SW5zdGFuY2VzXSBBIHNpbmdsZSBpbnN0YW5jZSBvciBwcmltYXJ5IGtleSwgb3IgYSBtaXhlZCBhcnJheSBvZiBwZXJzaXN0ZWQgaW5zdGFuY2VzIG9yIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQudXBkYXRlYC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhZGQoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0YXJnZXRJbnN0YW5jZXMpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXG4gICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcblxuICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpLFxuICAgICAgLi4udGhpcy5zY29wZVxuICAgIH07XG5cbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogdGFyZ2V0SW5zdGFuY2VzLm1hcCh1bmFzc29jaWF0ZWRPYmplY3QgPT5cbiAgICAgICAgdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlKVxuICAgICAgKVxuICAgIH07XG5cbiAgICBhd2FpdCB0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIHsgLi4ub3B0aW9ucywgd2hlcmUgfSk7XG5cbiAgICByZXR1cm4gc291cmNlSW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogVW4tYXNzb2NpYXRlIG9uZSBvciBzZXZlcmFsIHRhcmdldCByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBpbnN0YW5jZSB0byB1biBhc3NvY2lhdGUgaW5zdGFuY2VzIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW119IFt0YXJnZXRJbnN0YW5jZXNdIENhbiBiZSBhbiBJbnN0YW5jZSBvciBpdHMgcHJpbWFyeSBrZXksIG9yIGEgbWl4ZWQgYXJyYXkgb2YgaW5zdGFuY2VzIGFuZCBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LnVwZGF0ZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZW1vdmUoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IG51bGxcbiAgICB9O1xuXG4gICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcblxuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSksXG4gICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IHRhcmdldEluc3RhbmNlcy5tYXAodGFyZ2V0SW5zdGFuY2UgPT5cbiAgICAgICAgdGFyZ2V0SW5zdGFuY2UuZ2V0KHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGUpXG4gICAgICApXG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgeyAuLi5vcHRpb25zLCB3aGVyZSB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYXNzb2NpYXRlZCBtb2RlbCBhbmQgYXNzb2NpYXRlIGl0IHdpdGggdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXSB2YWx1ZXMgZm9yIHRhcmdldCBtb2RlbCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQuY3JlYXRlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZmllbGRzOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWVzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKHRoaXMuc2NvcGUpKSB7XG4gICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gdGhpcy5zY29wZVthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAob3B0aW9ucy5maWVsZHMpIG9wdGlvbnMuZmllbGRzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSBvcHRpb25zLmZpZWxkcy5wdXNoKHRoaXMuZm9yZWlnbktleSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnBsdXJhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnBsdXJhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzTWFueTtcbm1vZHVsZS5leHBvcnRzLkhhc01hbnkgPSBIYXNNYW55O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEhhc01hbnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbi8qKlxuICogT25lLXRvLW9uZSBhc3NvY2lhdGlvblxuICpcbiAqIEluIHRoZSBBUEkgcmVmZXJlbmNlIGJlbG93LCBhZGQgdGhlIG5hbWUgb2YgdGhlIGFzc29jaWF0aW9uIHRvIHRoZSBtZXRob2QsIGUuZy4gZm9yIGBVc2VyLmhhc09uZShQcm9qZWN0KWAgdGhlIGdldHRlciB3aWxsIGJlIGB1c2VyLmdldFByb2plY3QoKWAuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBgYmVsb25nc1RvYCB3aXRoIG9uZSBleGNlcHRpb24gLSBUaGUgZm9yZWlnbiBrZXkgd2lsbCBiZSBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgbW9kZWwuXG4gKlxuICogQHNlZSB7QGxpbmsgTW9kZWwuaGFzT25lfVxuICovXG5jbGFzcyBIYXNPbmUgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSAnSGFzT25lJztcbiAgICB0aGlzLmlzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuXG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICBzaW5ndWxhcjogdGhpcy5hc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcjtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShcbiAgICAgICAgW1xuICAgICAgICAgIFV0aWxzLnNpbmd1bGFyaXplKHRoaXMub3B0aW9ucy5hcyB8fCB0aGlzLnNvdXJjZS5uYW1lKSxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgIF0uam9pbignXycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5zb3VyY2VLZXlcbiAgICAgICYmICF0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMub3B0aW9ucy5zb3VyY2VLZXldXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIFwiJHt0aGlzLm9wdGlvbnMuc291cmNlS2V5fVwiIHBhc3NlZCBhcyBzb3VyY2VLZXksIGRlZmluZSB0aGlzIGF0dHJpYnV0ZSBvbiBtb2RlbCBcIiR7dGhpcy5zb3VyY2UubmFtZX1cIiBmaXJzdGApO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIHRoaXMuc291cmNlS2V5SXNQcmltYXJ5ID0gdGhpcy5zb3VyY2VLZXkgPT09IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMub3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMudXNlSG9va3M7XG5cbiAgICBpZiAodGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNpbmd1bGFyIG5hbWUsIHRyeWluZyB0byB1cHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciwgdW5sZXNzIHRoZSBtb2RlbCBmb3JiaWRzIGl0XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuXG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3Npbmd1bGFyfWAsXG4gICAgICBzZXQ6IGBzZXQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWBcbiAgICB9O1xuICB9XG5cbiAgLy8gdGhlIGlkIGlzIGluIHRoZSB0YXJnZXQgdGFibGVcbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiB7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5mb3JlaWduS2V5QXR0cmlidXRlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgdGhpcy5vcHRpb25zLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8ICh0YXJnZXQuYWxsb3dOdWxsID8gJ1NFVCBOVUxMJyA6ICdDQVNDQURFJyk7XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgJ0NBU0NBREUnO1xuICAgIH1cblxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy5zb3VyY2UsIHRoaXMudGFyZ2V0LCB0aGlzLm9wdGlvbnMsIHRoaXMuc291cmNlS2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy50YXJnZXQucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnRhcmdldC5yZWZyZXNoQXR0cmlidXRlcygpO1xuXG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuXG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ3NldCcsICdjcmVhdGUnXTtcblxuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfEFycmF5PE1vZGVsPn0gaW5zdGFuY2VzIHNvdXJjZSBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNjaGVtYV0gQXBwbHkgYSBzY2hlbWEgb24gdGhlIHJlbGF0ZWQgbW9kZWxcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZE9uZX0gZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuXG4gICAgbGV0IFRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY29wZScpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NoZW1hJykpIHtcbiAgICAgIFRhcmdldCA9IFRhcmdldC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgW09wLmluXTogaW5zdGFuY2VzLm1hcChfaW5zdGFuY2UgPT4gX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih3aGVyZSwgdGhpcy5zY29wZSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgP1xuICAgICAgeyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDpcbiAgICAgIHdoZXJlO1xuXG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFRhcmdldC5maW5kQWxsKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pXSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBfaW5zdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRhcmdldC5maW5kT25lKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXNzb2NpYXRlZCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez88TW9kZWw+fHN0cmluZ3xudW1iZXJ9IFthc3NvY2lhdGVkSW5zdGFuY2VdIEFuIHBlcnNpc3RlZCBpbnN0YW5jZSBvciB0aGUgcHJpbWFyeSBrZXkgb2YgYW4gaW5zdGFuY2UgdG8gYXNzb2NpYXRlIHdpdGggdGhpcy4gUGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIHRoZSBhc3NvY2lhdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBnZXRBc3NvY2lhdGlvbiBhbmQgYHRhcmdldC5zYXZlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgYXNzb2NpYXRlZEluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgc2NvcGU6IGZhbHNlIH07XG5cbiAgICBjb25zdCBvbGRJbnN0YW5jZSA9IGF3YWl0IHNvdXJjZUluc3RhbmNlW3RoaXMuYWNjZXNzb3JzLmdldF0ob3B0aW9ucyk7XG4gICAgLy8gVE9ETyBVc2UgZXF1YWxzIG1ldGhvZCBvbmNlICM1NjA1IGlzIHJlc29sdmVkXG4gICAgY29uc3QgYWxyZWFkeUFzc29jaWF0ZWQgPSBvbGRJbnN0YW5jZSAmJiBhc3NvY2lhdGVkSW5zdGFuY2UgJiYgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZXMuZXZlcnkoYXR0cmlidXRlID0+XG4gICAgICBvbGRJbnN0YW5jZS5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gKGFzc29jaWF0ZWRJbnN0YW5jZS5nZXQgPyBhc3NvY2lhdGVkSW5zdGFuY2UuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgOiBhc3NvY2lhdGVkSW5zdGFuY2UpXG4gICAgKTtcblxuICAgIGlmIChvbGRJbnN0YW5jZSAmJiAhYWxyZWFkeUFzc29jaWF0ZWQpIHtcbiAgICAgIG9sZEluc3RhbmNlW3RoaXMuZm9yZWlnbktleV0gPSBudWxsO1xuXG4gICAgICBhd2FpdCBvbGRJbnN0YW5jZS5zYXZlKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZmllbGRzOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgICAgYWxsb3dOdWxsOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgICAgYXNzb2NpYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYXNzb2NpYXRlZEluc3RhbmNlICYmICFhbHJlYWR5QXNzb2NpYXRlZCkge1xuICAgICAgaWYgKCEoYXNzb2NpYXRlZEluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpKSB7XG4gICAgICAgIGNvbnN0IHRtcEluc3RhbmNlID0ge307XG4gICAgICAgIHRtcEluc3RhbmNlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gYXNzb2NpYXRlZEluc3RhbmNlO1xuICAgICAgICBhc3NvY2lhdGVkSW5zdGFuY2UgPSB0aGlzLnRhcmdldC5idWlsZCh0bXBJbnN0YW5jZSwge1xuICAgICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihhc3NvY2lhdGVkSW5zdGFuY2UsIHRoaXMuc2NvcGUpO1xuICAgICAgYXNzb2NpYXRlZEluc3RhbmNlLnNldCh0aGlzLmZvcmVpZ25LZXksIHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSkpO1xuXG4gICAgICByZXR1cm4gYXNzb2NpYXRlZEluc3RhbmNlLnNhdmUob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBhc3NvY2lhdGVkIG1vZGVsIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzPXt9XSB2YWx1ZXMgdG8gY3JlYXRlIGFzc29jaWF0ZWQgbW9kZWwgaW5zdGFuY2Ugd2l0aFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQuY3JlYXRlYCBhbmQgc2V0QXNzb2NpYXRpb24uXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI2NyZWF0ZX0gZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn0gVGhlIGNyZWF0ZWQgdGFyZ2V0IG1vZGVsXG4gICAqL1xuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyh0aGlzLnNjb3BlKSkge1xuICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IHRoaXMuc2NvcGVbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVzW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUpO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cblxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5zaW5ndWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnNpbmd1bGFyO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNPbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrTmFtaW5nQ29sbGlzaW9uKGFzc29jaWF0aW9uKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXNzb2NpYXRpb24uc291cmNlLnJhd0F0dHJpYnV0ZXMsIGFzc29jaWF0aW9uLmFzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBOYW1pbmcgY29sbGlzaW9uIGJldHdlZW4gYXR0cmlidXRlICcke2Fzc29jaWF0aW9uLmFzfSdgICtcbiAgICAgIGAgYW5kIGFzc29jaWF0aW9uICcke2Fzc29jaWF0aW9uLmFzfScgb24gbW9kZWwgJHthc3NvY2lhdGlvbi5zb3VyY2UubmFtZX1gICtcbiAgICAgICcuIFRvIHJlbWVkeSB0aGlzLCBjaGFuZ2UgZWl0aGVyIGZvcmVpZ25LZXkgb3IgYXMgaW4geW91ciBhc3NvY2lhdGlvbiBkZWZpbml0aW9uJ1xuICAgICk7XG4gIH1cbn1cbmV4cG9ydHMuY2hlY2tOYW1pbmdDb2xsaXNpb24gPSBjaGVja05hbWluZ0NvbGxpc2lvbjtcblxuZnVuY3Rpb24gYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZSwgc291cmNlLCB0YXJnZXQsIG9wdGlvbnMsIGtleSkge1xuICAvLyBGSyBjb25zdHJhaW50cyBhcmUgb3B0LWluOiB1c2VycyBtdXN0IGVpdGhlciBzZXQgYGZvcmVpZ25LZXlDb25zdHJhaW50c2BcbiAgLy8gb24gdGhlIGFzc29jaWF0aW9uLCBvciByZXF1ZXN0IGFuIGBvbkRlbGV0ZWAgb3IgYG9uVXBkYXRlYCBiZWhhdmlvclxuXG4gIGlmIChvcHRpb25zLmZvcmVpZ25LZXlDb25zdHJhaW50IHx8IG9wdGlvbnMub25EZWxldGUgfHwgb3B0aW9ucy5vblVwZGF0ZSkge1xuICAgIC8vIEZpbmQgcHJpbWFyeSBrZXlzOiBjb21wb3NpdGUga2V5cyBub3Qgc3VwcG9ydGVkIHdpdGggdGhpcyBhcHByb2FjaFxuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gT2JqZWN0LmtleXMoc291cmNlLnByaW1hcnlLZXlzKVxuICAgICAgLm1hcChwcmltYXJ5S2V5QXR0cmlidXRlID0+IHNvdXJjZS5yYXdBdHRyaWJ1dGVzW3ByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkIHx8IHByaW1hcnlLZXlBdHRyaWJ1dGUpO1xuXG4gICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCA9PT0gMSB8fCAhcHJpbWFyeUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgbmV3QXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiBzb3VyY2UuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleToga2V5IHx8IHByaW1hcnlLZXlzWzBdXG4gICAgICB9O1xuXG4gICAgICBuZXdBdHRyaWJ1dGUub25EZWxldGUgPSBvcHRpb25zLm9uRGVsZXRlO1xuICAgICAgbmV3QXR0cmlidXRlLm9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzID0gYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzO1xuXG4vKipcbiAqIE1peGluIChpbmplY3QpIGFzc29jaWF0aW9uIG1ldGhvZHMgdG8gbW9kZWwgcHJvdG90eXBlXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXNzb2NpYXRpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogTW9kZWwgcHJvdG90eXBlXG4gKiBAcGFyYW0ge0FycmF5fSBtZXRob2RzIE1ldGhvZCBuYW1lcyB0byBpbmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBhbGlhc2VzIE1hcHBpbmcgYmV0d2VlbiBtb2RlbCBhbmQgYXNzb2NpYXRpb24gbWV0aG9kIG5hbWVzXG4gKlxuICovXG5mdW5jdGlvbiBtaXhpbk1ldGhvZHMoYXNzb2NpYXRpb24sIG9iaiwgbWV0aG9kcywgYWxpYXNlcykge1xuICBhbGlhc2VzID0gYWxpYXNlcyB8fCB7fTtcblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgLy8gZG9uJ3Qgb3ZlcnJpZGUgY3VzdG9tIG1ldGhvZHNcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGFzc29jaWF0aW9uLmFjY2Vzc29yc1ttZXRob2RdKSkge1xuICAgICAgY29uc3QgcmVhbE1ldGhvZCA9IGFsaWFzZXNbbWV0aG9kXSB8fCBtZXRob2Q7XG5cbiAgICAgIG9ialthc3NvY2lhdGlvbi5hY2Nlc3NvcnNbbWV0aG9kXV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uW3JlYWxNZXRob2RdKHRoaXMsIC4uLkFycmF5LmZyb20oYXJndW1lbnRzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5taXhpbk1ldGhvZHMgPSBtaXhpbk1ldGhvZHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbkFzc29jaWF0aW9uLkJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYmVsb25ncy10bycpO1xuQXNzb2NpYXRpb24uSGFzT25lID0gcmVxdWlyZSgnLi9oYXMtb25lJyk7XG5Bc3NvY2lhdGlvbi5IYXNNYW55ID0gcmVxdWlyZSgnLi9oYXMtbWFueScpO1xuQXNzb2NpYXRpb24uQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoJy4vYmVsb25ncy10by1tYW55Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzb2NpYXRpb247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQXNzb2NpYXRpb247XG5tb2R1bGUuZXhwb3J0cy5Bc3NvY2lhdGlvbiA9IEFzc29jaWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBIYXNPbmUgPSByZXF1aXJlKCcuL2hhcy1vbmUnKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKCcuL2hhcy1tYW55Jyk7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZSgnLi9iZWxvbmdzLXRvLW1hbnknKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYmVsb25ncy10bycpO1xuXG5mdW5jdGlvbiBpc01vZGVsKG1vZGVsLCBzZXF1ZWxpemUpIHtcbiAgcmV0dXJuIG1vZGVsXG4gICAgJiYgbW9kZWwucHJvdG90eXBlXG4gICAgJiYgbW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2Ygc2VxdWVsaXplLlNlcXVlbGl6ZS5Nb2RlbDtcbn1cblxuY29uc3QgTWl4aW4gPSB7XG4gIGhhc01hbnkodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCB0aGlzLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9Lmhhc01hbnkgY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhIG1peGluLCB3ZSdsbCBuZWVkIGEgdW5pcXVlIGxldGlhYmxlIG5hbWUgZm9yIGhvb2tzIChzaW5jZSBNb2RlbCB3aWxsIG92ZXJyaWRlIG91ciBob29rcyBvcHRpb24pXG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcblxuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgXy5vbWl0KHNvdXJjZS5vcHRpb25zLCBbJ2hvb2tzJ10pKTtcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBIYXNNYW55IH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIHRoZSBpZCBpcyBpbiB0aGUgZm9yZWlnbiB0YWJsZSBvciBpbiBhIGNvbm5lY3RpbmcgdGFibGVcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBIYXNNYW55KHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG5cbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoJ2FmdGVyQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogSGFzTWFueSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9LFxuXG4gIGJlbG9uZ3NUb01hbnkodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCB0aGlzLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9LmJlbG9uZ3NUb01hbnkgY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhIG1peGluLCB3ZSdsbCBuZWVkIGEgdW5pcXVlIGxldGlhYmxlIG5hbWUgZm9yIGhvb2tzIChzaW5jZSBNb2RlbCB3aWxsIG92ZXJyaWRlIG91ciBob29rcyBvcHRpb24pXG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcbiAgICBvcHRpb25zLnRpbWVzdGFtcHMgPSBvcHRpb25zLnRpbWVzdGFtcHMgPT09IHVuZGVmaW5lZCA/IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXN0YW1wcyA6IG9wdGlvbnMudGltZXN0YW1wcztcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIF8ub21pdChzb3VyY2Uub3B0aW9ucywgWydob29rcycsICd0aW1lc3RhbXBzJywgJ3Njb3BlcycsICdkZWZhdWx0U2NvcGUnXSkpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoJ2JlZm9yZUFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEJlbG9uZ3NUb01hbnkgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRoZSBpZCBpcyBpbiB0aGUgZm9yZWlnbiB0YWJsZSBvciBpbiBhIGNvbm5lY3RpbmcgdGFibGVcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBCZWxvbmdzVG9NYW55KHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG5cbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoJ2FmdGVyQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogQmVsb25nc1RvTWFueSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9LFxuXG4gIGdldEFzc29jaWF0aW9ucyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmFzc29jaWF0aW9ucykuZmlsdGVyKGFzc29jaWF0aW9uID0+IGFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSB0YXJnZXQubmFtZSk7XG4gIH0sXG5cbiAgZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXQsIGFsaWFzKSB7XG4gICAgLy8gVHdvIGFzc29jaWF0aW9ucyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBhbGlhcywgc28gd2UgY2FuIHVzZSBmaW5kIGluc3RlYWQgb2YgZmlsdGVyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldCkuZmluZChhc3NvY2lhdGlvbiA9PiBhc3NvY2lhdGlvbi52ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSkgfHwgbnVsbDtcbiAgfVxufTtcblxuLy8gVGhlIGxvZ2ljIGZvciBoYXNPbmUgYW5kIGJlbG9uZ3NUbyBpcyBleGFjdGx5IHRoZSBzYW1lXG5mdW5jdGlvbiBzaW5nbGVMaW5rZWQoVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCBzb3VyY2Uuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NvdXJjZS5uYW1lfS4ke18ubG93ZXJGaXJzdChUeXBlLm5hbWUpfSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cblxuXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhIG1peGluLCB3ZSdsbCBuZWVkIGEgdW5pcXVlIGxldGlhYmxlIG5hbWUgZm9yIGhvb2tzIChzaW5jZSBNb2RlbCB3aWxsIG92ZXJyaWRlIG91ciBob29rcyBvcHRpb24pXG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICBzb3VyY2UucnVuSG9va3MoJ2JlZm9yZUFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IFR5cGUgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRoZSBpZCBpcyBpbiB0aGUgZm9yZWlnbiB0YWJsZVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IFR5cGUoc291cmNlLCB0YXJnZXQsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgc291cmNlLm9wdGlvbnMpKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG5cbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHNvdXJjZS5ydW5Ib29rcygnYWZ0ZXJBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBUeXBlLCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH07XG59XG5cbk1peGluLmhhc09uZSA9IHNpbmdsZUxpbmtlZChIYXNPbmUpO1xuTWl4aW4uYmVsb25nc1RvID0gc2luZ2xlTGlua2VkKEJlbG9uZ3NUbyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWl4aW47XG5tb2R1bGUuZXhwb3J0cy5NaXhpbiA9IE1peGluO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IE1peGluO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3Qgd2t4ID0gcmVxdWlyZSgnd2t4Jyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0b3ItZXh0cmFzJykudmFsaWRhdG9yO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCB3YXJuaW5ncyA9IHt9O1xuY29uc3QgeyBjbGFzc1RvSW52b2thYmxlIH0gPSByZXF1aXJlKCcuL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZScpO1xuY29uc3QgeyBqb2luU1FMRnJhZ21lbnRzIH0gPSByZXF1aXJlKCcuL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cycpO1xuXG5jbGFzcyBBQlNUUkFDVCB7XG4gIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50b1NxbChvcHRpb25zKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbiAgc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZ2lmeSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBiaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fYmluZFBhcmFtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgc3RhdGljIHdhcm4obGluaywgdGV4dCkge1xuICAgIGlmICghd2FybmluZ3NbdGV4dF0pIHtcbiAgICAgIHdhcm5pbmdzW3RleHRdID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci53YXJuKGAke3RleHR9IFxcbj4+IENoZWNrOiAke2xpbmt9YCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBleHRlbmQob2xkVHlwZSkge1xuICAgIHJldHVybiBuZXcgdGhpcyhvbGRUeXBlLm9wdGlvbnMpO1xuICB9XG59XG5cbkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSAnJztcblxuLyoqXG4gKiBTVFJJTkcgQSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nXG4gKi9cbmNsYXNzIFNUUklORyBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTI1NV0gbGVuZ3RoIG9mIHN0cmluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtiaW5hcnk9ZmFsc2VdIElzIHRoaXMgYmluYXJ5P1xuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoLCBiaW5hcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGJpbmFyeSB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgMjU1O1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBWQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgLFxuICAgICAgdGhpcy5fYmluYXJ5ICYmICdCSU5BUlknXG4gICAgXSk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmluYXJ5ICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBzdHJpbmcnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldCBCSU5BUlkoKSB7XG4gICAgdGhpcy5fYmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMuYmluYXJ5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQklOQVJZKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLkJJTkFSWTtcbiAgfVxufVxuXG4vKipcbiAqIENIQVIgQSBmaXhlZCBsZW5ndGggc3RyaW5nXG4gKi9cbmNsYXNzIENIQVIgZXh0ZW5kcyBTVFJJTkcge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MjU1XSBsZW5ndGggb2Ygc3RyaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpbmFyeT1mYWxzZV0gSXMgdGhpcyBiaW5hcnk/XG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGJpbmFyeSkge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgYmluYXJ5IH0pO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBDSEFSKCR7dGhpcy5fbGVuZ3RofSlgLFxuICAgICAgdGhpcy5fYmluYXJ5ICYmICdCSU5BUlknXG4gICAgXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmxpbWl0ZWQgbGVuZ3RoIFRFWFQgY29sdW1uXG4gKi9cbmNsYXNzIFRFWFQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nJ10gY291bGQgYmUgdGlueSwgbWVkaXVtLCBsb25nLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAnJztcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICd0aW55JzpcbiAgICAgICAgcmV0dXJuICdUSU5ZVEVYVCc7XG4gICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICByZXR1cm4gJ01FRElVTVRFWFQnO1xuICAgICAgY2FzZSAnbG9uZyc6XG4gICAgICAgIHJldHVybiAnTE9OR1RFWFQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiB1bmxpbWl0ZWQgbGVuZ3RoIGNhc2UtaW5zZW5zaXRpdmUgdGV4dCBjb2x1bW4uXG4gKiBPcmlnaW5hbCBjYXNlIGlzIHByZXNlcnZlZCBidXQgYWN0cyBjYXNlLWluc2Vuc2l0aXZlIHdoZW4gY29tcGFyaW5nIHZhbHVlcyAoc3VjaCBhcyB3aGVuIGZpbmRpbmcgb3IgdW5pcXVlIGNvbnN0cmFpbnRzKS5cbiAqIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVzIGFuZCBTUUxpdGUuXG4gKlxuICovXG5jbGFzcyBDSVRFWFQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnQ0lURVhUJztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIG51bWJlciB0eXBlIHdoaWNoIGlzIHVzZWQgdG8gYnVpbGQgb3RoZXIgdHlwZXNcbiAqL1xuY2xhc3MgTlVNQkVSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdHlwZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMubGVuZ3RoXSBsZW5ndGggb2YgdHlwZSwgbGlrZSBgSU5UKDQpYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnplcm9maWxsXSBJcyB6ZXJvIGZpbGxlZD9cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bnNpZ25lZF0gSXMgdW5zaWduZWQ/XG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuZGVjaW1hbHNdIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgdXNlZCB3aXRoIGxlbmd0aCBgRkxPQVQoNSwgNClgXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMucHJlY2lzaW9uXSBkZWZpbmVzIHByZWNpc2lvbiBmb3IgZGVjaW1hbCB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuc2NhbGVdIGRlZmluZXMgc2NhbGUgZm9yIGRlY2ltYWwgdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsZW5ndGg6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5femVyb2ZpbGwgPSBvcHRpb25zLnplcm9maWxsO1xuICAgIHRoaXMuX2RlY2ltYWxzID0gb3B0aW9ucy5kZWNpbWFscztcbiAgICB0aGlzLl9wcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB0aGlzLl9zY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgdGhpcy5fdW5zaWduZWQgPSBvcHRpb25zLnVuc2lnbmVkO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICByZXN1bHQgKz0gYCgke3RoaXMuX2xlbmd0aH1gO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWNpbWFscyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9kZWNpbWFsc31gO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICcpJztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICByZXN1bHQgKz0gJyBVTlNJR05FRCc7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgcmVzdWx0ICs9ICcgWkVST0ZJTEwnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNGbG9hdChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoYCVqIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5rZXkudG9Mb3dlckNhc2UoKX1gLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbnVtYmVyID09PSAnYm9vbGVhbicgfHwgbnVtYmVyID09PSBudWxsIHx8IG51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bWJlci50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bWJlci50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgZ2V0IFVOU0lHTkVEKCkge1xuICAgIHRoaXMuX3Vuc2lnbmVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMudW5zaWduZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0IFpFUk9GSUxMKCkge1xuICAgIHRoaXMuX3plcm9maWxsID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMuemVyb2ZpbGwgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIGdldCBVTlNJR05FRCgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5VTlNJR05FRDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgWkVST0ZJTEwoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuWkVST0ZJTEw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIDMyIGJpdCBpbnRlZ2VyXG4gKi9cbmNsYXNzIElOVEVHRVIgZXh0ZW5kcyBOVU1CRVIge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzSW50KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChgJWogaXMgbm90IGEgdmFsaWQgJHt0aGlzLmtleS50b0xvd2VyQ2FzZSgpfWAsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSA4IGJpdCBpbnRlZ2VyXG4gKi9cbmNsYXNzIFRJTllJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cblxuLyoqXG4gKiBBIDE2IGJpdCBpbnRlZ2VyXG4gKi9cbmNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5cbi8qKlxuICogQSAyNCBiaXQgaW50ZWdlclxuICovXG5jbGFzcyBNRURJVU1JTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cblxuLyoqXG4gKiBBIDY0IGJpdCBpbnRlZ2VyXG4gKi9cbmNsYXNzIEJJR0lOVCBleHRlbmRzIElOVEVHRVIge1xufVxuXG4vKipcbiAqIEZsb2F0aW5nIHBvaW50IG51bWJlciAoNC1ieXRlIHByZWNpc2lvbikuXG4gKi9cbmNsYXNzIEZMT0FUIGV4dGVuZHMgTlVNQkVSIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIHR5cGUsIGxpa2UgYEZMT0FUKDQpYFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkZWNpbWFsc10gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCB1c2VkIHdpdGggbGVuZ3RoIGBGTE9BVCg1LCA0KWBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNGbG9hdChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGZsb2F0JywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBGbG9hdGluZyBwb2ludCBudW1iZXIgKDQtYnl0ZSBwcmVjaXNpb24pLlxuICovXG5jbGFzcyBSRUFMIGV4dGVuZHMgTlVNQkVSIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIHR5cGUsIGxpa2UgYFJFQUwoNClgXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2RlY2ltYWxzXSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIHVzZWQgd2l0aCBsZW5ndGggYFJFQUwoNSwgNClgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEZsb2F0aW5nIHBvaW50IG51bWJlciAoOC1ieXRlIHByZWNpc2lvbikuXG4gKi9cbmNsYXNzIERPVUJMRSBleHRlbmRzIE5VTUJFUiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0eXBlLCBsaWtlIGBET1VCTEUgUFJFQ0lTSU9OKDI1KWBcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGVjaW1hbHNdIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgdXNlZCB3aXRoIGxlbmd0aCBgRE9VQkxFIFBSRUNJU0lPTigyNSwgMTApYFxuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNpbWFsIHR5cGUsIHZhcmlhYmxlIHByZWNpc2lvbiwgdGFrZSBsZW5ndGggYXMgc3BlY2lmaWVkIGJ5IHVzZXJcbiAqL1xuY2xhc3MgREVDSU1BTCBleHRlbmRzIE5VTUJFUiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtwcmVjaXNpb25dIGRlZmluZXMgcHJlY2lzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3NjYWxlXSBkZWZpbmVzIHNjYWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwcmVjaXNpb24sIHNjYWxlKSB7XG4gICAgc3VwZXIodHlwZW9mIHByZWNpc2lvbiA9PT0gJ29iamVjdCcgJiYgcHJlY2lzaW9uIHx8IHsgcHJlY2lzaW9uLCBzY2FsZSB9KTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBpZiAodGhpcy5fcHJlY2lzaW9uIHx8IHRoaXMuX3NjYWxlKSB7XG4gICAgICByZXR1cm4gYERFQ0lNQUwoJHtbdGhpcy5fcHJlY2lzaW9uLCB0aGlzLl9zY2FsZV0uZmlsdGVyKF8uaWRlbnRpdHkpLmpvaW4oJywnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuICdERUNJTUFMJztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRGVjaW1hbChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBDcmVhdGUgaW50ZXJtZWRpYXRlIGNsYXNzXG5jb25zdCBwcm90b0V4dGVuc2lvbnMgPSB7XG4gIGVzY2FwZTogZmFsc2UsXG4gIF92YWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnTmFOJztcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICAgIHJldHVybiBgJHtzaWdufUluZmluaXR5YDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gYCcke3RoaXMuX3ZhbHVlKHZhbHVlKX0nYDtcbiAgfSxcbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZSkpO1xuICB9XG59O1xuXG5mb3IgKGNvbnN0IGZsb2F0aW5nIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMXSkge1xuICBPYmplY3QuYXNzaWduKGZsb2F0aW5nLnByb3RvdHlwZSwgcHJvdG9FeHRlbnNpb25zKTtcbn1cblxuLyoqXG4gKiBBIGJvb2xlYW4gLyB0aW55aW50IGNvbHVtbiwgZGVwZW5kaW5nIG9uIGRpYWxlY3RcbiAqL1xuY2xhc3MgQk9PTEVBTiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdUSU5ZSU5UKDEpJztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzQm9vbGVhbihTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4nLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEJpdCBmaWVsZHMgYXJlIHJldHVybmVkIGFzIGJ1ZmZlcnNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gT25seSB0YWtlIGFjdGlvbiBvbiB2YWxpZCBib29sZWFuIHN0cmluZ3MuXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBPbmx5IHRha2UgYWN0aW9uIG9uIHZhbGlkIGJvb2xlYW4gaW50ZWdlcnMuXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSA/IHRydWUgOiB2YWx1ZSA9PT0gMCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5cbkJPT0xFQU4ucGFyc2UgPSBCT09MRUFOLnByb3RvdHlwZS5fc2FuaXRpemU7XG5cbi8qKlxuICogQSB0aW1lIGNvbHVtblxuICpcbiAqL1xuY2xhc3MgVElNRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdUSU1FJztcbiAgfVxufVxuXG4vKipcbiAqIERhdGUgY29sdW1uIHdpdGggdGltZXpvbmUsIGRlZmF1bHQgaXMgVVRDXG4gKi9cbmNsYXNzIERBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtsZW5ndGhdIHByZWNpc2lvbiB0byBhbGxvdyBzdG9yaW5nIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAnJztcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ0RBVEVUSU1FJztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRGF0ZShTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGRhdGUnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISF2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF9pc0NoYW5nZWQodmFsdWUsIG9yaWdpbmFsVmFsdWUpIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiAhIXZhbHVlICYmXG4gICAgICAodmFsdWUgPT09IG9yaWdpbmFsVmFsdWUgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHZhbHVlLmdldFRpbWUoKSA9PT0gb3JpZ2luYWxWYWx1ZS5nZXRUaW1lKCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5vdCBjaGFuZ2VkIHdoZW4gc2V0IHRvIHNhbWUgZW1wdHkgdmFsdWVcbiAgICBpZiAoIW9yaWdpbmFsVmFsdWUgJiYgIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy50aW1lem9uZSkge1xuICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudFR6KGRhdGUpLnR6KG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUgPSBtb21lbnQoZGF0ZSkudXRjT2Zmc2V0KG9wdGlvbnMudGltZXpvbmUpO1xuICAgIH1cbiAgICByZXR1cm4gbW9tZW50VHooZGF0ZSk7XG4gIH1cbiAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgLy8gWiBoZXJlIG1lYW5zIGN1cnJlbnQgdGltZXpvbmUsIF9ub3RfIFVUQ1xuICAgIHJldHVybiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgWicpO1xuICB9XG59XG5cbi8qKlxuICogQSBkYXRlIG9ubHkgY29sdW1uIChubyB0aW1lc3RhbXApXG4gKi9cbmNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ0RBVEUnO1xuICB9XG4gIF9zdHJpbmdpZnkoZGF0ZSkge1xuICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISF2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfaXNDaGFuZ2VkKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSB7XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgISF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBub3QgY2hhbmdlZCB3aGVuIHNldCB0byBzYW1lIGVtcHR5IHZhbHVlXG4gICAgaWYgKCFvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEga2V5IC8gdmFsdWUgc3RvcmUgY29sdW1uLiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3Jlcy5cbiAqL1xuY2xhc3MgSFNUT1JFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGhzdG9yZScsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBKU09OIHN0cmluZyBjb2x1bW4uIEF2YWlsYWJsZSBpbiBNeVNRTCwgUG9zdGdyZXMgYW5kIFNRTGl0ZVxuICovXG5jbGFzcyBKU09OVFlQRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJpbmFyeSBzdG9yYWdlIEpTT04gY29sdW1uLiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3Jlcy5cbiAqL1xuY2xhc3MgSlNPTkIgZXh0ZW5kcyBKU09OVFlQRSB7XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbWVzdGFtcFxuICovXG5jbGFzcyBOT1cgZXh0ZW5kcyBBQlNUUkFDVCB7XG59XG5cbi8qKlxuICogQmluYXJ5IHN0b3JhZ2VcbiAqL1xuY2xhc3MgQkxPQiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPScnXSBjb3VsZCBiZSB0aW55LCBtZWRpdW0sIGxvbmcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8ICcnO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3RpbnknOlxuICAgICAgICByZXR1cm4gJ1RJTllCTE9CJztcbiAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgIHJldHVybiAnTUVESVVNQkxPQic7XG4gICAgICBjYXNlICdsb25nJzpcbiAgICAgICAgcmV0dXJuICdMT05HQkxPQic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBibG9iJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IHZhbHVlLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5faGV4aWZ5KGhleCk7XG4gIH1cbiAgX2hleGlmeShoZXgpIHtcbiAgICByZXR1cm4gYFgnJHtoZXh9J2A7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gIH1cbn1cblxuXG5CTE9CLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuLyoqXG4gKiBSYW5nZSB0eXBlcyBhcmUgZGF0YSB0eXBlcyByZXByZXNlbnRpbmcgYSByYW5nZSBvZiB2YWx1ZXMgb2Ygc29tZSBlbGVtZW50IHR5cGUgKGNhbGxlZCB0aGUgcmFuZ2UncyBzdWJ0eXBlKS5cbiAqIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVzLiBTZWUgW3RoZSBQb3N0Z3JlcyBkb2N1bWVudGF0aW9uXShodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS40L3N0YXRpYy9yYW5nZXR5cGVzLmh0bWwpIGZvciBtb3JlIGRldGFpbHNcbiAqL1xuY2xhc3MgUkFOR0UgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FCU1RSQUNUfSBzdWJ0eXBlIEEgc3VidHlwZSBmb3IgcmFuZ2UsIGxpa2UgUkFOR0UoREFURSlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN1YnR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3Qoc3VidHlwZSkgPyBzdWJ0eXBlIDogeyBzdWJ0eXBlIH07XG4gICAgaWYgKCFvcHRpb25zLnN1YnR5cGUpXG4gICAgICBvcHRpb25zLnN1YnR5cGUgPSBuZXcgSU5URUdFUigpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJ0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLnN1YnR5cGUgPSBuZXcgb3B0aW9ucy5zdWJ0eXBlKCk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnR5cGUgPSBvcHRpb25zLnN1YnR5cGUua2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgcmFuZ2UnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcignQSByYW5nZSBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBjb2x1bW4gc3RvcmluZyBhIHVuaXF1ZSB1bml2ZXJzYWwgaWRlbnRpZmllci5cbiAqIFVzZSB3aXRoIGBVVUlEVjFgIG9yIGBVVUlEVjRgIGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqL1xuY2xhc3MgVVVJRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgdXVpZCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHVuaXF1ZSB1bml2ZXJzYWwgaWRlbnRpZmllciBnZW5lcmF0ZWQgZm9sbG93aW5nIHRoZSBVVUlEIHYxIHN0YW5kYXJkXG4gKi9cbmNsYXNzIFVVSURWMSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgdXVpZCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHVuaXF1ZSB1bml2ZXJzYWwgaWRlbnRpZmllciBnZW5lcmF0ZWQgZm9sbG93aW5nIHRoZSBVVUlEIHY0IHN0YW5kYXJkXG4gKi9cbmNsYXNzIFVVSURWNCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSwgNCkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgdXVpZHY0JywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHZpcnR1YWwgdmFsdWUgdGhhdCBpcyBub3Qgc3RvcmVkIGluIHRoZSBEQi4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSB1c2VmdWwgaWYgeW91IHdhbnQgdG8gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaW4geW91ciBtb2RlbCB0aGF0IGlzIHJldHVybmVkIHRvIHRoZSB1c2VyIGJ1dCBub3Qgc3RvcmVkIGluIHRoZSBEQi5cbiAqXG4gKiBZb3UgY291bGQgYWxzbyB1c2UgaXQgdG8gdmFsaWRhdGUgYSB2YWx1ZSBiZWZvcmUgcGVybXV0aW5nIGFuZCBzdG9yaW5nIGl0LiBWSVJUVUFMIGFsc28gdGFrZXMgYSByZXR1cm4gdHlwZSBhbmQgZGVwZW5kZW5jeSBmaWVsZHMgYXMgYXJndW1lbnRzXG4gKiBJZiBhIHZpcnR1YWwgYXR0cmlidXRlIGlzIHByZXNlbnQgaW4gYGF0dHJpYnV0ZXNgIGl0IHdpbGwgYXV0b21hdGljYWxseSBwdWxsIGluIHRoZSBleHRyYSBmaWVsZHMgYXMgd2VsbC5cbiAqIFJldHVybiB0eXBlIGlzIG1vc3RseSB1c2VmdWwgZm9yIHNldHVwcyB0aGF0IHJlbHkgb24gdHlwZXMgbGlrZSBHcmFwaFFMLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNraW5nIHBhc3N3b3JkIGxlbmd0aCBiZWZvcmUgaGFzaGluZyBpdDwvY2FwdGlvbj5cbiAqIHNlcXVlbGl6ZS5kZWZpbmUoJ3VzZXInLCB7XG4gKiAgIHBhc3N3b3JkX2hhc2g6IERhdGFUeXBlcy5TVFJJTkcsXG4gKiAgIHBhc3N3b3JkOiB7XG4gKiAgICAgdHlwZTogRGF0YVR5cGVzLlZJUlRVQUwsXG4gKiAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gKiAgICAgICAgLy8gUmVtZW1iZXIgdG8gc2V0IHRoZSBkYXRhIHZhbHVlLCBvdGhlcndpc2UgaXQgd29uJ3QgYmUgdmFsaWRhdGVkXG4gKiAgICAgICAgdGhpcy5zZXREYXRhVmFsdWUoJ3Bhc3N3b3JkJywgdmFsKTtcbiAqICAgICAgICB0aGlzLnNldERhdGFWYWx1ZSgncGFzc3dvcmRfaGFzaCcsIHRoaXMuc2FsdCArIHZhbCk7XG4gKiAgICAgIH0sXG4gKiAgICAgIHZhbGlkYXRlOiB7XG4gKiAgICAgICAgIGlzTG9uZ0Vub3VnaDogZnVuY3Rpb24gKHZhbCkge1xuICogICAgICAgICAgIGlmICh2YWwubGVuZ3RoIDwgNykge1xuICogICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIGNob29zZSBhIGxvbmdlciBwYXNzd29yZFwiKVxuICogICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSlcbiAqXG4gKiAjIEluIHRoZSBhYm92ZSBjb2RlIHRoZSBwYXNzd29yZCBpcyBzdG9yZWQgcGxhaW5seSBpbiB0aGUgcGFzc3dvcmQgZmllbGQgc28gaXQgY2FuIGJlIHZhbGlkYXRlZCwgYnV0IGlzIG5ldmVyIHN0b3JlZCBpbiB0aGUgREIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VmlydHVhbCB3aXRoIGRlcGVuZGVuY3kgZmllbGRzPC9jYXB0aW9uPlxuICoge1xuICogICBhY3RpdmU6IHtcbiAqICAgICB0eXBlOiBuZXcgRGF0YVR5cGVzLlZJUlRVQUwoRGF0YVR5cGVzLkJPT0xFQU4sIFsnY3JlYXRlZEF0J10pLFxuICogICAgIGdldDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NyZWF0ZWRBdCcpID4gRGF0ZS5ub3coKSAtICg3ICogMjQgKiA2MCAqIDYwICogMTAwMClcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqXG4gKi9cbmNsYXNzIFZJUlRVQUwgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FCU1RSQUNUfSBbUmV0dXJuVHlwZV0gcmV0dXJuIHR5cGUgZm9yIHZpcnR1YWwgdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbZmllbGRzXSBhcnJheSBvZiBmaWVsZHMgdGhpcyB2aXJ0dWFsIHR5cGUgaXMgZGVwZW5kZW50IG9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihSZXR1cm5UeXBlLCBmaWVsZHMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICh0eXBlb2YgUmV0dXJuVHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIFJldHVyblR5cGUgPSBuZXcgUmV0dXJuVHlwZSgpO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IFJldHVyblR5cGU7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiwgUG9zdGdyZXMgT25seVxuICpcbiAqIEBleGFtcGxlXG4gKiBEYXRhVHlwZXMuRU5VTSgndmFsdWUnLCAnYW5vdGhlciB2YWx1ZScpXG4gKiBEYXRhVHlwZXMuRU5VTShbJ3ZhbHVlJywgJ2Fub3RoZXIgdmFsdWUnXSlcbiAqIERhdGFUeXBlcy5FTlVNKHtcbiAqICAgdmFsdWVzOiBbJ3ZhbHVlJywgJ2Fub3RoZXIgdmFsdWUnXVxuICogfSlcbiAqL1xuY2xhc3MgRU5VTSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fHsgdmFsdWVzOiBhbnlbXSB9fGFueVtdfSBhcmdzIGVpdGhlciBhcnJheSBvZiB2YWx1ZXMgb3Igb3B0aW9ucyBvYmplY3Qgd2l0aCB2YWx1ZXMgYXJyYXkuIEl0IGFsc28gc3VwcG9ydHMgdmFyaWFkaWMgdmFsdWVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlIHx8IHtcbiAgICAgIHZhbHVlczogYXJncy5yZWR1Y2UoKHJlc3VsdCwgZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChBcnJheS5pc0FycmF5KGVsZW1lbnQpID8gZWxlbWVudCA6IFtlbGVtZW50XSk7XG4gICAgICB9LCBbXSlcbiAgICB9O1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy52YWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgY2hvaWNlIGluICVqJywgdmFsdWUsIHRoaXMudmFsdWVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgYHR5cGVgLiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3Jlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGF0YVR5cGVzLkFSUkFZKERhdGFUeXBlcy5ERUNJTUFMKVxuICovXG5jbGFzcyBBUlJBWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QUJTVFJBQ1R9IHR5cGUgdHlwZSBvZiBhcnJheSB2YWx1ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSB0eXBlb2Ygb3B0aW9ucy50eXBlID09PSAnZnVuY3Rpb24nID8gbmV3IG9wdGlvbnMudHlwZSgpIDogb3B0aW9ucy50eXBlO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnR5cGUudG9TcWwoKX1bXWA7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgYXJyYXknLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXMob2JqLCB0eXBlKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFSUkFZICYmIG9iai50eXBlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29sdW1uIHN0b3JpbmcgR2VvbWV0cnkgaW5mb3JtYXRpb24uXG4gKiBJdCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3JlU1FMICh3aXRoIFBvc3RHSVMpLCBNYXJpYURCIG9yIE15U1FMLlxuICpcbiAqIEdlb0pTT04gaXMgYWNjZXB0ZWQgYXMgaW5wdXQgYW5kIHJldHVybmVkIGFzIG91dHB1dC5cbiAqXG4gKiBJbiBQb3N0R0lTLCB0aGUgR2VvSlNPTiBpcyBwYXJzZWQgdXNpbmcgdGhlIFBvc3RHSVMgZnVuY3Rpb24gYFNUX0dlb21Gcm9tR2VvSlNPTmAuXG4gKiBJbiBNeVNRTCBpdCBpcyBwYXJzZWQgdXNpbmcgdGhlIGZ1bmN0aW9uIGBHZW9tRnJvbVRleHRgLlxuICpcbiAqIFRoZXJlZm9yZSwgb25lIGNhbiBqdXN0IGZvbGxvdyB0aGUgW0dlb0pTT04gc3BlY10oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIGZvciBoYW5kbGluZyBnZW9tZXRyeSBvYmplY3RzLiAgU2VlIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXM6XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVmaW5pbmcgYSBHZW9tZXRyeSB0eXBlIGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAqIERhdGFUeXBlcy5HRU9NRVRSWVxuICogRGF0YVR5cGVzLkdFT01FVFJZKCdQT0lOVCcpXG4gKiBEYXRhVHlwZXMuR0VPTUVUUlkoJ1BPSU5UJywgNDMyNilcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGUgYSBuZXcgcG9pbnQ8L2NhcHRpb24+XG4gKiBjb25zdCBwb2ludCA9IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFszOS44MDcyMjIsLTc2Ljk4NDcyMl19O1xuICpcbiAqIFVzZXIuY3JlYXRlKHt1c2VybmFtZTogJ3VzZXJuYW1lJywgZ2VvbWV0cnk6IHBvaW50IH0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIG5ldyBsaW5lc3RyaW5nPC9jYXB0aW9uPlxuICogY29uc3QgbGluZSA9IHsgdHlwZTogJ0xpbmVTdHJpbmcnLCAnY29vcmRpbmF0ZXMnOiBbIFsxMDAuMCwgMC4wXSwgWzEwMS4wLCAxLjBdIF0gfTtcbiAqXG4gKiBVc2VyLmNyZWF0ZSh7dXNlcm5hbWU6ICd1c2VybmFtZScsIGdlb21ldHJ5OiBsaW5lIH0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIG5ldyBwb2x5Z29uPC9jYXB0aW9uPlxuICogY29uc3QgcG9seWdvbiA9IHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogW1xuICogICAgICAgICAgICAgICAgIFsgWzEwMC4wLCAwLjBdLCBbMTAxLjAsIDAuMF0sIFsxMDEuMCwgMS4wXSxcbiAqICAgICAgICAgICAgICAgICAgIFsxMDAuMCwgMS4wXSwgWzEwMC4wLCAwLjBdIF1cbiAqICAgICAgICAgICAgICAgICBdfTtcbiAqXG4gKiBVc2VyLmNyZWF0ZSh7dXNlcm5hbWU6ICd1c2VybmFtZScsIGdlb21ldHJ5OiBwb2x5Z29uIH0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIG5ldyBwb2ludCB3aXRoIGEgY3VzdG9tIFNSSUQ8L2NhcHRpb24+XG4gKiBjb25zdCBwb2ludCA9IHtcbiAqICAgdHlwZTogJ1BvaW50JyxcbiAqICAgY29vcmRpbmF0ZXM6IFszOS44MDcyMjIsLTc2Ljk4NDcyMl0sXG4gKiAgIGNyczogeyB0eXBlOiAnbmFtZScsIHByb3BlcnRpZXM6IHsgbmFtZTogJ0VQU0c6NDMyNid9IH1cbiAqIH07XG4gKlxuICogVXNlci5jcmVhdGUoe3VzZXJuYW1lOiAndXNlcm5hbWUnLCBnZW9tZXRyeTogcG9pbnQgfSlcbiAqXG4gKlxuICogQHNlZSB7QGxpbmsgRGF0YVR5cGVzLkdFT0dSQVBIWX1cbiAqL1xuY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZ2VvbWV0cnkgZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyaWRdIFNSSUQgb2YgdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUsIHNyaWQgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLnNyaWQgPSBvcHRpb25zLnNyaWQ7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5lc2NhcGUod2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5iaW5kUGFyYW0od2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbn1cblxuR0VPTUVUUlkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4vKipcbiAqIEEgZ2VvZ3JhcGh5IGRhdGF0eXBlIHJlcHJlc2VudHMgdHdvIGRpbWVuc2lvbmFsIHNwYWNpYWwgb2JqZWN0cyBpbiBhbiBlbGxpcHRpYyBjb29yZCBzeXN0ZW0uXG4gKlxuICogX19UaGUgZGlmZmVyZW5jZSBmcm9tIGdlb21ldHJ5IGFuZCBnZW9ncmFwaHkgdHlwZTpfX1xuICpcbiAqIFBvc3RHSVMgMS41IGludHJvZHVjZWQgYSBuZXcgc3BhdGlhbCB0eXBlIGNhbGxlZCBnZW9ncmFwaHksIHdoaWNoIHVzZXMgZ2VvZGV0aWMgbWVhc3VyZW1lbnQgaW5zdGVhZCBvZiBDYXJ0ZXNpYW4gbWVhc3VyZW1lbnQuXG4gKiBDb29yZGluYXRlIHBvaW50cyBpbiB0aGUgZ2VvZ3JhcGh5IHR5cGUgYXJlIGFsd2F5cyByZXByZXNlbnRlZCBpbiBXR1MgODQgbG9uIGxhdCBkZWdyZWVzIChTUklEIDQzMjYpLFxuICogYnV0IG1lYXN1cmVtZW50IGZ1bmN0aW9ucyBhbmQgcmVsYXRpb25zaGlwcyBTVF9EaXN0YW5jZSwgU1RfRFdpdGhpbiwgU1RfTGVuZ3RoLCBhbmQgU1RfQXJlYSBhbHdheXMgcmV0dXJuIGFuc3dlcnMgaW4gbWV0ZXJzIG9yIGFzc3VtZSBpbnB1dHMgaW4gbWV0ZXJzLlxuICpcbiAqIF9fV2hhdCBpcyBiZXN0IHRvIHVzZT8gSXQgZGVwZW5kczpfX1xuICpcbiAqIFdoZW4gY2hvb3NpbmcgYmV0d2VlbiB0aGUgZ2VvbWV0cnkgYW5kIGdlb2dyYXBoeSB0eXBlIGZvciBkYXRhIHN0b3JhZ2UsIHlvdSBzaG91bGQgY29uc2lkZXIgd2hhdCB5b3XigJlsbCBiZSB1c2luZyBpdCBmb3IuXG4gKiBJZiBhbGwgeW91IGRvIGFyZSBzaW1wbGUgbWVhc3VyZW1lbnRzIGFuZCByZWxhdGlvbnNoaXAgY2hlY2tzIG9uIHlvdXIgZGF0YSwgYW5kIHlvdXIgZGF0YSBjb3ZlcnMgYSBmYWlybHkgbGFyZ2UgYXJlYSwgdGhlbiBtb3N0IGxpa2VseSB5b3XigJlsbCBiZSBiZXR0ZXIgb2ZmIHN0b3JpbmcgeW91ciBkYXRhIHVzaW5nIHRoZSBuZXcgZ2VvZ3JhcGh5IHR5cGUuXG4gKiBBbHRob3VnaCB0aGUgbmV3IGdlb2dyYXBoeSBkYXRhIHR5cGUgY2FuIGNvdmVyIHRoZSBnbG9iZSwgdGhlIGdlb21ldHJ5IHR5cGUgaXMgZmFyIGZyb20gb2Jzb2xldGUuXG4gKiBUaGUgZ2VvbWV0cnkgdHlwZSBoYXMgYSBtdWNoIHJpY2hlciBzZXQgb2YgZnVuY3Rpb25zIHRoYW4gZ2VvZ3JhcGh5LCByZWxhdGlvbnNoaXAgY2hlY2tzIGFyZSBnZW5lcmFsbHkgZmFzdGVyLCBhbmQgaXQgaGFzIHdpZGVyIHN1cHBvcnQgY3VycmVudGx5IGFjcm9zcyBkZXNrdG9wIGFuZCB3ZWItbWFwcGluZyB0b29sc1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlZmluaW5nIGEgR2VvZ3JhcGh5IHR5cGUgYXR0cmlidXRlPC9jYXB0aW9uPlxuICogRGF0YVR5cGVzLkdFT0dSQVBIWVxuICogRGF0YVR5cGVzLkdFT0dSQVBIWSgnUE9JTlQnKVxuICogRGF0YVR5cGVzLkdFT0dSQVBIWSgnUE9JTlQnLCA0MzI2KVxuICovXG5jbGFzcyBHRU9HUkFQSFkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZ2VvZ3JhcGh5IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmlkXSBTUklEIG9mIHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlLCBzcmlkIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5zcmlkID0gb3B0aW9ucy5zcmlkO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYEdlb21Gcm9tVGV4dCgke29wdGlvbnMuZXNjYXBlKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYEdlb21Gcm9tVGV4dCgke29wdGlvbnMuYmluZFBhcmFtKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG59XG5cblxuR0VPR1JBUEhZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgY2lkciB0eXBlIGhvbGRzIGFuIElQdjQgb3IgSVB2NiBuZXR3b3JrIHNwZWNpZmljYXRpb24uIFRha2VzIDcgb3IgMTkgYnl0ZXMuXG4gKlxuICogT25seSBhdmFpbGFibGUgZm9yIFBvc3RncmVzXG4gKi9cbmNsYXNzIENJRFIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc0lQUmFuZ2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgQ0lEUicsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIElORVQgdHlwZSBob2xkcyBhbiBJUHY0IG9yIElQdjYgaG9zdCBhZGRyZXNzLCBhbmQgb3B0aW9uYWxseSBpdHMgc3VibmV0LiBUYWtlcyA3IG9yIDE5IGJ5dGVzXG4gKlxuICogT25seSBhdmFpbGFibGUgZm9yIFBvc3RncmVzXG4gKi9cbmNsYXNzIElORVQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc0lQKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIElORVQnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBNQUNBRERSIHR5cGUgc3RvcmVzIE1BQyBhZGRyZXNzZXMuIFRha2VzIDYgYnl0ZXNcbiAqXG4gKiBPbmx5IGF2YWlsYWJsZSBmb3IgUG9zdGdyZXNcbiAqXG4gKi9cbmNsYXNzIE1BQ0FERFIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc01BQ0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgTUFDQUREUicsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFRTVkVDVE9SIHR5cGUgc3RvcmVzIHRleHQgc2VhcmNoIHZlY3RvcnMuXG4gKlxuICogT25seSBhdmFpbGFibGUgZm9yIFBvc3RncmVzXG4gKlxuICovXG5jbGFzcyBUU1ZFQ1RPUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZycsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBjbGFzcyBob2xkaW5nIGNvbW1vbmx5IHVzZWQgZGF0YSB0eXBlcy4gVGhlIGRhdGEgdHlwZXMgYXJlIHVzZWQgd2hlbiBkZWZpbmluZyBhIG5ldyBtb2RlbCB1c2luZyBgU2VxdWVsaXplLmRlZmluZWAsIGxpa2UgdGhpczpcbiAqIGBgYGpzXG4gKiBzZXF1ZWxpemUuZGVmaW5lKCdtb2RlbCcsIHtcbiAqICAgY29sdW1uOiBEYXRhVHlwZXMuSU5URUdFUlxuICogfSlcbiAqIGBgYFxuICogV2hlbiBkZWZpbmluZyBhIG1vZGVsIHlvdSBjYW4ganVzdCBhcyBlYXNpbHkgcGFzcyBhIHN0cmluZyBhcyB0eXBlLCBidXQgb2Z0ZW4gdXNpbmcgdGhlIHR5cGVzIGRlZmluZWQgaGVyZSBpcyBiZW5lZmljaWFsLiBGb3IgZXhhbXBsZSwgdXNpbmcgYERhdGFUeXBlcy5CTE9CYCwgbWVhblxuICogdGhhdCB0aGF0IGNvbHVtbiB3aWxsIGJlIHJldHVybmVkIGFzIGFuIGluc3RhbmNlIG9mIGBCdWZmZXJgIHdoZW4gYmVpbmcgZmV0Y2hlZCBieSBzZXF1ZWxpemUuXG4gKlxuICogVG8gcHJvdmlkZSBhIGxlbmd0aCBmb3IgdGhlIGRhdGEgdHlwZSwgeW91IGNhbiBpbnZva2UgaXQgbGlrZSBhIGZ1bmN0aW9uOiBgSU5URUdFUigyKWBcbiAqXG4gKiBTb21lIGRhdGEgdHlwZXMgaGF2ZSBzcGVjaWFsIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgaW4gb3JkZXIgdG8gY2hhbmdlIHRoZSBkYXRhIHR5cGUuXG4gKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IGFuIHVuc2lnbmVkIGludGVnZXIgd2l0aCB6ZXJvZmlsbCB5b3UgY2FuIGRvIGBEYXRhVHlwZXMuSU5URUdFUi5VTlNJR05FRC5aRVJPRklMTGAuXG4gKiBUaGUgb3JkZXIgeW91IGFjY2VzcyB0aGUgcHJvcGVydGllcyBpbiBkbyBub3QgbWF0dGVyLCBzbyBgRGF0YVR5cGVzLklOVEVHRVIuWkVST0ZJTEwuVU5TSUdORURgIGlzIGZpbmUgYXMgd2VsbC5cbiAqXG4gKiAqIEFsbCBudW1iZXIgdHlwZXMgKGBJTlRFR0VSYCwgYEJJR0lOVGAsIGBGTE9BVGAsIGBET1VCTEVgLCBgUkVBTGAsIGBERUNJTUFMYCkgZXhwb3NlIHRoZSBwcm9wZXJ0aWVzIGBVTlNJR05FRGAgYW5kIGBaRVJPRklMTGBcbiAqICogVGhlIGBDSEFSYCBhbmQgYFNUUklOR2AgdHlwZXMgZXhwb3NlIHRoZSBgQklOQVJZYCBwcm9wZXJ0eVxuICpcbiAqIFRocmVlIG9mIHRoZSB2YWx1ZXMgcHJvdmlkZWQgaGVyZSAoYE5PV2AsIGBVVUlEVjFgIGFuZCBgVVVJRFY0YCkgYXJlIHNwZWNpYWwgZGVmYXVsdCB2YWx1ZXMsIHRoYXQgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIGRlZmluZSB0eXBlcy4gSW5zdGVhZCB0aGV5IGFyZSB1c2VkIGFzIHNob3J0aGFuZHMgZm9yXG4gKiBkZWZpbmluZyBkZWZhdWx0IHZhbHVlcy4gRm9yIGV4YW1wbGUsIHRvIGdldCBhIHV1aWQgZmllbGQgd2l0aCBhIGRlZmF1bHQgdmFsdWUgZ2VuZXJhdGVkIGZvbGxvd2luZyB2MSBvZiB0aGUgVVVJRCBzdGFuZGFyZDpcbiAqIGBgYGpzXG4gKiBzZXF1ZWxpemUuZGVmaW5lKCdtb2RlbCcsIHtcbiAqICAgdXVpZDoge1xuICogICAgIHR5cGU6IERhdGFUeXBlcy5VVUlELFxuICogICAgIGRlZmF1bHRWYWx1ZTogRGF0YVR5cGVzLlVVSURWMSxcbiAqICAgICBwcmltYXJ5S2V5OiB0cnVlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIFRoZXJlIG1heSBiZSB0aW1lcyB3aGVuIHlvdSB3YW50IHRvIGdlbmVyYXRlIHlvdXIgb3duIFVVSUQgY29uZm9ybWluZyB0byBzb21lIG90aGVyIGFsZ29yaXRobS4gVGhpcyBpcyBhY2NvbXBsaXNoZWRcbiAqIHVzaW5nIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHkgYXMgd2VsbCwgYnV0IGluc3RlYWQgb2Ygc3BlY2lmeWluZyBvbmUgb2YgdGhlIHN1cHBsaWVkIFVVSUQgdHlwZXMsIHlvdSByZXR1cm4gYSB2YWx1ZVxuICogZnJvbSBhIGZ1bmN0aW9uLlxuICogYGBganNcbiAqIHNlcXVlbGl6ZS5kZWZpbmUoJ21vZGVsJywge1xuICogICB1dWlkOiB7XG4gKiAgICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gKiAgICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiBnZW5lcmF0ZU15SWQoKVxuICogICAgIH0sXG4gKiAgICAgcHJpbWFyeUtleTogdHJ1ZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKi9cbmNvbnN0IERhdGFUeXBlcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBBQlNUUkFDVCxcbiAgU1RSSU5HLFxuICBDSEFSLFxuICBURVhULFxuICBOVU1CRVIsXG4gIFRJTllJTlQsXG4gIFNNQUxMSU5ULFxuICBNRURJVU1JTlQsXG4gIElOVEVHRVIsXG4gIEJJR0lOVCxcbiAgRkxPQVQsXG4gIFRJTUUsXG4gIERBVEUsXG4gIERBVEVPTkxZLFxuICBCT09MRUFOLFxuICBOT1csXG4gIEJMT0IsXG4gIERFQ0lNQUwsXG4gIE5VTUVSSUM6IERFQ0lNQUwsXG4gIFVVSUQsXG4gIFVVSURWMSxcbiAgVVVJRFY0LFxuICBIU1RPUkUsXG4gIEpTT046IEpTT05UWVBFLFxuICBKU09OQixcbiAgVklSVFVBTCxcbiAgQVJSQVksXG4gIEVOVU0sXG4gIFJBTkdFLFxuICBSRUFMLFxuICAnRE9VQkxFIFBSRUNJU0lPTic6IERPVUJMRSxcbiAgRE9VQkxFLFxuICBHRU9NRVRSWSxcbiAgR0VPR1JBUEhZLFxuICBDSURSLFxuICBJTkVULFxuICBNQUNBRERSLFxuICBDSVRFWFQsXG4gIFRTVkVDVE9SXG59O1xuXG5fLmVhY2goRGF0YVR5cGVzLCAoZGF0YVR5cGUsIG5hbWUpID0+IHtcbiAgLy8gZ3VhcmQgZm9yIGFsaWFzZXNcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsICdrZXknKSkge1xuICAgIGRhdGFUeXBlLnR5cGVzID0ge307XG4gICAgZGF0YVR5cGUua2V5ID0gZGF0YVR5cGUucHJvdG90eXBlLmtleSA9IG5hbWU7XG4gIH1cbn0pO1xuXG5jb25zdCBkaWFsZWN0TWFwID0ge307XG5kaWFsZWN0TWFwLnBvc3RncmVzID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzJykoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubXlzcWwgPSByZXF1aXJlKCcuL2RpYWxlY3RzL215c3FsL2RhdGEtdHlwZXMnKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5tYXJpYWRiID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXMnKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5zcWxpdGUgPSByZXF1aXJlKCcuL2RpYWxlY3RzL3NxbGl0ZS9kYXRhLXR5cGVzJykoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubXNzcWwgPSByZXF1aXJlKCcuL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXMnKShEYXRhVHlwZXMpO1xuXG5jb25zdCBkaWFsZWN0TGlzdCA9IE9iamVjdC52YWx1ZXMoZGlhbGVjdE1hcCk7XG5cbmZvciAoY29uc3QgZGF0YVR5cGVzIG9mIGRpYWxlY3RMaXN0KSB7XG4gIF8uZWFjaChkYXRhVHlwZXMsIChEYXRhVHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKCFEYXRhVHlwZS5rZXkpIHtcbiAgICAgIERhdGFUeXBlLmtleSA9IERhdGFUeXBlLnByb3RvdHlwZS5rZXkgPSBrZXk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gV3JhcCBhbGwgZGF0YSB0eXBlcyB0byBub3QgcmVxdWlyZSBgbmV3YFxuZm9yIChjb25zdCBkYXRhVHlwZXMgb2YgW0RhdGFUeXBlcywgLi4uZGlhbGVjdExpc3RdKSB7XG4gIF8uZWFjaChkYXRhVHlwZXMsIChEYXRhVHlwZSwga2V5KSA9PiB7XG4gICAgZGF0YVR5cGVzW2tleV0gPSBjbGFzc1RvSW52b2thYmxlKERhdGFUeXBlKTtcbiAgfSk7XG59XG5cbk9iamVjdC5hc3NpZ24oRGF0YVR5cGVzLCBkaWFsZWN0TWFwKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBjbGFzc1RvSW52b2thYmxlIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNsYXNzIEFCU1RSQUNUIHtcbiAgc3RhdGljIHRvU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS50b1N0cmluZyguLi5hcmdzKTtcbiAgfVxuXG4gIHRvU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50b1NxbCguLi5hcmdzKTtcbiAgfVxuXG4gIHRvU3FsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9TcWwgaW1wbGVtZW50YXRpb24gbWlzc2luZycpO1xuICB9XG59XG5cbmNsYXNzIElOSVRJQUxMWV9ERUZFUlJFRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdERUZFUlJBQkxFIElOSVRJQUxMWSBERUZFUlJFRCc7XG4gIH1cbn1cblxuY2xhc3MgSU5JVElBTExZX0lNTUVESUFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdERUZFUlJBQkxFIElOSVRJQUxMWSBJTU1FRElBVEUnO1xuICB9XG59XG5cbmNsYXNzIE5PVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdOT1QgREVGRVJSQUJMRSc7XG4gIH1cbn1cblxuY2xhc3MgU0VUX0RFRkVSUkVEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICB9XG5cbiAgdG9TcWwocXVlcnlHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gcXVlcnlHZW5lcmF0b3Iuc2V0RGVmZXJyZWRRdWVyeSh0aGlzLmNvbnN0cmFpbnRzKTtcbiAgfVxufVxuXG5jbGFzcyBTRVRfSU1NRURJQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICB9XG5cbiAgdG9TcWwocXVlcnlHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gcXVlcnlHZW5lcmF0b3Iuc2V0SW1tZWRpYXRlUXVlcnkodGhpcy5jb25zdHJhaW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgcHJvcGVydGllcyByZWxhdGVkIHRvIGRlZmVycmFibGUgY29uc3RyYWludHMuIEl0IGNhbiBiZSB1c2VkIHRvXG4gKiBtYWtlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIGRlZmVycmFibGUgYW5kIHRvIHNldCB0aGUgY29uc3RyYWludHMgd2l0aGluIGFcbiAqIHRyYW5zYWN0aW9uLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGluIFBvc3RncmVTUUwuXG4gKlxuICogVGhlIGZvcmVpZ24ga2V5cyBjYW4gYmUgY29uZmlndXJlZCBsaWtlIHRoaXMuIEl0IHdpbGwgY3JlYXRlIGEgZm9yZWlnbiBrZXlcbiAqIHRoYXQgd2lsbCBjaGVjayB0aGUgY29uc3RyYWludHMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgZGF0YSB3YXMgaW5zZXJ0ZWQuXG4gKlxuICogYGBganNcbiAqIHNlcXVlbGl6ZS5kZWZpbmUoJ01vZGVsJywge1xuICogICBmb3JlaWduX2lkOiB7XG4gKiAgICAgdHlwZTogU2VxdWVsaXplLklOVEVHRVIsXG4gKiAgICAgcmVmZXJlbmNlczoge1xuICogICAgICAgbW9kZWw6IE90aGVyTW9kZWwsXG4gKiAgICAgICBrZXk6ICdpZCcsXG4gKiAgICAgICBkZWZlcnJhYmxlOiBTZXF1ZWxpemUuRGVmZXJyYWJsZS5JTklUSUFMTFlfSU1NRURJQVRFXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFRoZSBjb25zdHJhaW50cyBjYW4gYmUgY29uZmlndXJlZCBpbiBhIHRyYW5zYWN0aW9uIGxpa2UgdGhpcy4gSXQgd2lsbFxuICogdHJpZ2dlciBhIHF1ZXJ5IG9uY2UgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQgYW5kIHNldCB0aGUgY29uc3RyYWludHNcbiAqIHRvIGJlIGNoZWNrZWQgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogc2VxdWVsaXplLnRyYW5zYWN0aW9uKHtcbiAqICAgZGVmZXJyYWJsZTogU2VxdWVsaXplLkRlZmVycmFibGUuU0VUX0RFRkVSUkVEXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBJTklUSUFMTFlfREVGRVJSRUQgICAgVXNlIHdoZW4gZGVjbGFyaW5nIGEgY29uc3RyYWludC4gQWxsb3cgYW5kIGVuYWJsZSBieSBkZWZhdWx0IHRoaXMgY29uc3RyYWludCdzIGNoZWNrcyB0byBiZSBkZWZlcnJlZCBhdCB0aGUgZW5kIG9mIHRyYW5zYWN0aW9ucy5cbiAqIEBwcm9wZXJ0eSBJTklUSUFMTFlfSU1NRURJQVRFICAgVXNlIHdoZW4gZGVjbGFyaW5nIGEgY29uc3RyYWludC4gQWxsb3cgdGhlIGNvbnN0cmFpbnQncyBjaGVja3MgdG8gYmUgZGVmZXJyZWQgYXQgdGhlIGVuZCBvZiB0cmFuc2FjdGlvbnMuXG4gKiBAcHJvcGVydHkgTk9UICAgICAgICAgICAgICAgICAgIFVzZSB3aGVuIGRlY2xhcmluZyBhIGNvbnN0cmFpbnQuIFNldCB0aGUgY29uc3RyYWludCB0byBub3QgZGVmZXJyZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW4gUG9zdGdyZVNRTCBhbmQgbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBkeW5hbWljYWxseSBkZWZlciB0aGUgY29uc3RyYWludHMgd2l0aGluIGEgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkgU0VUX0RFRkVSUkVEICAgICAgICAgIFVzZSB3aGVuIGRlY2xhcmluZyBhIHRyYW5zYWN0aW9uLiBEZWZlciB0aGUgZGVmZXJyYWJsZSBjaGVja3MgaW52b2x2ZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBhdCBjb21taXQuXG4gKiBAcHJvcGVydHkgU0VUX0lNTUVESUFURSAgICAgICAgIFVzZSB3aGVuIGRlY2xhcmluZyBhIHRyYW5zYWN0aW9uLiBFeGVjdXRlIHRoZSBkZWZlcnJhYmxlIGNoZWNrcyBpbnZvbHZlZCBpbiB0aGlzIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5LlxuICovXG5cbmNvbnN0IERlZmVycmFibGUgPSB7XG4gIElOSVRJQUxMWV9ERUZFUlJFRDogY2xhc3NUb0ludm9rYWJsZShJTklUSUFMTFlfREVGRVJSRUQpLFxuICBJTklUSUFMTFlfSU1NRURJQVRFOiBjbGFzc1RvSW52b2thYmxlKElOSVRJQUxMWV9JTU1FRElBVEUpLFxuICBOT1Q6IGNsYXNzVG9JbnZva2FibGUoTk9UKSxcbiAgU0VUX0RFRkVSUkVEOiBjbGFzc1RvSW52b2thYmxlKFNFVF9ERUZFUlJFRCksXG4gIFNFVF9JTU1FRElBVEU6IGNsYXNzVG9JbnZva2FibGUoU0VUX0lNTUVESUFURSlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmZXJyYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBQb29sLCBUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoJ3NlcXVlbGl6ZS1wb29sJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3Bvb2wnKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBDb25uZWN0aW9uIE1hbmFnZXJcbiAqXG4gKiBDb25uZWN0aW9uIG1hbmFnZXIgd2hpY2ggaGFuZGxlcyBwb29saW5nICYgcmVwbGljYXRpb24uXG4gKiBVc2VzIHNlcXVlbGl6ZS1wb29sIGZvciBwb29saW5nXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBjb25zdCBjb25maWcgPSBfLmNsb25lRGVlcChzZXF1ZWxpemUuY29uZmlnKTtcblxuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuZGlhbGVjdCA9IGRpYWxlY3Q7XG4gICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5kaWFsZWN0TmFtZSA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdDtcblxuICAgIGlmIChjb25maWcucG9vbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgcG9vbDpmYWxzZSB3YXMgcmVtb3ZlZCBpbiB2NC4wJyk7XG4gICAgfVxuXG4gICAgY29uZmlnLnBvb2wgPSBfLmRlZmF1bHRzKGNvbmZpZy5wb29sIHx8IHt9LCB7XG4gICAgICBtYXg6IDUsXG4gICAgICBtaW46IDAsXG4gICAgICBpZGxlOiAxMDAwMCxcbiAgICAgIGFjcXVpcmU6IDYwMDAwLFxuICAgICAgZXZpY3Q6IDEwMDAsXG4gICAgICB2YWxpZGF0ZTogdGhpcy5fdmFsaWRhdGUuYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0UG9vbHMoKTtcbiAgfVxuXG4gIHJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcykge1xuICAgIF8uZWFjaChkYXRhVHlwZXMsIGRhdGFUeXBlID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsICdwYXJzZScpKSB7XG4gICAgICAgIGlmIChkYXRhVHlwZS50eXBlc1t0aGlzLmRpYWxlY3ROYW1lXSkge1xuICAgICAgICAgIHRoaXMuX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnNlIGZ1bmN0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJHtkYXRhVHlwZS5rZXl9IGluIGRpYWxlY3QgJHt0aGlzLmRpYWxlY3ROYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIGxvYWQgZGlhbGVjdCBtb2R1bGUgZnJvbSB2YXJpb3VzIGNvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICogUHJpb3JpdHkgZ29lcyBsaWtlIGRpYWxlY3RNb2R1bGVQYXRoID4gZGlhbGVjdE1vZHVsZSA+IHJlcXVpcmUoZGVmYXVsdClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTmFtZSBvZiBkaWFsZWN0IG1vZHVsZSB0byBsb29rdXBcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIF9sb2FkRGlhbGVjdE1vZHVsZShtb2R1bGVOYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWlyZShtb2R1bGVOYW1lKTtcblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZGlhbGVjdCBhdCAke3RoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsZWFzZSBpbnN0YWxsICR7bW9kdWxlTmFtZX0gcGFja2FnZSBtYW51YWxseWApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgd2hpY2ggZXhlY3V0ZXMgb24gcHJvY2VzcyBleGl0IG9yIGNvbm5lY3Rpb24gbWFuYWdlciBzaHV0ZG93blxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIF9vblByb2Nlc3NFeGl0KCkge1xuICAgIGlmICghdGhpcy5wb29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wb29sLmRyYWluKCk7XG4gICAgZGVidWcoJ2Nvbm5lY3Rpb24gZHJhaW4gZHVlIHRvIHByb2Nlc3MgZXhpdCcpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9vbC5kZXN0cm95QWxsTm93KCk7XG4gIH1cblxuICAvKipcbiAgICogRHJhaW4gdGhlIHBvb2wgYW5kIGNsb3NlIGl0IHBlcm1hbmVudGx5XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgLy8gTWFyayBjbG9zZSBvZiBwb29sXG4gICAgdGhpcy5nZXRDb25uZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbiB3YXMgY2FsbGVkIGFmdGVyIHRoZSBjb25uZWN0aW9uIG1hbmFnZXIgd2FzIGNsb3NlZCEnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX29uUHJvY2Vzc0V4aXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNvbm5lY3Rpb24gcG9vbC4gQnkgZGVmYXVsdCBwb29sIGF1dG9zdGFydCBpcyBzZXQgdG8gZmFsc2UsIHNvIG5vIGNvbm5lY3Rpb24gd2lsbCBiZVxuICAgKiBiZSBjcmVhdGVkIHVubGVzcyBgcG9vbC5hY3F1aXJlYCBpcyBjYWxsZWQuXG4gICAqL1xuICBpbml0UG9vbHMoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAoIWNvbmZpZy5yZXBsaWNhdGlvbikge1xuICAgICAgdGhpcy5wb29sID0gbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiAnc2VxdWVsaXplJyxcbiAgICAgICAgY3JlYXRlOiAoKSA9PiB0aGlzLl9jb25uZWN0KGNvbmZpZyksXG4gICAgICAgIGRlc3Ryb3k6IGFzeW5jIGNvbm5lY3Rpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gZGVzdHJveScpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pO1xuXG4gICAgICBkZWJ1ZyhgcG9vbCBjcmVhdGVkIHdpdGggbWF4L21pbjogJHtjb25maWcucG9vbC5tYXh9LyR7Y29uZmlnLnBvb2wubWlufSwgbm8gcmVwbGljYXRpb25gKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcucmVwbGljYXRpb24ucmVhZCkpIHtcbiAgICAgIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkID0gW2NvbmZpZy5yZXBsaWNhdGlvbi5yZWFkXTtcbiAgICB9XG5cbiAgICAvLyBNYXAgbWFpbiBjb25uZWN0aW9uIGNvbmZpZ1xuICAgIGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSA9IF8uZGVmYXVsdHMoY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlLCBfLm9taXQoY29uZmlnLCAncmVwbGljYXRpb24nKSk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0cyB0byBlYWNoIHJlYWQgY29uZmlnXG4gICAgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQgPSBjb25maWcucmVwbGljYXRpb24ucmVhZC5tYXAocmVhZENvbmZpZyA9PlxuICAgICAgXy5kZWZhdWx0cyhyZWFkQ29uZmlnLCBfLm9taXQodGhpcy5jb25maWcsICdyZXBsaWNhdGlvbicpKVxuICAgICk7XG5cbiAgICAvLyBjdXN0b20gcG9vbGluZyBmb3IgcmVwbGljYXRpb24gKG9yaWdpbmFsIGF1dGhvciBAamFubWVpZXIpXG4gICAgbGV0IHJlYWRzID0gMDtcbiAgICB0aGlzLnBvb2wgPSB7XG4gICAgICByZWxlYXNlOiBjbGllbnQgPT4ge1xuICAgICAgICBpZiAoY2xpZW50LnF1ZXJ5VHlwZSA9PT0gJ3JlYWQnKSB7XG4gICAgICAgICAgdGhpcy5wb29sLnJlYWQucmVsZWFzZShjbGllbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucG9vbC53cml0ZS5yZWxlYXNlKGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3F1aXJlOiAocXVlcnlUeXBlLCB1c2VNYXN0ZXIpID0+IHtcbiAgICAgICAgdXNlTWFzdGVyID0gdXNlTWFzdGVyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHVzZU1hc3RlcjtcbiAgICAgICAgaWYgKHF1ZXJ5VHlwZSA9PT0gJ1NFTEVDVCcgJiYgIXVzZU1hc3Rlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvb2wucmVhZC5hY3F1aXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbC53cml0ZS5hY3F1aXJlKCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogY29ubmVjdGlvbiA9PiB7XG4gICAgICAgIHRoaXMucG9vbFtjb25uZWN0aW9uLnF1ZXJ5VHlwZV0uZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gZGVzdHJveScpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lBbGxOb3c6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHRoaXMucG9vbC5yZWFkLmRlc3Ryb3lBbGxOb3coKSxcbiAgICAgICAgICB0aGlzLnBvb2wud3JpdGUuZGVzdHJveUFsbE5vdygpXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGRlYnVnKCdhbGwgY29ubmVjdGlvbnMgZGVzdHJveWVkJyk7XG4gICAgICB9LFxuICAgICAgZHJhaW46IGFzeW5jICgpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5wb29sLndyaXRlLmRyYWluKCksXG4gICAgICAgIHRoaXMucG9vbC5yZWFkLmRyYWluKClcbiAgICAgIF0pLFxuICAgICAgcmVhZDogbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiAnc2VxdWVsaXplOnJlYWQnLFxuICAgICAgICBjcmVhdGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyByb3VuZCByb2JpbiBjb25maWdcbiAgICAgICAgICBjb25zdCBuZXh0UmVhZCA9IHJlYWRzKysgJSBjb25maWcucmVwbGljYXRpb24ucmVhZC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoY29uZmlnLnJlcGxpY2F0aW9uLnJlYWRbbmV4dFJlYWRdKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5VHlwZSA9ICdyZWFkJztcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogY29ubmVjdGlvbiA9PiB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pLFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KSxcbiAgICAgIHdyaXRlOiBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6ICdzZXF1ZWxpemU6d3JpdGUnLFxuICAgICAgICBjcmVhdGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdChjb25maWcucmVwbGljYXRpb24ud3JpdGUpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnlUeXBlID0gJ3dyaXRlJztcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogY29ubmVjdGlvbiA9PiB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pLFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KVxuICAgIH07XG5cbiAgICBkZWJ1ZyhgcG9vbCBjcmVhdGVkIHdpdGggbWF4L21pbjogJHtjb25maWcucG9vbC5tYXh9LyR7Y29uZmlnLnBvb2wubWlufSwgd2l0aCByZXBsaWNhdGlvbmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb25uZWN0aW9uIGZyb20gcG9vbC4gSXQgc2V0cyBkYXRhYmFzZSB2ZXJzaW9uIGlmIGl0J3Mgbm90IGFscmVhZHkgc2V0LlxuICAgKiBDYWxsIHBvb2wuYWNxdWlyZSB0byBnZXQgYSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgUG9vbCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnR5cGVdICAgICAgICAgICAgU2V0IHdoaWNoIHJlcGxpY2EgdG8gdXNlLiBBdmFpbGFibGUgb3B0aW9ucyBhcmUgYHJlYWRgIGFuZCBgd3JpdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnVzZU1hc3Rlcj1mYWxzZV0gRm9yY2UgbWFzdGVyIG9yIHdyaXRlIHJlcGxpY2EgdG8gZ2V0IGNvbm5lY3Rpb24gZnJvbVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIGdldENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMudmVyc2lvblByb21pc2UpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KHRoaXMuY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlIHx8IHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IF9vcHRpb25zID0ge307XG5cbiAgICAgICAgICAgIF9vcHRpb25zLnRyYW5zYWN0aW9uID0geyBjb25uZWN0aW9uIH07IC8vIENoZWF0IC5xdWVyeSB0byB1c2Ugb3VyIHByaXZhdGUgY29ubmVjdGlvblxuICAgICAgICAgICAgX29wdGlvbnMubG9nZ2luZyA9ICgpID0+IHt9O1xuICAgICAgICAgICAgX29wdGlvbnMubG9nZ2luZy5fX3Rlc3RMb2dnaW5nRm4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvL2Nvbm5lY3Rpb24gbWlnaHQgaGF2ZSBzZXQgZGF0YWJhc2VWZXJzaW9uIHZhbHVlIGF0IGluaXRpYWxpemF0aW9uLFxuICAgICAgICAgICAgLy9hdm9pZGluZyBhIHVzZWxlc3Mgcm91bmQgdHJpcFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5kYXRhYmFzZVZlcnNpb24oX29wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWZXJzaW9uID0gXy5nZXQoc2VtdmVyLmNvZXJjZSh2ZXJzaW9uKSwgJ3ZlcnNpb24nKSB8fCB2ZXJzaW9uO1xuICAgICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci52YWxpZChwYXJzZWRWZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gcGFyc2VkVmVyc2lvblxuICAgICAgICAgICAgICAgIDogdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VtdmVyLmx0KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgIGRlcHJlY2F0aW9ucy51bnN1cHBvcnRlZEVuZ2luZSgpO1xuICAgICAgICAgICAgICBkZWJ1ZyhgVW5zdXBwb3J0ZWQgZGF0YWJhc2UgZW5naW5lIHZlcnNpb24gJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMudmVyc2lvblByb21pc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnBvb2wuYWNxdWlyZShvcHRpb25zLnR5cGUsIG9wdGlvbnMudXNlTWFzdGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVGltZW91dEVycm9yKSB0aHJvdyBuZXcgZXJyb3JzLkNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGRlYnVnKCdjb25uZWN0aW9uIGFjcXVpcmVkJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgYSBwb29sZWQgY29ubmVjdGlvbiBzbyBpdCBjYW4gYmUgdXRpbGl6ZWQgYnkgb3RoZXIgY29ubmVjdGlvbiByZXF1ZXN0c1xuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5wb29sLnJlbGVhc2UoY29ubmVjdGlvbik7XG4gICAgZGVidWcoJ2Nvbm5lY3Rpb24gcmVsZWFzZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRpYWxlY3QgbGlicmFyeSB0byBnZXQgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbmZpZyBDb25uZWN0aW9uIGNvbmZpZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIF9jb25uZWN0KGNvbmZpZykge1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdiZWZvcmVDb25uZWN0JywgY29uZmlnKTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3QoY29uZmlnKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYWZ0ZXJDb25uZWN0JywgY29ubmVjdGlvbiwgY29uZmlnKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRpYWxlY3QgbGlicmFyeSB0byBkaXNjb25uZWN0IGEgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBfZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2JlZm9yZURpc2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICBhd2FpdCB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2FmdGVyRGlzY29ubmVjdCcsIGNvbm5lY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIGNvbm5lY3Rpb24gaXMgc3RpbGwgdmFsaWQgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIF92YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIudmFsaWRhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIudmFsaWRhdGUoY29ubmVjdGlvbik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNsYXNzIEFic3RyYWN0RGlhbGVjdCB7fVxuXG5BYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0ge1xuICAnREVGQVVMVCc6IHRydWUsXG4gICdERUZBVUxUIFZBTFVFUyc6IGZhbHNlLFxuICAnVkFMVUVTICgpJzogZmFsc2UsXG4gICdMSU1JVCBPTiBVUERBVEUnOiBmYWxzZSxcbiAgJ09SREVSIE5VTExTJzogZmFsc2UsXG4gICdVTklPTic6IHRydWUsXG4gICdVTklPTiBBTEwnOiB0cnVlLFxuICAnUklHSFQgSk9JTic6IHRydWUsXG5cbiAgLyogZG9lcyB0aGUgZGlhbGVjdCBzdXBwb3J0IHJldHVybmluZyB2YWx1ZXMgZm9yIGluc2VydGVkL3VwZGF0ZWQgZmllbGRzICovXG4gIHJldHVyblZhbHVlczogZmFsc2UsXG5cbiAgLyogZmVhdHVyZXMgc3BlY2lmaWMgdG8gYXV0b0luY3JlbWVudCB2YWx1ZXMgKi9cbiAgYXV0b0luY3JlbWVudDoge1xuICAgIC8qIGRvZXMgdGhlIGRpYWxlY3QgcmVxdWlyZSBtb2RpZmljYXRpb24gb2YgaW5zZXJ0IHF1ZXJpZXMgd2hlbiBpbnNlcnRpbmcgYXV0byBpbmNyZW1lbnQgZmllbGRzICovXG4gICAgaWRlbnRpdHlJbnNlcnQ6IGZhbHNlLFxuXG4gICAgLyogZG9lcyB0aGUgZGlhbGVjdCBzdXBwb3J0IGluc2VydGluZyBkZWZhdWx0L251bGwgdmFsdWVzIGZvciBhdXRvaW5jcmVtZW50IGZpZWxkcyAqL1xuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcblxuICAgIC8qIGRvZXMgdGhlIGRpYWxlY3Qgc3VwcG9ydCB1cGRhdGluZyBhdXRvaW5jcmVtZW50IGZpZWxkcyAqL1xuICAgIHVwZGF0ZTogdHJ1ZVxuICB9LFxuICAvKiBEbyB3ZSBuZWVkIHRvIHNheSBERUZBVUxUIGZvciBidWxrIGluc2VydCAqL1xuICBidWxrRGVmYXVsdDogZmFsc2UsXG4gIHNjaGVtYXM6IGZhbHNlLFxuICB0cmFuc2FjdGlvbnM6IHRydWUsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiB0cnVlLFxuICB0cmFuc2FjdGlvbk9wdGlvbnM6IHtcbiAgICB0eXBlOiBmYWxzZVxuICB9LFxuICBtaWdyYXRpb25zOiB0cnVlLFxuICB1cHNlcnRzOiB0cnVlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogJycsIC8qIGRpYWxlY3Qgc3BlY2lmaWMgd29yZHMgZm9yIElOU0VSVCBJR05PUkUgb3IgRE8gTk9USElORyAqL1xuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBmYWxzZSwgLyogd2hldGhlciBkaWFsZWN0IHN1cHBvcnRzIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFICovXG4gICAgb25Db25mbGljdERvTm90aGluZzogJycgLyogZGlhbGVjdCBzcGVjaWZpYyB3b3JkcyBmb3IgT04gQ09ORkxJQ1QgRE8gTk9USElORyAqL1xuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiB0cnVlLFxuICAgIGFkZENvbnN0cmFpbnQ6IHRydWUsXG4gICAgZHJvcENvbnN0cmFpbnQ6IHRydWUsXG4gICAgdW5pcXVlOiB0cnVlLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIGNoZWNrOiB0cnVlLFxuICAgIGZvcmVpZ25LZXk6IHRydWUsXG4gICAgcHJpbWFyeUtleTogdHJ1ZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IHRydWUsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIGNvbmN1cnJlbnRseTogZmFsc2UsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgdXNpbmc6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogZmFsc2UsXG4gICAgb3BlcmF0b3I6IGZhbHNlXG4gIH0sXG4gIGpvaW5UYWJsZURlcGVuZGVudDogdHJ1ZSxcbiAgZ3JvdXBlZExpbWl0OiB0cnVlLFxuICBpbmRleFZpYUFsdGVyOiBmYWxzZSxcbiAgSlNPTjogZmFsc2UsXG4gIGRlZmVycmFibGVDb25zdHJhaW50czogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3REaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuQWJzdHJhY3REaWFsZWN0ID0gQWJzdHJhY3REaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoJ3V1aWQnKS52NDtcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zJyk7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKCcuLi8uLi9zcWwtc3RyaW5nJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2Fzc29jaWF0aW9ucy9iYXNlJyk7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKCcuLi8uLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10bycpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoJy4uLy4uL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnknKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKCcuLi8uLi9hc3NvY2lhdGlvbnMvaGFzLW1hbnknKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3JzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgSW5kZXhIaW50cyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4LWhpbnRzJyk7XG5cbmNvbnN0IFF1b3RlSGVscGVyID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3IvaGVscGVycy9xdW90ZScpO1xuXG4vKipcbiAqIEFic3RyYWN0IFF1ZXJ5IEdlbmVyYXRvclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5zZXF1ZWxpemUpIHRocm93IG5ldyBFcnJvcignUXVlcnlHZW5lcmF0b3IgaW5pdGlhbGl6ZWQgd2l0aG91dCBvcHRpb25zLnNlcXVlbGl6ZScpO1xuICAgIGlmICghb3B0aW9ucy5fZGlhbGVjdCkgdGhyb3cgbmV3IEVycm9yKCdRdWVyeUdlbmVyYXRvciBpbml0aWFsaXplZCB3aXRob3V0IG9wdGlvbnMuX2RpYWxlY3QnKTtcblxuICAgIHRoaXMuc2VxdWVsaXplID0gb3B0aW9ucy5zZXF1ZWxpemU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXF1ZWxpemUub3B0aW9ucztcblxuICAgIC8vIGRpYWxlY3QgbmFtZVxuICAgIHRoaXMuZGlhbGVjdCA9IG9wdGlvbnMuX2RpYWxlY3QubmFtZTtcbiAgICB0aGlzLl9kaWFsZWN0ID0gb3B0aW9ucy5fZGlhbGVjdDtcbiAgfVxuXG4gIGV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGFibGVOYW1lID0gdGFibGVOYW1lIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWEgfHwgJ3B1YmxpYycsXG4gICAgICB0YWJsZU5hbWU6IF8uaXNQbGFpbk9iamVjdCh0YWJsZU5hbWUpID8gdGFibGVOYW1lLnRhYmxlTmFtZSA6IHRhYmxlTmFtZSxcbiAgICAgIGRlbGltaXRlcjogdGFibGVOYW1lLmRlbGltaXRlciB8fCBvcHRpb25zLmRlbGltaXRlciB8fCAnLidcbiAgICB9O1xuICB9XG5cbiAgYWRkU2NoZW1hKHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbS5fc2NoZW1hKSByZXR1cm4gcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZU5hbWU6IHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbSxcbiAgICAgIHRhYmxlOiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW0sXG4gICAgICBuYW1lOiBwYXJhbS5uYW1lIHx8IHBhcmFtLFxuICAgICAgc2NoZW1hOiBwYXJhbS5fc2NoZW1hLFxuICAgICAgZGVsaW1pdGVyOiBwYXJhbS5fc2NoZW1hRGVsaW1pdGVyIHx8ICcuJyxcbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5xdW90ZVRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBkcm9wU2NoZW1hKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKFxuICAgICAgdGhpcy5hZGRTY2hlbWEoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gYERFU0NSSUJFICR7dGFibGV9O2A7XG4gIH1cblxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9O2A7XG4gIH1cblxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKGJlZm9yZSl9IFJFTkFNRSBUTyAke3RoaXMucXVvdGVUYWJsZShhZnRlcil9O2A7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbnNlcnQgaW50byBjb21tYW5kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVIYXNoICAgICAgIGF0dHJpYnV0ZSB2YWx1ZSBwYWlyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWxBdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluc2VydFF1ZXJ5KHRhYmxlLCB2YWx1ZUhhc2gsIG1vZGVsQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcblxuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGNvbnN0IHJldHVybmluZ01vZGVsQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlKTtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5iaW5kUGFyYW0oYmluZCkgOiBvcHRpb25zLmJpbmRQYXJhbTtcbiAgICBsZXQgcXVlcnk7XG4gICAgbGV0IHZhbHVlUXVlcnkgPSAnJztcbiAgICBsZXQgZW1wdHlRdWVyeSA9ICcnO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9ICcnO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9ICcnO1xuICAgIGxldCBpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGxldCB0bXBUYWJsZSA9ICcnOyAvL3RtcFRhYmxlIGRlY2xhcmF0aW9uIGZvciB0cmlnZ2VyXG5cbiAgICBpZiAobW9kZWxBdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2gobW9kZWxBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydERUZBVUxUIFZBTFVFUyddKSB7XG4gICAgICBlbXB0eVF1ZXJ5ICs9ICcgREVGQVVMVCBWQUxVRVMnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snVkFMVUVTICgpJ10pIHtcbiAgICAgIGVtcHR5UXVlcnkgKz0gJyBWQUxVRVMgKCknO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMucHVzaCguLi5yZXR1cm5WYWx1ZXMucmV0dXJuRmllbGRzKTtcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgdG1wVGFibGUgPSByZXR1cm5WYWx1ZXMudG1wVGFibGUgfHwgJyc7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudCB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoXy5nZXQodGhpcywgWydzZXF1ZWxpemUnLCAnb3B0aW9ucycsICdkaWFsZWN0T3B0aW9ucycsICdwcmVwZW5kU2VhcmNoUGF0aCddKSB8fCBvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIC8vIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIHdpdGggc2VhcmNoIHBhdGggKHJlcXVpcmVzIG91dHB1dCBvZiBtdWx0aXBsZSBxdWVyaWVzKVxuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5FWENFUFRJT04gJiYgb3B0aW9ucy5leGNlcHRpb24pIHtcbiAgICAgIC8vIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIHdpdGggYmluZCBwYXJhbWV0ZXJzIChyZXF1aXJlcyBvdXRwdXQgb2YgbXVsdGlwbGUgcXVlcmllcylcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKHZhbHVlSGFzaCwgdGhpcy5vcHRpb25zLm9taXROdWxsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZUhhc2gpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVIYXNoLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVIYXNoW2tleV07XG4gICAgICAgIGZpZWxkcy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuXG4gICAgICAgIC8vIFNFUklBTFMnIGNhbid0IGJlIE5VTEwgaW4gcG9zdGdyZXNxbCwgdXNlIERFRkFVTFQgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5ERUZBVUxUKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCgnREVGQVVMVCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmVzY2FwZShudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnSU5TRVJUJyB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnSU5TRVJUJyB9LCBiaW5kUGFyYW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSAnJztcblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgJiYgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSA9PSAnIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVQnKSB7IC8vIHBvc3RncmVzIC8gc3FsaXRlXG4gICAgICAgIC8vIElmIG5vIGNvbmZsaWN0IHRhcmdldCBjb2x1bW5zIHdlcmUgc3BlY2lmaWVkLCB1c2UgdGhlIHByaW1hcnkga2V5IG5hbWVzIGZyb20gb3B0aW9ucy51cHNlcnRLZXlzXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0S2V5cyA9IG9wdGlvbnMudXBzZXJ0S2V5cy5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcChhdHRyID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1FWENMVURFRC4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWApO1xuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IGAgT04gQ09ORkxJQ1QgKCR7Y29uZmxpY3RLZXlzLmpvaW4oJywnKX0pIERPIFVQREFURSBTRVQgJHt1cGRhdGVLZXlzLmpvaW4oJywnKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoYXR0ciA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09VkFMVUVTKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9KWApO1xuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSArPSBgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGV9ICR7dmFsdWVLZXlzLmpvaW4oJywnKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5pZ25vcmVEdXBsaWNhdGVzIDogJycsXG4gICAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdERvTm90aGluZyA6ICcnLFxuICAgICAgYXR0cmlidXRlczogZmllbGRzLmpvaW4oJywnKSxcbiAgICAgIG91dHB1dDogb3V0cHV0RnJhZ21lbnQsXG4gICAgICB2YWx1ZXM6IHZhbHVlcy5qb2luKCcsJyksXG4gICAgICB0bXBUYWJsZVxuICAgIH07XG5cbiAgICB2YWx1ZVF1ZXJ5ID0gYCR7dG1wVGFibGV9SU5TRVJUJHtyZXBsYWNlbWVudHMuaWdub3JlRHVwbGljYXRlc30gSU5UTyAke3F1b3RlZFRhYmxlfSAoJHtyZXBsYWNlbWVudHMuYXR0cmlidXRlc30pJHtyZXBsYWNlbWVudHMub3V0cHV0fSBWQUxVRVMgKCR7cmVwbGFjZW1lbnRzLnZhbHVlc30pJHtvbkR1cGxpY2F0ZUtleVVwZGF0ZX0ke3JlcGxhY2VtZW50cy5vbkNvbmZsaWN0RG9Ob3RoaW5nfSR7dmFsdWVRdWVyeX1gO1xuICAgIGVtcHR5UXVlcnkgPSBgJHt0bXBUYWJsZX1JTlNFUlQke3JlcGxhY2VtZW50cy5pZ25vcmVEdXBsaWNhdGVzfSBJTlRPICR7cXVvdGVkVGFibGV9JHtyZXBsYWNlbWVudHMub3V0cHV0fSR7b25EdXBsaWNhdGVLZXlVcGRhdGV9JHtyZXBsYWNlbWVudHMub25Db25mbGljdERvTm90aGluZ30ke2VtcHR5UXVlcnl9YDtcblxuICAgIC8vIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNlLCBzbyB3ZSBleHBlY3QgdGhlIHVzZXIgdG8ga25vdyB3aGF0IGhlJ3MgZG9pbmchXG4gICAgLy8gcGdfdGVtcCBmdW5jdGlvbnMgYXJlIHByaXZhdGUgcGVyIGNvbm5lY3Rpb24sIHNvIHdlIG5ldmVyIHJpc2sgdGhpcyBmdW5jdGlvbiBpbnRlcmZlcmluZyB3aXRoIGFub3RoZXIgb25lLlxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkVYQ0VQVElPTiAmJiBvcHRpb25zLmV4Y2VwdGlvbikge1xuICAgICAgY29uc3QgZHJvcEZ1bmN0aW9uID0gJ0RST1AgRlVOQ1RJT04gSUYgRVhJU1RTIHBnX3RlbXAudGVzdGZ1bmMoKSc7XG5cbiAgICAgIGlmIChyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5wdXNoKCcqJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGAkZnVuY18ke3V1aWR2NCgpLnJlcGxhY2UoLy0vZywgJycpfSRgO1xuICAgICAgY29uc3Qgc2VsZWN0UXVlcnkgPSBgU0VMRUNUICh0ZXN0ZnVuYy5yZXNwb25zZSkuJHtyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMuam9pbignLCAodGVzdGZ1bmMucmVzcG9uc2UpLicpfSwgdGVzdGZ1bmMuc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gRlJPTSBwZ190ZW1wLnRlc3RmdW5jKCk7YDtcblxuICAgICAgb3B0aW9ucy5leGNlcHRpb24gPSAnV0hFTiB1bmlxdWVfdmlvbGF0aW9uIFRIRU4gR0VUIFNUQUNLRUQgRElBR05PU1RJQ1Mgc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gPSBQR19FWENFUFRJT05fREVUQUlMOyc7XG4gICAgICB2YWx1ZVF1ZXJ5ID0gYENSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OIHBnX3RlbXAudGVzdGZ1bmMoT1VUIHJlc3BvbnNlICR7cXVvdGVkVGFibGV9LCBPVVQgc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gdGV4dCkgUkVUVVJOUyBSRUNPUkQgQVMgJHtkZWxpbWl0ZXJ9IEJFR0lOICR7dmFsdWVRdWVyeX0gUkVUVVJOSU5HICogSU5UTyByZXNwb25zZTsgRVhDRVBUSU9OICR7b3B0aW9ucy5leGNlcHRpb259IEVORCAke2RlbGltaXRlcn0gTEFOR1VBR0UgcGxwZ3NxbDsgJHtzZWxlY3RRdWVyeX0gJHtkcm9wRnVuY3Rpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVRdWVyeSArPSByZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIGVtcHR5UXVlcnkgKz0gcmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgcXVlcnkgPSBgJHtyZXBsYWNlbWVudHMuYXR0cmlidXRlcy5sZW5ndGggPyB2YWx1ZVF1ZXJ5IDogZW1wdHlRdWVyeX07YDtcbiAgICBpZiAoaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LmlkZW50aXR5SW5zZXJ0KSB7XG4gICAgICBxdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9OOyAke3F1ZXJ5fSBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9GRjtgO1xuICAgIH1cblxuICAgIC8vIFVzZWQgYnkgUG9zdGdyZXMgdXBzZXJ0UXVlcnkgYW5kIGNhbGxzIHRvIGhlcmUgd2l0aCBvcHRpb25zLmV4Y2VwdGlvbiBzZXQgdG8gdHJ1ZVxuICAgIGNvbnN0IHJlc3VsdCA9IHsgcXVlcnkgfTtcbiAgICBpZiAob3B0aW9ucy5iaW5kUGFyYW0gIT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuYmluZCA9IGJpbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc2VydCBpbnRvIGNvbW1hbmQgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZmllbGRWYWx1ZUhhc2hlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBidWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCBmaWVsZFZhbHVlSGFzaGVzLCBvcHRpb25zLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgPSBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgfHwge307XG5cbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBzZXJpYWxzID0ge307XG4gICAgY29uc3QgYWxsQXR0cmlidXRlcyA9IFtdO1xuICAgIGxldCBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBfLmZvck93bihmaWVsZFZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFhbGxBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICAmJiBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlXG4gICAgICAgICkge1xuICAgICAgICAgIHNlcmlhbHNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZUhhc2ggb2YgZmllbGRWYWx1ZUhhc2hlcykge1xuICAgICAgY29uc3QgdmFsdWVzID0gYWxsQXR0cmlidXRlcy5tYXAoa2V5ID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYnVsa0RlZmF1bHRcbiAgICAgICAgICAmJiBzZXJpYWxzW2tleV0gPT09IHRydWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWVIYXNoW2tleV0gfHwgJ0RFRkFVTFQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKGZpZWxkVmFsdWVIYXNoW2tleV0sIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLCB7IGNvbnRleHQ6ICdJTlNFUlQnIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHR1cGxlcy5wdXNoKGAoJHt2YWx1ZXMuam9pbignLCcpfSlgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlICYmIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgPT0gJyBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUJykgeyAvLyBwb3N0Z3JlcyAvIHNxbGl0ZVxuICAgICAgICAvLyBJZiBubyBjb25mbGljdCB0YXJnZXQgY29sdW1ucyB3ZXJlIHNwZWNpZmllZCwgdXNlIHRoZSBwcmltYXJ5IGtleSBuYW1lcyBmcm9tIG9wdGlvbnMudXBzZXJ0S2V5c1xuICAgICAgICBjb25zdCBjb25mbGljdEtleXMgPSBvcHRpb25zLnVwc2VydEtleXMubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpO1xuICAgICAgICBjb25zdCB1cGRhdGVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoYXR0ciA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09RVhDTFVERUQuJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gKTtcbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBgIE9OIENPTkZMSUNUICgke2NvbmZsaWN0S2V5cy5qb2luKCcsJyl9KSBETyBVUERBVEUgU0VUICR7dXBkYXRlS2V5cy5qb2luKCcsJyl9YDtcbiAgICAgIH0gZWxzZSB7IC8vIG15c3FsIC8gbWFyaWFcbiAgICAgICAgY29uc3QgdmFsdWVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoYXR0ciA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09VkFMVUVTKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9KWApO1xuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IGAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZX0gJHt2YWx1ZUtleXMuam9pbignLCcpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaWdub3JlRHVwbGljYXRlcyA9IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5pZ25vcmVEdXBsaWNhdGVzIDogJyc7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oJywnKTtcbiAgICBjb25zdCBvbkNvbmZsaWN0RG9Ob3RoaW5nID0gb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3REb05vdGhpbmcgOiAnJztcbiAgICBsZXQgcmV0dXJuaW5nID0gJyc7XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoZmllbGRNYXBwZWRBdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuaW5nICs9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnSU5TRVJUJyxcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXMsXG4gICAgICAnSU5UTycsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGAoJHthdHRyaWJ1dGVzfSlgLFxuICAgICAgJ1ZBTFVFUycsXG4gICAgICB0dXBsZXMuam9pbignLCcpLFxuICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUsXG4gICAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nLFxuICAgICAgcmV0dXJuaW5nLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiB1cGRhdGUgcXVlcnlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0clZhbHVlSGFzaFxuICAgKiBAcGFyYW0ge29iamVjdH0gd2hlcmUgQSBoYXNoIHdpdGggY29uZGl0aW9ucyAoZS5nLiB7bmFtZTogJ2Zvbyd9KSBPUiBhbiBJRCBhcyBpbnRlZ2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgYXR0clZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChhdHRyVmFsdWVIYXNoLCBvcHRpb25zLm9taXROdWxsLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9ICcnO1xuICAgIGxldCB0bXBUYWJsZSA9ICcnOyAvLyB0bXBUYWJsZSBkZWNsYXJhdGlvbiBmb3IgdHJpZ2dlclxuICAgIGxldCBzdWZmaXggPSAnJztcblxuICAgIGlmIChfLmdldCh0aGlzLCBbJ3NlcXVlbGl6ZScsICdvcHRpb25zJywgJ2RpYWxlY3RPcHRpb25zJywgJ3ByZXBlbmRTZWFyY2hQYXRoJ10pIHx8IG9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgLy8gTm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgd2l0aCBzZWFyY2ggcGF0aCAocmVxdWlyZXMgb3V0cHV0IG9mIG11bHRpcGxlIHF1ZXJpZXMpXG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtID09PSB1bmRlZmluZWQgPyB0aGlzLmJpbmRQYXJhbShiaW5kKSA6IG9wdGlvbnMuYmluZFBhcmFtO1xuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ0xJTUlUIE9OIFVQREFURSddICYmIG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGlmICh0aGlzLmRpYWxlY3QgIT09ICdtc3NxbCcpIHtcbiAgICAgICAgc3VmZml4ID0gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhhdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgICAgc3VmZml4ICs9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIHRtcFRhYmxlID0gcmV0dXJuVmFsdWVzLnRtcFRhYmxlIHx8ICcnO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQgfHwgJyc7XG5cbiAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSByZXR1cm4gb3V0cHV0IGlzIHByb3Blcmx5IG1hcHBlZCB0byBtb2RlbCBmaWVsZHMuXG4gICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLm91dHB1dCAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgICBvcHRpb25zLm1hcFRvTW9kZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2goYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyVmFsdWVIYXNoKSB7XG4gICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJlxuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUgJiZcbiAgICAgICAgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC51cGRhdGUpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQgdG8gdXBkYXRlIGlkZW50aXR5IGNvbHVtblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWVIYXNoW2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ1VQREFURScgfSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnVVBEQVRFJyB9LCBiaW5kUGFyYW0pfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdoZXJlT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgYmluZFBhcmFtIH07XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0gYCR7dG1wVGFibGV9VVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKCcsJyl9JHtvdXRwdXRGcmFnbWVudH0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9JHtzdWZmaXh9YC50cmltKCk7XG4gICAgLy8gVXNlZCBieSBQb3N0Z3JlcyB1cHNlcnRRdWVyeSBhbmQgY2FsbHMgdG8gaGVyZSB3aXRoIG9wdGlvbnMuZXhjZXB0aW9uIHNldCB0byB0cnVlXG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gYmluZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHVwZGF0ZSBxdWVyeSB1c2luZyBhcml0aG1ldGljIG9wZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciAgICAgICAgICAgICAgICAgICAgU3RyaW5nIHdpdGggdGhlIGFyaXRobWV0aWMgb3BlcmF0b3IgKGUuZy4gJysnIG9yICctJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICAgICAgICAgICAgICBOYW1lIG9mIHRoZSB0YWJsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gd2hlcmUgICAgICAgICAgICAgICAgICAgICAgIEEgcGxhaW4tb2JqZWN0IHdpdGggY29uZGl0aW9ucyAoZS5nLiB7bmFtZTogJ2Zvbyd9KSBPUiBhbiBJRCBhcyBpbnRlZ2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCAgICAgQSBwbGFpbi1vYmplY3Qgd2l0aCBhdHRyaWJ1dGUtdmFsdWUtcGFpcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkICBBIHBsYWluLW9iamVjdCB3aXRoIGF0dHJpYnV0ZS12YWx1ZS1wYWlyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXJpdGhtZXRpY1F1ZXJ5KG9wZXJhdG9yLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgcmV0dXJuaW5nOiB0cnVlIH0pO1xuXG4gICAgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQgPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIHRoaXMub3B0aW9ucy5vbWl0TnVsbCk7XG5cbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSAnJztcbiAgICBsZXQgcmV0dXJuaW5nRnJhZ21lbnQgPSAnJztcblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhudWxsLCBvcHRpb25zKTtcblxuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQ7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVTZXRTcWxGcmFnbWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIGluY3JlbWVudEFtb3VudHNCeUZpZWxkKSB7XG4gICAgICBjb25zdCBpbmNyZW1lbnRBbW91bnQgPSBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFtmaWVsZF07XG4gICAgICBjb25zdCBxdW90ZWRGaWVsZCA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIGNvbnN0IGVzY2FwZWRBbW91bnQgPSB0aGlzLmVzY2FwZShpbmNyZW1lbnRBbW91bnQpO1xuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLnB1c2goYCR7cXVvdGVkRmllbGR9PSR7cXVvdGVkRmllbGR9JHtvcGVyYXRvcn0gJHtlc2NhcGVkQW1vdW50fWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkW2ZpZWxkXTtcbiAgICAgIGNvbnN0IHF1b3RlZEZpZWxkID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgY29uc3QgZXNjYXBlZFZhbHVlID0gdGhpcy5lc2NhcGUobmV3VmFsdWUpO1xuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLnB1c2goYCR7cXVvdGVkRmllbGR9PSR7ZXNjYXBlZFZhbHVlfWApO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdVUERBVEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnU0VUJyxcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5qb2luKCcsJyksXG4gICAgICBvdXRwdXRGcmFnbWVudCxcbiAgICAgIHRoaXMud2hlcmVRdWVyeSh3aGVyZSksXG4gICAgICByZXR1cm5pbmdGcmFnbWVudFxuICAgIF0pO1xuICB9XG5cbiAgLypcbiAgICBSZXR1cm5zIGFuIGFkZCBpbmRleCBxdWVyeS5cbiAgICBQYXJhbWV0ZXJzOlxuICAgICAgLSB0YWJsZU5hbWUgLT4gTmFtZSBvZiBhbiBleGlzdGluZyB0YWJsZSwgcG9zc2libHkgd2l0aCBzY2hlbWEuXG4gICAgICAtIG9wdGlvbnM6XG4gICAgICAgIC0gdHlwZTogVU5JUVVFfEZVTExURVhUfFNQQVRJQUxcbiAgICAgICAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgaW5kZXguIERlZmF1bHQgaXMgPHRhYmxlPl88YXR0cjE+XzxhdHRyMj5cbiAgICAgICAgLSBmaWVsZHM6IEFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgYXMgc3RyaW5nIG9yIGFzIGhhc2guXG4gICAgICAgICAgICAgICAgICBJZiB0aGUgYXR0cmlidXRlIGlzIGEgaGFzaCwgaXQgbXVzdCBoYXZlIHRoZSBmb2xsb3dpbmcgY29udGVudDpcbiAgICAgICAgICAgICAgICAgIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS9jb2x1bW5cbiAgICAgICAgICAgICAgICAgIC0gbGVuZ3RoOiBBbiBpbnRlZ2VyLiBPcHRpb25hbFxuICAgICAgICAgICAgICAgICAgLSBvcmRlcjogJ0FTQycgb3IgJ0RFU0MnLiBPcHRpb25hbFxuICAgICAgICAtIHBhcnNlclxuICAgICAgICAtIHVzaW5nXG4gICAgICAgIC0gb3BlcmF0b3JcbiAgICAgICAgLSBjb25jdXJyZW50bHk6IFBhc3MgQ09OQ1VSUkVOVCBzbyBvdGhlciBvcGVyYXRpb25zIHJ1biB3aGlsZSB0aGUgaW5kZXggaXMgY3JlYXRlZFxuICAgICAgLSByYXdUYWJsZW5hbWUsIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSwgd2l0aG91dCBzY2hlbWEuIFVzZWQgdG8gY3JlYXRlIHRoZSBuYW1lIG9mIHRoZSBpbmRleFxuICAgQHByaXZhdGVcbiAgKi9cbiAgYWRkSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICBvcHRpb25zID0gYXR0cmlidXRlcztcbiAgICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8IHJhd1RhYmxlbmFtZSB8fCB0YWJsZU5hbWU7XG4gICAgaWYgKG9wdGlvbnMucHJlZml4ICYmIHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXgucmVwbGFjZSgvXFwuL2csICdfJyk7XG4gICAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4LnJlcGxhY2UoLyhcInwnKS9nLCAnJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmllbGRzU3FsID0gb3B0aW9ucy5maWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgbmFtZTogZmllbGRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgICAgaWYgKGZpZWxkLmF0dHJpYnV0ZSkge1xuICAgICAgICBmaWVsZC5uYW1lID0gZmllbGQuYXR0cmlidXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIGluZGV4IGZpZWxkIGhhcyBubyBuYW1lOiAke3V0aWwuaW5zcGVjdChmaWVsZCl9YCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5uYW1lKTtcblxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXguY29sbGF0ZSAmJiBmaWVsZC5jb2xsYXRlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgIENPTExBVEUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5jb2xsYXRlKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5vcGVyYXRvcikge1xuICAgICAgICBjb25zdCBvcGVyYXRvciA9IGZpZWxkLm9wZXJhdG9yIHx8IG9wdGlvbnMub3BlcmF0b3I7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCArPSBgICR7b3BlcmF0b3J9YDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5sZW5ndGggJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7ZmllbGQubGVuZ3RofSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQub3JkZXIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAgJHtmaWVsZC5vcmRlcn1gO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgIC8vIE1vc3RseSBmb3IgY2FzZXMgd2hlcmUgYWRkSW5kZXggaXMgY2FsbGVkIGRpcmVjdGx5IGJ5IHRoZSB1c2VyIHdpdGhvdXQgYW4gb3B0aW9ucyBvYmplY3QgKGZvciBleGFtcGxlIGluIG1pZ3JhdGlvbnMpXG4gICAgICAvLyBBbGwgY2FsbHMgdGhhdCBnbyB0aHJvdWdoIHNlcXVlbGl6ZSBzaG91bGQgYWxyZWFkeSBoYXZlIGEgbmFtZVxuICAgICAgb3B0aW9ucyA9IFV0aWxzLm5hbWVJbmRleChvcHRpb25zLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE1vZGVsLl9jb25mb3JtSW5kZXgob3B0aW9ucyk7XG5cbiAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudHlwZSkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMudHlwZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53aGVyZSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMud2hlcmVRdWVyeShvcHRpb25zLndoZXJlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25jdXJyZW50bHkgPSB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LmNvbmN1cnJlbnRseSAmJiBvcHRpb25zLmNvbmN1cnJlbnRseSA/ICdDT05DVVJSRU5UTFknIDogdW5kZWZpbmVkO1xuICAgIGxldCBpbmQ7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlcikge1xuICAgICAgaW5kID0gW1xuICAgICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIGNvbmN1cnJlbnRseSxcbiAgICAgICAgJ0FERCdcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZCA9IFsnQ1JFQVRFJ107XG4gICAgfVxuXG4gICAgaW5kID0gaW5kLmNvbmNhdChcbiAgICAgIG9wdGlvbnMudW5pcXVlID8gJ1VOSVFVRScgOiAnJyxcbiAgICAgIG9wdGlvbnMudHlwZSwgJ0lOREVYJyxcbiAgICAgICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIgPyBjb25jdXJyZW50bHkgOiB1bmRlZmluZWQsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcnMob3B0aW9ucy5uYW1lKSxcbiAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudXNpbmcgPT09IDEgJiYgb3B0aW9ucy51c2luZyA/IGBVU0lORyAke29wdGlvbnMudXNpbmd9YCA6ICcnLFxuICAgICAgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlciA/IGBPTiAke3RhYmxlTmFtZX1gIDogdW5kZWZpbmVkLFxuICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC51c2luZyA9PT0gMiAmJiBvcHRpb25zLnVzaW5nID8gYFVTSU5HICR7b3B0aW9ucy51c2luZ31gIDogJycsXG4gICAgICBgKCR7ZmllbGRzU3FsLmpvaW4oJywgJyl9KWAsXG4gICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnBhcnNlciAmJiBvcHRpb25zLnBhcnNlciA/IGBXSVRIIFBBUlNFUiAke29wdGlvbnMucGFyc2VyfWAgOiB1bmRlZmluZWQsXG4gICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LndoZXJlICYmIG9wdGlvbnMud2hlcmUgPyBvcHRpb25zLndoZXJlIDogdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIHJldHVybiBfLmNvbXBhY3QoaW5kKS5qb2luKCcgJyk7XG4gIH1cblxuICBhZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgICdBREQnLFxuICAgICAgdGhpcy5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMgfHwge30pLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBnZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY29uc3RyYWludFNuaXBwZXQsIGNvbnN0cmFpbnROYW1lO1xuXG4gICAgY29uc3QgZmllbGRzU3FsID0gb3B0aW9ucy5maWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgZmllbGQubmFtZSA9IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaWVsZC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBpbmRleCBmaWVsZCBoYXMgbm8gbmFtZTogJHtmaWVsZH1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLm5hbWUpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZmllbGRzU3FsUXVvdGVkU3RyaW5nID0gZmllbGRzU3FsLmpvaW4oJywgJyk7XG4gICAgY29uc3QgZmllbGRzU3FsU3RyaW5nID0gZmllbGRzU3FsLmpvaW4oJ18nKTtcblxuICAgIHN3aXRjaCAob3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ1VOSVFVRSc6XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X3VrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gVU5JUVVFICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdDSEVDSyc6XG4gICAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShvcHRpb25zLndoZXJlKTtcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fY2tgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBDSEVDSyAoJHtvcHRpb25zLndoZXJlfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RFRkFVTFQnOlxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCB2YWx1ZSBtdXN0IGJlIHNwZWNpZmVkIGZvciBERUZBVUxUIENPTlNUUkFJTlQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kaWFsZWN0Lm5hbWUgIT09ICdtc3NxbCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgY29uc3RyYWludHMgYXJlIHN1cHBvcnRlZCBvbmx5IGZvciBNU1NRTCBkaWFsZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fZGZgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBERUZBVUxUICgke3RoaXMuZXNjYXBlKG9wdGlvbnMuZGVmYXVsdFZhbHVlKX0pIEZPUiAke2ZpZWxkc1NxbFswXX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BSSU1BUlkgS0VZJzpcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fcGtgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBQUklNQVJZIEtFWSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRk9SRUlHTiBLRVknOlxuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gb3B0aW9ucy5yZWZlcmVuY2VzO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZXMgfHwgIXJlZmVyZW5jZXMudGFibGUgfHwgIShyZWZlcmVuY2VzLmZpZWxkIHx8IHJlZmVyZW5jZXMuZmllbGRzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVmZXJlbmNlcyBvYmplY3Qgd2l0aCB0YWJsZSBhbmQgZmllbGQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV8ke3JlZmVyZW5jZXMudGFibGV9X2ZrYCk7XG4gICAgICAgIGNvbnN0IHF1b3RlZFJlZmVyZW5jZXMgPVxuICAgICAgICAgIHR5cGVvZiByZWZlcmVuY2VzLmZpZWxkICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB0aGlzLnF1b3RlSWRlbnRpZmllcihyZWZlcmVuY2VzLmZpZWxkKVxuICAgICAgICAgICAgOiByZWZlcmVuY2VzLmZpZWxkcy5tYXAoZiA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmKSkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlc1NuaXBwZXQgPSBgJHt0aGlzLnF1b3RlVGFibGUocmVmZXJlbmNlcy50YWJsZSl9ICgke3F1b3RlZFJlZmVyZW5jZXN9KWA7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gYDtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYEZPUkVJR04gS0VZICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzU25pcHBldH1gO1xuICAgICAgICBpZiAob3B0aW9ucy5vblVwZGF0ZSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gVVBEQVRFICR7b3B0aW9ucy5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub25EZWxldGUpIHtcbiAgICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIERFTEVURSAke29wdGlvbnMub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbnMudHlwZX0gaXMgaW52YWxpZC5gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kZWZlcnJhYmxlICYmIFsnVU5JUVVFJywgJ1BSSU1BUlkgS0VZJywgJ0ZPUkVJR04gS0VZJ10uaW5jbHVkZXMob3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgICR7dGhpcy5kZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucyl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uc3RyYWludFNuaXBwZXQ7XG4gIH1cblxuICByZW1vdmVDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0YWJsZU5hbWUsXG4gICAgICAnRFJPUCBDT05TVFJBSU5UJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVycyhjb25zdHJhaW50TmFtZSlcbiAgICBdKTtcbiAgfVxuXG4gIC8qXG4gICAgUXVvdGUgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyB0eXBlLiBUaGlzIGlzIGEgbW9yZSBnZW5lcmFsIHZlcnNpb24gb2YgcXVvdGVJZGVudGlmaWVyc1xuICAgIFN0cmluZ3M6IHNob3VsZCBwcm94eSB0byBxdW90ZUlkZW50aWZpZXJzXG4gICAgQXJyYXlzOlxuICAgICAgKiBFeHBlY3RzIGFycmF5IGluIHRoZSBmb3JtOiBbPG1vZGVsPiAob3B0aW9uYWwpLCA8bW9kZWw+IChvcHRpb25hbCksLi4uIFN0cmluZywgU3RyaW5nIChvcHRpb25hbCldXG4gICAgICAgIEVhY2ggPG1vZGVsPiBjYW4gYmUgYSBtb2RlbCwgb3IgYW4gb2JqZWN0IHttb2RlbDogTW9kZWwsIGFzOiBTdHJpbmd9LCBtYXRjaGluZyBpbmNsdWRlLCBvciBhblxuICAgICAgICBhc3NvY2lhdGlvbiBvYmplY3QsIG9yIHRoZSBuYW1lIG9mIGFuIGFzc29jaWF0aW9uLlxuICAgICAgKiBaZXJvIG9yIG1vcmUgbW9kZWxzIGNhbiBiZSBpbmNsdWRlZCBpbiB0aGUgYXJyYXkgYW5kIGFyZSB1c2VkIHRvIHRyYWNlIGEgcGF0aCB0aHJvdWdoIHRoZSB0cmVlIG9mXG4gICAgICAgIGluY2x1ZGVkIG5lc3RlZCBhc3NvY2lhdGlvbnMuIFRoaXMgcHJvZHVjZXMgdGhlIGNvcnJlY3QgdGFibGUgbmFtZSBmb3IgdGhlIE9SREVSIEJZL0dST1VQIEJZIFNRTFxuICAgICAgICBhbmQgcXVvdGVzIGl0LlxuICAgICAgKiBJZiBhIHNpbmdsZSBzdHJpbmcgaXMgYXBwZW5kZWQgdG8gZW5kIG9mIGFycmF5LCBpdCBpcyBxdW90ZWQuXG4gICAgICAgIElmIHR3byBzdHJpbmdzIGFwcGVuZGVkLCB0aGUgMXN0IHN0cmluZyBpcyBxdW90ZWQsIHRoZSAybmQgc3RyaW5nIHVucXVvdGVkLlxuICAgIE9iamVjdHM6XG4gICAgICAqIElmIHJhdyBpcyBzZXQsIHRoYXQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIHZlcmJhdGltLCB3aXRob3V0IHF1b3RpbmdcbiAgICAgICogSWYgZm4gaXMgc2V0LCB0aGUgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIHRoZSB2YWx1ZSBvZiBmbiwgc3RhcnRpbmcgcGFyZW4sIGZvbGxvd2VkIGJ5XG4gICAgICAgIHRoZSB2YWx1ZXMgb2YgY29scyAod2hpY2ggaXMgYXNzdW1lZCB0byBiZSBhbiBhcnJheSksIHF1b3RlZCBhbmQgam9pbmVkIHdpdGggJywgJyxcbiAgICAgICAgdW5sZXNzIHRoZXkgYXJlIHRoZW1zZWx2ZXMgb2JqZWN0c1xuICAgICAgKiBJZiBkaXJlY3Rpb24gaXMgc2V0LCBzaG91bGQgYmUgcHJlcGVuZGVkXG5cbiAgICBDdXJyZW50bHkgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIG9yZGVyaW5nIC8gZ3JvdXBpbmcgY29sdW1ucyBhbmQgU2VxdWVsaXplLmNvbCgpLCBidXQgaXQgY291bGRcbiAgICBwb3RlbnRpYWxseSBhbHNvIGJlIHVzZWQgZm9yIG90aGVyIHBsYWNlcyB3aGVyZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gY2FsbCBTUUwgZnVuY3Rpb25zIChlLmcuIGFzIGRlZmF1bHQgdmFsdWVzKVxuICAgQHByaXZhdGVcbiAgKi9cbiAgcXVvdGUoY29sbGVjdGlvbiwgcGFyZW50LCBjb25uZWN0b3IpIHtcbiAgICAvLyBpbml0XG4gICAgY29uc3QgdmFsaWRPcmRlck9wdGlvbnMgPSBbXG4gICAgICAnQVNDJyxcbiAgICAgICdERVNDJyxcbiAgICAgICdBU0MgTlVMTFMgTEFTVCcsXG4gICAgICAnREVTQyBOVUxMUyBMQVNUJyxcbiAgICAgICdBU0MgTlVMTFMgRklSU1QnLFxuICAgICAgJ0RFU0MgTlVMTFMgRklSU1QnLFxuICAgICAgJ05VTExTIEZJUlNUJyxcbiAgICAgICdOVUxMUyBMQVNUJ1xuICAgIF07XG5cbiAgICAvLyBkZWZhdWx0XG4gICAgY29ubmVjdG9yID0gY29ubmVjdG9yIHx8ICcuJztcblxuICAgIC8vIGp1c3QgcXVvdGUgYXMgaWRlbnRpZmllcnMgaWYgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVycyhjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY29sbGVjdGlvbiBhbmQgbXV0YXRlIG9iamVjdHMgaW50byBhc3NvY2lhdGlvbnNcbiAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG4gICAgICAgIGxldCBwcmV2aW91c0Fzc29jaWF0aW9uO1xuICAgICAgICBsZXQgcHJldmlvdXNNb2RlbDtcblxuICAgICAgICAvLyBzZXQgdGhlIHByZXZpb3VzIGFzIHRoZSBwYXJlbnQgd2hlbiBwcmV2aW91cyBpcyB1bmRlZmluZWQgb3IgdGhlIHRhcmdldCBvZiB0aGUgYXNzb2NpYXRpb25cbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByZXZpb3VzTW9kZWwgPSBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgJiYgcHJldmlvdXMgaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHByZXZpb3VzQXNzb2NpYXRpb24gPSBwcmV2aW91cztcbiAgICAgICAgICBwcmV2aW91c01vZGVsID0gcHJldmlvdXMudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gaXMgYSBtb2RlbCwgdGhlbiBhdHRlbXB0IGdldHRpbmcgYW4gYXNzb2NpYXRpb25cbiAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwgJiYgcHJldmlvdXNNb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgICBsZXQgYXM7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgICBtb2RlbCA9IGl0ZW07XG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkgJiYgaXRlbS5tb2RlbCAmJiBpdGVtLm1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICAgIG1vZGVsID0gaXRlbS5tb2RlbDtcbiAgICAgICAgICAgIGFzID0gaXRlbS5hcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgYXMgdG8gZWl0aGVyIHRoZSB0aHJvdWdoIG5hbWUgb3IgdGhlIG1vZGVsIG5hbWVcbiAgICAgICAgICAgIGlmICghYXMgJiYgcHJldmlvdXNBc3NvY2lhdGlvbiAmJiBwcmV2aW91c0Fzc29jaWF0aW9uIGluc3RhbmNlb2YgQXNzb2NpYXRpb24gJiYgcHJldmlvdXNBc3NvY2lhdGlvbi50aHJvdWdoICYmIHByZXZpb3VzQXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCA9PT0gbW9kZWwpIHtcbiAgICAgICAgICAgICAgLy8gZ2V0IGZyb20gcHJldmlvdXMgYXNzb2NpYXRpb25cbiAgICAgICAgICAgICAgaXRlbSA9IG5ldyBBc3NvY2lhdGlvbihwcmV2aW91c01vZGVsLCBtb2RlbCwge1xuICAgICAgICAgICAgICAgIGFzOiBtb2RlbC5uYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZ2V0IGFzc29jaWF0aW9uIGZyb20gcHJldmlvdXMgbW9kZWxcbiAgICAgICAgICAgICAgaXRlbSA9IHByZXZpb3VzTW9kZWwuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyhtb2RlbCwgYXMpO1xuXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gdXNlIHRoZSBtb2RlbCBuYW1lIGlmIHRoZSBpdGVtIGlzIHN0aWxsIG51bGxcbiAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHByZXZpb3VzTW9kZWwuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyhtb2RlbCwgbW9kZWwubmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYW4gYXNzb2NpYXRpb25cbiAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdVbmFibGUgdG8gZmluZCBhIHZhbGlkIGFzc29jaWF0aW9uIGZvciBtb2RlbCwgXFwnJXNcXCcnLCBtb2RlbC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGdldCBvcmRlciBpbmRleFxuICAgICAgICAgIGNvbnN0IG9yZGVySW5kZXggPSB2YWxpZE9yZGVyT3B0aW9ucy5pbmRleE9mKGl0ZW0udG9VcHBlckNhc2UoKSk7XG5cbiAgICAgICAgICAvLyBzZWUgaWYgdGhpcyBpcyBhbiBvcmRlclxuICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgb3JkZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGAgJHt2YWxpZE9yZGVyT3B0aW9uc1tvcmRlckluZGV4XX1gKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW9kZWwgJiYgcHJldmlvdXNNb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgLy8gb25seSBnbyBkb3duIHRoaXMgcGF0aCBpZiB3ZSBoYXZlIHByZWl2b3VzIG1vZGVsIGFuZCBjaGVjayBvbmx5IG9uY2VcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGVsLmFzc29jaWF0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zW2l0ZW1dKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGl0ZW0gdG8gYW4gYXNzb2NpYXRpb25cbiAgICAgICAgICAgICAgaXRlbSA9IHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zW2l0ZW1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbV0gJiYgaXRlbSAhPT0gcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1dLmZpZWxkKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGl0ZW0gYXR0cmlidXRlIGZyb20gaXRzIGFsaWFzXG4gICAgICAgICAgICAgIGl0ZW0gPSBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbV0uZmllbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBpdGVtLmluY2x1ZGVzKCcuJylcbiAgICAgICAgICAgICAgJiYgcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtU3BsaXQgPSBpdGVtLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtU3BsaXRbMF1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgcXVvdGUgaWRlbnRpZmllcnMgZm9yIG5vd1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYCR7cHJldmlvdXNNb2RlbC5uYW1lfS4ke3ByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtU3BsaXRbMF1dLmZpZWxkfWApO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHBhdGhcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gaXRlbVNwbGl0LnNsaWNlKDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBwYXRoXG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoaWRlbnRpZmllciwgcGF0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFsIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhcHBlbmQgdGhlIG1vZGVsIG5hbWUgd2hlbiBzdHJpbmdcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxlY3Rpb25baW5kZXhdID0gaXRlbTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAvLyBsb29wIHRocm91Z2ggYXJyYXksIGFkZGluZyB0YWJsZSBuYW1lcyBvZiBtb2RlbHMgdG8gcXVvdGVkXG4gICAgICBjb25zdCBjb2xsZWN0aW9uTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBjb25zdCB0YWJsZU5hbWVzID0gW107XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGxldCBpID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbGxlY3Rpb25MZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNvbGxlY3Rpb25baV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgaXRlbS5fbW9kZWxBdHRyaWJ1dGUgfHwgaXRlbSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHRhYmxlTmFtZXNbaV0gPSBpdGVtLmFzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IGJ1aWxkaW5nIHNxbFxuICAgICAgbGV0IHNxbCA9ICcnO1xuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgc3FsICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlTmFtZXMuam9pbihjb25uZWN0b3IpKX0uYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxlY3Rpb25bMF0gPT09ICdzdHJpbmcnICYmIHBhcmVudCkge1xuICAgICAgICBzcWwgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIocGFyZW50Lm5hbWUpfS5gO1xuICAgICAgfVxuXG4gICAgICAvLyBsb29wIHRocm91Z2ggZXZlcnl0aGluZyBwYXN0IGkgYW5kIGFwcGVuZCB0byB0aGUgc3FsXG4gICAgICBjb2xsZWN0aW9uLnNsaWNlKGkpLmZvckVhY2goY29sbGVjdGlvbkl0ZW0gPT4ge1xuICAgICAgICBzcWwgKz0gdGhpcy5xdW90ZShjb2xsZWN0aW9uSXRlbSwgcGFyZW50LCBjb25uZWN0b3IpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBzcWw7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uLl9tb2RlbEF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMucXVvdGVUYWJsZShjb2xsZWN0aW9uLk1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGNvbGxlY3Rpb24uZmllbGROYW1lKX1gO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGNvbGxlY3Rpb24pICYmIGNvbGxlY3Rpb24ucmF3KSB7XG4gICAgICAvLyBzaW1wbGUgb2JqZWN0cyB3aXRoIHJhdyBpcyBubyBsb25nZXIgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBge3JhdzogXCIuLi5cIn1gIHN5bnRheCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAgVXNlIGBzZXF1ZWxpemUubGl0ZXJhbGAgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cnVjdHVyZSBwYXNzZWQgdG8gb3JkZXIgLyBncm91cDogJHt1dGlsLmluc3BlY3QoY29sbGVjdGlvbil9YCk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgYSBsaXN0IG9mIGlkZW50aWZpZXJzIGJ5IFwiLlwiIGFuZCBxdW90ZSBlYWNoIHBhcnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIFF1b3RlSGVscGVyLnF1b3RlSWRlbnRpZmllcih0aGlzLmRpYWxlY3QsIGlkZW50aWZpZXIsIHtcbiAgICAgIGZvcmNlLFxuICAgICAgcXVvdGVJZGVudGlmaWVyczogdGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnNcbiAgICB9KTtcbiAgfVxuXG4gIHF1b3RlSWRlbnRpZmllcnMoaWRlbnRpZmllcnMpIHtcbiAgICBpZiAoaWRlbnRpZmllcnMuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgaWRlbnRpZmllcnMgPSBpZGVudGlmaWVycy5zcGxpdCgnLicpO1xuXG4gICAgICBjb25zdCBoZWFkID0gaWRlbnRpZmllcnMuc2xpY2UoMCwgaWRlbnRpZmllcnMubGVuZ3RoIC0gMSkuam9pbignLT4nKTtcbiAgICAgIGNvbnN0IHRhaWwgPSBpZGVudGlmaWVyc1tpZGVudGlmaWVycy5sZW5ndGggLSAxXTtcblxuICAgICAgcmV0dXJuIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGhlYWQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhaWwpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXJzKTtcbiAgfVxuXG4gIHF1b3RlQXR0cmlidXRlKGF0dHJpYnV0ZSwgbW9kZWwpIHtcbiAgICBpZiAobW9kZWwgJiYgYXR0cmlidXRlIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGF0dHJpYnV0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUXVvdGUgdGFibGUgbmFtZSB3aXRoIG9wdGlvbmFsIGFsaWFzIGFuZCBzY2hlbWEgYXR0cmlidXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgcGFyYW0gdGFibGUgc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBhbGlhcyBhbGlhcyBuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBxdW90ZVRhYmxlKHBhcmFtLCBhbGlhcykge1xuICAgIGxldCB0YWJsZSA9ICcnO1xuXG4gICAgaWYgKGFsaWFzID09PSB0cnVlKSB7XG4gICAgICBhbGlhcyA9IHBhcmFtLmFzIHx8IHBhcmFtLm5hbWUgfHwgcGFyYW07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QocGFyYW0pKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5zY2hlbWFzKSB7XG4gICAgICAgIGlmIChwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgICB0YWJsZSArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbS5zY2hlbWEpfS5gO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUgKz0gdGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0udGFibGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgICB0YWJsZSArPSBwYXJhbS5zY2hlbWEgKyAocGFyYW0uZGVsaW1pdGVyIHx8ICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZSArPSBwYXJhbS50YWJsZU5hbWU7XG4gICAgICAgIHRhYmxlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtKTtcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMpIHtcbiAgICAgIHRhYmxlICs9IGAgQVMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcyl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICAvKlxuICAgIEVzY2FwZSBhIHZhbHVlIChlLmcuIGEgc3RyaW5nLCBudW1iZXIgb3IgZGF0ZSlcbiAgICBAcHJpdmF0ZVxuICAqL1xuICBlc2NhcGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgJiYgZmllbGQudHlwZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZpZWxkLnR5cGUuc3RyaW5naWZ5KSB7XG4gICAgICAgICAgLy8gVXNlcnMgc2hvdWxkbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhlc2UgYXJncyAtIGp1c3QgZ2l2ZSB0aGVtIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmdcbiAgICAgICAgICBjb25zdCBzaW1wbGVFc2NhcGUgPSBlc2NWYWwgPT4gU3FsU3RyaW5nLmVzY2FwZShlc2NWYWwsIHRoaXMub3B0aW9ucy50aW1lem9uZSwgdGhpcy5kaWFsZWN0KTtcblxuICAgICAgICAgIHZhbHVlID0gZmllbGQudHlwZS5zdHJpbmdpZnkodmFsdWUsIHsgZXNjYXBlOiBzaW1wbGVFc2NhcGUsIGZpZWxkLCB0aW1lem9uZTogdGhpcy5vcHRpb25zLnRpbWV6b25lLCBvcGVyYXRpb246IG9wdGlvbnMub3BlcmF0aW9uIH0pO1xuXG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUuZXNjYXBlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gVGhlIGRhdGEtdHlwZSBhbHJlYWR5IGRpZCB0aGUgcmVxdWlyZWQgZXNjYXBpbmdcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodmFsdWUsIHRoaXMub3B0aW9ucy50aW1lem9uZSwgdGhpcy5kaWFsZWN0KTtcbiAgfVxuXG4gIGJpbmRQYXJhbShiaW5kKSB7XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIGJpbmQucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gYCQke2JpbmQubGVuZ3RofWA7XG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAgUmV0dXJucyBhIGJpbmQgcGFyYW1ldGVyIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsdWUgKGUuZy4gYSBzdHJpbmcsIG51bWJlciBvciBkYXRlKVxuICAgIEBwcml2YXRlXG4gICovXG4gIGZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIGJpbmRQYXJhbSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXNzIFNlcXVlbGl6ZU1ldGhvZCBhcyBhIGJpbmQgcGFyYW1ldGVyIC0gdXNlIGVzY2FwZSBpbnN0ZWFkJyk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgJiYgZmllbGQudHlwZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZpZWxkLnR5cGUuYmluZFBhcmFtKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLnR5cGUuYmluZFBhcmFtKHZhbHVlLCB7IGVzY2FwZTogXy5pZGVudGl0eSwgZmllbGQsIHRpbWV6b25lOiB0aGlzLm9wdGlvbnMudGltZXpvbmUsIG9wZXJhdGlvbjogb3B0aW9ucy5vcGVyYXRpb24sIGJpbmRQYXJhbSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5kUGFyYW0odmFsdWUpO1xuICB9XG5cbiAgLypcbiAgICBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBmaWVsZCBzcGVjaWZpY2F0aW9uXG4gICAgQHByaXZhdGVcbiAgKi9cbiAgdmFsaWRhdGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMudHlwZVZhbGlkYXRpb24gJiYgZmllbGQudHlwZS52YWxpZGF0ZSAmJiB2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNMaXN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBmaWVsZC50eXBlLnZhbGlkYXRlKGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZC50eXBlLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgJ1ZhbGlkYXRpb24gZXJyb3InLFxuICAgICAgICAgICAgZmllbGQuZmllbGROYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYCR7ZmllbGQudHlwZS5rZXl9IHZhbGlkYXRvcmBcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzSWRlbnRpZmllclF1b3RlZChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIFF1b3RlSGVscGVyLmlzSWRlbnRpZmllclF1b3RlZChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgZXh0cmFjdCBKU09OIHByb3BlcnR5IG9mIGdpdmVuIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICAgICAgICAgY29sdW1uICBUaGUgSlNPTiBjb2x1bW5cbiAgICogQHBhcmFtICAge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBbcGF0aF0gIFRoZSBwYXRoIHRvIGV4dHJhY3QgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aCkge1xuICAgIGxldCBwYXRocyA9IF8udG9QYXRoKHBhdGgpO1xuICAgIGxldCBwYXRoU3RyO1xuICAgIGNvbnN0IHF1b3RlZENvbHVtbiA9IHRoaXMuaXNJZGVudGlmaWVyUXVvdGVkKGNvbHVtbilcbiAgICAgID8gY29sdW1uXG4gICAgICA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbik7XG5cbiAgICBzd2l0Y2ggKHRoaXMuZGlhbGVjdCkge1xuICAgICAgY2FzZSAnbXlzcWwnOlxuICAgICAgY2FzZSAnbWFyaWFkYic6XG4gICAgICBjYXNlICdzcWxpdGUnOlxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uIGRpZ2l0IHN1YiBwYXRocyBuZWVkIHRvIGJlIHF1b3RlZCBhcyBFQ01BU2NyaXB0IGlkZW50aWZpZXJzXG4gICAgICAgICAqIGh0dHBzOi8vYnVncy5teXNxbC5jb20vYnVnLnBocD9pZD04MTg5NlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gJ215c3FsJykge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMubWFwKHN1YlBhdGggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIC9cXEQvLnRlc3Qoc3ViUGF0aClcbiAgICAgICAgICAgICAgPyBVdGlscy5hZGRUaWNrcyhzdWJQYXRoLCAnXCInKVxuICAgICAgICAgICAgICA6IHN1YlBhdGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoU3RyID0gdGhpcy5lc2NhcGUoWyckJ11cbiAgICAgICAgICAuY29uY2F0KHBhdGhzKVxuICAgICAgICAgIC5qb2luKCcuJylcbiAgICAgICAgICAucmVwbGFjZSgvXFwuKFxcZCspKD86KD89XFwuKXwkKS9nLCAoX18sIGRpZ2l0KSA9PiBgWyR7ZGlnaXR9XWApKTtcblxuICAgICAgICBpZiAodGhpcy5kaWFsZWN0ID09PSAnc3FsaXRlJykge1xuICAgICAgICAgIHJldHVybiBganNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYGpzb25fdW5xdW90ZShqc29uX2V4dHJhY3QoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pKWA7XG5cbiAgICAgIGNhc2UgJ3Bvc3RncmVzJzpcbiAgICAgICAgcGF0aFN0ciA9IHRoaXMuZXNjYXBlKGB7JHtwYXRocy5qb2luKCcsJyl9fWApO1xuICAgICAgICByZXR1cm4gYCgke3F1b3RlZENvbHVtbn0jPj4ke3BhdGhTdHJ9KWA7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgJHt0aGlzLmRpYWxlY3R9IGZvciBKU09OIG9wZXJhdGlvbnNgKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgIFJldHVybnMgYSBxdWVyeSBmb3Igc2VsZWN0aW5nIGVsZW1lbnRzIGluIHRoZSB0YWJsZSA8dGFibGVOYW1lPi5cbiAgICBPcHRpb25zOlxuICAgICAgLSBhdHRyaWJ1dGVzIC0+IEFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgKGUuZy4gWyduYW1lJywgJ2JpcnRoZGF5J10pLiBEZWZhdWx0OiAqXG4gICAgICAtIHdoZXJlIC0+IEEgaGFzaCB3aXRoIGNvbmRpdGlvbnMgKGUuZy4ge25hbWU6ICdmb28nfSlcbiAgICAgICAgICAgICAgICAgT1IgYW4gSUQgYXMgaW50ZWdlclxuICAgICAgLSBvcmRlciAtPiBlLmcuICdpZCBERVNDJ1xuICAgICAgLSBncm91cFxuICAgICAgLSBsaW1pdCAtPiBUaGUgbWF4aW11bSBjb3VudCB5b3Ugd2FudCB0byBnZXQuXG4gICAgICAtIG9mZnNldCAtPiBBbiBvZmZzZXQgdmFsdWUgdG8gc3RhcnQgZnJvbS4gT25seSB1c2VhYmxlIHdpdGggbGltaXQhXG4gICBAcHJpdmF0ZVxuICAqL1xuICBzZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0O1xuICAgIGNvbnN0IG1haW5RdWVyeUl0ZW1zID0gW107XG4gICAgY29uc3Qgc3ViUXVlcnlJdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5ID0gb3B0aW9ucy5zdWJRdWVyeSA9PT0gdW5kZWZpbmVkID8gbGltaXQgJiYgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uIDogb3B0aW9ucy5zdWJRdWVyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogb3B0aW9ucy5hdHRyaWJ1dGVzICYmIG9wdGlvbnMuYXR0cmlidXRlcy5zbGljZSgpLFxuICAgICAgc3ViUXVlcnk6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IG1haW5UYWJsZSA9IHtcbiAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgIHF1b3RlZE5hbWU6IG51bGwsXG4gICAgICBhczogbnVsbCxcbiAgICAgIG1vZGVsXG4gICAgfTtcbiAgICBjb25zdCB0b3BMZXZlbEluZm8gPSB7XG4gICAgICBuYW1lczogbWFpblRhYmxlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHN1YlF1ZXJ5XG4gICAgfTtcbiAgICBsZXQgbWFpbkpvaW5RdWVyaWVzID0gW107XG4gICAgbGV0IHN1YkpvaW5RdWVyaWVzID0gW107XG4gICAgbGV0IHF1ZXJ5O1xuXG4gICAgLy8gQWxpYXNlcyBjYW4gYmUgcGFzc2VkIHRocm91Z2ggc3VicXVlcmllcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byByZXNldCB0aGVtXG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmICFvcHRpb25zLmFsaWFzZXNNYXBwaW5nKSB7XG4gICAgICBvcHRpb25zLmFsaWFzZXNNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZSA9IHt9O1xuICAgICAgb3B0aW9ucy5pbmNsdWRlQWxpYXNlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRhYmxlIG5hbWUgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLnRhYmxlQXMpIHtcbiAgICAgIG1haW5UYWJsZS5hcyA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMudGFibGVBcyk7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYWluVGFibGUubmFtZSkgJiYgbWFpblRhYmxlLm1vZGVsKSB7XG4gICAgICBtYWluVGFibGUuYXMgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihtYWluVGFibGUubW9kZWwubmFtZSk7XG4gICAgfVxuXG4gICAgbWFpblRhYmxlLnF1b3RlZE5hbWUgPSAhQXJyYXkuaXNBcnJheShtYWluVGFibGUubmFtZSkgPyB0aGlzLnF1b3RlVGFibGUobWFpblRhYmxlLm5hbWUpIDogdGFibGVOYW1lLm1hcCh0ID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdGhpcy5xdW90ZVRhYmxlKHRbMF0sIHRbMV0pIDogdGhpcy5xdW90ZVRhYmxlKHQsIHRydWUpO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoc3ViUXVlcnkgJiYgYXR0cmlidXRlcy5tYWluKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleUF0dCBvZiBtYWluVGFibGUubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbWFpbkF0dHJpYnV0ZXMgY29udGFpbiB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIG1vZGVsIGVpdGhlciBhcyBhIGZpZWxkIG9yIGFuIGFsaWFzZWQgZmllbGRcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLm1haW4uc29tZShhdHRyID0+IGtleUF0dCA9PT0gYXR0ciB8fCBrZXlBdHQgPT09IGF0dHJbMF0gfHwga2V5QXR0ID09PSBhdHRyWzFdKSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKG1haW5UYWJsZS5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleUF0dF0uZmllbGQgPyBba2V5QXR0LCBtYWluVGFibGUubW9kZWwucmF3QXR0cmlidXRlc1trZXlBdHRdLmZpZWxkXSA6IGtleUF0dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVzLm1haW4gPSB0aGlzLmVzY2FwZUF0dHJpYnV0ZXMoYXR0cmlidXRlcy5tYWluLCBvcHRpb25zLCBtYWluVGFibGUuYXMpO1xuICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbiB8fCAob3B0aW9ucy5pbmNsdWRlID8gW2Ake21haW5UYWJsZS5hc30uKmBdIDogWycqJ10pO1xuXG4gICAgLy8gSWYgc3VicXVlcnksIHdlIGFkZCB0aGUgbWFpbkF0dHJpYnV0ZXMgdG8gdGhlIHN1YlF1ZXJ5IGFuZCBzZXQgdGhlIG1haW5BdHRyaWJ1dGVzIHRvIHNlbGVjdCAqIGZyb20gc3VicXVlcnlcbiAgICBpZiAoc3ViUXVlcnkgfHwgb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIC8vIFdlIG5lZWQgcHJpbWFyeSBrZXlzXG4gICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5tYWluO1xuICAgICAgYXR0cmlidXRlcy5tYWluID0gW2Ake21haW5UYWJsZS5hcyB8fCBtYWluVGFibGUucXVvdGVkTmFtZX0uKmBdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuc2VwYXJhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqb2luUXVlcmllcyA9IHRoaXMuZ2VuZXJhdGVJbmNsdWRlKGluY2x1ZGUsIHsgZXh0ZXJuYWxBczogbWFpblRhYmxlLmFzLCBpbnRlcm5hbEFzOiBtYWluVGFibGUuYXMgfSwgdG9wTGV2ZWxJbmZvKTtcblxuICAgICAgICBzdWJKb2luUXVlcmllcyA9IHN1YkpvaW5RdWVyaWVzLmNvbmNhdChqb2luUXVlcmllcy5zdWJRdWVyeSk7XG4gICAgICAgIG1haW5Kb2luUXVlcmllcyA9IG1haW5Kb2luUXVlcmllcy5jb25jYXQoam9pblF1ZXJpZXMubWFpblF1ZXJ5KTtcblxuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4gPSBfLnVuaXEoYXR0cmlidXRlcy5tYWluLmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IF8udW5pcShhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaCh0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCwgYXR0cmlidXRlcy5zdWJRdWVyeSwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcykpO1xuICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKHN1YkpvaW5RdWVyaWVzLmpvaW4oJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICAgIGlmICghbWFpblRhYmxlLmFzKSB7XG4gICAgICAgICAgbWFpblRhYmxlLmFzID0gbWFpblRhYmxlLnF1b3RlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hlcmUgPSB7IC4uLm9wdGlvbnMud2hlcmUgfTtcbiAgICAgICAgbGV0IGdyb3VwZWRMaW1pdE9yZGVyLFxuICAgICAgICAgIHdoZXJlS2V5LFxuICAgICAgICAgIGluY2x1ZGUsXG4gICAgICAgICAgZ3JvdXBlZFRhYmxlTmFtZSA9IG1haW5UYWJsZS5hcztcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHdoZXJlS2V5ID0gb3B0aW9ucy5ncm91cGVkTGltaXQub247XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ncm91cGVkTGltaXQub24gaW5zdGFuY2VvZiBIYXNNYW55KSB7XG4gICAgICAgICAgd2hlcmVLZXkgPSBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5mb3JlaWduS2V5RmllbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5ncm91cGVkTGltaXQub24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSB7XG4gICAgICAgICAgLy8gQlRNIGluY2x1ZGVzIG5lZWRzIHRvIGpvaW4gdGhlIHRocm91Z2ggdGFibGUgb24gdG8gY2hlY2sgSURcbiAgICAgICAgICBncm91cGVkVGFibGVOYW1lID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24ubWFueUZyb21Tb3VyY2UuYXM7XG4gICAgICAgICAgY29uc3QgZ3JvdXBlZExpbWl0T3B0aW9ucyA9IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMoe1xuICAgICAgICAgICAgaW5jbHVkZTogW3tcbiAgICAgICAgICAgICAgYXNzb2NpYXRpb246IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLm1hbnlGcm9tU291cmNlLFxuICAgICAgICAgICAgICBkdXBsaWNhdGluZzogZmFsc2UsIC8vIFRoZSBVTklPTidlZCBxdWVyeSBtYXkgY29udGFpbiBkdXBsaWNhdGVzLCBidXQgZWFjaCBzdWItcXVlcnkgY2Fubm90XG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgIFtPcC5wbGFjZWhvbGRlcl06IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCAmJiBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoLndoZXJlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgbW9kZWxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhdHRyaWJ1dGVzIGZyb20gdGhlIGpvaW4gdGFibGUgYXJlIG1hcHBlZCBiYWNrIHRvIG1vZGVsc1xuICAgICAgICAgIG9wdGlvbnMuaGFzSm9pbiA9IHRydWU7XG4gICAgICAgICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVNYXAgPSBPYmplY3QuYXNzaWduKGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU1hcCwgb3B0aW9ucy5pbmNsdWRlTWFwKTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVOYW1lcyA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU5hbWVzLmNvbmNhdChvcHRpb25zLmluY2x1ZGVOYW1lcyB8fCBbXSk7XG4gICAgICAgICAgaW5jbHVkZSA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXIpKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgb3JkZXIgYnkgYXR0cmlidXRlcyBhcmUgYXZhaWxhYmxlIHRvIHRoZSBwYXJlbnQgcXVlcnlcbiAgICAgICAgICAgIG9wdGlvbnMub3JkZXIuZm9yRWFjaCgob3JkZXIsIGkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBvcmRlclswXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBhbGlhcyA9IGBzdWJxdWVyeV9vcmRlcl8ke2l9YDtcbiAgICAgICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLnB1c2goW29yZGVyLCBhbGlhc10pO1xuXG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcHJlcGVuZCBtb2RlbCBuYW1lIHdoZW4gd2UgYWxpYXMgdGhlIGF0dHJpYnV0ZXMsIHNvIHF1b3RlIHRoZW0gaGVyZVxuICAgICAgICAgICAgICBhbGlhcyA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZShhbGlhcykpO1xuXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcmRlcltpXVswXSA9IGFsaWFzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JkZXJbaV0gPSBhbGlhcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cGVkTGltaXRPcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9yZGVyaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YnF1ZXJpZXMsIHNvIG9yZGVyaW5nIHRoZSBVTklPTidlZCByZXN1bHQgaXMgbm90IG5lZWRlZFxuICAgICAgICAgIGdyb3VwZWRMaW1pdE9yZGVyID0gb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICB3aGVyZVtPcC5wbGFjZWhvbGRlcl0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGluZyB0aGUgYmFzZSBxdWVyeSBhbmQgc3BsaWNpbmcgdGhlIHdoZXJlIHBhcnQgaW50byBpdCBpcyBjb25zaXN0ZW50bHkgPiB0d2ljZVxuICAgICAgICAvLyBhcyBmYXN0IHRoYW4gZ2VuZXJhdGluZyBmcm9tIHNjcmF0Y2ggZWFjaCB0aW1lIGZvciB2YWx1ZXMubGVuZ3RoID49IDVcbiAgICAgICAgY29uc3QgYmFzZVF1ZXJ5ID0gYFNFTEVDVCAqIEZST00gKCR7dGhpcy5zZWxlY3RRdWVyeShcbiAgICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmdyb3VwZWRMaW1pdC5saW1pdCxcbiAgICAgICAgICAgIG9yZGVyOiBncm91cGVkTGltaXRPcmRlcixcbiAgICAgICAgICAgIGFsaWFzZXNNYXBwaW5nOiBvcHRpb25zLmFsaWFzZXNNYXBwaW5nLFxuICAgICAgICAgICAgYWxpYXNlc0J5VGFibGU6IG9wdGlvbnMuYWxpYXNlc0J5VGFibGUsXG4gICAgICAgICAgICB3aGVyZSxcbiAgICAgICAgICAgIGluY2x1ZGUsXG4gICAgICAgICAgICBtb2RlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kZWxcbiAgICAgICAgKS5yZXBsYWNlKC87JC8sICcnKX0pIEFTIHN1YmA7IC8vIEV2ZXJ5IGRlcml2ZWQgdGFibGUgbXVzdCBoYXZlIGl0cyBvd24gYWxpYXNcbiAgICAgICAgY29uc3QgcGxhY2VIb2xkZXIgPSB0aGlzLndoZXJlSXRlbVF1ZXJ5KE9wLnBsYWNlaG9sZGVyLCB0cnVlLCB7IG1vZGVsIH0pO1xuICAgICAgICBjb25zdCBzcGxpY2VQb3MgPSBiYXNlUXVlcnkuaW5kZXhPZihwbGFjZUhvbGRlcik7XG5cbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaCh0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCwgYXR0cmlidXRlcy5tYWluLCBgKCR7XG4gICAgICAgICAgb3B0aW9ucy5ncm91cGVkTGltaXQudmFsdWVzLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBXaGVyZTtcbiAgICAgICAgICAgIGlmICh3aGVyZUtleSkge1xuICAgICAgICAgICAgICBncm91cFdoZXJlID0ge1xuICAgICAgICAgICAgICAgIFt3aGVyZUtleV06IHZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgICBncm91cFdoZXJlID0ge1xuICAgICAgICAgICAgICAgIFtvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5mb3JlaWduSWRlbnRpZmllckZpZWxkXTogdmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnNwbGljZVN0cihiYXNlUXVlcnksIHNwbGljZVBvcywgcGxhY2VIb2xkZXIubGVuZ3RoLCB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhncm91cFdoZXJlLCBncm91cGVkVGFibGVOYW1lKSk7XG4gICAgICAgICAgfSkuam9pbihcbiAgICAgICAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ1VOSU9OIEFMTCddID8gJyBVTklPTiBBTEwgJyA6ICcgVU5JT04gJ1xuICAgICAgICAgIClcbiAgICAgICAgfSlgLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcykpO1xuICAgICAgfVxuXG4gICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKG1haW5Kb2luUXVlcmllcy5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIFdIRVJFIHRvIHN1YiBvciBtYWluIHF1ZXJ5XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnd2hlcmUnKSAmJiAhb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLndoZXJlLCBtYWluVGFibGUuYXMgfHwgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy53aGVyZSkge1xuICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBXSEVSRSAke29wdGlvbnMud2hlcmV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIFdIRVJFICR7b3B0aW9ucy53aGVyZX1gKTtcbiAgICAgICAgICAvLyBXYWxrIHRoZSBtYWluIHF1ZXJ5IHRvIHVwZGF0ZSBhbGwgc2VsZWN0c1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdTRUxFQ1QnKSkge1xuICAgICAgICAgICAgICBtYWluUXVlcnlJdGVtc1trZXldID0gdGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcy5tYWluLCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBHUk9VUCBCWSB0byBzdWIgb3IgbWFpbiBxdWVyeVxuICAgIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICBvcHRpb25zLmdyb3VwID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmdyb3VwKSA/IG9wdGlvbnMuZ3JvdXAubWFwKHQgPT4gdGhpcy5hbGlhc0dyb3VwaW5nKHQsIG1vZGVsLCBtYWluVGFibGUuYXMsIG9wdGlvbnMpKS5qb2luKCcsICcpIDogdGhpcy5hbGlhc0dyb3VwaW5nKG9wdGlvbnMuZ3JvdXAsIG1vZGVsLCBtYWluVGFibGUuYXMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoc3ViUXVlcnkgJiYgb3B0aW9ucy5ncm91cCkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBHUk9VUCBCWSAke29wdGlvbnMuZ3JvdXB9YCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIEdST1VQIEJZICR7b3B0aW9ucy5ncm91cH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgSEFWSU5HIHRvIHN1YiBvciBtYWluIHF1ZXJ5XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnaGF2aW5nJykpIHtcbiAgICAgIG9wdGlvbnMuaGF2aW5nID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMob3B0aW9ucy5oYXZpbmcsIHRhYmxlTmFtZSwgbW9kZWwsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIGlmIChvcHRpb25zLmhhdmluZykge1xuICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBIQVZJTkcgJHtvcHRpb25zLmhhdmluZ31gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgSEFWSU5HICR7b3B0aW9ucy5oYXZpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgT1JERVIgdG8gc3ViIG9yIG1haW4gcXVlcnlcbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgY29uc3Qgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpO1xuICAgICAgaWYgKG9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIE9SREVSIEJZICR7b3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXJzLnN1YlF1ZXJ5T3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIE9SREVSIEJZICR7b3JkZXJzLnN1YlF1ZXJ5T3JkZXIuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgTElNSVQsIE9GRlNFVCB0byBzdWIgb3IgbWFpbiBxdWVyeVxuICAgIGNvbnN0IGxpbWl0T3JkZXIgPSB0aGlzLmFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCk7XG4gICAgaWYgKGxpbWl0T3JkZXIgJiYgIW9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGxpbWl0T3JkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChsaW1pdE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcy5tYWluLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZS5hcyB9KTtcbiAgICAgIHF1ZXJ5ID0gYFNFTEVDVCAke2F0dHJpYnV0ZXMubWFpbi5qb2luKCcsICcpfSBGUk9NICgke3N1YlF1ZXJ5SXRlbXMuam9pbignJyl9KSBBUyAke21haW5UYWJsZS5hc30ke21haW5Kb2luUXVlcmllcy5qb2luKCcnKX0ke21haW5RdWVyeUl0ZW1zLmpvaW4oJycpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gbWFpblF1ZXJ5SXRlbXMuam9pbignJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9jayAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2spIHtcbiAgICAgIGxldCBsb2NrID0gb3B0aW9ucy5sb2NrO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2sgPSBvcHRpb25zLmxvY2subGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5sb2NrS2V5ICYmIChsb2NrID09PSAnS0VZIFNIQVJFJyB8fCBsb2NrID09PSAnTk8gS0VZIFVQREFURScpKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgRk9SICR7bG9ja31gO1xuICAgICAgfSBlbHNlIGlmIChsb2NrID09PSAnU0hBUkUnKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmZvclNoYXJlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSAnIEZPUiBVUERBVEUnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMubG9ja09mICYmIG9wdGlvbnMubG9jay5vZiAmJiBvcHRpb25zLmxvY2sub2YucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgcXVlcnkgKz0gYCBPRiAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLmxvY2sub2YubmFtZSl9YDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnNraXBMb2NrZWQgJiYgb3B0aW9ucy5za2lwTG9ja2VkKSB7XG4gICAgICAgIHF1ZXJ5ICs9ICcgU0tJUCBMT0NLRUQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBgJHtxdWVyeX07YDtcbiAgfVxuXG4gIGFsaWFzR3JvdXBpbmcoZmllbGQsIG1vZGVsLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcmMgPSBBcnJheS5pc0FycmF5KGZpZWxkKSA/IGZpZWxkWzBdIDogZmllbGQ7XG5cbiAgICByZXR1cm4gdGhpcy5xdW90ZSh0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgc3JjLCBvcHRpb25zKSB8fCBzcmMsIG1vZGVsKTtcbiAgfVxuXG4gIGVzY2FwZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgb3B0aW9ucywgbWFpblRhYmxlQXMpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLm1hcChhdHRyID0+IHtcbiAgICAgIGxldCBhZGRUYWJsZSA9IHRydWU7XG5cbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpKSB7XG4gICAgICAgIGlmIChhdHRyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKU09OLnN0cmluZ2lmeShhdHRyKX0gaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIGRlZmluaXRpb24uIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IFsnYXR0cmlidXRlIGRlZmluaXRpb24nLCAnYWxpYXMnXWApO1xuICAgICAgICB9XG4gICAgICAgIGF0dHIgPSBhdHRyLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICBhdHRyWzBdID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0clswXSk7XG4gICAgICAgICAgYWRkVGFibGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghYXR0clswXS5pbmNsdWRlcygnKCcpICYmICFhdHRyWzBdLmluY2x1ZGVzKCcpJykpIHtcbiAgICAgICAgICBhdHRyWzBdID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0clswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwcmVjYXRpb25zLm5vUmF3QXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGlhcyA9IGF0dHJbMV07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCBtYWluVGFibGVBcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyID0gW2F0dHJbMF0sIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKV0uam9pbignIEFTICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0ciA9ICFhdHRyLmluY2x1ZGVzKFV0aWxzLlRJQ0tfQ0hBUikgJiYgIWF0dHIuaW5jbHVkZXMoJ1wiJylcbiAgICAgICAgICA/IHRoaXMucXVvdGVBdHRyaWJ1dGUoYXR0ciwgb3B0aW9ucy5tb2RlbClcbiAgICAgICAgICA6IHRoaXMuZXNjYXBlKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmlzRW1wdHkob3B0aW9ucy5pbmNsdWRlKSAmJiAhYXR0ci5pbmNsdWRlcygnLicpICYmIGFkZFRhYmxlKSB7XG4gICAgICAgIGF0dHIgPSBgJHttYWluVGFibGVBc30uJHthdHRyfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0pO1xuICB9XG5cbiAgZ2VuZXJhdGVJbmNsdWRlKGluY2x1ZGUsIHBhcmVudFRhYmxlTmFtZSwgdG9wTGV2ZWxJbmZvKSB7XG4gICAgY29uc3Qgam9pblF1ZXJpZXMgPSB7XG4gICAgICBtYWluUXVlcnk6IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBjb25zdCBtYWluQ2hpbGRJbmNsdWRlcyA9IFtdO1xuICAgIGNvbnN0IHN1YkNoaWxkSW5jbHVkZXMgPSBbXTtcbiAgICBsZXQgcmVxdWlyZWRNaXNtYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IGluY2x1ZGVBcyA9IHtcbiAgICAgIGludGVybmFsQXM6IGluY2x1ZGUuYXMsXG4gICAgICBleHRlcm5hbEFzOiBpbmNsdWRlLmFzXG4gICAgfTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogW10sXG4gICAgICBzdWJRdWVyeTogW11cbiAgICB9O1xuICAgIGxldCBqb2luUXVlcnk7XG5cbiAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy5rZXlzRXNjYXBlZCA9IHRydWU7XG5cbiAgICBpZiAodG9wTGV2ZWxJbmZvLm5hbWVzLm5hbWUgIT09IHBhcmVudFRhYmxlTmFtZS5leHRlcm5hbEFzICYmIHRvcExldmVsSW5mby5uYW1lcy5hcyAhPT0gcGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXMpIHtcbiAgICAgIGluY2x1ZGVBcy5pbnRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmludGVybmFsQXN9LT4ke2luY2x1ZGUuYXN9YDtcbiAgICAgIGluY2x1ZGVBcy5leHRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXN9LiR7aW5jbHVkZS5hc31gO1xuICAgIH1cblxuICAgIC8vIGluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzIGlzIHVzZWQgYnkgYWdncmVnYXRlIGZ1bmN0aW9uc1xuICAgIGlmICh0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlSWdub3JlQXR0cmlidXRlcyAhPT0gZmFsc2UpIHtcbiAgICAgIGluY2x1ZGUubW9kZWwuX2V4cGFuZEF0dHJpYnV0ZXMoaW5jbHVkZSk7XG4gICAgICBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuXG4gICAgICBjb25zdCBpbmNsdWRlQXR0cmlidXRlcyA9IGluY2x1ZGUuYXR0cmlidXRlcy5tYXAoYXR0ciA9PiB7XG4gICAgICAgIGxldCBhdHRyQXMgPSBhdHRyO1xuICAgICAgICBsZXQgdmVyYmF0aW0gPSBmYWxzZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSAmJiBhdHRyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGlmIChhdHRyWzBdIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kICYmIChcbiAgICAgICAgICAgIGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsIHx8XG4gICAgICAgICAgICBhdHRyWzBdIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCB8fFxuICAgICAgICAgICAgYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkZuXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgdmVyYmF0aW0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dHIgPSBhdHRyLm1hcChhdHRyID0+IGF0dHIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgPyB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyKSA6IGF0dHIpO1xuXG4gICAgICAgICAgYXR0ckFzID0gYXR0clsxXTtcbiAgICAgICAgICBhdHRyID0gYXR0clswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci52YWw7IC8vIFdlIHRydXN0IHRoZSB1c2VyIHRvIHJlbmFtZSB0aGUgZmllbGQgY29ycmVjdGx5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8IGF0dHIgaW5zdGFuY2VvZiBVdGlscy5Gbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUcmllZCB0byBzZWxlY3QgYXR0cmlidXRlcyB1c2luZyBTZXF1ZWxpemUuY2FzdCBvciBTZXF1ZWxpemUuZm4gd2l0aG91dCBzcGVjaWZ5aW5nIGFuIGFsaWFzIGZvciB0aGUgcmVzdWx0LCBkdXJpbmcgZWFnZXIgbG9hZGluZy4gJyArXG4gICAgICAgICAgICAnVGhpcyBtZWFucyB0aGUgYXR0cmlidXRlIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSByZXR1cm5lZCBpbnN0YW5jZSdcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgaWYgKHZlcmJhdGltID09PSB0cnVlKSB7XG4gICAgICAgICAgcHJlZml4ID0gYXR0cjtcbiAgICAgICAgfSBlbHNlIGlmICgvIz4+fC0+Pi8udGVzdChhdHRyKSkge1xuICAgICAgICAgIHByZWZpeCA9IGAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LiR7YXR0ci5yZXBsYWNlKC9cXCh8XFwpL2csICcnKX0pYDtcbiAgICAgICAgfSBlbHNlIGlmICgvanNvbl9leHRyYWN0XFwoLy50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgcHJlZml4ID0gYXR0ci5yZXBsYWNlKC9qc29uX2V4dHJhY3RcXCgvaSwgYGpzb25fZXh0cmFjdCgke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4ID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWFzID0gYCR7aW5jbHVkZUFzLmV4dGVybmFsQXN9LiR7YXR0ckFzfWA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCBpbmNsdWRlQXMuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAnQVMnLFxuICAgICAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzLCB0cnVlKVxuICAgICAgICBdKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkgJiYgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBpbmNsdWRlQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3Rocm91Z2hcbiAgICBpZiAoaW5jbHVkZS50aHJvdWdoKSB7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlVGhyb3VnaEpvaW4oaW5jbHVkZSwgaW5jbHVkZUFzLCBwYXJlbnRUYWJsZU5hbWUuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBwb3NzaWJsZSBuZXcgYXR0cmlidXRlcyBjcmVhdGVkIGluIGpvaW5cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLm1haW4gPSBhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLm1haW4pO1xuICAgIH1cblxuICAgIGlmIChqb2luUXVlcnkuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5zdWJRdWVyeS5jb25jYXQoam9pblF1ZXJ5LmF0dHJpYnV0ZXMuc3ViUXVlcnkpO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGRJbmNsdWRlIG9mIGluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgICBpZiAoY2hpbGRJbmNsdWRlLnNlcGFyYXRlIHx8IGNoaWxkSW5jbHVkZS5fcHNldWRvKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZEpvaW5RdWVyaWVzID0gdGhpcy5nZW5lcmF0ZUluY2x1ZGUoY2hpbGRJbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGUucmVxdWlyZWQgPT09IGZhbHNlICYmIGNoaWxkSW5jbHVkZS5yZXF1aXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlcXVpcmVkTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBjaGlsZCBpcyBhIHN1YiBxdWVyeSB3ZSBqdXN0IGdpdmUgaXQgdG8gdGhlXG4gICAgICAgIGlmIChjaGlsZEluY2x1ZGUuc3ViUXVlcnkgJiYgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3ViQ2hpbGRJbmNsdWRlcy5wdXNoKGNoaWxkSm9pblF1ZXJpZXMuc3ViUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLm1haW5RdWVyeSkge1xuICAgICAgICAgIG1haW5DaGlsZEluY2x1ZGVzLnB1c2goY2hpbGRKb2luUXVlcmllcy5tYWluUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluID0gYXR0cmlidXRlcy5tYWluLmNvbmNhdChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAmJiB0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgIGlmIChyZXF1aXJlZE1pc21hdGNoICYmIHN1YkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gKCAke2pvaW5RdWVyeS5ib2R5fSR7c3ViQ2hpbGRJbmNsdWRlcy5qb2luKCcnKX0gKSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gJHtqb2luUXVlcnkuYm9keX0gT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgICBpZiAoc3ViQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChzdWJDaGlsZEluY2x1ZGVzLmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2gobWFpbkNoaWxkSW5jbHVkZXMuam9pbignJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVxdWlyZWRNaXNtYXRjaCAmJiBtYWluQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gKCAke2pvaW5RdWVyeS5ib2R5fSR7bWFpbkNoaWxkSW5jbHVkZXMuam9pbignJyl9ICkgT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAke2pvaW5RdWVyeS5ib2R5fSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICAgIGlmIChtYWluQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2gobWFpbkNoaWxkSW5jbHVkZXMuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKHN1YkNoaWxkSW5jbHVkZXMuam9pbignJykpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtYWluUXVlcnk6IGpvaW5RdWVyaWVzLm1haW5RdWVyeS5qb2luKCcnKSxcbiAgICAgIHN1YlF1ZXJ5OiBqb2luUXVlcmllcy5zdWJRdWVyeS5qb2luKCcnKSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9XG5cbiAgX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJlLWFsaWFzIGluIGNhc2Ugb2YgYSBzdWJxdWVyeVxuICAgIGlmIChvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXTtcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgYWxpYXMgY3VzdG9tIHN1cXVlcnlfb3JkZXJzXG4gICAgaWYgKGFsaWFzLm1hdGNoKC9zdWJxdWVyeV9vcmRlcl9bMC05XS8pKSB7XG4gICAgICByZXR1cm4gYWxpYXM7XG4gICAgfVxuXG4gICAgY29uc3QgbWluaWZpZWRBbGlhcyA9IGBfJHtvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNpemV9YDtcblxuICAgIG9wdGlvbnMuYWxpYXNlc01hcHBpbmcuc2V0KG1pbmlmaWVkQWxpYXMsIGFsaWFzKTtcbiAgICBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdID0gbWluaWZpZWRBbGlhcztcblxuICAgIHJldHVybiBtaW5pZmllZEFsaWFzO1xuICB9XG5cbiAgX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF0pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2VuZXJhdGVKb2luKGluY2x1ZGUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICBjb25zdCBwYXJlbnQgPSBpbmNsdWRlLnBhcmVudDtcbiAgICBjb25zdCBwYXJlbnRJc1RvcCA9ICEhcGFyZW50ICYmICFpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbC5uYW1lID09PSB0b3BMZXZlbEluZm8ub3B0aW9ucy5tb2RlbC5uYW1lO1xuICAgIGxldCAkcGFyZW50O1xuICAgIGxldCBqb2luV2hlcmU7XG4gICAgLyogQXR0cmlidXRlcyBmb3IgdGhlIGxlZnQgc2lkZSAqL1xuICAgIGNvbnN0IGxlZnQgPSBhc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgY29uc3QgYXR0ckxlZnQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/XG4gICAgICBhc3NvY2lhdGlvbi5pZGVudGlmaWVyIDpcbiAgICAgIGFzc29jaWF0aW9uLnNvdXJjZUtleUF0dHJpYnV0ZSB8fCBsZWZ0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgZmllbGRMZWZ0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gP1xuICAgICAgYXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkIDpcbiAgICAgIGxlZnQucmF3QXR0cmlidXRlc1thc3NvY2lhdGlvbi5zb3VyY2VLZXlBdHRyaWJ1dGUgfHwgbGVmdC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZDtcbiAgICBsZXQgYXNMZWZ0O1xuICAgIC8qIEF0dHJpYnV0ZXMgZm9yIHRoZSByaWdodCBzaWRlICovXG4gICAgY29uc3QgcmlnaHQgPSBpbmNsdWRlLm1vZGVsO1xuICAgIGNvbnN0IHRhYmxlUmlnaHQgPSByaWdodC5nZXRUYWJsZU5hbWUoKTtcbiAgICBjb25zdCBmaWVsZFJpZ2h0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gP1xuICAgICAgcmlnaHQucmF3QXR0cmlidXRlc1thc3NvY2lhdGlvbi50YXJnZXRJZGVudGlmaWVyIHx8IHJpZ2h0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkIDpcbiAgICAgIGFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcbiAgICBsZXQgYXNSaWdodCA9IGluY2x1ZGUuYXM7XG5cbiAgICB3aGlsZSAoKCRwYXJlbnQgPSAkcGFyZW50ICYmICRwYXJlbnQucGFyZW50IHx8IGluY2x1ZGUucGFyZW50KSAmJiAkcGFyZW50LmFzc29jaWF0aW9uKSB7XG4gICAgICBpZiAoYXNMZWZ0KSB7XG4gICAgICAgIGFzTGVmdCA9IGAkeyRwYXJlbnQuYXN9LT4ke2FzTGVmdH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNMZWZ0ID0gJHBhcmVudC5hcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFzTGVmdCkgYXNMZWZ0ID0gcGFyZW50LmFzIHx8IHBhcmVudC5tb2RlbC5uYW1lO1xuICAgIGVsc2UgYXNSaWdodCA9IGAke2FzTGVmdH0tPiR7YXNSaWdodH1gO1xuXG4gICAgbGV0IGpvaW5PbiA9IGAke3RoaXMucXVvdGVUYWJsZShhc0xlZnQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkTGVmdCl9YDtcbiAgICBjb25zdCBzdWJxdWVyeUF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIGlmICh0b3BMZXZlbEluZm8ub3B0aW9ucy5ncm91cGVkTGltaXQgJiYgcGFyZW50SXNUb3AgfHwgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmIGluY2x1ZGUucGFyZW50LnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5KSB7XG4gICAgICBpZiAocGFyZW50SXNUb3ApIHtcbiAgICAgICAgLy8gVGhlIG1haW4gbW9kZWwgYXR0cmlidXRlcyBpcyBub3QgYWxpYXNlZCB0byBhIHByZWZpeFxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUocGFyZW50LmFzIHx8IHBhcmVudC5tb2RlbC5uYW1lKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgcG90ZW50aWFsIGFsaWFzZWQgSk9JTiBjb25kaXRpb25cbiAgICAgICAgam9pbk9uID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIGF0dHJMZWZ0LCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgYCR7dGFibGVOYW1lfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJMZWZ0KX1gO1xuXG4gICAgICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJxdWVyeUF0dHJpYnV0ZXMucHVzaChgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRMZWZ0KX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgam9pblNvdXJjZSA9IGAke2FzTGVmdC5yZXBsYWNlKC8tPi9nLCAnLicpfS4ke2F0dHJMZWZ0fWA7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBvdGVudGlhbCBhbGlhc2VkIEpPSU4gY29uZGl0aW9uXG4gICAgICAgIGpvaW5PbiA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQoYXNMZWZ0LCBqb2luU291cmNlLCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgdGhpcy5xdW90ZUlkZW50aWZpZXIoam9pblNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgam9pbk9uICs9IGAgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkUmlnaHQpfWA7XG5cbiAgICBpZiAoaW5jbHVkZS5vbikge1xuICAgICAgam9pbk9uID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaW5jbHVkZS5vbiwge1xuICAgICAgICBwcmVmaXg6IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCkpLFxuICAgICAgICBtb2RlbDogaW5jbHVkZS5tb2RlbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUud2hlcmUpIHtcbiAgICAgIGpvaW5XaGVyZSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGluY2x1ZGUud2hlcmUsIHtcbiAgICAgICAgcHJlZml4OiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpKSxcbiAgICAgICAgbW9kZWw6IGluY2x1ZGUubW9kZWxcbiAgICAgIH0pO1xuICAgICAgaWYgKGpvaW5XaGVyZSkge1xuICAgICAgICBpZiAoaW5jbHVkZS5vcikge1xuICAgICAgICAgIGpvaW5PbiArPSBgIE9SICR7am9pbldoZXJlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgam9pbk9uICs9IGAgQU5EICR7am9pbldoZXJlfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgYXNSaWdodC5sZW5ndGggPiA2Mykge1xuICAgICAgY29uc3QgYWxpYXMgPSBgJSR7dG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2l6ZX1gO1xuXG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlQWxpYXNlcy5zZXQoYWxpYXMsIGFzUmlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBqb2luOiBpbmNsdWRlLnJlcXVpcmVkID8gJ0lOTkVSIEpPSU4nIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydSSUdIVCBKT0lOJ10gPyAnUklHSFQgT1VURVIgSk9JTicgOiAnTEVGVCBPVVRFUiBKT0lOJyxcbiAgICAgIGJvZHk6IHRoaXMucXVvdGVUYWJsZSh0YWJsZVJpZ2h0LCBhc1JpZ2h0KSxcbiAgICAgIGNvbmRpdGlvbjogam9pbk9uLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc3ViUXVlcnk6IHN1YnF1ZXJ5QXR0cmlidXRlc1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgU1FMIGZyYWdtZW50cyB0byBoYW5kbGUgcmV0dXJuaW5nIHRoZSBhdHRyaWJ1dGVzIGZyb20gYW4gaW5zZXJ0L3VwZGF0ZSBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBtb2RlbEF0dHJpYnV0ZXMgQW4gb2JqZWN0IHdpdGggdGhlIG1vZGVsIGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAgICAgICAgIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW5lcmF0ZVJldHVyblZhbHVlcyhtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXR1cm5GaWVsZHMgPSBbXTtcbiAgICBjb25zdCByZXR1cm5UeXBlcyA9IFtdO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9ICcnO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9ICcnO1xuICAgIGxldCB0bXBUYWJsZSA9ICcnO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZXR1cm5pbmcpKSB7XG4gICAgICByZXR1cm5GaWVsZHMucHVzaCguLi5vcHRpb25zLnJldHVybmluZy5tYXAoZmllbGQgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKSk7XG4gICAgfSBlbHNlIGlmIChtb2RlbEF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChtb2RlbEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSA9PiB7XG4gICAgICAgIGlmICghKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlZJUlRVQUwpKSB7XG4gICAgICAgICAgcmV0dXJuRmllbGRzLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKSk7XG4gICAgICAgICAgcmV0dXJuVHlwZXMucHVzaChhdHRyaWJ1dGUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChfLmlzRW1wdHkocmV0dXJuRmllbGRzKSkge1xuICAgICAgcmV0dXJuRmllbGRzLnB1c2goJyonKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMucmV0dXJuaW5nKSB7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IGAgUkVUVVJOSU5HICR7cmV0dXJuRmllbGRzLmpvaW4oJywnKX1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMub3V0cHV0KSB7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IGAgT1VUUFVUICR7cmV0dXJuRmllbGRzLm1hcChmaWVsZCA9PiBgSU5TRVJURUQuJHtmaWVsZH1gKS5qb2luKCcsJyl9YDtcblxuICAgICAgLy9UbyBjYXB0dXJlIG91dHB1dCByb3dzIHdoZW4gdGhlcmUgaXMgYSB0cmlnZ2VyIG9uIE1TU1FMIERCXG4gICAgICBpZiAob3B0aW9ucy5oYXNUcmlnZ2VyICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMudG1wVGFibGVUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnN0IHRtcENvbHVtbnMgPSByZXR1cm5GaWVsZHMubWFwKChmaWVsZCwgaSkgPT4gYCR7ZmllbGR9ICR7cmV0dXJuVHlwZXNbaV0udG9TcWwoKX1gKTtcblxuICAgICAgICB0bXBUYWJsZSA9IGBERUNMQVJFIEB0bXAgVEFCTEUgKCR7dG1wQ29sdW1ucy5qb2luKCcsJyl9KTsgYDtcbiAgICAgICAgb3V0cHV0RnJhZ21lbnQgKz0gJyBJTlRPIEB0bXAnO1xuICAgICAgICByZXR1cm5pbmdGcmFnbWVudCA9ICc7IFNFTEVDVCAqIEZST00gQHRtcCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgb3V0cHV0RnJhZ21lbnQsIHJldHVybkZpZWxkcywgcmV0dXJuaW5nRnJhZ21lbnQsIHRtcFRhYmxlIH07XG4gIH1cblxuICBnZW5lcmF0ZVRocm91Z2hKb2luKGluY2x1ZGUsIGluY2x1ZGVBcywgcGFyZW50VGFibGVOYW1lLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCB0aHJvdWdoID0gaW5jbHVkZS50aHJvdWdoO1xuICAgIGNvbnN0IHRocm91Z2hUYWJsZSA9IHRocm91Z2gubW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgY29uc3QgdGhyb3VnaEFzID0gYCR7aW5jbHVkZUFzLmludGVybmFsQXN9LT4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCBleHRlcm5hbFRocm91Z2hBcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IHRocm91Z2guYXR0cmlidXRlcy5tYXAoYXR0ciA9PiB7XG4gICAgICBsZXQgYWxpYXMgPSBgJHtleHRlcm5hbFRocm91Z2hBc30uJHtBcnJheS5pc0FycmF5KGF0dHIpID8gYXR0clsxXSA6IGF0dHJ9YDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGhyb3VnaEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihBcnJheS5pc0FycmF5KGF0dHIpID8gYXR0clswXSA6IGF0dHIpfWAsXG4gICAgICAgICdBUycsXG4gICAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKVxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IHBhcmVudElzVG9wID0gIWluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsLm5hbWUgPT09IHRvcExldmVsSW5mby5vcHRpb25zLm1vZGVsLm5hbWU7XG4gICAgY29uc3QgdGFibGVTb3VyY2UgPSBwYXJlbnRUYWJsZU5hbWU7XG4gICAgY29uc3QgaWRlbnRTb3VyY2UgPSBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgdGFibGVUYXJnZXQgPSBpbmNsdWRlQXMuaW50ZXJuYWxBcztcbiAgICBjb25zdCBpZGVudFRhcmdldCA9IGFzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgYXR0clRhcmdldCA9IGFzc29jaWF0aW9uLnRhcmdldEtleUZpZWxkO1xuXG4gICAgY29uc3Qgam9pblR5cGUgPSBpbmNsdWRlLnJlcXVpcmVkID8gJ0lOTkVSIEpPSU4nIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydSSUdIVCBKT0lOJ10gPyAnUklHSFQgT1VURVIgSk9JTicgOiAnTEVGVCBPVVRFUiBKT0lOJztcbiAgICBsZXQgam9pbkJvZHk7XG4gICAgbGV0IGpvaW5Db25kaXRpb247XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleTtcbiAgICBsZXQgc291cmNlSm9pbk9uO1xuICAgIGxldCB0YXJnZXRKb2luT247XG4gICAgbGV0IHRocm91Z2hXaGVyZTtcbiAgICBsZXQgdGFyZ2V0V2hlcmU7XG5cbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICAvLyBUaHJvdWdoIGluY2x1ZGVzIGFyZSBhbHdheXMgaGFzTWFueSwgc28gd2UgbmVlZCB0byBhZGQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIG1haW5BdHRyaWJ1dGVzIG5vIG1hdHRlciB3aGF0IChSZWFsIGpvaW4gd2lsbCBuZXZlciBiZSBleGVjdXRlZCBpbiBzdWJxdWVyeSlcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiB0aHJvdWdoQXR0cmlidXRlcykge1xuICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIG5lZWQgdG8gdXNlIGZpZWxkIG9yIGF0dHJpYnV0ZVxuICAgIGlmICghdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQ7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkgJiYgIWluY2x1ZGUucGFyZW50LnN1YlF1ZXJ5ICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsICE9PSB0b3BMZXZlbEluZm8ub3B0aW9ucy5tYWluTW9kZWwpIHtcbiAgICAgIGF0dHJTb3VyY2UgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZDtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgc3RhdGVtZW50IGZvciBsZWZ0IHNpZGUgb2YgdGhyb3VnaFxuICAgIC8vIFVzZWQgYnkgYm90aCBqb2luIGFuZCBzdWJxdWVyeSB3aGVyZVxuICAgIC8vIElmIHBhcmVudCBpbmNsdWRlIHdhcyBpbiBhIHN1YnF1ZXJ5IG5lZWQgdG8gam9pbiBvbiB0aGUgYWxpYXNlZCBhdHRyaWJ1dGVcbiAgICBpZiAodG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5ICYmIGluY2x1ZGUucGFyZW50LnN1YlF1ZXJ5ICYmICFwYXJlbnRJc1RvcCkge1xuICAgICAgLy8gSWYgd2UgYXJlIG1pbmlmeWluZyBhbGlhc2VzIGFuZCBvdXIgSk9JTiB0YXJnZXQgaGFzIGJlZW4gbWluaWZpZWQsIHdlIG5lZWQgdG8gdXNlIHRoZSBhbGlhcyBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjb2x1bW4gbmFtZVxuICAgICAgY29uc3Qgam9pblNvdXJjZSA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVTb3VyY2UsIGAke3RhYmxlU291cmNlfS4ke2F0dHJTb3VyY2V9YCwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IGAke3RhYmxlU291cmNlfS4ke2F0dHJTb3VyY2V9YDtcblxuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoam9pblNvdXJjZSl9ID0gYDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgYXJlIG1pbmlmeWluZyBhbGlhc2VzIGFuZCBvdXIgSk9JTiB0YXJnZXQgaGFzIGJlZW4gbWluaWZpZWQsIHdlIG5lZWQgdG8gdXNlIHRoZSBhbGlhcyBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjb2x1bW4gbmFtZVxuICAgICAgY29uc3QgYWxpYXNlZFNvdXJjZSA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVTb3VyY2UsIGF0dHJTb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBhdHRyU291cmNlO1xuXG4gICAgICBzb3VyY2VKb2luT24gPSBgJHt0aGlzLnF1b3RlVGFibGUodGFibGVTb3VyY2UpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzZWRTb3VyY2UpfSA9IGA7XG4gICAgfVxuICAgIHNvdXJjZUpvaW5PbiArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50U291cmNlKX1gO1xuXG4gICAgLy8gRmlsdGVyIHN0YXRlbWVudCBmb3IgcmlnaHQgc2lkZSBvZiB0aHJvdWdoXG4gICAgLy8gVXNlZCBieSBib3RoIGpvaW4gYW5kIHN1YnF1ZXJ5IHdoZXJlXG4gICAgdGFyZ2V0Sm9pbk9uID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVUYXJnZXQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJUYXJnZXQpfSA9IGA7XG4gICAgdGFyZ2V0Sm9pbk9uICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRUYXJnZXQpfWA7XG5cbiAgICBpZiAodGhyb3VnaC53aGVyZSkge1xuICAgICAgdGhyb3VnaFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnModGhyb3VnaC53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpKSwgdGhyb3VnaC5tb2RlbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuam9pblRhYmxlRGVwZW5kZW50KSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHdyYXBwZWQgam9pbiBzbyB0aGF0IHRoZSB0aHJvdWdoIHRhYmxlIGpvaW4gY2FuIGJlIGRlcGVuZGVudCBvbiB0aGUgdGFyZ2V0IGpvaW5cbiAgICAgIGpvaW5Cb2R5ID0gYCggJHt0aGlzLnF1b3RlVGFibGUodGhyb3VnaFRhYmxlLCB0aHJvdWdoQXMpfSBJTk5FUiBKT0lOICR7dGhpcy5xdW90ZVRhYmxlKGluY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCksIGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0gT04gJHt0YXJnZXRKb2luT259YDtcbiAgICAgIGlmICh0aHJvdWdoV2hlcmUpIHtcbiAgICAgICAgam9pbkJvZHkgKz0gYCBBTkQgJHt0aHJvdWdoV2hlcmV9YDtcbiAgICAgIH1cbiAgICAgIGpvaW5Cb2R5ICs9ICcpJztcbiAgICAgIGpvaW5Db25kaXRpb24gPSBzb3VyY2VKb2luT247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdlbmVyYXRlIGpvaW4gU1FMIGZvciBsZWZ0IHNpZGUgb2YgdGhyb3VnaFxuICAgICAgam9pbkJvZHkgPSBgJHt0aGlzLnF1b3RlVGFibGUodGhyb3VnaFRhYmxlLCB0aHJvdWdoQXMpfSBPTiAke3NvdXJjZUpvaW5Pbn0gJHtqb2luVHlwZX0gJHt0aGlzLnF1b3RlVGFibGUoaW5jbHVkZS5tb2RlbC5nZXRUYWJsZU5hbWUoKSwgaW5jbHVkZUFzLmludGVybmFsQXMpfWA7XG4gICAgICBqb2luQ29uZGl0aW9uID0gdGFyZ2V0Sm9pbk9uO1xuICAgICAgaWYgKHRocm91Z2hXaGVyZSkge1xuICAgICAgICBqb2luQ29uZGl0aW9uICs9IGAgQU5EICR7dGhyb3VnaFdoZXJlfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUud2hlcmUgfHwgaW5jbHVkZS50aHJvdWdoLndoZXJlKSB7XG4gICAgICBpZiAoaW5jbHVkZS53aGVyZSkge1xuICAgICAgICB0YXJnZXRXaGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKGluY2x1ZGUud2hlcmUsIHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpKSwgaW5jbHVkZS5tb2RlbCwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGFyZ2V0V2hlcmUpIHtcbiAgICAgICAgICBqb2luQ29uZGl0aW9uICs9IGAgQU5EICR7dGFyZ2V0V2hlcmV9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGpvaW46IGpvaW5UeXBlLFxuICAgICAgYm9keTogam9pbkJvZHksXG4gICAgICBjb25kaXRpb246IGpvaW5Db25kaXRpb24sXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAqIEdlbmVyYXRlcyBzdWJRdWVyeUZpbHRlciAtIGEgc2VsZWN0IG5lc3RlZCBpbiB0aGUgd2hlcmUgY2xhdXNlIG9mIHRoZSBzdWJRdWVyeS5cbiAgICogRm9yIGEgZ2l2ZW4gaW5jbHVkZSBhIHF1ZXJ5IGlzIGdlbmVyYXRlZCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgd2F5IGZyb20gdGhlIHN1YlF1ZXJ5XG4gICAqIHRhYmxlIHRvIHRoZSBpbmNsdWRlIHRhYmxlIHBsdXMgZXZlcnl0aGluZyB0aGF0J3MgaW4gcmVxdWlyZWQgdHJhbnNpdGl2ZSBjbG9zdXJlIG9mIHRoZVxuICAgKiBnaXZlbiBpbmNsdWRlLlxuICAgKi9cbiAgX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pIHtcbiAgICBpZiAoIXRvcExldmVsSW5mby5zdWJRdWVyeSB8fCAhaW5jbHVkZS5zdWJRdWVyeUZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmUpIHtcbiAgICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlID0ge307XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBpbmNsdWRlO1xuICAgIGxldCBjaGlsZCA9IGluY2x1ZGU7XG4gICAgbGV0IG5lc3RlZEluY2x1ZGVzID0gdGhpcy5fZ2V0UmVxdWlyZWRDbG9zdXJlKGluY2x1ZGUpLmluY2x1ZGU7XG4gICAgbGV0IHF1ZXJ5O1xuXG4gICAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQucGFyZW50KSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAocGFyZW50LnBhcmVudCAmJiAhcGFyZW50LnJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybjsgLy8gb25seSBnZW5lcmF0ZSBzdWJRdWVyeUZpbHRlciBpZiBhbGwgdGhlIHBhcmVudHMgb2YgdGhpcyBpbmNsdWRlIGFyZSByZXF1aXJlZFxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50LnN1YlF1ZXJ5RmlsdGVyKSB7XG4gICAgICAgIC8vIHRoZSBpbmNsdWRlIGlzIGFscmVhZHkgaGFuZGxlZCBhcyB0aGlzIHBhcmVudCBoYXMgdGhlIGluY2x1ZGUgb24gaXRzIHJlcXVpcmVkIGNsb3N1cmVcbiAgICAgICAgLy8gc2tpcCB0byBwcmV2ZW50IGR1cGxpY2F0ZSBzdWJRdWVyeUZpbHRlclxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5lc3RlZEluY2x1ZGVzID0gW3sgLi4uY2hpbGQsIGluY2x1ZGU6IG5lc3RlZEluY2x1ZGVzLCBhdHRyaWJ1dGVzOiBbXSB9XTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHRvcEluY2x1ZGUgPSBuZXN0ZWRJbmNsdWRlc1swXTtcbiAgICBjb25zdCB0b3BQYXJlbnQgPSB0b3BJbmNsdWRlLnBhcmVudDtcbiAgICBjb25zdCB0b3BBc3NvY2lhdGlvbiA9IHRvcEluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgdG9wSW5jbHVkZS5hc3NvY2lhdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0b3BJbmNsdWRlLnRocm91Z2ggJiYgT2JqZWN0KHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCkgPT09IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCkge1xuICAgICAgcXVlcnkgPSB0aGlzLnNlbGVjdFF1ZXJ5KHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5nZXRUYWJsZU5hbWUoKSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiBbdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLnByaW1hcnlLZXlGaWVsZF0sXG4gICAgICAgIGluY2x1ZGU6IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMoe1xuICAgICAgICAgIG1vZGVsOiB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwsXG4gICAgICAgICAgaW5jbHVkZTogW3tcbiAgICAgICAgICAgIGFzc29jaWF0aW9uOiB0b3BBc3NvY2lhdGlvbi50b1RhcmdldCxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgd2hlcmU6IHRvcEluY2x1ZGUud2hlcmUsXG4gICAgICAgICAgICBpbmNsdWRlOiB0b3BJbmNsdWRlLmluY2x1ZGVcbiAgICAgICAgICB9XVxuICAgICAgICB9KS5pbmNsdWRlLFxuICAgICAgICBtb2RlbDogdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKFtcbiAgICAgICAgICAgICAgYCR7dGhpcy5xdW90ZVRhYmxlKHRvcFBhcmVudC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BQYXJlbnQubW9kZWwucHJpbWFyeUtleUZpZWxkKX1gLFxuICAgICAgICAgICAgICBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wQXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkKX1gXG4gICAgICAgICAgICBdLmpvaW4oJyA9ICcpKSxcbiAgICAgICAgICAgIHRvcEluY2x1ZGUudGhyb3VnaC53aGVyZVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgIGluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZVxuICAgICAgfSwgdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNCZWxvbmdzVG8gPSB0b3BBc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUgPT09ICdCZWxvbmdzVG8nO1xuICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBpc0JlbG9uZ3NUbyA/IHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCA6IHRvcEFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkIHx8IHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQ7XG4gICAgICBjb25zdCB0YXJnZXRGaWVsZCA9IGlzQmVsb25nc1RvID8gdG9wQXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQgfHwgdG9wSW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5RmllbGQgOiB0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG5cbiAgICAgIGNvbnN0IGpvaW4gPSBbXG4gICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEluY2x1ZGUuYXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhcmdldEZpZWxkKX1gLFxuICAgICAgICBgJHt0aGlzLnF1b3RlVGFibGUodG9wUGFyZW50LmFzIHx8IHRvcFBhcmVudC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzb3VyY2VGaWVsZCl9YFxuICAgICAgXS5qb2luKCcgPSAnKTtcblxuICAgICAgcXVlcnkgPSB0aGlzLnNlbGVjdFF1ZXJ5KHRvcEluY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCksIHtcbiAgICAgICAgYXR0cmlidXRlczogW3RhcmdldEZpZWxkXSxcbiAgICAgICAgaW5jbHVkZTogTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh0b3BJbmNsdWRlKS5pbmNsdWRlLFxuICAgICAgICBtb2RlbDogdG9wSW5jbHVkZS5tb2RlbCxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBbT3AuYW5kXTogW1xuICAgICAgICAgICAgdG9wSW5jbHVkZS53aGVyZSxcbiAgICAgICAgICAgIHsgW09wLmpvaW5dOiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGpvaW4pIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICB0YWJsZUFzOiB0b3BJbmNsdWRlLmFzLFxuICAgICAgICBpbmNsdWRlSWdub3JlQXR0cmlidXRlczogZmFsc2VcbiAgICAgIH0sIHRvcEluY2x1ZGUubW9kZWwpO1xuICAgIH1cblxuICAgIGlmICghdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmVbT3AuYW5kXSkge1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmVbT3AuYW5kXSA9IFtdO1xuICAgIH1cblxuICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW2BfXyR7aW5jbHVkZUFzLmludGVybmFsQXN9YF0gPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKFtcbiAgICAgICcoJyxcbiAgICAgIHF1ZXJ5LnJlcGxhY2UoLzskLywgJycpLFxuICAgICAgJyknLFxuICAgICAgJ0lTIE5PVCBOVUxMJ1xuICAgIF0uam9pbignICcpKTtcbiAgfVxuXG4gIC8qXG4gICAqIEZvciBhIGdpdmVuIGluY2x1ZGUgaGllcmFyY2h5IGNyZWF0ZXMgYSBjb3B5IG9mIGl0IHdoZXJlIG9ubHkgdGhlIHJlcXVpcmVkIGluY2x1ZGVzXG4gICAqIGFyZSBwcmVzZXJ2ZWQuXG4gICAqL1xuICBfZ2V0UmVxdWlyZWRDbG9zdXJlKGluY2x1ZGUpIHtcbiAgICBjb25zdCBjb3B5ID0geyAuLi5pbmNsdWRlLCBhdHRyaWJ1dGVzOiBbXSwgaW5jbHVkZTogW10gfTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGluY2x1ZGUuaW5jbHVkZSkpIHtcbiAgICAgIGNvcHkuaW5jbHVkZSA9IGluY2x1ZGUuaW5jbHVkZVxuICAgICAgICAuZmlsdGVyKGkgPT4gaS5yZXF1aXJlZClcbiAgICAgICAgLm1hcChpbmMgPT4gdGhpcy5fZ2V0UmVxdWlyZWRDbG9zdXJlKGluYykpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIHN1YlF1ZXJ5KSB7XG4gICAgY29uc3QgbWFpblF1ZXJ5T3JkZXIgPSBbXTtcbiAgICBjb25zdCBzdWJRdWVyeU9yZGVyID0gW107XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgZm9yIChsZXQgb3JkZXIgb2Ygb3B0aW9ucy5vcmRlcikge1xuXG4gICAgICAgIC8vIHdyYXAgaWYgbm90IGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICBvcmRlciA9IFtvcmRlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgc3ViUXVlcnlcbiAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KG9yZGVyKVxuICAgICAgICAgICYmIG9yZGVyWzBdXG4gICAgICAgICAgJiYgIShvcmRlclswXSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKVxuICAgICAgICAgICYmICEodHlwZW9mIG9yZGVyWzBdID09PSAnZnVuY3Rpb24nICYmIG9yZGVyWzBdLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKVxuICAgICAgICAgICYmICEodHlwZW9mIG9yZGVyWzBdLm1vZGVsID09PSAnZnVuY3Rpb24nICYmIG9yZGVyWzBdLm1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKVxuICAgICAgICAgICYmICEodHlwZW9mIG9yZGVyWzBdID09PSAnc3RyaW5nJyAmJiBtb2RlbCAmJiBtb2RlbC5hc3NvY2lhdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5hc3NvY2lhdGlvbnNbb3JkZXJbMF1dKVxuICAgICAgICApIHtcbiAgICAgICAgICBzdWJRdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZShvcmRlciwgbW9kZWwsICctPicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHN1Yi1xdWVyeSByZW5hbWVzIGF0dHJpYnV0ZSB3ZSB3YW50IHRvIG9yZGVyIGJ5LFxuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9pc3N1ZXMvODczOVxuICAgICAgICAgIGNvbnN0IHN1YlF1ZXJ5QXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGVzLmZpbmQoYSA9PiBBcnJheS5pc0FycmF5KGEpICYmIGFbMF0gPT09IG9yZGVyWzBdICYmIGFbMV0pO1xuICAgICAgICAgIGlmIChzdWJRdWVyeUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwubmFtZSk7XG5cbiAgICAgICAgICAgIG9yZGVyWzBdID0gbmV3IFV0aWxzLkNvbCh0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKG1vZGVsTmFtZSwgc3ViUXVlcnlBdHRyaWJ1dGVbMV0sIG9wdGlvbnMpIHx8IHN1YlF1ZXJ5QXR0cmlidXRlWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYWluUXVlcnlPcmRlci5wdXNoKHRoaXMucXVvdGUob3JkZXIsIG1vZGVsLCAnLT4nKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm9yZGVyIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICBjb25zdCBzcWwgPSB0aGlzLnF1b3RlKG9wdGlvbnMub3JkZXIsIG1vZGVsLCAnLT4nKTtcbiAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICBzdWJRdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICAgIH1cbiAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlciBtdXN0IGJlIHR5cGUgb2YgYXJyYXkgb3IgaW5zdGFuY2Ugb2YgYSB2YWxpZCBzZXF1ZWxpemUgbWV0aG9kLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IG1haW5RdWVyeU9yZGVyLCBzdWJRdWVyeU9yZGVyIH07XG4gIH1cblxuICBfdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBleHRyYUluZm8gPSB7fSkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHJldHVybjtcbiAgICBjb25zdCBhc1BhcnQgPSBleHRyYUluZm8uYXMgJiYgYGFzICR7ZXh0cmFJbmZvLmFzfWAgfHwgJyc7XG4gICAgY29uc3QgbmFtZVBhcnQgPSBleHRyYUluZm8ubW9kZWxOYW1lICYmIGBmb3IgbW9kZWwgJyR7ZXh0cmFJbmZvLm1vZGVsTmFtZX0nYCB8fCAnJztcbiAgICBjb25zdCBtZXNzYWdlID0gYEF0dGVtcHRlZCBhIFNFTEVDVCBxdWVyeSAke25hbWVQYXJ0fSAke2FzUGFydH0gd2l0aG91dCBzZWxlY3RpbmcgYW55IGNvbHVtbnNgO1xuICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5RdWVyeUVycm9yKG1lc3NhZ2UucmVwbGFjZSgvICsvZywgJyAnKSk7XG4gIH1cblxuICBzZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcywgdGFibGVzLCBtYWluVGFibGVBcykge1xuICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGVBcyB9KTtcblxuICAgIGxldCBmcmFnbWVudCA9IGBTRUxFQ1QgJHthdHRyaWJ1dGVzLmpvaW4oJywgJyl9IEZST00gJHt0YWJsZXN9YDtcblxuICAgIGlmIChtYWluVGFibGVBcykge1xuICAgICAgZnJhZ21lbnQgKz0gYCBBUyAke21haW5UYWJsZUFzfWA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZXhIaW50cyAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4SGludHMpIHtcbiAgICAgIGZvciAoY29uc3QgaGludCBvZiBvcHRpb25zLmluZGV4SGludHMpIHtcbiAgICAgICAgaWYgKEluZGV4SGludHNbaGludC50eXBlXSkge1xuICAgICAgICAgIGZyYWdtZW50ICs9IGAgJHtJbmRleEhpbnRzW2hpbnQudHlwZV19IElOREVYICgke2hpbnQudmFsdWVzLm1hcChpbmRleE5hbWUgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSkpLmpvaW4oJywnKX0pYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFNRTCBmcmFnbWVudCBmb3IgYWRkaW5nIHJlc3VsdCBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIHNlbGVjdFF1ZXJ5IG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gJyc7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsICYmIG9wdGlvbnMubGltaXQgPT0gbnVsbCkge1xuICAgICAgZnJhZ21lbnQgKz0gJyBMSU1JVCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpICsgJywgJyArIDEwMDAwMDAwMDAwMDAwO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBmcmFnbWVudCArPSAnIExJTUlUICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCkgKyAnLCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudCArPSAnIExJTUlUICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuT3BlcmF0b3JNYXAsIHNtdGguY29tcGFyYXRvcikpIHtcbiAgICAgIHNtdGguY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbc210aC5jb21wYXJhdG9yXTtcbiAgICB9XG5cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLldoZXJlKSB7XG4gICAgICBsZXQgdmFsdWUgPSBzbXRoLmxvZ2ljO1xuICAgICAgbGV0IGtleTtcblxuICAgICAgaWYgKHNtdGguYXR0cmlidXRlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHNtdGguYXR0cmlidXRlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHNtdGguYXR0cmlidXRlLk1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHNtdGguYXR0cmlidXRlLmZpZWxkIHx8IHNtdGguYXR0cmlidXRlLmZpZWxkTmFtZSl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnModmFsdWUsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnTlVMTCcpIHtcbiAgICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSAnPScpIHtcbiAgICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9ICdJUyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzbXRoLmNvbXBhcmF0b3IgPT09ICchPScpIHtcbiAgICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9ICdJUyBOT1QnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7c210aC5jb21wYXJhdG9yfSBgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KHNtdGguYXR0cmlidXRlLCB2YWx1ZSwge1xuICAgICAgICAgIG1vZGVsOiBmYWN0b3J5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFt0aGlzLk9wZXJhdG9yTWFwW09wLmJldHdlZW5dLCB0aGlzLk9wZXJhdG9yTWFwW09wLm5vdEJldHdlZW5dXS5pbmNsdWRlcyhzbXRoLmNvbXBhcmF0b3IpKSB7XG4gICAgICAgIHZhbHVlID0gYCR7dGhpcy5lc2NhcGUodmFsdWVbMF0pfSBBTkQgJHt0aGlzLmVzY2FwZSh2YWx1ZVsxXSl9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmJvb2xlYW5WYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAnTlVMTCcpIHtcbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgICAgc210aC5jb21wYXJhdG9yID0gJ0lTJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSAnIT0nKSB7XG4gICAgICAgICAgc210aC5jb21wYXJhdG9yID0gJ0lTIE5PVCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtzbXRoLmNvbXBhcmF0b3J9IGApO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgIHJldHVybiBzbXRoLnZhbDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoc210aC52YWwgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aC52YWwsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChzbXRoLnZhbCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aC52YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5lc2NhcGUoc210aC52YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYENBU1QoJHtyZXN1bHR9IEFTICR7c210aC50eXBlLnRvVXBwZXJDYXNlKCl9KWA7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuRm4pIHtcbiAgICAgIHJldHVybiBgJHtzbXRoLmZufSgke1xuICAgICAgICBzbXRoLmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGFyZywgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnLnJlcGxhY2UoJyQnLCAnJCQkJykgOiBhcmcpO1xuICAgICAgICB9KS5qb2luKCcsICcpXG4gICAgICB9KWA7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ29sKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzbXRoLmNvbCkgJiYgIWZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBTZXF1ZWxpemUuY29sKCkgd2l0aCBhcnJheSBvdXRzaWRlIG9mIG9yZGVyIC8gZ3JvdXAgY2xhdXNlJyk7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5jb2wuc3RhcnRzV2l0aCgnKicpKSB7XG4gICAgICAgIHJldHVybiAnKic7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZShzbXRoLmNvbCwgZmFjdG9yeSk7XG4gICAgfVxuICAgIHJldHVybiBzbXRoLnRvU3RyaW5nKHRoaXMsIGZhY3RvcnkpO1xuICB9XG5cbiAgd2hlcmVRdWVyeSh3aGVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMpO1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBgV0hFUkUgJHtxdWVyeX1gO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB3aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMsIGJpbmRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB3aGVyZSA9PT0gbnVsbCB8fFxuICAgICAgd2hlcmUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgVXRpbHMuZ2V0Q29tcGxleFNpemUod2hlcmUpID09PSAwXG4gICAgKSB7XG4gICAgICAvLyBOTyBPUFxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2hlcmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIGB7d2hlcmU6IFxcJ3JhdyBxdWVyeVxcJ31gIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcblxuICAgIGJpbmRpbmcgPSBiaW5kaW5nIHx8ICdBTkQnO1xuICAgIGlmIChiaW5kaW5nWzBdICE9PSAnICcpIGJpbmRpbmcgPSBgICR7YmluZGluZ30gYDtcblxuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qod2hlcmUpKSB7XG4gICAgICBVdGlscy5nZXRDb21wbGV4S2V5cyh3aGVyZSkuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHdoZXJlW3Byb3BdO1xuICAgICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkocHJvcCwgaXRlbSwgb3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh1bmRlZmluZWQsIHdoZXJlLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCAmJiBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKS5qb2luKGJpbmRpbmcpIHx8ICcnO1xuICB9XG5cbiAgd2hlcmVJdGVtUXVlcnkoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV0hFUkUgcGFyYW1ldGVyIFwiJHtrZXl9XCIgaGFzIGludmFsaWQgXCJ1bmRlZmluZWRcIiB2YWx1ZWApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuaW5jbHVkZXMoJy4nKSAmJiBvcHRpb25zLm1vZGVsKSB7XG4gICAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV0gJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgY29uc3QgdG1wID0ge307XG4gICAgICAgIGNvbnN0IGZpZWxkID0gb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXTtcbiAgICAgICAgXy5zZXQodG1wLCBrZXlQYXJ0cy5zbGljZSgxKSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShmaWVsZC5maWVsZCB8fCBrZXlQYXJ0c1swXSwgdG1wLCB7IGZpZWxkLCAuLi5vcHRpb25zIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5fZmluZEZpZWxkKGtleSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmllbGRUeXBlID0gZmllbGQgJiYgZmllbGQudHlwZSB8fCBvcHRpb25zLnR5cGU7XG5cbiAgICBjb25zdCBpc1BsYWluT2JqZWN0ID0gXy5pc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCBpc0FycmF5ID0gIWlzUGxhaW5PYmplY3QgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAga2V5ID0gdGhpcy5PcGVyYXRvcnNBbGlhc01hcCAmJiB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwW2tleV0gfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVLZXlzID0gaXNQbGFpbk9iamVjdCAmJiBVdGlscy5nZXRDb21wbGV4S2V5cyh2YWx1ZSk7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3QgJiYgdmFsdWVLZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeSh2YWx1ZUtleXNbMF0sIHZhbHVlW3ZhbHVlS2V5c1swXV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gJ05VTEwnIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmlzXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCAmJiAhKGtleSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuRm4pKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgd2hlcmU6IFtdIHRvIE9wLmFuZCBpZiBwb3NzaWJsZSwgZWxzZSB0cmVhdCBhcyBsaXRlcmFsL3JlcGxhY2VtZW50c1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KSB7XG4gICAgICBpZiAoVXRpbHMuY2FuVHJlYXRBcnJheUFzQW5kKHZhbHVlKSkge1xuICAgICAgICBrZXkgPSBPcC5hbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIGxpdGVyYWwgcmVwbGFjZW1lbnRzIGluIHRoZSBgd2hlcmVgIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09IE9wLm9yIHx8IGtleSA9PT0gT3AuYW5kIHx8IGtleSA9PT0gT3Aubm90KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG5cbiAgICBpZiAodmFsdWVbT3Aub3JdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVCaW5kKHRoaXMuT3BlcmF0b3JNYXBbT3Aub3JdLCBrZXksIHZhbHVlW09wLm9yXSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlW09wLmFuZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdLCBrZXksIHZhbHVlW09wLmFuZF0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5ICYmIGZpZWxkVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QgJiYgZmllbGRUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04gJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlSlNPTihrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gSWYgbXVsdGlwbGUga2V5cyB3ZSBjb21iaW5lIHRoZSBkaWZmZXJlbnQgbG9naWMgY29uZGl0aW9uc1xuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIHZhbHVlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVCaW5kKHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSwga2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgT3AuaW4sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QpIHtcbiAgICAgIGlmICh0aGlzLk9wZXJhdG9yTWFwW3ZhbHVlS2V5c1swXV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCB2YWx1ZUtleXNbMF0sIHZhbHVlW3ZhbHVlS2V5c1swXV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IE9wLnBsYWNlaG9sZGVyKSB7XG4gICAgICBjb25zdCBvcFZhbHVlID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKHRoaXMuT3BlcmF0b3JNYXBba2V5XSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBjb25zdCBvcFZhbHVlID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gIH1cblxuICBfZmluZEZpZWxkKGtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmZpZWxkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5maWVsZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXMgJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcCAmJiBvcHRpb25zLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXBba2V5XTtcbiAgICB9XG4gIH1cblxuICAvLyBPUi9BTkQvTk9UIGdyb3VwaW5nIGxvZ2ljXG4gIF93aGVyZUdyb3VwQmluZChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGtleSA9PT0gT3Aub3IgPyB0aGlzLk9wZXJhdG9yTWFwW09wLm9yXSA6IHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXTtcbiAgICBjb25zdCBvdXRlckJpbmRpbmcgPSBrZXkgPT09IE9wLm5vdCA/ICdOT1QgJyA6ICcnO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChpdGVtID0+IHtcbiAgICAgICAgbGV0IGl0ZW1RdWVyeSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGl0ZW0sIG9wdGlvbnMsIHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSk7XG4gICAgICAgIGlmIChpdGVtUXVlcnkgJiYgaXRlbVF1ZXJ5Lmxlbmd0aCAmJiAoQXJyYXkuaXNBcnJheShpdGVtKSB8fCBfLmlzUGxhaW5PYmplY3QoaXRlbSkpICYmIFV0aWxzLmdldENvbXBsZXhTaXplKGl0ZW0pID4gMSkge1xuICAgICAgICAgIGl0ZW1RdWVyeSA9IGAoJHtpdGVtUXVlcnl9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1RdWVyeTtcbiAgICAgIH0pLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpO1xuXG4gICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZS5qb2luKGJpbmRpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHZhbHVlLCBvcHRpb25zLCBiaW5kaW5nKTtcbiAgICB9XG4gICAgLy8gT3Aub3I6IFtdIHNob3VsZCByZXR1cm4gbm8gZGF0YS5cbiAgICAvLyBPcC5ub3Qgb2Ygbm8gcmVzdHJpY3Rpb24gc2hvdWxkIGFsc28gcmV0dXJuIG5vIGRhdGFcbiAgICBpZiAoKGtleSA9PT0gT3Aub3IgfHwga2V5ID09PSBPcC5ub3QpICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuICcwID0gMSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlID8gYCR7b3V0ZXJCaW5kaW5nfSgke3ZhbHVlfSlgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgX3doZXJlQmluZChiaW5kaW5nLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gVXRpbHMuZ2V0Q29tcGxleEtleXModmFsdWUpLm1hcChwcm9wID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW3Byb3BdO1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHsgW3Byb3BdOiBpdGVtIH0sIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGl0ZW0gPT4gdGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIGl0ZW0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IGAoJHt2YWx1ZS5qb2luKGJpbmRpbmcpfSlgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgX3doZXJlSlNPTihrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgYmFzZUtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgaWYgKG9wdGlvbnMucHJlZml4KSB7XG4gICAgICBpZiAob3B0aW9ucy5wcmVmaXggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgIGJhc2VLZXkgPSBgJHt0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChvcHRpb25zLnByZWZpeCl9LiR7YmFzZUtleX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUtleSA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnByZWZpeCl9LiR7YmFzZUtleX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIFV0aWxzLmdldE9wZXJhdG9ycyh2YWx1ZSkuZm9yRWFjaChvcCA9PiB7XG4gICAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgICAgW29wXTogdmFsdWVbb3BdXG4gICAgICB9O1xuICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgd2hlcmUsIHsgLi4ub3B0aW9ucywganNvbjogZmFsc2UgfSkpO1xuICAgIH0pO1xuXG4gICAgXy5mb3JPd24odmFsdWUsIChpdGVtLCBwcm9wKSA9PiB7XG4gICAgICB0aGlzLl90cmF2ZXJzZUpTT04oaXRlbXMsIGJhc2VLZXksIHByb3AsIGl0ZW0sIFtwcm9wXSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBpdGVtcy5qb2luKHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSk7XG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDEgPyBgKCR7cmVzdWx0fSlgIDogcmVzdWx0O1xuICB9XG5cbiAgX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgcHJvcCwgaXRlbSwgcGF0aCkge1xuICAgIGxldCBjYXN0O1xuXG4gICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXS5pbmNsdWRlcygnOjonKSkge1xuICAgICAgY29uc3QgdG1wID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdLnNwbGl0KCc6OicpO1xuICAgICAgY2FzdCA9IHRtcFsxXTtcbiAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9IHRtcFswXTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoS2V5ID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShiYXNlS2V5LCBwYXRoKTtcblxuICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgIFV0aWxzLmdldE9wZXJhdG9ycyhpdGVtKS5mb3JFYWNoKG9wID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl90b0pTT05WYWx1ZShpdGVtW29wXSk7XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh0aGlzLl9jYXN0S2V5KHBhdGhLZXksIHZhbHVlLCBjYXN0KSwgeyBbb3BdOiB2YWx1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIF8uZm9yT3duKGl0ZW0sICh2YWx1ZSwgaXRlbVByb3ApID0+IHtcbiAgICAgICAgdGhpcy5fdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBpdGVtUHJvcCwgdmFsdWUsIHBhdGguY29uY2F0KFtpdGVtUHJvcF0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXRlbSA9IHRoaXMuX3RvSlNPTlZhbHVlKGl0ZW0pO1xuICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh0aGlzLl9jYXN0S2V5KHBhdGhLZXksIGl0ZW0sIGNhc3QpLCB7IFtPcC5lcV06IGl0ZW0gfSkpO1xuICB9XG5cbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgX2Nhc3RLZXkoa2V5LCB2YWx1ZSwgY2FzdCwganNvbikge1xuICAgIGNhc3QgPSBjYXN0IHx8IHRoaXMuX2dldEpzb25DYXN0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSk7XG4gICAgaWYgKGNhc3QpIHtcbiAgICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbCh0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChuZXcgVXRpbHMuQ2FzdChuZXcgVXRpbHMuTGl0ZXJhbChrZXkpLCBjYXN0LCBqc29uKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbChrZXkpO1xuICB9XG5cbiAgX2dldEpzb25DYXN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnZG91YmxlIHByZWNpc2lvbic7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAndGltZXN0YW1wdHonO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIF9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciwgcHJlZml4KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleX0gYW5kICR7dmFsdWV9IGhhcyBubyBjb21wYXJhdG9yYCk7XG4gICAgfVxuICAgIGtleSA9IHRoaXMuX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7Y29tcGFyYXRvcn0gYCk7XG4gIH1cblxuICBfZ2V0U2FmZUtleShrZXksIHByZWZpeCkge1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgIGtleSA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGtleSk7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlZml4S2V5KHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGtleSksIHByZWZpeCk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxzLmlzQ29sU3RyaW5nKGtleSkpIHtcbiAgICAgIGtleSA9IGtleS5zdWJzdHIoMSwga2V5Lmxlbmd0aCAtIDIpLnNwbGl0KCcuJyk7XG5cbiAgICAgIGlmIChrZXkubGVuZ3RoID4gMikge1xuICAgICAgICBrZXkgPSBbXG4gICAgICAgICAgLy8gam9pbiB0aGUgdGFibGVzIGJ5IC0+IHRvIG1hdGNoIG91dCBpbnRlcm5hbCBuYW1pbmdzXG4gICAgICAgICAga2V5LnNsaWNlKDAsIC0xKS5qb2luKCctPicpLFxuICAgICAgICAgIGtleVtrZXkubGVuZ3RoIC0gMV1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleS5tYXAoaWRlbnRpZmllciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyKSkuam9pbignLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcmVmaXhLZXkodGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSwgcHJlZml4KTtcbiAgfVxuXG4gIF9wcmVmaXhLZXkoa2V5LCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4IGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHByZWZpeCksIGtleV0uam9pbignLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3RoaXMucXVvdGVUYWJsZShwcmVmaXgpLCBrZXldLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCBwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wID09PSBPcC5ub3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBwcm9wID0gT3Aubm90SW47XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICBwcm9wID0gT3AubmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW3Byb3BdIHx8IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdO1xuXG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlIE9wLmluOlxuICAgICAgY2FzZSBPcC5ub3RJbjpcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZS52YWwsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3ZhbHVlLm1hcChpdGVtID0+IHRoaXMuZXNjYXBlKGl0ZW0sIGZpZWxkKSkuam9pbignLCAnKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmF0b3IgPT09IHRoaXMuT3BlcmF0b3JNYXBbT3AuaW5dKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksICcoTlVMTCknLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICBjYXNlIE9wLmFueTpcbiAgICAgIGNhc2UgT3AuYWxsOlxuICAgICAgICBjb21wYXJhdG9yID0gYCR7dGhpcy5PcGVyYXRvck1hcFtPcC5lcV19ICR7Y29tcGFyYXRvcn1gO1xuICAgICAgICBpZiAodmFsdWVbT3AudmFsdWVzXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKFZBTFVFUyAke3ZhbHVlW09wLnZhbHVlc10ubWFwKGl0ZW0gPT4gYCgke3RoaXMuZXNjYXBlKGl0ZW0pfSlgKS5qb2luKCcsICcpfSlgLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3RoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCl9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNhc2UgT3AuYmV0d2VlbjpcbiAgICAgIGNhc2UgT3Aubm90QmV0d2VlbjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdLCBmaWVsZCl9IEFORCAke3RoaXMuZXNjYXBlKHZhbHVlWzFdLCBmaWVsZCl9YCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5yYXc6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGAkcmF3YCB3aGVyZSBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAgVXNlIGBzZXF1ZWxpemUubGl0ZXJhbGAgaW5zdGVhZC4nKTtcbiAgICAgIGNhc2UgT3AuY29sOlxuICAgICAgICBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtPcC5lcV07XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJy4nKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhbHVlID0gW1xuICAgICAgICAgICAgLy8gam9pbiB0aGUgdGFibGVzIGJ5IC0+IHRvIG1hdGNoIG91dCBpbnRlcm5hbCBuYW1pbmdzXG4gICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAtMSkuam9pbignLT4nKSxcbiAgICAgICAgICAgIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZS5tYXAoaWRlbnRpZmllciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyKSkuam9pbignLicpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICBjYXNlIE9wLnN0YXJ0c1dpdGg6XG4gICAgICBjYXNlIE9wLmVuZHNXaXRoOlxuICAgICAgY2FzZSBPcC5zdWJzdHJpbmc6XG4gICAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW09wLmxpa2VdO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXR0ZXJuID0gYCR7dmFsdWV9JWA7XG5cbiAgICAgICAgaWYgKHByb3AgPT09IE9wLmVuZHNXaXRoKSBwYXR0ZXJuID0gYCUke3ZhbHVlfWA7XG4gICAgICAgIGlmIChwcm9wID09PSBPcC5zdWJzdHJpbmcpIHBhdHRlcm4gPSBgJSR7dmFsdWV9JWA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHBhdHRlcm4pLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXNjYXBlT3B0aW9ucyA9IHtcbiAgICAgIGFjY2VwdFN0cmluZ3M6IGNvbXBhcmF0b3IuaW5jbHVkZXModGhpcy5PcGVyYXRvck1hcFtPcC5saWtlXSlcbiAgICB9O1xuXG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZVtPcC5jb2xdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLndoZXJlSXRlbVF1ZXJ5KG51bGwsIHZhbHVlKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlW09wLmFueV0pIHtcbiAgICAgICAgZXNjYXBlT3B0aW9ucy5pc0xpc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3RoaXMuZXNjYXBlKHZhbHVlW09wLmFueV0sIGZpZWxkLCBlc2NhcGVPcHRpb25zKX0pYCwgYCR7Y29tcGFyYXRvcn0gJHt0aGlzLk9wZXJhdG9yTWFwW09wLmFueV19YCwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlW09wLmFsbF0pIHtcbiAgICAgICAgZXNjYXBlT3B0aW9ucy5pc0xpc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3RoaXMuZXNjYXBlKHZhbHVlW09wLmFsbF0sIGZpZWxkLCBlc2NhcGVPcHRpb25zKX0pYCwgYCR7Y29tcGFyYXRvcn0gJHt0aGlzLk9wZXJhdG9yTWFwW09wLmFsbF19YCwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3AuaXNdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLm5lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3Aubm90XSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gIH1cblxuICAvKlxuICAgIFRha2VzIHNvbWV0aGluZyBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIHZhbHVlcyBvZiBhIHdoZXJlIGNvbmRpdGlvbi5cbiAgIEBwcml2YXRlXG4gICovXG4gIGdldFdoZXJlQ29uZGl0aW9ucyhzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVOYW1lKSkge1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lWzBdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWVbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAocHJlcGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVwZW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc210aCAmJiBzbXRoIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7IC8vIENoZWNraW5nIGEgcHJvcGVydHkgaXMgY2hlYXBlciB0aGFuIGEgbG90IG9mIGluc3RhbmNlb2YgY2FsbHNcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgIH1cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHNtdGgpKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aCwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZSxcbiAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzbXRoID09PSAnbnVtYmVyJykge1xuICAgICAgbGV0IHByaW1hcnlLZXlzID0gZmFjdG9yeSA/IE9iamVjdC5rZXlzKGZhY3RvcnkucHJpbWFyeUtleXMpIDogW107XG5cbiAgICAgIGlmIChwcmltYXJ5S2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGp1c3QgYSBudW1iZXIsIGFzc3VtZSBvbmx5IHRoZSBmaXJzdCBrZXlcbiAgICAgICAgcHJpbWFyeUtleXMgPSBwcmltYXJ5S2V5c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW1hcnlLZXlzID0gJ2lkJztcbiAgICAgIH1cblxuICAgICAgd2hlcmVbcHJpbWFyeUtleXNdID0gc210aDtcblxuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHdoZXJlLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzbXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNtdGgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc2NhcGUoc210aCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGgpKSB7XG4gICAgICBpZiAoc210aC5sZW5ndGggPT09IDAgfHwgc210aC5sZW5ndGggPiAwICYmIHNtdGhbMF0ubGVuZ3RoID09PSAwKSByZXR1cm4gJzE9MSc7XG4gICAgICBpZiAoVXRpbHMuY2FuVHJlYXRBcnJheUFzQW5kKHNtdGgpKSB7XG4gICAgICAgIGNvbnN0IF9zbXRoID0geyBbT3AuYW5kXTogc210aCB9O1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoX3NtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIGxpdGVyYWwgcmVwbGFjZW1lbnRzIGluIHRoZSBgd2hlcmVgIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkLicpO1xuICAgIH1cbiAgICBpZiAoc210aCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiAnMT0xJztcbiAgfVxuXG4gIC8vIEEgcmVjdXJzaXZlIHBhcnNlciBmb3IgbmVzdGVkIHdoZXJlIGNvbmRpdGlvbnNcbiAgcGFyc2VDb25kaXRpb25PYmplY3QoY29uZGl0aW9ucywgcGF0aCkge1xuICAgIHBhdGggPSBwYXRoIHx8IFtdO1xuICAgIHJldHVybiBfLnJlZHVjZShjb25kaXRpb25zLCAocmVzdWx0LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQodGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdCh2YWx1ZSwgcGF0aC5jb25jYXQoa2V5KSkpOyAvLyBSZWN1cnNpdmVseSBwYXJzZSBvYmplY3RzXG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7IHBhdGg6IHBhdGguY29uY2F0KGtleSksIHZhbHVlIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cblxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUsIHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yL29wZXJhdG9ycycpKTtcbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvci90cmFuc2FjdGlvbicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUdlbmVyYXRvcjtcbiIsIi8qKlxuICogUXVvdGUgaGVscGVycyBpbXBsZW1lbnQgcXVvdGUgYWJpbGl0eSBmb3IgYWxsIGRpYWxlY3RzLlxuICogVGhlc2UgYXJlIGJhc2ljIGJsb2NrIG9mIHF1ZXJ5IGJ1aWxkaW5nXG4gKlxuICogSXRzIGJldHRlciB0byBpbXBsZW1lbnQgYWxsIGRpYWxlY3QgaW1wbGVtZW50YXRpb24gdG9nZXRoZXIgaGVyZS4gV2hpY2ggd2lsbCBhbGxvd1xuICogZXZlbiBhYnN0cmFjdCBnZW5lcmF0b3IgdG8gdXNlIHRoZW0gYnkganVzdCBzcGVjaWZ5aW5nIGRpYWxlY3QgdHlwZS5cbiAqXG4gKiBEZWZpbmluZyB0aGVzZSBoZWxwZXJzIGluIGVhY2ggcXVlcnkgZGlhbGVjdCB3aWxsIGxlYXZlXG4gKiBjb2RlIGluIGR1YWwgZGVwZW5kZW5jeSBvZiBhYnN0cmFjdCA8LT4gc3BlY2lmaWMgZGlhbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlscycpO1xuXG4vKipcbiAqIGxpc3Qgb2YgcmVzZXJ2ZWQgd29yZHMgaW4gUG9zdGdyZVNRTCAxMFxuICogc291cmNlOiBodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzEwL3N0YXRpYy9zcWwta2V5d29yZHMtYXBwZW5kaXguaHRtbFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHBvc3RncmVzUmVzZXJ2ZWRXb3JkcyA9ICdhbGwsYW5hbHlzZSxhbmFseXplLGFuZCxhbnksYXJyYXksYXMsYXNjLGFzeW1tZXRyaWMsYXV0aG9yaXphdGlvbixiaW5hcnksYm90aCxjYXNlLGNhc3QsY2hlY2ssY29sbGF0ZSxjb2xsYXRpb24sY29sdW1uLGNvbmN1cnJlbnRseSxjb25zdHJhaW50LGNyZWF0ZSxjcm9zcyxjdXJyZW50X2NhdGFsb2csY3VycmVudF9kYXRlLGN1cnJlbnRfcm9sZSxjdXJyZW50X3NjaGVtYSxjdXJyZW50X3RpbWUsY3VycmVudF90aW1lc3RhbXAsY3VycmVudF91c2VyLGRlZmF1bHQsZGVmZXJyYWJsZSxkZXNjLGRpc3RpbmN0LGRvLGVsc2UsZW5kLGV4Y2VwdCxmYWxzZSxmZXRjaCxmb3IsZm9yZWlnbixmcmVlemUsZnJvbSxmdWxsLGdyYW50LGdyb3VwLGhhdmluZyxpbGlrZSxpbixpbml0aWFsbHksaW5uZXIsaW50ZXJzZWN0LGludG8saXMsaXNudWxsLGpvaW4sbGF0ZXJhbCxsZWFkaW5nLGxlZnQsbGlrZSxsaW1pdCxsb2NhbHRpbWUsbG9jYWx0aW1lc3RhbXAsbmF0dXJhbCxub3Qsbm90bnVsbCxudWxsLG9mZnNldCxvbixvbmx5LG9yLG9yZGVyLG91dGVyLG92ZXJsYXBzLHBsYWNpbmcscHJpbWFyeSxyZWZlcmVuY2VzLHJldHVybmluZyxyaWdodCxzZWxlY3Qsc2Vzc2lvbl91c2VyLHNpbWlsYXIsc29tZSxzeW1tZXRyaWMsdGFibGUsdGFibGVzYW1wbGUsdGhlbix0byx0cmFpbGluZyx0cnVlLHVuaW9uLHVuaXF1ZSx1c2VyLHVzaW5nLHZhcmlhZGljLHZlcmJvc2Usd2hlbix3aGVyZSx3aW5kb3csd2l0aCcuc3BsaXQoJywnKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICBkaWFsZWN0ICAgICAgICAgRGlhbGVjdCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gIGlkZW50aWZpZXIgICAgICBJZGVudGlmaWVyIHRvIHF1b3RlXG4gKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZT1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucXVvdGVJZGVudGlmaWVycz10cnVlXVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBxdW90ZUlkZW50aWZpZXIoZGlhbGVjdCwgaWRlbnRpZmllciwgb3B0aW9ucykge1xuICBpZiAoaWRlbnRpZmllciA9PT0gJyonKSByZXR1cm4gaWRlbnRpZmllcjtcblxuICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xuICAgIGZvcmNlOiBmYWxzZSxcbiAgICBxdW90ZUlkZW50aWZpZXJzOiB0cnVlXG4gIH0pO1xuXG4gIHN3aXRjaCAoZGlhbGVjdCkge1xuICAgIGNhc2UgJ3NxbGl0ZSc6XG4gICAgY2FzZSAnbWFyaWFkYic6XG4gICAgY2FzZSAnbXlzcWwnOlxuICAgICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdgJyksICdgJyk7XG5cbiAgICBjYXNlICdwb3N0Z3Jlcyc6XG4gICAgICBjb25zdCByYXdJZGVudGlmaWVyID0gVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgJ1wiJyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5mb3JjZSAhPT0gdHJ1ZSAmJlxuICAgICAgICBvcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlICYmXG4gICAgICAgICFpZGVudGlmaWVyLmluY2x1ZGVzKCcuJykgJiZcbiAgICAgICAgIWlkZW50aWZpZXIuaW5jbHVkZXMoJy0+JykgJiZcbiAgICAgICAgIXBvc3RncmVzUmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyhyYXdJZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICApIHtcbiAgICAgICAgLy8gSW4gUG9zdGdyZXMsIGlmIHRhYmxlcyBvciBhdHRyaWJ1dGVzIGFyZSBjcmVhdGVkIGRvdWJsZS1xdW90ZWQsXG4gICAgICAgIC8vIHRoZXkgYXJlIGFsc28gY2FzZSBzZW5zaXRpdmUuIElmIHRoZXkgY29udGFpbiBhbnkgdXBwZXJjYXNlXG4gICAgICAgIC8vIGNoYXJhY3RlcnMsIHRoZXkgbXVzdCBhbHdheXMgYmUgZG91YmxlLXF1b3RlZC4gVGhpcyBtYWtlcyBpdFxuICAgICAgICAvLyBpbXBvc3NpYmxlIHRvIHdyaXRlIHF1ZXJpZXMgaW4gcG9ydGFibGUgU1FMIGlmIHRhYmxlcyBhcmUgY3JlYXRlZCBpblxuICAgICAgICAvLyB0aGlzIHdheS4gSGVuY2UsIHdlIHN0cmlwIHF1b3RlcyBpZiB3ZSBkb24ndCB3YW50IGNhc2Ugc2Vuc2l0aXZpdHkuXG4gICAgICAgIHJldHVybiByYXdJZGVudGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKHJhd0lkZW50aWZpZXIsICdcIicpO1xuICAgIGNhc2UgJ21zc3FsJzpcbiAgICAgIHJldHVybiBgWyR7aWRlbnRpZmllci5yZXBsYWNlKC9bW1xcXSddKy9nLCAnJyl9XWA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWFsZWN0IFwiJHtkaWFsZWN0fVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMucXVvdGVJZGVudGlmaWVyID0gcXVvdGVJZGVudGlmaWVyO1xuXG4vKipcbiAqIFRlc3QgaWYgYSBnaXZlIHN0cmluZyBpcyBhbHJlYWR5IHF1b3RlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJRdW90ZWQoaWRlbnRpZmllcikge1xuICByZXR1cm4gL15cXHMqKD86KFtgXCInXSkoPzooPyFcXDEpLnxcXDF7Mn0pKlxcMVxcLj8pK1xccyokL2kudGVzdChpZGVudGlmaWVyKTtcbn1cbm1vZHVsZS5leHBvcnRzLmlzSWRlbnRpZmllclF1b3RlZCA9IGlzSWRlbnRpZmllclF1b3RlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRvcnMnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuY29uc3QgT3BlcmF0b3JIZWxwZXJzID0ge1xuICBPcGVyYXRvck1hcDoge1xuICAgIFtPcC5lcV06ICc9JyxcbiAgICBbT3AubmVdOiAnIT0nLFxuICAgIFtPcC5ndGVdOiAnPj0nLFxuICAgIFtPcC5ndF06ICc+JyxcbiAgICBbT3AubHRlXTogJzw9JyxcbiAgICBbT3AubHRdOiAnPCcsXG4gICAgW09wLm5vdF06ICdJUyBOT1QnLFxuICAgIFtPcC5pc106ICdJUycsXG4gICAgW09wLmluXTogJ0lOJyxcbiAgICBbT3Aubm90SW5dOiAnTk9UIElOJyxcbiAgICBbT3AubGlrZV06ICdMSUtFJyxcbiAgICBbT3Aubm90TGlrZV06ICdOT1QgTElLRScsXG4gICAgW09wLmlMaWtlXTogJ0lMSUtFJyxcbiAgICBbT3Aubm90SUxpa2VdOiAnTk9UIElMSUtFJyxcbiAgICBbT3Auc3RhcnRzV2l0aF06ICdMSUtFJyxcbiAgICBbT3AuZW5kc1dpdGhdOiAnTElLRScsXG4gICAgW09wLnN1YnN0cmluZ106ICdMSUtFJyxcbiAgICBbT3AucmVnZXhwXTogJ34nLFxuICAgIFtPcC5ub3RSZWdleHBdOiAnIX4nLFxuICAgIFtPcC5pUmVnZXhwXTogJ34qJyxcbiAgICBbT3Aubm90SVJlZ2V4cF06ICchfionLFxuICAgIFtPcC5iZXR3ZWVuXTogJ0JFVFdFRU4nLFxuICAgIFtPcC5ub3RCZXR3ZWVuXTogJ05PVCBCRVRXRUVOJyxcbiAgICBbT3Aub3ZlcmxhcF06ICcmJicsXG4gICAgW09wLmNvbnRhaW5zXTogJ0A+JyxcbiAgICBbT3AuY29udGFpbmVkXTogJzxAJyxcbiAgICBbT3AuYWRqYWNlbnRdOiAnLXwtJyxcbiAgICBbT3Auc3RyaWN0TGVmdF06ICc8PCcsXG4gICAgW09wLnN0cmljdFJpZ2h0XTogJz4+JyxcbiAgICBbT3Aubm9FeHRlbmRSaWdodF06ICcmPCcsXG4gICAgW09wLm5vRXh0ZW5kTGVmdF06ICcmPicsXG4gICAgW09wLmFueV06ICdBTlknLFxuICAgIFtPcC5hbGxdOiAnQUxMJyxcbiAgICBbT3AuYW5kXTogJyBBTkQgJyxcbiAgICBbT3Aub3JdOiAnIE9SICcsXG4gICAgW09wLmNvbF06ICdDT0wnLFxuICAgIFtPcC5wbGFjZWhvbGRlcl06ICckJFBMQUNFSE9MREVSJCQnLFxuICAgIFtPcC5tYXRjaF06ICdAQCdcbiAgfSxcblxuICBPcGVyYXRvcnNBbGlhc01hcDoge30sXG5cbiAgc2V0T3BlcmF0b3JzQWxpYXNlcyhhbGlhc2VzKSB7XG4gICAgaWYgKCFhbGlhc2VzIHx8IF8uaXNFbXB0eShhbGlhc2VzKSkge1xuICAgICAgdGhpcy5PcGVyYXRvcnNBbGlhc01hcCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwID0geyAuLi5hbGlhc2VzIH07XG4gICAgfVxuICB9LFxuXG4gIF9yZXBsYWNlQWxpYXNlcyhvcmlnKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgaWYgKCF0aGlzLk9wZXJhdG9yc0FsaWFzTWFwKSB7XG4gICAgICByZXR1cm4gb3JpZztcbiAgICB9XG5cbiAgICBVdGlscy5nZXRPcGVyYXRvcnMob3JpZykuZm9yRWFjaChvcCA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gb3JpZ1tvcF07XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIG9ialtvcF0gPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyhpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtvcF0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgXy5mb3JPd24ob3JpZywgKGl0ZW0sIHByb3ApID0+IHtcbiAgICAgIHByb3AgPSB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwW3Byb3BdIHx8IHByb3A7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIG9ialtwcm9wXSA9IGl0ZW07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRvckhlbHBlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoJ3V1aWQnKS52NDtcblxuY29uc3QgVHJhbnNhY3Rpb25RdWVyaWVzID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIHF1ZXJ5IHRoYXQgc2V0cyB0aGUgdHJhbnNhY3Rpb24gaXNvbGF0aW9uIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlICAgVGhlIGlzb2xhdGlvbiBsZXZlbC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGBTRVQgVFJBTlNBQ1RJT04gSVNPTEFUSU9OIExFVkVMICR7dmFsdWV9O2A7XG4gIH0sXG5cbiAgZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCkge1xuICAgIHJldHVybiB1dWlkdjQoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHF1ZXJ5IHRoYXQgc3RhcnRzIGEgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgLy8gZm9yY2UgcXVvdGluZyBvZiBzYXZlcG9pbnQgaWRlbnRpZmllcnMgZm9yIHBvc3RncmVzXG4gICAgICByZXR1cm4gYFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUsIHRydWUpfTtgO1xuICAgIH1cblxuICAgIHJldHVybiAnU1RBUlQgVFJBTlNBQ1RJT047JztcbiAgfSxcblxuICBkZWZlckNvbnN0cmFpbnRzUXVlcnkoKSB7fSxcblxuICBzZXRDb25zdHJhaW50UXVlcnkoKSB7fSxcbiAgc2V0RGVmZXJyZWRRdWVyeSgpIHt9LFxuICBzZXRJbW1lZGlhdGVRdWVyeSgpIHt9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcXVlcnkgdGhhdCBjb21taXRzIGEgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0NPTU1JVDsnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcXVlcnkgdGhhdCByb2xsYmFja3MgYSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICAvLyBmb3JjZSBxdW90aW5nIG9mIHNhdmVwb2ludCBpZGVudGlmaWVycyBmb3IgcG9zdGdyZXNcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVE8gU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSwgdHJ1ZSl9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuICdST0xMQkFDSzsnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uUXVlcmllcztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zYWN0aW9uJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIHRoYXQgU2VxdWVsaXplIHVzZXMgdG8gdGFsayB0byBhbGwgZGF0YWJhc2VzXG4gKi9cbmNsYXNzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplLCBxdWVyeUdlbmVyYXRvcikge1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBxdWVyeUdlbmVyYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkYXRhYmFzZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2UgIERhdGFiYXNlIG5hbWUgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2hhcnNldF0gRGF0YWJhc2UgZGVmYXVsdCBjaGFyYWN0ZXIgc2V0LCBNWVNRTCBvbmx5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb2xsYXRlXSBEYXRhYmFzZSBkZWZhdWx0IGNvbGxhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2RpbmddIERhdGFiYXNlIGRlZmF1bHQgY2hhcmFjdGVyIHNldCwgUG9zdGdyZVNRTCBvbmx5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jdHlwZV0gRGF0YWJhc2UgY2hhcmFjdGVyIGNsYXNzaWZpY2F0aW9uLCBQb3N0Z3JlU1FMIG9ubHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRlbXBsYXRlXSBUaGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgZnJvbSB3aGljaCB0byBjcmVhdGUgdGhlIG5ldyBkYXRhYmFzZSwgUG9zdGdyZVNRTCBvbmx5XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRGF0YWJhc2UoZGF0YWJhc2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYSBkYXRhYmFzZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2UgIERhdGFiYXNlIG5hbWUgdG8gZHJvcFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wRGF0YWJhc2UoZGF0YWJhc2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzY2hlbWFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYSAgICBTY2hlbWEgbmFtZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhIHNjaGVtYVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hICAgIFNjaGVtYSBuYW1lIHRvIGRyb3BcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BTY2hlbWEoc2NoZW1hKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCBzY2hlbWFzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5xdWVyeUdlbmVyYXRvci5fZGlhbGVjdC5zdXBwb3J0cy5zY2hlbWFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuZHJvcChvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFNjaGVtYXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNjaGVtYXMubWFwKHNjaGVtYU5hbWUgPT4gdGhpcy5kcm9wU2NoZW1hKHNjaGVtYU5hbWUsIG9wdGlvbnMpKSk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhbGwgc2NoZW1hc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKi9cbiAgYXN5bmMgc2hvd0FsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmF3OiB0cnVlLFxuICAgICAgdHlwZTogdGhpcy5zZXF1ZWxpemUuUXVlcnlUeXBlcy5TRUxFQ1RcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvd1NjaGVtYXNTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dTY2hlbWFzUXVlcnkob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzY2hlbWFOYW1lcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNob3dTY2hlbWFzU3FsLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBfLmZsYXR0ZW4oc2NoZW1hTmFtZXMubWFwKHZhbHVlID0+IHZhbHVlLnNjaGVtYV9uYW1lID8gdmFsdWUuc2NoZW1hX25hbWUgOiB2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkYXRhYmFzZSB2ZXJzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBbb3B0aW9uc10gICAgICBRdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7UXVlcnlUeXBlfSBbb3B0aW9ucy50eXBlXSBRdWVyeSB0eXBlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnZlcnNpb25RdWVyeSgpLFxuICAgICAgeyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLlZFUlNJT04gfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGFibGUgd2l0aCBnaXZlbiBzZXQgb2YgYXR0cmlidXRlc1xuICAgKlxuICAgKiBgYGBqc1xuICAgKiBxdWVyeUludGVyZmFjZS5jcmVhdGVUYWJsZShcbiAgICogICAnbmFtZU9mVGhlTmV3VGFibGUnLFxuICAgKiAgIHtcbiAgICogICAgIGlkOiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5JTlRFR0VSLFxuICAgKiAgICAgICBwcmltYXJ5S2V5OiB0cnVlLFxuICAgKiAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAqICAgICB9LFxuICAgKiAgICAgY3JlYXRlZEF0OiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5EQVRFXG4gICAqICAgICB9LFxuICAgKiAgICAgdXBkYXRlZEF0OiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5EQVRFXG4gICAqICAgICB9LFxuICAgKiAgICAgYXR0cjE6IFNlcXVlbGl6ZS5TVFJJTkcsXG4gICAqICAgICBhdHRyMjogU2VxdWVsaXplLklOVEVHRVIsXG4gICAqICAgICBhdHRyMzoge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuQk9PTEVBTixcbiAgICogICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICogICAgICAgYWxsb3dOdWxsOiBmYWxzZVxuICAgKiAgICAgfSxcbiAgICogICAgIC8vZm9yZWlnbiBrZXkgdXNhZ2VcbiAgICogICAgIGF0dHI0OiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5JTlRFR0VSLFxuICAgKiAgICAgICByZWZlcmVuY2VzOiB7XG4gICAqICAgICAgICAgbW9kZWw6ICdhbm90aGVyX3RhYmxlX25hbWUnLFxuICAgKiAgICAgICAgIGtleTogJ2lkJ1xuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBvblVwZGF0ZTogJ2Nhc2NhZGUnLFxuICAgKiAgICAgICBvbkRlbGV0ZTogJ2Nhc2NhZGUnXG4gICAqICAgICB9XG4gICAqICAgfSxcbiAgICogICB7XG4gICAqICAgICBlbmdpbmU6ICdNWUlTQU0nLCAgICAvLyBkZWZhdWx0OiAnSW5ub0RCJ1xuICAgKiAgICAgY2hhcnNldDogJ2xhdGluMScsICAgLy8gZGVmYXVsdDogbnVsbFxuICAgKiAgICAgc2NoZW1hOiAncHVibGljJywgICAgLy8gZGVmYXVsdDogcHVibGljLCBQb3N0Z3JlU1FMIG9ubHkuXG4gICAqICAgICBjb21tZW50OiAnbXkgdGFibGUnLCAvLyBjb21tZW50IGZvciB0YWJsZVxuICAgKiAgICAgY29sbGF0ZTogJ2xhdGluMV9kYW5pc2hfY2knIC8vIGNvbGxhdGlvbiwgTVlTUUwgb25seVxuICAgKiAgIH1cbiAgICogKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgTmFtZSBvZiB0YWJsZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgT2JqZWN0IHJlcHJlc2VudGluZyBhIGxpc3Qgb2YgdGFibGUgYXR0cmlidXRlcyB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBjcmVhdGUgdGFibGUgYW5kIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtNb2RlbH0gIFttb2RlbF0gbW9kZWwgY2xhc3NcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgbGV0IHNxbCA9ICcnO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmZvck93bihvcHRpb25zLnVuaXF1ZUtleXMsIHVuaXF1ZUtleSA9PiB7XG4gICAgICAgIGlmICh1bmlxdWVLZXkuY3VzdG9tSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVuaXF1ZUtleS5jdXN0b21JbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtb2RlbCkge1xuICAgICAgb3B0aW9ucy51bmlxdWVLZXlzID0gb3B0aW9ucy51bmlxdWVLZXlzIHx8IG1vZGVsLnVuaXF1ZUtleXM7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IF8ubWFwVmFsdWVzKFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZSA9PiB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKVxuICAgICk7XG5cbiAgICAvLyBQb3N0Z3JlcyByZXF1aXJlcyBzcGVjaWFsIFNRTCBjb21tYW5kcyBmb3IgRU5VTS9FTlVNW11cbiAgICBhd2FpdCB0aGlzLmVuc3VyZUVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpO1xuXG4gICAgaWYgKFxuICAgICAgIXRhYmxlTmFtZS5zY2hlbWEgJiZcbiAgICAgIChvcHRpb25zLnNjaGVtYSB8fCAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEpXG4gICAgKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZFNjaGVtYSh7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgX3NjaGVtYTogISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgeyB0YWJsZTogdGFibGVOYW1lLCBjb250ZXh0OiAnY3JlYXRlVGFibGUnIH0pO1xuICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhIHRhYmxlIGZyb20gZGF0YWJhc2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSBUYWJsZSBuYW1lIHRvIGRyb3BcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIC8vIGlmIHdlJ3JlIGZvcmNpbmcgd2Ugc2hvdWxkIGJlIGNhc2NhZGluZyB1bmxlc3MgZXhwbGljaXRseSBzdGF0ZWQgb3RoZXJ3aXNlXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMuY2FzY2FkZSA9IG9wdGlvbnMuY2FzY2FkZSB8fCBvcHRpb25zLmZvcmNlIHx8IGZhbHNlO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuXG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIF9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XG4gICAgICAvLyBpZiB0YWJsZU5hbWUgaXMgbm90IGluIHRoZSBBcnJheSBvZiB0YWJsZXMgbmFtZXMgdGhlbiBkb24ndCBkcm9wIGl0XG4gICAgICBpZiAoIXNraXAuaW5jbHVkZXModGFibGVOYW1lLnRhYmxlTmFtZSB8fCB0YWJsZU5hbWUpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZHJvcFRhYmxlKHRhYmxlTmFtZSwgeyAuLi5vcHRpb25zLCBjYXNjYWRlOiB0cnVlIH0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgdGFibGVzIGZyb20gZGF0YWJhc2VcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5za2lwXSBMaXN0IG9mIHRhYmxlIHRvIHNraXBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wQWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBza2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuXG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFRhYmxlcyhvcHRpb25zKTtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleXNGb3JUYWJsZXModGFibGVOYW1lcywgb3B0aW9ucyk7XG5cbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XG4gICAgICBsZXQgbm9ybWFsaXplZFRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgbm9ybWFsaXplZFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXkgb2YgZm9yZWlnbktleXNbbm9ybWFsaXplZFRhYmxlTmFtZV0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiZWZvcmUgICAgQ3VycmVudCBuYW1lIG9mIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZnRlciAgICAgTmV3IG5hbWUgZnJvbSB0YWJsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZW5hbWVUYWJsZShiZWZvcmUsIGFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdGFibGVzIGluIGN1cnJlbnQgZGF0YWJhc2VcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgIFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICBbb3B0aW9ucy5yYXc9dHJ1ZV0gUnVuIHF1ZXJ5IGluIHJhdyBtb2RlXG4gICAqIEBwYXJhbSB7UXVlcnlUeXBlfSBbb3B0aW9ucy50eXBlPVF1ZXJ5VHlwZS5TSE9XVEFCTEVdIHF1ZXJ5IHR5cGVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgc2hvd0FsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICByYXc6IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNIT1dUQUJMRVNcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvd1RhYmxlc1NxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd1RhYmxlc1F1ZXJ5KHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSk7XG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNob3dUYWJsZXNTcWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfLmZsYXR0ZW4odGFibGVOYW1lcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzY3JpYmUgYSB0YWJsZSBzdHJ1Y3R1cmVcbiAgICpcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBhcnJheSBvZiBoYXNoZXMgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgYXR0cmlidXRlcyBpbiB0aGUgdGFibGUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHtcbiAgICogICAgbmFtZToge1xuICAgKiAgICAgIHR5cGU6ICAgICAgICAgJ1ZBUkNIQVIoMjU1KScsIC8vIHRoaXMgd2lsbCBiZSAnQ0hBUkFDVEVSIFZBUllJTkcnIGZvciBwZyFcbiAgICogICAgICBhbGxvd051bGw6ICAgIHRydWUsXG4gICAqICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAqICAgIH0sXG4gICAqICAgIGlzQmV0YU1lbWJlcjoge1xuICAgKiAgICAgIHR5cGU6ICAgICAgICAgJ1RJTllJTlQoMSknLCAvLyB0aGlzIHdpbGwgYmUgJ0JPT0xFQU4nIGZvciBwZyFcbiAgICogICAgICBhbGxvd051bGw6ICAgIGZhbHNlLFxuICAgKiAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICogICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lIHRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59XG4gICAqL1xuICBhc3luYyBkZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSBudWxsO1xuICAgIGxldCBzY2hlbWFEZWxpbWl0ZXIgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYSB8fCBudWxsO1xuICAgICAgc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ29iamVjdCcgJiYgdGFibGVOYW1lICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKTtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLkRFU0NSSUJFIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgICAvKlxuICAgICAgICogSWYgbm8gZGF0YSBpcyByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeSwgdGhlbiB0aGUgdGFibGUgbmFtZSBtYXkgYmUgd3JvbmcuXG4gICAgICAgKiBRdWVyeSBnZW5lcmF0b3JzIHRoYXQgdXNlIGluZm9ybWF0aW9uX3NjaGVtYSBmb3IgcmV0cmlldmluZyB0YWJsZSBpbmZvIHdpbGwganVzdCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0IHNldCxcbiAgICAgICAqIGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIGxpa2UgYnVpbHQtaW5zIGRvIChlLmcuIERFU0NSSUJFIG9uIE15U3FsKS5cbiAgICAgICAqL1xuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUub3JpZ2luYWwgJiYgZS5vcmlnaW5hbC5jb2RlID09PSAnRVJfTk9fU1VDSF9UQUJMRScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBjb2x1bW4gdG8gYSB0YWJsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb2x1bW4oJ3RhYmxlQScsICdjb2x1bW5DJywgU2VxdWVsaXplLlNUUklORywge1xuICAgKiAgICBhZnRlcjogJ2NvbHVtbkInIC8vIGFmdGVyIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBieSBNeVNRTFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZSAgICAgVGFibGUgdG8gYWRkIGNvbHVtbiB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5ICAgICAgIENvbHVtbiBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGUgQXR0cmlidXRlIGRlZmluaXRpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWRkQ29sdW1uKHRhYmxlLCBrZXksIGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghdGFibGUgfHwgIWtleSB8fCAhYXR0cmlidXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZENvbHVtbiB0YWtlcyBhdCBsZWFzdCAzIGFyZ3VtZW50cyAodGFibGUsIGF0dHJpYnV0ZSBuYW1lLCBhdHRyaWJ1dGUgZGVmaW5pdGlvbiknKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBhdHRyaWJ1dGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5hZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBhdHRyaWJ1dGUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb2x1bW4gZnJvbSBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICBUYWJsZSB0byByZW1vdmUgY29sdW1uIGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWUgIENvbHVtbiBuYW1lIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICAgUXVlcnkgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgbm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKSB7XG4gICAgbGV0IGF0dHJpYnV0ZTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhEYXRhVHlwZXMpLmluY2x1ZGVzKGRhdGFUeXBlT3JPcHRpb25zKSkge1xuICAgICAgYXR0cmlidXRlID0geyB0eXBlOiBkYXRhVHlwZU9yT3B0aW9ucywgYWxsb3dOdWxsOiB0cnVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGRhdGFUeXBlT3JPcHRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgYSBjb2x1bW4gZGVmaW5pdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgICAgIFRhYmxlIG5hbWUgdG8gY2hhbmdlIGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWUgICAgICBDb2x1bW4gbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVR5cGVPck9wdGlvbnMgIEF0dHJpYnV0ZSBkZWZpbml0aW9uIGZvciBuZXcgY29sdW1uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgICAgICAgUXVlcnkgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgZGF0YVR5cGVPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoe1xuICAgICAgW2F0dHJpYnV0ZU5hbWVdOiB0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucylcbiAgICB9LCB7XG4gICAgICBjb250ZXh0OiAnY2hhbmdlQ29sdW1uJyxcbiAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgcXVlcnkpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVqZWN0cyBpZiB0aGUgdGFibGUgZG9lc24ndCBoYXZlIHRoZSBzcGVjaWZpZWQgY29sdW1uLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgY29sdW1uIGRlc2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBhc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChkZXNjcmlwdGlvbltjb2x1bW5OYW1lXSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRhYmxlICR7dGFibGVOYW1lfSBkb2Vzbid0IGhhdmUgdGhlIGNvbHVtbiAke2NvbHVtbk5hbWV9YCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuYW1lIGEgY29sdW1uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgIFRhYmxlIG5hbWUgd2hvc2UgY29sdW1uIHRvIHJlbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVCZWZvcmUgICBDdXJyZW50IGNvbHVtbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZUFmdGVyICAgIE5ldyBjb2x1bW4gbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICAgICBRdWVyeSBvcHRpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZW5hbWVDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgdGhpcy5hc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBvcHRpb25zKSlbYXR0ck5hbWVCZWZvcmVdO1xuXG4gICAgY29uc3QgX29wdGlvbnMgPSB7fTtcblxuICAgIF9vcHRpb25zW2F0dHJOYW1lQWZ0ZXJdID0ge1xuICAgICAgYXR0cmlidXRlOiBhdHRyTmFtZUFmdGVyLFxuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgYWxsb3dOdWxsOiBkYXRhLmFsbG93TnVsbCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGF0YS5kZWZhdWx0VmFsdWVcbiAgICB9O1xuXG4gICAgLy8gZml4OiBhIG5vdC1udWxsIGNvbHVtbiBjYW5ub3QgaGF2ZSBudWxsIGFzIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAoZGF0YS5kZWZhdWx0VmFsdWUgPT09IG51bGwgJiYgIWRhdGEuYWxsb3dOdWxsKSB7XG4gICAgICBkZWxldGUgX29wdGlvbnNbYXR0ck5hbWVBZnRlcl0uZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lQ29sdW1uUXVlcnkoXG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBhdHRyTmFtZUJlZm9yZSxcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKF9vcHRpb25zKVxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGluZGV4IHRvIGEgY29sdW1uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gIHRhYmxlTmFtZSBUYWJsZSBuYW1lIHRvIGFkZCBpbmRleCBvbiwgY2FuIGJlIGEgb2JqZWN0IHdpdGggc2NoZW1hXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgW2F0dHJpYnV0ZXNdICAgICBVc2Ugb3B0aW9ucy5maWVsZHMgaW5zdGVhZCwgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGFkZCBpbmRleCBvblxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgICAgICAgaW5kZXhlcyBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgb3B0aW9ucy5maWVsZHMgICBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gYWRkIGluZGV4IG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29uY3VycmVudGx5XSBQYXNzIENPTkNVUlJFTlQgc28gb3RoZXIgb3BlcmF0aW9ucyBydW4gd2hpbGUgdGhlIGluZGV4IGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmlxdWVdIENyZWF0ZSBhIHVuaXF1ZSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtvcHRpb25zLnVzaW5nXSAgVXNlZnVsIGZvciBHSU4gaW5kZXhlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtvcHRpb25zLm9wZXJhdG9yXSBJbmRleCBvcGVyYXRvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtvcHRpb25zLnR5cGVdICAgVHlwZSBvZiBpbmRleCwgYXZhaWxhYmxlIG9wdGlvbnMgYXJlIFVOSVFVRXxGVUxMVEVYVHxTUEFUSUFMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW29wdGlvbnMubmFtZV0gICBOYW1lIG9mIHRoZSBpbmRleC4gRGVmYXVsdCBpcyA8dGFibGU+XzxhdHRyMT5fPGF0dHIyPlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zLndoZXJlXSAgV2hlcmUgY29uZGl0aW9uIG9uIGluZGV4LCBmb3IgcGFydGlhbCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW3Jhd1RhYmxlbmFtZV0gICB0YWJsZSBuYW1lLCB0aGlzIGlzIGp1c3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWl0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZEluZGV4KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgcGFzc2luZyB0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMgb3IgdGFibGVOYW1lLCBvcHRpb25zICh3aXRoIGEgZmllbGRzIHBhcmFtIHdoaWNoIGlzIHRoZSBhdHRyaWJ1dGVzKVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgcmF3VGFibGVuYW1lID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBhdHRyaWJ1dGVzO1xuICAgICAgYXR0cmlidXRlcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cblxuICAgIGlmICghcmF3VGFibGVuYW1lKSB7XG4gICAgICAvLyBNYXAgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICAgIHJhd1RhYmxlbmFtZSA9IHRhYmxlTmFtZTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuZmllbGRzID0gYXR0cmlidXRlcztcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucywgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGluZGV4ZXMgb24gYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lIHRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgc2hvd0luZGV4KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5TSE9XSU5ERVhFUyB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIG9mIHJlcXVlc3RlZCB0YWJsZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gdGFibGVOYW1lcyB0YWJsZSBuYW1lc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBnZXRGb3JlaWduS2V5c0ZvclRhYmxlcyh0YWJsZU5hbWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhYmxlTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZUyB9O1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYmxlTmFtZXMubWFwKHRhYmxlTmFtZSA9PlxuICAgICAgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKSwgb3B0aW9ucykpKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgdGFibGVOYW1lcy5mb3JFYWNoKCh0YWJsZU5hbWUsIGkpID0+IHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt0YWJsZU5hbWVdID0gQXJyYXkuaXNBcnJheShyZXN1bHRzW2ldKVxuICAgICAgICA/IHJlc3VsdHNbaV0ubWFwKHIgPT4gci5jb25zdHJhaW50X25hbWUpXG4gICAgICAgIDogW3Jlc3VsdHNbaV0gJiYgcmVzdWx0c1tpXS5jb25zdHJhaW50X25hbWVdO1xuXG4gICAgICByZXN1bHRbdGFibGVOYW1lXSA9IHJlc3VsdFt0YWJsZU5hbWVdLmZpbHRlcihfLmlkZW50aXR5KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZvcmVpZ24ga2V5IHJlZmVyZW5jZXMgZGV0YWlscyBmb3IgdGhlIHRhYmxlXG4gICAqXG4gICAqIFRob3NlIGRldGFpbHMgY29udGFpbnMgY29uc3RyYWludFNjaGVtYSwgY29uc3RyYWludE5hbWUsIGNvbnN0cmFpbnRDYXRhbG9nXG4gICAqIHRhYmxlQ2F0YWxvZywgdGFibGVTY2hlbWEsIHRhYmxlTmFtZSwgY29sdW1uTmFtZSxcbiAgICogcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZywgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZywgcmVmZXJlbmNlZFRhYmxlU2NoZW1hLCByZWZlcmVuY2VkVGFibGVOYW1lLCByZWZlcmVuY2VkQ29sdW1uTmFtZS5cbiAgICogUmVtaW5kOiBjb25zdHJhaW50IGluZm9ybWF0aW9ucyB3b24ndCByZXR1cm4gaWYgaXQncyBzcWxpdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgdGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICBRdWVyeSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTXG4gICAgfTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBxdWVyeU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBhbHJlYWR5IGV4aXN0aW5nIGluZGV4IGZyb20gYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgICAgICAgICAgICAgICBUYWJsZSBuYW1lIHRvIGRyb3AgaW5kZXggZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzICBJbmRleCBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IGluIHRoZSBpbmRleFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSW5kZXgodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gYSB0YWJsZVxuICAgKlxuICAgKiBBdmFpbGFibGUgY29uc3RyYWludHM6XG4gICAqIC0gVU5JUVVFXG4gICAqIC0gREVGQVVMVCAoTVNTUUwgb25seSlcbiAgICogLSBDSEVDSyAoTXlTUUwgLSBJZ25vcmVkIGJ5IHRoZSBkYXRhYmFzZSBlbmdpbmUgKVxuICAgKiAtIEZPUkVJR04gS0VZXG4gICAqIC0gUFJJTUFSWSBLRVlcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VU5JUVVFPC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdVc2VycycsIHtcbiAgICogICBmaWVsZHM6IFsnZW1haWwnXSxcbiAgICogICB0eXBlOiAndW5pcXVlJyxcbiAgICogICBuYW1lOiAnY3VzdG9tX3VuaXF1ZV9jb25zdHJhaW50X25hbWUnXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5DSEVDSzwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnVXNlcnMnLCB7XG4gICAqICAgZmllbGRzOiBbJ3JvbGVzJ10sXG4gICAqICAgdHlwZTogJ2NoZWNrJyxcbiAgICogICB3aGVyZToge1xuICAgKiAgICAgIHJvbGVzOiBbJ3VzZXInLCAnYWRtaW4nLCAnbW9kZXJhdG9yJywgJ2d1ZXN0J11cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZhdWx0IC0gTVNTUUwgb25seTwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnVXNlcnMnLCB7XG4gICAqICAgIGZpZWxkczogWydyb2xlcyddLFxuICAgKiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAqICAgIGRlZmF1bHRWYWx1ZTogJ2d1ZXN0J1xuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UHJpbWFyeSBLZXk8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1VzZXJzJywge1xuICAgKiAgICBmaWVsZHM6IFsndXNlcm5hbWUnXSxcbiAgICogICAgdHlwZTogJ3ByaW1hcnkga2V5JyxcbiAgICogICAgbmFtZTogJ2N1c3RvbV9wcmltYXJ5X2NvbnN0cmFpbnRfbmFtZSdcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkZvcmVpZ24gS2V5PC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdQb3N0cycsIHtcbiAgICogICBmaWVsZHM6IFsndXNlcm5hbWUnXSxcbiAgICogICB0eXBlOiAnZm9yZWlnbiBrZXknLFxuICAgKiAgIG5hbWU6ICdjdXN0b21fZmtleV9jb25zdHJhaW50X25hbWUnLFxuICAgKiAgIHJlZmVyZW5jZXM6IHsgLy9SZXF1aXJlZCBmaWVsZFxuICAgKiAgICAgdGFibGU6ICd0YXJnZXRfdGFibGVfbmFtZScsXG4gICAqICAgICBmaWVsZDogJ3RhcmdldF9jb2x1bW5fbmFtZSdcbiAgICogICB9LFxuICAgKiAgIG9uRGVsZXRlOiAnY2FzY2FkZScsXG4gICAqICAgb25VcGRhdGU6ICdjYXNjYWRlJ1xuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29tcG9zaXRlIEZvcmVpZ24gS2V5PC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdUYWJsZU5hbWUnLCB7XG4gICAqICAgZmllbGRzOiBbJ3NvdXJjZV9jb2x1bW5fbmFtZScsICdvdGhlcl9zb3VyY2VfY29sdW1uX25hbWUnXSxcbiAgICogICB0eXBlOiAnZm9yZWlnbiBrZXknLFxuICAgKiAgIG5hbWU6ICdjdXN0b21fZmtleV9jb25zdHJhaW50X25hbWUnLFxuICAgKiAgIHJlZmVyZW5jZXM6IHsgLy9SZXF1aXJlZCBmaWVsZFxuICAgKiAgICAgdGFibGU6ICd0YXJnZXRfdGFibGVfbmFtZScsXG4gICAqICAgICBmaWVsZHM6IFsndGFyZ2V0X2NvbHVtbl9uYW1lJywgJ290aGVyX3RhcmdldF9jb2x1bW5fbmFtZSddXG4gICAqICAgfSxcbiAgICogICBvbkRlbGV0ZTogJ2Nhc2NhZGUnLFxuICAgKiAgIG9uVXBkYXRlOiAnY2FzY2FkZSdcbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgICAgICAgICAgICAgVGFibGUgbmFtZSB3aGVyZSB5b3Ugd2FudCB0byBhZGQgYSBjb25zdHJhaW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHRvIGRlZmluZSB0aGUgY29uc3RyYWludCBuYW1lLCB0eXBlIGV0Y1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlICAgICAgICAgICAgICAgIFR5cGUgb2YgY29uc3RyYWludC4gT25lIG9mIHRoZSB2YWx1ZXMgaW4gYXZhaWxhYmxlIGNvbnN0cmFpbnRzKGNhc2UgaW5zZW5zaXRpdmUpXG4gICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRpb25zLmZpZWxkcyAgICAgICAgICAgICAgQXJyYXkgb2YgY29sdW1uIG5hbWVzIHRvIGFwcGx5IHRoZSBjb25zdHJhaW50IG92ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdICAgICAgICAgICAgICBOYW1lIG9mIHRoZSBjb25zdHJhaW50LiBJZiBub3Qgc3BlY2lmaWVkLCBzZXF1ZWxpemUgYXV0b21hdGljYWxseSBjcmVhdGVzIGEgbmFtZWQgY29uc3RyYWludCBiYXNlZCBvbiBjb25zdHJhaW50IHR5cGUsIHRhYmxlICYgY29sdW1uIG5hbWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdICAgICAgVGhlIHZhbHVlIGZvciB0aGUgZGVmYXVsdCBjb25zdHJhaW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53aGVyZV0gICAgICAgICAgICAgV2hlcmUgY2xhdXNlL2V4cHJlc3Npb24gZm9yIHRoZSBDSEVDSyBjb25zdHJhaW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5yZWZlcmVuY2VzXSAgICAgICAgT2JqZWN0IHNwZWNpZnlpbmcgdGFyZ2V0IHRhYmxlLCBjb2x1bW4gbmFtZSB0byBjcmVhdGUgZm9yZWlnbiBrZXkgY29uc3RyYWludFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVmZXJlbmNlcy50YWJsZV0gIFRhcmdldCB0YWJsZSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWZlcmVuY2VzLmZpZWxkXSAgVGFyZ2V0IGNvbHVtbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWZlcmVuY2VzLmZpZWxkc10gVGFyZ2V0IGNvbHVtbiBuYW1lcyBmb3IgYSBjb21wb3NpdGUgcHJpbWFyeSBrZXkuIE11c3QgbWF0Y2ggdGhlIG9yZGVyIG9mIGZpZWxkcyBpbiBvcHRpb25zLmZpZWxkcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmVycmFibGVdICAgICAgICBTZXRzIHRoZSBjb25zdHJhaW50IHRvIGJlIGRlZmVycmVkIG9yIGltbWVkaWF0ZWx5IGNoZWNrZWQuIFNlZSBTZXF1ZWxpemUuRGVmZXJyYWJsZS4gUG9zdGdyZVNRTCBPbmx5XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWRkQ29uc3RyYWludCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkcyBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMuZmllbGRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RyYWludCB0eXBlIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy50eXBlJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBzaG93Q29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbnN0cmFpbnQgZnJvbSBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgVGFibGUgbmFtZSB0byBkcm9wIGNvbnN0cmFpbnQgZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uc3RyYWludE5hbWUgIENvbnN0cmFpbnQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBpbnNlcnQoaW5zdGFuY2UsIHRhYmxlTmFtZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLmhhc1RyaWdnZXI7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLklOU0VSVDtcbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UpIHJlc3VsdHNbMF0uaXNOZXdSZWNvcmQgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwc2VydFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgIHRhYmxlIHRvIHVwc2VydCBvblxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zZXJ0VmFsdWVzIHZhbHVlcyB0byBiZSBpbnNlcnRlZCwgbWFwcGVkIHRvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZVZhbHVlcyB2YWx1ZXMgdG8gYmUgdXBkYXRlZCwgbWFwcGVkIHRvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IHdoZXJlICAgICAgICB3aGVyZSBjb25kaXRpb25zLCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgVVBEQVRFIHBhcnQgd2hlbiBJTlNFUlQgZmFpbHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICBxdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4sP251bWJlcj59IFJlc29sdmVzIGFuIGFycmF5IHdpdGggPGNyZWF0ZWQsIHByaW1hcnlLZXk+XG4gICAqL1xuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoaXRlbSA9PiBpdGVtLmZpZWxkKTtcbiAgICBjb25zdCB1bmlxdWVLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5maWx0ZXIoYyA9PiBjLmZpZWxkcy5sZW5ndGggPj0gMSkubWFwKGMgPT4gYy5maWVsZHMpO1xuICAgIGNvbnN0IGluZGV4S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwuX2luZGV4ZXMpLmZpbHRlcihjID0+IGMudW5pcXVlICYmIGMuZmllbGRzLmxlbmd0aCA+PSAxKS5tYXAoYyA9PiBjLmZpZWxkcyk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBbXTtcblxuICAgIC8vIEZvciBmaWVsZHMgaW4gdXBkYXRlVmFsdWVzLCB0cnkgdG8gZmluZCBhIGNvbnN0cmFpbnQgb3IgdW5pcXVlIGluZGV4XG4gICAgLy8gdGhhdCBpbmNsdWRlcyBnaXZlbiBmaWVsZC4gT25seSBmaXJzdCBtYXRjaGluZyB1cHNlcnQga2V5IGlzIHVzZWQuXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBjb25zdCB1bmlxdWVLZXkgPSB1bmlxdWVLZXlzLmZpbmQoZmllbGRzID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSB1bmlxdWVLZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleEtleSA9IGluZGV4S2V5cy5maW5kKGZpZWxkcyA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgIGlmIChpbmRleEtleSkge1xuICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBpbmRleEtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHVzZSBQSywgaWYgbm8gY29uc3RyYWludCBhdmFpbGFibGUgT1IgdXBkYXRlIGRhdGEgY29udGFpbnMgUEtcbiAgICBpZiAoXG4gICAgICBvcHRpb25zLnVwc2VydEtleXMubGVuZ3RoID09PSAwXG4gICAgICB8fCBfLmludGVyc2VjdGlvbihvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLCBwcmltYXJ5S2V5cykubGVuZ3RoXG4gICAgKSB7XG4gICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBwcmltYXJ5S2V5cztcbiAgICB9XG5cbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBfLnVuaXEob3B0aW9ucy51cHNlcnRLZXlzKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIG1vZGVsLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBtdWx0aXBsZSByZWNvcmRzIGludG8gYSB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBxdWVyeUludGVyZmFjZS5idWxrSW5zZXJ0KCdyb2xlcycsIFt7XG4gICAqICAgIGxhYmVsOiAndXNlcicsXG4gICAqICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICogICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAqICB9LCB7XG4gICAqICAgIGxhYmVsOiAnYWRtaW4nLFxuICAgKiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAqICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgKiAgfV0pO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgVGFibGUgbmFtZSB0byBpbnNlcnQgcmVjb3JkIHRvXG4gICAqIEBwYXJhbSB7QXJyYXl9ICByZWNvcmRzICAgICBMaXN0IG9mIHJlY29yZHMgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICBWYXJpb3VzIG9wdGlvbnMsIHBsZWFzZSBzZWUgTW9kZWwuYnVsa0NyZWF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzICBWYXJpb3VzIGF0dHJpYnV0ZXMgbWFwcGVkIGJ5IGZpZWxkIG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBidWxrSW5zZXJ0KHRhYmxlTmFtZSwgcmVjb3Jkcywgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLklOU0VSVDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IuYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgcmVjb3Jkcywgb3B0aW9ucywgYXR0cmlidXRlcyksXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHRzWzBdO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlKGluc3RhbmNlLCB0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLmhhc1RyaWdnZXI7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyLCBvcHRpb25zLCBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuXG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtdWx0aXBsZSByZWNvcmRzIG9mIGEgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSgncm9sZXMnLCB7XG4gICAqICAgICBsYWJlbDogJ2FkbWluJyxcbiAgICogICB9LCB7XG4gICAqICAgICB1c2VyVHlwZTogMyxcbiAgICogICB9LFxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICBUYWJsZSBuYW1lIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzICAgICAgICBWYWx1ZXMgdG8gYmUgaW5zZXJ0ZWQsIG1hcHBlZCB0byBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpZGVudGlmaWVyICAgIEEgaGFzaCB3aXRoIGNvbmRpdGlvbnMgT1IgYW4gSUQgYXMgaW50ZWdlciBPUiBhIHN0cmluZyB3aXRoIGNvbmRpdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgVmFyaW91cyBvcHRpb25zLCBwbGVhc2Ugc2VlIE1vZGVsLmJ1bGtDcmVhdGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2F0dHJpYnV0ZXNdICBBdHRyaWJ1dGVzIG9uIHJldHVybiBvYmplY3RzIGlmIHN1cHBvcnRlZCBieSBTUUwgZGlhbGVjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGJ1bGtVcGRhdGUodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ29iamVjdCcpIGlkZW50aWZpZXIgPSBVdGlscy5jbG9uZURlZXAoaWRlbnRpZmllcik7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyLCBvcHRpb25zLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB0YWJsZSA9IF8uaXNPYmplY3QodGFibGVOYW1lKSA/IHRhYmxlTmFtZSA6IHsgdGFibGVOYW1lIH07XG4gICAgY29uc3QgbW9kZWwgPSBfLmZpbmQodGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLm1vZGVscywgeyB0YWJsZU5hbWU6IHRhYmxlLnRhYmxlTmFtZSB9KTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBkZWxldGUoaW5zdGFuY2UsIHRhYmxlTmFtZSwgaWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhc2NhZGVzID0gW107XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZWxldGVRdWVyeSh0YWJsZU5hbWUsIGlkZW50aWZpZXIsIHt9LCBpbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICAvLyBDaGVjayBmb3IgYSByZXN0cmljdCBmaWVsZFxuICAgIGlmICghIWluc3RhbmNlLmNvbnN0cnVjdG9yICYmICEhaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgbGV0IGFzc29jaWF0aW9uO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc29jaWF0aW9uID0gaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zW2tleXNbaV1dO1xuICAgICAgICBpZiAoYXNzb2NpYXRpb24ub3B0aW9ucyAmJiBhc3NvY2lhdGlvbi5vcHRpb25zLm9uRGVsZXRlICYmXG4gICAgICAgICAgYXNzb2NpYXRpb24ub3B0aW9ucy5vbkRlbGV0ZS50b0xvd2VyQ2FzZSgpID09PSAnY2FzY2FkZScgJiZcbiAgICAgICAgICBhc3NvY2lhdGlvbi5vcHRpb25zLnVzZUhvb2tzID09PSB0cnVlKSB7XG4gICAgICAgICAgY2FzY2FkZXMucHVzaChhc3NvY2lhdGlvbi5hY2Nlc3NvcnMuZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgY2FzY2FkZSBvZiBjYXNjYWRlcykge1xuICAgICAgbGV0IGluc3RhbmNlcyA9IGF3YWl0IGluc3RhbmNlW2Nhc2NhZGVdKG9wdGlvbnMpO1xuICAgICAgLy8gQ2hlY2sgZm9yIGhhc09uZSByZWxhdGlvbnNoaXAgd2l0aCBub24tZXhpc3RpbmcgYXNzb2NpYXRlIChcImhhcyB6ZXJvXCIpXG4gICAgICBpZiAoIWluc3RhbmNlcykgY29udGludWU7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIGF3YWl0IF9pbnN0YW5jZS5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIG11bHRpcGxlIHJlY29yZHMgZnJvbSBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgdGFibGVOYW1lICAgICAgICAgICAgdGFibGUgbmFtZSBmcm9tIHdoZXJlIHRvIGRlbGV0ZSByZWNvcmRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgd2hlcmUgICAgICAgICAgICAgICAgd2hlcmUgY29uZGl0aW9ucyB0byBmaW5kIHJlY29yZHMgdG8gZGVsZXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdICAgICAgICAgICAgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRydW5jYXRlXSAgIFVzZSB0cnVuY2F0ZSB0YWJsZSBjb21tYW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FzY2FkZT1mYWxzZV0gICAgICAgICBPbmx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBUUlVOQ0FURS4gVHJ1bmNhdGVzICBhbGwgdGFibGVzIHRoYXQgaGF2ZSBmb3JlaWduLWtleSByZWZlcmVuY2VzIHRvIHRoZSBuYW1lZCB0YWJsZSwgb3IgdG8gYW55IHRhYmxlcyBhZGRlZCB0byB0aGUgZ3JvdXAgZHVlIHRvIENBU0NBREUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzdGFydElkZW50aXR5PWZhbHNlXSBPbmx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBUUlVOQ0FURS4gQXV0b21hdGljYWxseSByZXN0YXJ0IHNlcXVlbmNlcyBvd25lZCBieSBjb2x1bW5zIG9mIHRoZSB0cnVuY2F0ZWQgdGFibGUuXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgW21vZGVsXSAgICAgICAgICAgICAgTW9kZWxcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBidWxrRGVsZXRlKHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7IGxpbWl0OiBudWxsIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMudHJ1bmNhdGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci50cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdvYmplY3QnKSB3aGVyZSA9IFV0aWxzLmNsb25lRGVlcCh3aGVyZSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMsIG1vZGVsKSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgc2VsZWN0KG1vZGVsLCB0YWJsZU5hbWUsIG9wdGlvbnNBcmcpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi5vcHRpb25zQXJnLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCwgbW9kZWwgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3Iuc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBtb2RlbCksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGluY3JlbWVudChtb2RlbCwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXJpdGhtZXRpY1F1ZXJ5KCcrJywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgZGVjcmVtZW50KG1vZGVsLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hcml0aG1ldGljUXVlcnkoJy0nLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyByYXdTZWxlY3QodGFibGVOYW1lLCBvcHRpb25zLCBhdHRyaWJ1dGVTZWxlY3RvciwgTW9kZWwpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHBsYWluOiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1RcbiAgICB9KTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBNb2RlbCk7XG5cbiAgICBpZiAoYXR0cmlidXRlU2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3IhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBsYWluKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBkYXRhID8gZGF0YVthdHRyaWJ1dGVTZWxlY3Rvcl0gOiBudWxsO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmRhdGFUeXBlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFUeXBlID0gb3B0aW9ucy5kYXRhVHlwZTtcblxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5ERUNJTUFMIHx8IGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkZMT0FUKSB7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5JTlRFR0VSIHx8IGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkJJR0lOVCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdCwgMTApO1xuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURSkge1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiAhKHJlc3VsdCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlVHJpZ2dlcihcbiAgICB0YWJsZU5hbWUsXG4gICAgdHJpZ2dlck5hbWUsXG4gICAgdGltaW5nVHlwZSxcbiAgICBmaXJlT25BcnJheSxcbiAgICBmdW5jdGlvbk5hbWUsXG4gICAgZnVuY3Rpb25QYXJhbXMsXG4gICAgb3B0aW9uc0FycmF5LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIHRpbWluZ1R5cGUsIGZpcmVPbkFycmF5LCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCBvcHRpb25zQXJyYXkpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFNRTCBmdW5jdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBxdWVyeUludGVyZmFjZS5jcmVhdGVGdW5jdGlvbihcbiAgICogICAnc29tZUZ1bmN0aW9uJyxcbiAgICogICBbXG4gICAqICAgICB7dHlwZTogJ2ludGVnZXInLCBuYW1lOiAncGFyYW0nLCBkaXJlY3Rpb246ICdJTid9XG4gICAqICAgXSxcbiAgICogICAnaW50ZWdlcicsXG4gICAqICAgJ3BscGdzcWwnLFxuICAgKiAgICdSRVRVUk4gcGFyYW0gKyAxOycsXG4gICAqICAgW1xuICAgKiAgICAgJ0lNTVVUQUJMRScsXG4gICAqICAgICAnTEVBS1BST09GJ1xuICAgKiAgIF0sXG4gICAqICAge1xuICAgKiAgICB2YXJpYWJsZXM6XG4gICAqICAgICAgW1xuICAgKiAgICAgICAge3R5cGU6ICdpbnRlZ2VyJywgbmFtZTogJ215VmFyJywgZGVmYXVsdDogMTAwfVxuICAgKiAgICAgIF0sXG4gICAqICAgICAgZm9yY2U6IHRydWVcbiAgICogICB9O1xuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGZ1bmN0aW9uTmFtZSAgTmFtZSBvZiBTUUwgZnVuY3Rpb24gdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgcGFyYW1zICAgICAgICBMaXN0IG9mIHBhcmFtZXRlcnMgZGVjbGFyZWQgZm9yIFNRTCBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHJldHVyblR5cGUgICAgU1FMIHR5cGUgb2YgZnVuY3Rpb24gcmV0dXJuZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBsYW5ndWFnZSAgICAgIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0aGF0IHRoZSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBpblxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGJvZHkgICAgICAgICAgU291cmNlIGNvZGUgb2YgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gICBvcHRpb25zQXJyYXkgIEV4dHJhLW9wdGlvbnMgZm9yIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdICAgICBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5mb3JjZSBJZiBmb3JjZSBpcyB0cnVlLCBhbnkgZXhpc3RpbmcgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJlcGxhY2VkLiBGb3IgcG9zdGdyZXMsIHRoaXMgbWVhbnMgdXNpbmcgYENSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OYCBpbnN0ZWFkIG9mIGBDUkVBVEUgRlVOQ1RJT05gLiBEZWZhdWx0IGlzIGZhbHNlXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gICBvcHRpb25zLnZhcmlhYmxlcyBMaXN0IG9mIGRlY2xhcmVkIHZhcmlhYmxlcy4gRWFjaCB2YXJpYWJsZSBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGZpZWxkcyBgdHlwZWAgYW5kIGBuYW1lYCwgYW5kIG9wdGlvbmFsbHkgaGF2aW5nIGEgYGRlZmF1bHRgIGZpZWxkIGFzIHdlbGwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFuIFNRTCBmdW5jdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBxdWVyeUludGVyZmFjZS5kcm9wRnVuY3Rpb24oXG4gICAqICAgJ3NvbWVGdW5jdGlvbicsXG4gICAqICAgW1xuICAgKiAgICAge3R5cGU6ICd2YXJjaGFyJywgbmFtZTogJ3BhcmFtMScsIGRpcmVjdGlvbjogJ0lOJ30sXG4gICAqICAgICB7dHlwZTogJ2ludGVnZXInLCBuYW1lOiAncGFyYW0yJywgZGlyZWN0aW9uOiAnSU5PVVQnfVxuICAgKiAgIF1cbiAgICogKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZSBOYW1lIG9mIFNRTCBmdW5jdGlvbiB0byBkcm9wXG4gICAqIEBwYXJhbSB7QXJyYXl9ICBwYXJhbXMgICAgICAgTGlzdCBvZiBwYXJhbWV0ZXJzIGRlY2xhcmVkIGZvciBTUUwgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICBxdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhbiBTUUwgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcXVlcnlJbnRlcmZhY2UucmVuYW1lRnVuY3Rpb24oXG4gICAqICAgJ2Zvb0Z1bmN0aW9uJyxcbiAgICogICBbXG4gICAqICAgICB7dHlwZTogJ3ZhcmNoYXInLCBuYW1lOiAncGFyYW0xJywgZGlyZWN0aW9uOiAnSU4nfSxcbiAgICogICAgIHt0eXBlOiAnaW50ZWdlcicsIG5hbWU6ICdwYXJhbTInLCBkaXJlY3Rpb246ICdJTk9VVCd9XG4gICAqICAgXSxcbiAgICogICAnYmFyRnVuY3Rpb24nXG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRGdW5jdGlvbk5hbWUgIEN1cnJlbnQgbmFtZSBvZiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSAgcGFyYW1zICAgICAgICAgICBMaXN0IG9mIHBhcmFtZXRlcnMgZGVjbGFyZWQgZm9yIFNRTCBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3RnVuY3Rpb25OYW1lICBOZXcgbmFtZSBvZiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICAgICBxdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kcyB1c2VmdWwgZm9yIHF1ZXJ5aW5nXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnN1cmVFbnVtcygpIHtcbiAgICAvLyBub29wIGJ5IGRlZmF1bHRcbiAgfVxuXG4gIGFzeW5jIHNldElzb2xhdGlvbkxldmVsKHRyYW5zYWN0aW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGlzb2xhdGlvbiBsZXZlbCBmb3IgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCEnKTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50IHx8ICF2YWx1ZSkge1xuICAgICAgLy8gTm90IHBvc3NpYmxlIHRvIHNldCBhIHNlcGFyYXRlIGlzb2xhdGlvbiBsZXZlbCBmb3Igc2F2ZXBvaW50c1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSwge1xuICAgICAgcGFyZW50OiB0cmFuc2FjdGlvbi5wYXJlbnRcbiAgICB9KTtcblxuICAgIGlmICghc3FsKSByZXR1cm47XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHN0YXJ0IGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9O1xuICAgIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSA9IHRyYW5zYWN0aW9uLnBhcmVudCA/IHRyYW5zYWN0aW9uLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBkZWZlckNvbnN0cmFpbnRzKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9O1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucyk7XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjb21taXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY29tbWl0IGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhJyk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIC8vIFNhdmVwb2ludHMgY2Fubm90IGJlIGNvbW1pdHRlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbixcbiAgICAgIHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UsXG4gICAgICBjb21wbGV0ZXNUcmFuc2FjdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuXG4gICAgdHJhbnNhY3Rpb24uZmluaXNoZWQgPSAnY29tbWl0JztcblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgcm9sbGJhY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcm9sbGJhY2sgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCEnKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24sXG4gICAgICBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlLFxuICAgICAgY29tcGxldGVzVHJhbnNhY3Rpb246IHRydWVcbiAgICB9O1xuICAgIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSA9IHRyYW5zYWN0aW9uLnBhcmVudCA/IHRyYW5zYWN0aW9uLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuXG4gICAgdHJhbnNhY3Rpb24uZmluaXNoZWQgPSAncm9sbGJhY2snO1xuXG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5RdWVyeUludGVyZmFjZSA9IFF1ZXJ5SW50ZXJmYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKCcuLi8uLi9zcWwtc3RyaW5nJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IERvdCA9IHJlcXVpcmUoJ2RvdHRpZScpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zJyk7XG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuXG5jbGFzcyBBYnN0cmFjdFF1ZXJ5IHtcblxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnV1aWQgPSB1dWlkKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmluc3RhbmNlID0gb3B0aW9ucy5pbnN0YW5jZTtcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBwbGFpbjogZmFsc2UsXG4gICAgICByYXc6IGZhbHNlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZ2dpbmc6IGNvbnNvbGUubG9nLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5jaGVja0xvZ2dpbmdPcHRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXdyaXRlIHF1ZXJ5IHdpdGggcGFyYW1ldGVyc1xuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICBxdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycygnc2VsZWN0ICQxIGFzIGZvbycsIFsnZm9vdmFsJ10pO1xuICAgKlxuICAgKiAgIHF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKCdzZWxlY3QgJGZvbyBhcyBmb28nLCB7IGZvbzogJ2Zvb3ZhbCcgfSk7XG4gICAqXG4gICAqIE9wdGlvbnNcbiAgICogICBza2lwVW5lc2NhcGU6IGJvb2wsIHNraXAgdW5lc2NhcGluZyAkJFxuICAgKiAgIHNraXBWYWx1ZVJlcGxhY2U6IGJvb2wsIGRvIG5vdCByZXBsYWNlIChidXQgZG8gdW5lc2NhcGUgJCQpLiBDaGVjayBjb3JyZWN0IHN5bnRheCBhbmQgaWYgYWxsIHZhbHVlcyBhcmUgYXZhaWxhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcWxcbiAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IHZhbHVlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhbGVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVwbGFjZW1lbnRGdW5jXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYywgb3B0aW9ucykge1xuICAgIGlmICghdmFsdWVzKSB7XG4gICAgICByZXR1cm4gW3NxbCwgW11dO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnRGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0gcmVwbGFjZW1lbnRGdW5jIHx8IHt9O1xuICAgICAgcmVwbGFjZW1lbnRGdW5jID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghcmVwbGFjZW1lbnRGdW5jKSB7XG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsdWVSZXBsYWNlKSB7XG4gICAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMpID0+IHtcbiAgICAgICAgICBpZiAodmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QpID0+IHtcbiAgICAgICAgICBpZiAodmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodmFsdWVzW2tleV0sIHRpbWVab25lLCBkaWFsZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2tpcFZhbHVlUmVwbGFjZSkge1xuICAgICAgY29uc3Qgb3JpZ1JlcGxhY2VtZW50RnVuYyA9IHJlcGxhY2VtZW50RnVuYztcbiAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChvcmlnUmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHZhbHVlcyk7XG4gICAgc3FsID0gc3FsLnJlcGxhY2UoL1xcQlxcJChcXCR8XFx3KykvZywgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgIGlmICgnJCcgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5za2lwVW5lc2NhcGUgPyBtYXRjaCA6IGtleTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlcGxWYWw7XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICBpZiAoa2V5Lm1hdGNoKC9eWzEtOV1cXGQqJC8pKSB7XG4gICAgICAgICAga2V5ID0ga2V5IC0gMTtcbiAgICAgICAgICByZXBsVmFsID0gcmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFrZXkubWF0Y2goL15cXGQqJC8pKSB7XG4gICAgICAgIHJlcGxWYWwgPSByZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZWQgYmluZCBwYXJhbWV0ZXIgXCIke21hdGNofVwiIGhhcyBubyB2YWx1ZSBpbiB0aGUgZ2l2ZW4gb2JqZWN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxWYWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzcWwsIFtdXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBwYXNzZWQgc3FsIHF1ZXJ5LlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHF1ZXJ5LnJ1bignU0VMRUNUIDEnKVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJ1biBtZXRob2Qgd2FzblxcJ3Qgb3ZlcndyaXR0ZW4hJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGxvZ2dpbmcgb3B0aW9uIG9mIHRoZSBpbnN0YW5jZSBhbmQgcHJpbnQgZGVwcmVjYXRpb24gd2FybmluZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja0xvZ2dpbmdPcHRpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMub3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiBhbiBpbnNlcnQgcXVlcnksIHdoaWNoIGNvbnRhaW5zIHRoZSBqdXN0IGluc2VydGVkIGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmllbGQgbmFtZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuICdpbnNlcnRJZCc7XG4gIH1cblxuICBnZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBmaWVsZCA/IGAke2ZpZWxkfSBtdXN0IGJlIHVuaXF1ZWAgOiAnTXVzdCBiZSB1bmlxdWUnO1xuXG4gICAgaWYgKGZpZWxkICYmIHRoaXMubW9kZWwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLmZpZWxkcy5pbmNsdWRlcyhmaWVsZC5yZXBsYWNlKC9cIi9nLCAnJykpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLm1zZykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLm1zZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICBpc1Jhd1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5SQVc7XG4gIH1cblxuICBpc1ZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVkVSU0lPTjtcbiAgfVxuXG4gIGlzVXBzZXJ0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgfVxuXG4gIGlzSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5JTlNFUlQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlzIGluc2VydCBxdWVyeSBpZiBzcWwgY29udGFpbnMgaW5zZXJ0IGludG9cbiAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdpbnNlcnQgaW50bycpO1xuXG4gICAgLy8gaXMgaW5zZXJ0IHF1ZXJ5IGlmIG5vIHJlc3VsdHMgYXJlIHBhc3NlZCBvciBpZiB0aGUgcmVzdWx0IGhhcyB0aGUgaW5zZXJ0ZWQgaWRcbiAgICByZXN1bHQgPSByZXN1bHQgJiYgKCFyZXN1bHRzIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCB0aGlzLmdldEluc2VydElkRmllbGQoKSkpO1xuXG4gICAgLy8gaXMgaW5zZXJ0IHF1ZXJ5IGlmIG5vIG1ldGFkYXRhIGFyZSBwYXNzZWQgb3IgaWYgdGhlIG1ldGFkYXRhIGhhcyB0aGUgaW5zZXJ0ZWQgaWRcbiAgICByZXN1bHQgPSByZXN1bHQgJiYgKCFtZXRhRGF0YSB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWV0YURhdGEsIHRoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpKSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgLy8gYWRkIHRoZSBpbnNlcnRlZCByb3cgaWQgdG8gdGhlIGluc3RhbmNlXG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50QXR0cmlidXRlID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGlkID0gbnVsbDtcblxuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG5cbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0gPSBpZDtcbiAgICB9XG4gIH1cblxuICBpc1Nob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV1RBQkxFUztcbiAgfVxuXG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihyZXN1bHRzLm1hcChyZXN1bHRTZXQgPT4gT2JqZWN0LnZhbHVlcyhyZXN1bHRTZXQpKSk7XG4gIH1cblxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dJTkRFWEVTO1xuICB9XG5cbiAgaXNTaG93Q29uc3RyYWludHNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTO1xuICB9XG5cbiAgaXNEZXNjcmliZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5ERVNDUklCRTtcbiAgfVxuXG4gIGlzU2VsZWN0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNFTEVDVDtcbiAgfVxuXG4gIGlzQnVsa1VwZGF0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICB9XG5cbiAgaXNCdWxrRGVsZXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtERUxFVEU7XG4gIH1cblxuICBpc0ZvcmVpZ25LZXlzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkZPUkVJR05LRVlTO1xuICB9XG5cbiAgaXNVcGRhdGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICB9XG5cbiAgaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgLy8gTWFwIHJhdyBmaWVsZHMgdG8gbmFtZXMgaWYgYSBtYXBwaW5nIGlzIHByb3ZpZGVkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWVsZE1hcCkge1xuICAgICAgY29uc3QgZmllbGRNYXAgPSB0aGlzLm9wdGlvbnMuZmllbGRNYXA7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAocmVzdWx0ID0+IF8ucmVkdWNlKGZpZWxkTWFwLCAocmVzdWx0LCBuYW1lLCBmaWVsZCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0W2ZpZWxkXSAhPT0gdW5kZWZpbmVkICYmIG5hbWUgIT09IGZpZWxkKSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gcmVzdWx0W2ZpZWxkXTtcbiAgICAgICAgICBkZWxldGUgcmVzdWx0W2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgcmVzdWx0KSk7XG4gICAgfVxuXG4gICAgLy8gUmF3IHF1ZXJpZXNcbiAgICBpZiAodGhpcy5vcHRpb25zLnJhdykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0cy5tYXAocmVzdWx0ID0+IHtcbiAgICAgICAgbGV0IG8gPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgb1trZXldID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uZXN0KSB7XG4gICAgICAgICAgbyA9IERvdC50cmFuc2Zvcm0obyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0pO1xuICAgIC8vIFF1ZXJpZXMgd2l0aCBpbmNsdWRlXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuaGFzSm9pbiA9PT0gdHJ1ZSkge1xuICAgICAgcmVzdWx0cyA9IEFic3RyYWN0UXVlcnkuX2dyb3VwSm9pbkRhdGEocmVzdWx0cywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgaW5jbHVkZU1hcDogdGhpcy5vcHRpb25zLmluY2x1ZGVNYXAsXG4gICAgICAgIGluY2x1ZGVOYW1lczogdGhpcy5vcHRpb25zLmluY2x1ZGVOYW1lc1xuICAgICAgfSwge1xuICAgICAgICBjaGVja0V4aXN0aW5nOiB0aGlzLm9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwuYnVsa0J1aWxkKHJlc3VsdHMsIHtcbiAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlOiB0aGlzLm9wdGlvbnMuaW5jbHVkZSxcbiAgICAgICAgaW5jbHVkZU5hbWVzOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU5hbWVzLFxuICAgICAgICBpbmNsdWRlTWFwOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1hcCxcbiAgICAgICAgaW5jbHVkZVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy5vcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyB8fCB0aGlzLm9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9KTtcbiAgICAvLyBSZWd1bGFyIHF1ZXJpZXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5idWxrQnVpbGQocmVzdWx0cywge1xuICAgICAgICBpc05ld1JlY29yZDogZmFsc2UsXG4gICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy5vcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyB8fCB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBmaXJzdCByZWFsIG1vZGVsIGluc3RhbmNlIGlmIG9wdGlvbnMucGxhaW4gaXMgc2V0IChlLmcuIE1vZGVsLmZpbmQpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbGFpbikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXN1bHRbMF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpc1Nob3dPckRlc2NyaWJlUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnc2hvdycpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Rlc2NyaWJlJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaXNDYWxsUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnY2FsbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGVidWdDb250ZXh0XG4gICAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSBwYXJhbWV0ZXJzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgdGhlIHF1ZXJ5IHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBfbG9nUXVlcnkoc3FsLCBkZWJ1Z0NvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgYmVuY2htYXJrID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5iZW5jaG1hcmsgfHwgb3B0aW9ucy5iZW5jaG1hcms7XG4gICAgY29uc3QgbG9nUXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5sb2dRdWVyeVBhcmFtZXRlcnMgfHwgb3B0aW9ucy5sb2dRdWVyeVBhcmFtZXRlcnM7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgbG9nUGFyYW1ldGVyID0gJyc7XG5cbiAgICBpZiAobG9nUXVlcnlQYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IHNxbC5lbmRzV2l0aCgnOycpID8gJycgOiAnOyc7XG4gICAgICBsZXQgcGFyYW1TdHI7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSkge1xuICAgICAgICBwYXJhbVN0ciA9IHBhcmFtZXRlcnMubWFwKHA9PkpTT04uc3RyaW5naWZ5KHApKS5qb2luKCcsICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1TdHIgPSBKU09OLnN0cmluZ2lmeShwYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGxvZ1BhcmFtZXRlciA9IGAke2RlbGltaXRlcn0gJHtwYXJhbVN0cn1gO1xuICAgIH1cbiAgICBjb25zdCBmbXQgPSBgKCR7Y29ubmVjdGlvbi51dWlkIHx8ICdkZWZhdWx0J30pOiAke3NxbH0ke2xvZ1BhcmFtZXRlcn1gO1xuICAgIGNvbnN0IG1zZyA9IGBFeGVjdXRpbmcgJHtmbXR9YDtcbiAgICBkZWJ1Z0NvbnRleHQobXNnKTtcbiAgICBpZiAoIWJlbmNobWFyaykge1xuICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBFeGVjdXRpbmcgJHtmbXR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1zZyA9IGBFeGVjdXRlZCAke2ZtdH1gO1xuICAgICAgZGVidWdDb250ZXh0KGFmdGVyTXNnKTtcbiAgICAgIGlmIChiZW5jaG1hcmspIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGFmdGVyTXNnLCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0YWtlcyB0aGUgcmVzdWx0IG9mIHRoZSBxdWVyeSBleGVjdXRpb24gYW5kIGdyb3Vwc1xuICAgKiB0aGUgYXNzb2NpYXRlZCBkYXRhIGJ5IHRoZSBjYWxsZWUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICAgZ3JvdXBKb2luRGF0YShbXG4gICAqICAgICB7XG4gICAqICAgICAgIHNvbWU6ICdkYXRhJyxcbiAgICogICAgICAgaWQ6IDEsXG4gICAqICAgICAgIGFzc29jaWF0aW9uOiB7IGZvbzogJ2JhcicsIGlkOiAxIH1cbiAgICogICAgIH0sIHtcbiAgICogICAgICAgc29tZTogJ2RhdGEnLFxuICAgKiAgICAgICBpZDogMSxcbiAgICogICAgICAgYXNzb2NpYXRpb246IHsgZm9vOiAnYmFyJywgaWQ6IDIgfVxuICAgKiAgICAgfSwge1xuICAgKiAgICAgICBzb21lOiAnZGF0YScsXG4gICAqICAgICAgIGlkOiAxLFxuICAgKiAgICAgICBhc3NvY2lhdGlvbjogeyBmb286ICdiYXInLCBpZDogMyB9XG4gICAqICAgICB9XG4gICAqICAgXSlcbiAgICpcbiAgICogUmVzdWx0OlxuICAgKiAgIFNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAqXG4gICAqICAgW1xuICAgKiAgICAge1xuICAgKiAgICAgICBzb21lOiAnZGF0YScsXG4gICAqICAgICAgIGlkOiAxLFxuICAgKiAgICAgICBhc3NvY2lhdGlvbjogW1xuICAgKiAgICAgICAgIHsgZm9vOiAnYmFyJywgaWQ6IDEgfSxcbiAgICogICAgICAgICB7IGZvbzogJ2JhcicsIGlkOiAyIH0sXG4gICAqICAgICAgICAgeyBmb286ICdiYXInLCBpZDogMyB9XG4gICAqICAgICAgIF1cbiAgICogICAgIH1cbiAgICogICBdXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJvd3NcbiAgICogQHBhcmFtIHtvYmplY3R9IGluY2x1ZGVPcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX2dyb3VwSm9pbkRhdGEocm93cywgaW5jbHVkZU9wdGlvbnMsIG9wdGlvbnMpIHtcblxuICAgIC8qXG4gICAgICogQXNzdW1wdGlvbnNcbiAgICAgKiBJRCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlIGZpcnN0IGZpZWxkXG4gICAgICogQWxsIGZpZWxkcyBmb3IgYSBsZXZlbCBpcyBncm91cGVkIGluIHRoZSBzYW1lIHNldCAoaS5lLiBQYW5lbC5pZCwgVGFzay5pZCwgUGFuZWwudGl0bGUgaXMgbm90IHBvc3NpYmxlKVxuICAgICAqIFBhcmVudCBrZXlzIHdpbGwgYmUgc2VlbiBiZWZvcmUgYW55IGluY2x1ZGUvY2hpbGQga2V5c1xuICAgICAqIFByZXZpb3VzIHNldCB3b24ndCBuZWNlc3NhcmlseSBiZSBwYXJlbnQgc2V0IChvbmUgcGFyZW50IGNvdWxkIGhhdmUgdHdvIGNoaWxkcmVuLCBvbmUgY2hpbGQgd291bGQgdGhlbiBiZSBwcmV2aW91cyBzZXQgZm9yIHRoZSBvdGhlcilcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogQXV0aG9yIChNSCkgY29tbWVudDogVGhpcyBjb2RlIGlzIGFuIHVucmVhZGFibGUgbWVzcywgYnV0IGl0J3MgcGVyZm9ybWFudC5cbiAgICAgKiBncm91cEpvaW5EYXRhIGlzIGEgcGVyZm9ybWFuY2UgY3JpdGljYWwgZnVuY3Rpb24gc28gd2UgcHJpb3JpdGl6ZSBwZXJmIG92ZXIgcmVhZGFiaWxpdHkuXG4gICAgICovXG4gICAgaWYgKCFyb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIEdlbmVyaWMgbG9vcGluZ1xuICAgIGxldCBpO1xuICAgIGxldCBsZW5ndGg7XG4gICAgbGV0ICRpO1xuICAgIGxldCAkbGVuZ3RoO1xuICAgIC8vIFJvdyBzcGVjaWZpYyBsb29waW5nXG4gICAgbGV0IHJvd3NJO1xuICAgIGxldCByb3c7XG4gICAgY29uc3Qgcm93c0xlbmd0aCA9IHJvd3MubGVuZ3RoO1xuICAgIC8vIEtleSBzcGVjaWZpYyBsb29waW5nXG4gICAgbGV0IGtleXM7XG4gICAgbGV0IGtleTtcbiAgICBsZXQga2V5STtcbiAgICBsZXQga2V5TGVuZ3RoO1xuICAgIGxldCBwcmV2S2V5O1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IHRvcFZhbHVlcztcbiAgICBsZXQgdG9wRXhpc3RzO1xuICAgIGNvbnN0IGNoZWNrRXhpc3RpbmcgPSBvcHRpb25zLmNoZWNrRXhpc3Rpbmc7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0byBkZWR1cGxpY2F0ZSB3ZSBjYW4gcHJlLWFsbG9jYXRlIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICBsZXQgaXRlbUhhc2g7XG4gICAgbGV0IHBhcmVudEhhc2g7XG4gICAgbGV0IHRvcEhhc2g7XG4gICAgY29uc3QgcmVzdWx0cyA9IGNoZWNrRXhpc3RpbmcgPyBbXSA6IG5ldyBBcnJheShyb3dzTGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCBpbmNsdWRlTWFwID0ge307XG4gICAgLy8gUmVzdWx0IHZhcmlhYmxlcyBmb3IgdGhlIHJlc3BlY3RpdmUgZnVuY3Rpb25zXG4gICAgbGV0ICRrZXlQcmVmaXg7XG4gICAgbGV0ICRrZXlQcmVmaXhTdHJpbmc7XG4gICAgbGV0ICRwcmV2S2V5UHJlZml4U3RyaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgbGV0ICRwcmV2S2V5UHJlZml4O1xuICAgIGxldCAkbGFzdEtleVByZWZpeDtcbiAgICBsZXQgJGN1cnJlbnQ7XG4gICAgbGV0ICRwYXJlbnQ7XG4gICAgLy8gTWFwIGVhY2gga2V5IHRvIGFuIGluY2x1ZGUgb3B0aW9uXG4gICAgbGV0IHByZXZpb3VzUGllY2U7XG4gICAgY29uc3QgYnVpbGRJbmNsdWRlTWFwID0gcGllY2UgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkY3VycmVudC5pbmNsdWRlTWFwLCBwaWVjZSkpIHtcbiAgICAgICAgaW5jbHVkZU1hcFtrZXldID0gJGN1cnJlbnQgPSAkY3VycmVudC5pbmNsdWRlTWFwW3BpZWNlXTtcbiAgICAgICAgaWYgKHByZXZpb3VzUGllY2UpIHtcbiAgICAgICAgICBwcmV2aW91c1BpZWNlID0gYCR7cHJldmlvdXNQaWVjZX0uJHtwaWVjZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzUGllY2UgPSBwaWVjZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdWRlTWFwW3ByZXZpb3VzUGllY2VdID0gJGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN0cmluZyBwcmVmaXggb2YgYSBrZXkgKCdVc2VyLlJlc3VsdHMnIGZvciAnVXNlci5SZXN1bHRzLmlkJylcbiAgICBjb25zdCBrZXlQcmVmaXhTdHJpbmdNZW1vID0ge307XG4gICAgY29uc3Qga2V5UHJlZml4U3RyaW5nID0gKGtleSwgbWVtbykgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWVtbywga2V5KSkge1xuICAgICAgICBtZW1vW2tleV0gPSBrZXkuc3Vic3RyKDAsIGtleS5sYXN0SW5kZXhPZignLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vW2tleV07XG4gICAgfTtcbiAgICAvLyBSZW1vdmVzIHRoZSBwcmVmaXggZnJvbSBhIGtleSAoJ2lkJyBmb3IgJ1VzZXIuUmVzdWx0cy5pZCcpXG4gICAgY29uc3QgcmVtb3ZlS2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IHJlbW92ZUtleVByZWZpeCA9IGtleSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZW1vdmVLZXlQcmVmaXhNZW1vLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2V5Lmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIHJlbW92ZUtleVByZWZpeE1lbW9ba2V5XSA9IGtleS5zdWJzdHIoaW5kZXggPT09IC0xID8gMCA6IGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlS2V5UHJlZml4TWVtb1trZXldO1xuICAgIH07XG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgYXJyYXkgcHJlZml4IG9mIGEga2V5IChbJ1VzZXInLCAnUmVzdWx0cyddIGZvciAnVXNlci5SZXN1bHRzLmlkJylcbiAgICBjb25zdCBrZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3Qga2V5UHJlZml4ID0ga2V5ID0+IHtcbiAgICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBtZW1vIGFuZCBrZXlQcmVmaXhTdHJpbmcgc28gdGhhdCBkaWZmZXJlbnQga2V5cyB3aXRoIHRoZSBzYW1lIHByZWZpeCB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJyYXkgaW5zdGVhZCBvZiBkaWZmZXJuZXQgYXJyYXlzIHdpdGggZXF1YWwgdmFsdWVzXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrZXlQcmVmaXhNZW1vLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeFN0cmluZyA9IGtleVByZWZpeFN0cmluZyhrZXksIGtleVByZWZpeFN0cmluZ01lbW8pO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrZXlQcmVmaXhNZW1vLCBwcmVmaXhTdHJpbmcpKSB7XG4gICAgICAgICAga2V5UHJlZml4TWVtb1twcmVmaXhTdHJpbmddID0gcHJlZml4U3RyaW5nID8gcHJlZml4U3RyaW5nLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBrZXlQcmVmaXhNZW1vW2tleV0gPSBrZXlQcmVmaXhNZW1vW3ByZWZpeFN0cmluZ107XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5UHJlZml4TWVtb1trZXldO1xuICAgIH07XG4gICAgLy8gQ2FsY3VhdGUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXkgcHJlZml4ICgnUmVzdWx0cycgZm9yICdVc2VyLlJlc3VsdHMuaWQnKVxuICAgIGNvbnN0IGxhc3RLZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3QgbGFzdEtleVByZWZpeCA9IGtleSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXN0S2V5UHJlZml4TWVtbywga2V5KSkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBrZXlQcmVmaXgoa2V5KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcHJlZml4Lmxlbmd0aDtcblxuICAgICAgICBsYXN0S2V5UHJlZml4TWVtb1trZXldID0gIWxlbmd0aCA/ICcnIDogcHJlZml4W2xlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RLZXlQcmVmaXhNZW1vW2tleV07XG4gICAgfTtcbiAgICBjb25zdCBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzID0gbW9kZWwgPT4ge1xuICAgICAgbGV0IHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBfLmNoYWluKG1vZGVsLnVuaXF1ZUtleXMpO1xuICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IHVuaXF1ZUtleUF0dHJpYnV0ZXNcbiAgICAgICAgLnJlc3VsdChgJHt1bmlxdWVLZXlBdHRyaWJ1dGVzLmZpbmRLZXkoKX0uZmllbGRzYClcbiAgICAgICAgLm1hcChmaWVsZCA9PiBfLmZpbmRLZXkobW9kZWwuYXR0cmlidXRlcywgY2hyID0+IGNoci5maWVsZCA9PT0gZmllbGQpKVxuICAgICAgICAudmFsdWUoKTtcblxuICAgICAgcmV0dXJuIHVuaXF1ZUtleUF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBjb25zdCBzdHJpbmdpZnkgPSBvYmogPT4gb2JqIGluc3RhbmNlb2YgQnVmZmVyID8gb2JqLnRvU3RyaW5nKCdoZXgnKSA6IG9iajtcbiAgICBsZXQgcHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgbGV0IHVuaXF1ZUtleUF0dHJpYnV0ZXM7XG4gICAgbGV0IHByZWZpeDtcblxuICAgIGZvciAocm93c0kgPSAwOyByb3dzSSA8IHJvd3NMZW5ndGg7IHJvd3NJKyspIHtcbiAgICAgIHJvdyA9IHJvd3Nbcm93c0ldO1xuXG4gICAgICAvLyBLZXlzIGFyZSB0aGUgc2FtZSBmb3IgYWxsIHJvd3MsIHNvIG9ubHkgbmVlZCB0byBjb21wdXRlIHRoZW0gb24gdGhlIGZpcnN0IHJvd1xuICAgICAgaWYgKHJvd3NJID09PSAwKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhyb3cpO1xuICAgICAgICBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgdG9wRXhpc3RzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0b3AgbGV2ZWwgaGFzaCBrZXkgKHRoaXMgaXMgdXN1YWxseSBqdXN0IHRoZSBwcmltYXJ5IGtleSB2YWx1ZXMpXG4gICAgICAgICRsZW5ndGggPSBpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHRvcEhhc2ggPSAnJztcbiAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0b3BIYXNoID0gc3RyaW5naWZ5KHJvd1tpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlc1swXV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRsZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgdG9wSGFzaCArPSBzdHJpbmdpZnkocm93W2luY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVPcHRpb25zLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU9wdGlvbnMubW9kZWwpO1xuICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICB0b3BIYXNoICs9IHJvd1t1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvcFZhbHVlcyA9IHZhbHVlcyA9IHt9O1xuICAgICAgJHByZXZLZXlQcmVmaXggPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKGtleUkgPSAwOyBrZXlJIDwga2V5TGVuZ3RoOyBrZXlJKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1trZXlJXTtcblxuICAgICAgICAvLyBUaGUgc3RyaW5nIHByZWZpeCBpc24ndCBhY3R1YWx5IG5lZWRlZFxuICAgICAgICAvLyBXZSB1c2UgaXQgc28ga2V5UHJlZml4IGZvciBkaWZmZXJlbnQga2V5cyB3aWxsIHJlc29sdmUgdG8gdGhlIHNhbWUgYXJyYXkgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHByZWZpeFxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheT9cbiAgICAgICAgJGtleVByZWZpeFN0cmluZyA9IGtleVByZWZpeFN0cmluZyhrZXksIGtleVByZWZpeFN0cmluZ01lbW8pO1xuICAgICAgICAka2V5UHJlZml4ID0ga2V5UHJlZml4KGtleSk7XG5cbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IHJvdyB3ZSBjb21wdXRlIHRoZSBpbmNsdWRlTWFwXG4gICAgICAgIGlmIChyb3dzSSA9PT0gMCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY2x1ZGVNYXAsIGtleSkpIHtcbiAgICAgICAgICBpZiAoISRrZXlQcmVmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbmNsdWRlTWFwW2tleV0gPSBpbmNsdWRlTWFwWycnXSA9IGluY2x1ZGVPcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkY3VycmVudCA9IGluY2x1ZGVPcHRpb25zO1xuICAgICAgICAgICAgcHJldmlvdXNQaWVjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICRrZXlQcmVmaXguZm9yRWFjaChidWlsZEluY2x1ZGVNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgb2Yga2V5IHNldFxuICAgICAgICBpZiAoJHByZXZLZXlQcmVmaXggIT09IHVuZGVmaW5lZCAmJiAkcHJldktleVByZWZpeCAhPT0gJGtleVByZWZpeCkge1xuICAgICAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIGhhc2gga2V5IGZvciB0aGlzIHNldCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemVcbiAgICAgICAgICAgIGxlbmd0aCA9ICRwcmV2S2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICRwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcGFyZW50SGFzaCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJHBhcmVudCA/IGAkeyRwYXJlbnR9LiR7JHByZXZLZXlQcmVmaXhbaV19YCA6ICRwcmV2S2V5UHJlZml4W2ldO1xuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzID0gaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICRsZW5ndGggPSBwcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdfWBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldfWBdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSByb3dbYCR7cHJlZml4fS4ke3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldfWBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudEhhc2gpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1IYXNoID0gcGFyZW50SGFzaCArIGl0ZW1IYXNoO1xuICAgICAgICAgICAgICAgICRwYXJlbnQgPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gaXRlbUhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtSGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtSGFzaCA9PT0gdG9wSGFzaCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcEV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgICAgJHBhcmVudCA9IHJlc3VsdE1hcFtwYXJlbnRIYXNoXTtcbiAgICAgICAgICAgICAgJGxhc3RLZXlQcmVmaXggPSBsYXN0S2V5UHJlZml4KHByZXZLZXkpO1xuXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlTWFwW3ByZXZLZXldLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdKSB7XG4gICAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XS5wdXNoKHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHZhbHVlc1xuICAgICAgICAgICAgdmFsdWVzID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoZWNrRXhpc3RpbmcgaXMgZmFsc2UgaXQncyBiZWNhdXNlIHRoZXJlJ3Mgb25seSAxOjEgYXNzb2NpYXRpb25zIGluIHRoaXMgcXVlcnlcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBtYXAgb250byB0aGUgYXBwcm9wcmlhdGUgcGFyZW50XG4gICAgICAgICAgICAvLyBGb3IgMToxIHdlIG1hcCBmb3J3YXJkLCBpbml0aWFsaXppbmcgdGhlIHZhbHVlIG9iamVjdCBvbiB0aGUgcGFyZW50IHRvIGJlIGZpbGxlZCBpbiB0aGUgbmV4dCBpdGVyYXRpb25zIG9mIHRoZSBsb29wXG4gICAgICAgICAgICAkY3VycmVudCA9IHRvcFZhbHVlcztcbiAgICAgICAgICAgIGxlbmd0aCA9ICRrZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWVzID0gJGN1cnJlbnRbJGtleVByZWZpeFtpXV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGN1cnJlbnQgPSAkY3VycmVudFska2V5UHJlZml4W2ldXSB8fCB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCBvZiBpdGVyYXRpb24sIHNldCB2YWx1ZSBhbmQgc2V0IHByZXYgdmFsdWVzIChmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgICAgIHZhbHVlc1tyZW1vdmVLZXlQcmVmaXgoa2V5KV0gPSByb3dba2V5XTtcbiAgICAgICAgcHJldktleSA9IGtleTtcbiAgICAgICAgJHByZXZLZXlQcmVmaXggPSAka2V5UHJlZml4O1xuICAgICAgICAkcHJldktleVByZWZpeFN0cmluZyA9ICRrZXlQcmVmaXhTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgIGxlbmd0aCA9ICRwcmV2S2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgJHBhcmVudCA9IG51bGw7XG4gICAgICAgIHBhcmVudEhhc2ggPSBudWxsO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICRwYXJlbnQgPyBgJHskcGFyZW50fS4keyRwcmV2S2V5UHJlZml4W2ldfWAgOiAkcHJldktleVByZWZpeFtpXTtcbiAgICAgICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzID0gaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgJGxlbmd0aCA9IHByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGl0ZW1IYXNoID0gcHJlZml4O1xuICAgICAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbMF19YF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXX1gXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbCk7XG4gICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gcm93W2Ake3ByZWZpeH0uJHt1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXX1gXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJlbnRIYXNoKSB7XG4gICAgICAgICAgICAgIHBhcmVudEhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtSGFzaCA9IHBhcmVudEhhc2ggKyBpdGVtSGFzaDtcbiAgICAgICAgICAgICRwYXJlbnQgPSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IGl0ZW1IYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtSGFzaCA9IHRvcEhhc2g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbUhhc2ggPT09IHRvcEhhc2gpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcEV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgJHBhcmVudCA9IHJlc3VsdE1hcFtwYXJlbnRIYXNoXTtcbiAgICAgICAgICAkbGFzdEtleVByZWZpeCA9IGxhc3RLZXlQcmVmaXgocHJldktleSk7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZU1hcFtwcmV2S2V5XS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoJHBhcmVudCkge1xuICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghJHBhcmVudFskbGFzdEtleVByZWZpeF0pIHtcbiAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdLnB1c2gocmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wRXhpc3RzKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRvcFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNbcm93c0ldID0gdG9wVmFsdWVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RRdWVyeTtcbm1vZHVsZS5leHBvcnRzLkFic3RyYWN0UXVlcnkgPSBBYnN0cmFjdFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UXVlcnk7XG4iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9ICgpID0+IChbXSk7XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdCBzeW5jIHJlY3Vyc2l2ZVwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0OyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5tYXJpYWRiO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjptYXJpYWRiJyk7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ21hcmlhZGInKTtcblxuLyoqXG4gKiBNYXJpYURCIENvbm5lY3Rpb24gTWFuYWdlclxuICpcbiAqIEdldCBjb25uZWN0aW9ucywgdmFsaWRhdGUgYW5kIGRpc2Nvbm5lY3QgdGhlbS5cbiAqIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgcG9vbGluZyB1c2UgaXQgdG8gaGFuZGxlIE1hcmlhREIgc3BlY2lmaWMgY29ubmVjdGlvbnNcbiAqIFVzZSBodHRwczovL2dpdGh1Yi5jb20vTWFyaWFEQi9tYXJpYWRiLWNvbm5lY3Rvci1ub2RlanMgdG8gY29ubmVjdCB3aXRoIE1hcmlhREIgc2VydmVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKCdtYXJpYWRiJyk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG5cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cblxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB3aXRoIE1hcmlhREIgZGF0YWJhc2UgYmFzZWQgb24gY29uZmlnLCBIYW5kbGUgYW55IGVycm9ycyBpbiBjb25uZWN0aW9uXG4gICAqIFNldCB0aGUgcG9vbCBoYW5kbGVycyBvbiBjb25uZWN0aW9uLmVycm9yXG4gICAqIEFsc28gc2V0IHByb3BlciB0aW1lem9uZSBvbmNlIGNvbm5lY3Rpb24gaXMgY29ubmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICAvLyBOYW1lZCB0aW1lem9uZSBpcyBub3Qgc3VwcG9ydGVkIGluIG1hcmlhZGIsIGNvbnZlcnQgdG8gb2Zmc2V0XG4gICAgbGV0IHR6T2Zmc2V0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZTtcbiAgICB0ek9mZnNldCA9IC9cXC8vLnRlc3QodHpPZmZzZXQpID8gbW9tZW50VHoudHoodHpPZmZzZXQpLmZvcm1hdCgnWicpXG4gICAgICA6IHR6T2Zmc2V0O1xuXG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIHRpbWV6b25lOiB0ek9mZnNldCxcbiAgICAgIHR5cGVDYXN0OiBDb25uZWN0aW9uTWFuYWdlci5fdHlwZWNhc3QuYmluZCh0aGlzKSxcbiAgICAgIGJpZ051bWJlclN0cmluZ3M6IGZhbHNlLFxuICAgICAgc3VwcG9ydEJpZ051bWJlcnM6IHRydWUsXG4gICAgICBmb3VuZFJvd3M6IGZhbHNlLFxuICAgICAgLi4uY29uZmlnLmRpYWxlY3RPcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgIC8vIHNldCB0aW1lem9uZSBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShcbiAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwpKSB7XG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsID0gW2Nvbm5lY3Rpb25Db25maWcuaW5pdFNxbF07XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsLnB1c2goYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwgPSBgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5saWIuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShjb25uZWN0aW9uLnNlcnZlclZlcnNpb24oKSkudmVyc2lvbjtcblxuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gYWNxdWlyZWQnKTtcbiAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICBjYXNlICdFU09DS0VUJzpcbiAgICAgICAgICBjYXNlICdFQ09OTlJFU0VUJzpcbiAgICAgICAgICBjYXNlICdFUElQRSc6XG4gICAgICAgICAgY2FzZSAnUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUJzpcbiAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICBjYXNlICdFQ09OTlJFRlVTRUQnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFUl9BQ0NFU1NfREVOSUVEX0VSUk9SJzpcbiAgICAgICAgY2FzZSAnRVJfQUNDRVNTX0RFTklFRF9OT19QQVNTV09SRF9FUlJPUic6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFTk9URk9VTkQnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRUhPU1RVTlJFQUNIJzpcbiAgICAgICAgY2FzZSAnRU5FVFVOUkVBQ0gnOlxuICAgICAgICBjYXNlICdFQUREUk5PVEFWQUlMJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFSU5WQUwnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgLy8gRG9uJ3QgZGlzY29ubmVjdCBjb25uZWN0aW9ucyB3aXRoIENMT1NFRCBzdGF0ZVxuICAgIGlmICghY29ubmVjdGlvbi5pc1ZhbGlkKCkpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5lbmQoKTtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmlzVmFsaWQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgd2t4ID0gcmVxdWlyZSgnd2t4Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHlwZXMgPT4ge1xuICBCYXNlVHlwZXMuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9ICdodHRwczovL21hcmlhZGIuY29tL2tiL2VuL2xpYnJhcnkvcmVzdWx0c2V0LyNmaWVsZC10eXBlcyc7XG5cbiAgLyoqXG4gICAqIHR5cGVzOiBbYnVmZmVyX3R5cGUsIC4uLl1cbiAgICpcbiAgICogQHNlZSBkb2N1bWVudGF0aW9uIDogaHR0cHM6Ly9tYXJpYWRiLmNvbS9rYi9lbi9saWJyYXJ5L3Jlc3VsdHNldC8jZmllbGQtdHlwZXNcbiAgICogQHNlZSBjb25uZWN0b3IgaW1wbGVtZW50YXRpb24gOiBodHRwczovL2dpdGh1Yi5jb20vTWFyaWFEQi9tYXJpYWRiLWNvbm5lY3Rvci1ub2RlanMvYmxvYi9tYXN0ZXIvbGliL2NvbnN0L2ZpZWxkLXR5cGUuanNcbiAgICovXG5cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubWFyaWFkYiA9IFsnREFURVRJTUUnXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5tYXJpYWRiID0gWydWQVJfU1RSSU5HJ107XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm1hcmlhZGIgPSBbJ1NUUklORyddO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5tYXJpYWRiID0gWydCTE9CJ107XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm1hcmlhZGIgPSBbJ1RJTlknXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm1hcmlhZGIgPSBbJ1NIT1JUJ107XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubWFyaWFkYiA9IFsnSU5UMjQnXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubWFyaWFkYiA9IFsnTE9ORyddO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm1hcmlhZGIgPSBbJ0xPTkdMT05HJ107XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5tYXJpYWRiID0gWydGTE9BVCddO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5tYXJpYWRiID0gWydUSU1FJ107XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5tYXJpYWRiID0gWydEQVRFJ107XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm1hcmlhZGIgPSBbJ1RJTlknXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubWFyaWFkYiA9IFsnVElOWUJMT0InLCAnQkxPQicsICdMT05HQkxPQiddO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5tYXJpYWRiID0gWydORVdERUNJTUFMJ107XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm1hcmlhZGIgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubWFyaWFkYiA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5tYXJpYWRiID0gWydET1VCTEUnXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5tYXJpYWRiID0gWydET1VCTEUnXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm1hcmlhZGIgPSBbJ0dFT01FVFJZJ107XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLm1hcmlhZGIgPSBbJ0pTT04nXTtcblxuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBzdXBlci50b1NxbCgpO1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gJyBVTlNJR05FRCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSAnIFpFUk9GSUxMJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID8gYERBVEVUSU1FKCR7dGhpcy5fbGVuZ3RofSlgIDogJ0RBVEVUSU1FJztcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcy5TU1MnKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb21lbnQudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudC50eih2YWx1ZSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgJHt2YWx1ZX0gJHtvcHRpb25zLnRpbWV6b25lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdDSEFSKDM2KSBCSU5BUlknO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgICBzdXBlcih0eXBlLCBzcmlkKTtcbiAgICAgIGlmIChfLmlzRW1wdHkodGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLmtleTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXIoKTtcbiAgICAgIC8vIEVtcHR5IGJ1ZmZlciwgTXlTUUwgZG9lc24ndCBzdXBwb3J0IFBPSU5UIEVNUFRZXG4gICAgICAvLyBjaGVjaywgaHR0cHM6Ly9kZXYubXlzcWwuY29tL3dvcmtsb2cvdGFzay8/aWQ9MjM4MVxuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBGb3Igc29tZSByZWFzb24sIGRpc2NhcmQgdGhlIGZpcnN0IDQgYnl0ZXNcbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoNCk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKHZhbHVlKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcWxUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBFTlVNKCR7dGhpcy52YWx1ZXMubWFwKHZhbHVlID0+IG9wdGlvbnMuZXNjYXBlKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09ICd3aGVyZScgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgRU5VTSxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFVVSUQsXG4gICAgR0VPTUVUUlksXG4gICAgREVDSU1BTCxcbiAgICBKU09OOiBKU09OVFlQRVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QnKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgeyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuLi9teXNxbC9xdWVyeS1pbnRlcmZhY2UnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5tYXJpYWRiO1xuXG5jbGFzcyBNYXJpYWRiRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE15U1FMUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuXG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKFxuICBfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICAgICdWQUxVRVMgKCknOiB0cnVlLFxuICAgICdMSU1JVCBPTiBVUERBVEUnOiB0cnVlLFxuICAgIGxvY2s6IHRydWUsXG4gICAgZm9yU2hhcmU6ICdMT0NLIElOIFNIQVJFIE1PREUnLFxuICAgIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiBmYWxzZSxcbiAgICBzY2hlbWFzOiB0cnVlLFxuICAgIGluc2VydHM6IHtcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6ICcgSUdOT1JFJyxcbiAgICAgIHVwZGF0ZU9uRHVwbGljYXRlOiAnIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFJ1xuICAgIH0sXG4gICAgaW5kZXg6IHtcbiAgICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgICAgbGVuZ3RoOiB0cnVlLFxuICAgICAgcGFyc2VyOiB0cnVlLFxuICAgICAgdHlwZTogdHJ1ZSxcbiAgICAgIHVzaW5nOiAxXG4gICAgfSxcbiAgICBjb25zdHJhaW50czoge1xuICAgICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgICAgY2hlY2s6IGZhbHNlXG4gICAgfSxcbiAgICBpbmRleFZpYUFsdGVyOiB0cnVlLFxuICAgIGluZGV4SGludHM6IHRydWUsXG4gICAgTlVNRVJJQzogdHJ1ZSxcbiAgICBHRU9NRVRSWTogdHJ1ZSxcbiAgICBKU09OOiB0cnVlLFxuICAgIFJFR0VYUDogdHJ1ZVxuICB9KTtcblxuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gJzEwLjEuNDQnO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuUXVlcnlHZW5lcmF0b3IgPSBRdWVyeUdlbmVyYXRvcjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9ICdtYXJpYWRiJztcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnYCc7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBNYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IE1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaWFkYkRpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE15U1FMUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9teXNxbC9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi8uLi8uLi91dGlscycpO1xuXG5jbGFzcyBNYXJpYURCUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBNeVNRTFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0NSRUFURSBTQ0hFTUEgSUYgTk9UIEVYSVNUUycsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJBQ1RFUiBTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNoYXJzZXQpfWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYERFRkFVTFQgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYERST1AgU0NIRU1BIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSl9O2A7XG4gIH1cblxuICBzaG93U2NoZW1hc1F1ZXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY2hlbWFzVG9Ta2lwID0gW1xuICAgICAgJ1xcJ01ZU1FMXFwnJyxcbiAgICAgICdcXCdJTkZPUk1BVElPTl9TQ0hFTUFcXCcnLFxuICAgICAgJ1xcJ1BFUkZPUk1BTkNFX1NDSEVNQVxcJydcbiAgICBdO1xuICAgIGlmIChvcHRpb25zLnNraXAgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLnNraXApICYmIG9wdGlvbnMuc2tpcC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVtYU5hbWUgb2Ygb3B0aW9ucy5za2lwKSB7XG4gICAgICAgIHNjaGVtYXNUb1NraXAucHVzaCh0aGlzLmVzY2FwZShzY2hlbWFOYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QgU0NIRU1BX05BTUUgYXMgc2NoZW1hX25hbWUnLFxuICAgICAgJ0ZST00gSU5GT1JNQVRJT05fU0NIRU1BLlNDSEVNQVRBJyxcbiAgICAgIGBXSEVSRSBTQ0hFTUFfTkFNRSBOT1QgSU4gKCR7c2NoZW1hc1RvU2tpcC5qb2luKCcsICcpfSlgLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBzaG93VGFibGVzUXVlcnkoZGF0YWJhc2UpIHtcbiAgICBsZXQgcXVlcnkgPSAnU0VMRUNUIFRBQkxFX05BTUUsIFRBQkxFX1NDSEVNQSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9IFxcJ0JBU0UgVEFCTEVcXCcnO1xuICAgIGlmIChkYXRhYmFzZSkge1xuICAgICAgcXVlcnkgKz0gYCBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShkYXRhYmFzZSl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgKz0gJyBBTkQgVEFCTEVfU0NIRU1BIE5PVCBJTiAoXFwnTVlTUUxcXCcsIFxcJ0lORk9STUFUSU9OX1NDSEVNQVxcJywgXFwnUEVSRk9STUFOQ0VfU0NIRU1BXFwnKSc7XG4gICAgfVxuICAgIHJldHVybiBgJHtxdWVyeX07YDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlhREJRdWVyeUdlbmVyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5Jyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcblxuY29uc3QgRVJfRFVQX0VOVFJZID0gMTA2MjtcbmNvbnN0IEVSX0RFQURMT0NLID0gMTIxMztcbmNvbnN0IEVSX1JPV19JU19SRUZFUkVOQ0VEID0gMTQ1MTtcbmNvbnN0IEVSX05PX1JFRkVSRU5DRURfUk9XID0gMTQ1MjtcblxuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdzcWw6bWFyaWFkYicpO1xuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIHsgc2hvd1dhcm5pbmdzOiBmYWxzZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXNfKSA9PiB7XG4gICAgICBpZiAodmFsdWVzX1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmluZFBhcmFtLnB1c2godmFsdWVzX1trZXldKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW0ubGVuZ3RoID4gMCA/IGJpbmRQYXJhbSA6IHVuZGVmaW5lZF07XG4gIH1cblxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2hvd1dhcm5pbmdzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zaG93V2FybmluZ3MgfHwgb3B0aW9ucy5zaG93V2FybmluZ3M7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGRlYnVnKCdwYXJhbWV0ZXJzKCVqKScsIHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHMgPSBhd2FpdCBjb25uZWN0aW9uLnF1ZXJ5KHRoaXMuc3FsLCBwYXJhbWV0ZXJzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgZXJyb3IuZXJybm8gPT09IEVSX0RFQURMT0NLKSB7XG4gICAgICAgIC8vIE1hcmlhREIgYXV0b21hdGljYWxseSByb2xscy1iYWNrIHRyYW5zYWN0aW9ucyBpbiB0aGUgZXZlbnQgb2YgYSBkZWFkbG9jay5cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugc3RpbGwgaW5pdGlhdGUgYSBtYW51YWwgcm9sbGJhY2sgdG8gZW5zdXJlIHRoZSBjb25uZWN0aW9uIGdldHMgcmVsZWFzZWQgLSBzZWUgIzEzMTAyLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9wdGlvbnMudHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycyAtIHNpbmNlIE1hcmlhREIgYXV0b21hdGljYWxseSByb2xsZWQgYmFjaywgd2UncmVcbiAgICAgICAgICAvLyBub3QgdGhhdCB3b3JyaWVkIGFib3V0IHRoaXMgcmVkdW5kYW50IHJvbGxiYWNrIGZhaWxpbmcuXG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkID0gJ3JvbGxiYWNrJztcbiAgICAgIH1cblxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvd1dhcm5pbmdzICYmIHJlc3VsdHMgJiYgcmVzdWx0cy53YXJuaW5nU3RhdHVzID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dXYXJuaW5ncyhyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICpcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogIHF1ZXJ5LmZvcm1hdFJlc3VsdHMoW1xuICAgKiAgICB7XG4gICAqICAgICAgaWQ6IDEsICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBhdHRyMjogJ3NuYWZ1JywgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIFRhc2tzLmlkOiAxLCAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgICAgVGFza3MudGl0bGU6ICd0YXNrJyAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgfVxuICAgKiAgXSlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIFRoZSByZXN1bHQgb2YgdGhlIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuXG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhLmFmZmVjdGVkUm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3MgPT09IDFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuXG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gaGFuZGxlIGJ1bGtDcmVhdGUgQUkgcHJpbWFyeSBrZXlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubW9kZWxcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIE9OTFkgVFJVRSBJRiBAYXV0b19pbmNyZW1lbnRfaW5jcmVtZW50IGlzIHNldCB0byAxICEhXG4gICAgICAgICAgLy8gRG9lc24ndCB3b3JrIHdpdGggR0FMRVJBID0+IGVhY2ggbm9kZSB3aWxsIHJlc2VydmUgaW5jcmVtZW50ICh4IGZvciBmaXJzdCBzZXJ2ZXIsIHgrMSBmb3IgbmV4dCBub2RlLi4uKVxuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoZGF0YS5hZmZlY3RlZFJvd3MpO1xuICAgICAgICAgIGNvbnN0IHBrRmllbGQgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuYWZmZWN0ZWRSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHsgW3BrRmllbGRdOiBzdGFydElkICsgaSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXSwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgdGhpcy5oYW5kbGVKc29uU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICBjb25zdCBtZXRhID0gZGF0YS5tZXRhO1xuICAgICAgZGVsZXRlIGRhdGEubWV0YTtcbiAgICAgIHJldHVybiBbZGF0YSwgbWV0YV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSB8fCB0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICByZXN1bHRbX3Jlc3VsdC5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZW51bScpID8gX3Jlc3VsdC5UeXBlLnJlcGxhY2UoL15lbnVtL2ksXG4gICAgICAgICAgICAnRU5VTScpIDogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk51bGwgPT09ICdZRVMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5ID09PSAnUFJJJyxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwgJ0V4dHJhJylcbiAgICAgICAgICAgICYmIF9yZXN1bHQuRXh0cmEudG9Mb3dlckNhc2UoKSA9PT0gJ2F1dG9faW5jcmVtZW50JyxcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnQgPyBfcmVzdWx0LkNvbW1lbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBoYW5kbGVKc29uU2VsZWN0UXVlcnkocm93cykge1xuICAgIGlmICghdGhpcy5tb2RlbCB8fCAhdGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBfZmllbGQgb2YgT2JqZWN0LmtleXModGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXApKSB7XG4gICAgICBjb25zdCBtb2RlbEZpZWxkID0gdGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXBbX2ZpZWxkXTtcbiAgICAgIGlmIChtb2RlbEZpZWxkLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICAvLyBWYWx1ZSBpcyByZXR1cm5lZCBhcyBTdHJpbmcsIG5vdCBKU09OXG4gICAgICAgIHJvd3MgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0gPSByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdID8gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0pIDogbnVsbDtcbiAgICAgICAgICBpZiAoRGF0YVR5cGVzLkpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhVHlwZXMuSlNPTi5wYXJzZShtb2RlbEZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLFxuICAgICAgICAgICAgICByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbG9nV2FybmluZ3MocmVzdWx0cykge1xuICAgIGNvbnN0IHdhcm5pbmdSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW4oJ1NIT1cgV0FSTklOR1MnKTtcbiAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBNYXJpYURCIFdhcm5pbmdzICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8ICdkZWZhdWx0J30pOiBgO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBfd2FybmluZ1JvdyBvZiB3YXJuaW5nUmVzdWx0cykge1xuICAgICAgaWYgKF93YXJuaW5nUm93ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIF93YXJuaW5nUm93W1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF93YXJuaW5nUmVzdWx0IG9mIF93YXJuaW5nUm93KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3dhcm5pbmdSZXN1bHQsICdNZXNzYWdlJykpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKF93YXJuaW5nUmVzdWx0Lk1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgX29iamVjdEtleSBvZiBfd2FybmluZ1Jlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goW19vYmplY3RLZXksIF93YXJuaW5nUmVzdWx0W19vYmplY3RLZXldXS5qb2luKCc6ICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlcXVlbGl6ZS5sb2cod2FybmluZ01lc3NhZ2UgKyBtZXNzYWdlcy5qb2luKCc7ICcpLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBzd2l0Y2ggKGVyci5lcnJubykge1xuICAgICAgY2FzZSBFUl9EVVBfRU5UUlk6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaChcbiAgICAgICAgICAvRHVwbGljYXRlIGVudHJ5ICcoW1xcc1xcU10qKScgZm9yIGtleSAnPygoLnxcXHMpKj8pJz9cXHMuKiQvKTtcblxuICAgICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICAgIGxldCBtZXNzYWdlID0gJ1ZhbGlkYXRpb24gZXJyb3InO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCctJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpZWxkS2V5ID0gbWF0Y2ggPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmllbGRWYWwgPSBtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1tmaWVsZEtleV07XG5cbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGlmICh1bmlxdWVLZXkubXNnKSBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tmaWVsZEtleV0gPSBmaWVsZFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgICB0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLFxuICAgICAgICAgICAgJ3VuaXF1ZSB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkRCLFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgICAnbm90X3VuaXF1ZSdcbiAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEVSX1JPV19JU19SRUZFUkVOQ0VEOlxuICAgICAgY2FzZSBFUl9OT19SRUZFUkVOQ0VEX1JPVzoge1xuICAgICAgICAvLyBlLmcuIENPTlNUUkFJTlQgYGV4YW1wbGVfY29uc3RyYWludF9uYW1lYCBGT1JFSUdOIEtFWSAoYGV4YW1wbGVfaWRgKSBSRUZFUkVOQ0VTIGBleGFtcGxlc2AgKGBpZGApXG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goXG4gICAgICAgICAgL0NPTlNUUkFJTlQgKFtgXCJdKSguKilcXDEgRk9SRUlHTiBLRVkgXFwoXFwxKC4qKVxcMVxcKSBSRUZFUkVOQ0VTIFxcMSguKilcXDEgXFwoXFwxKC4qKVxcMVxcKS9cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICdgJztcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWF0Y2ggPyBtYXRjaFszXS5zcGxpdChuZXcgUmVnRXhwKGAke3F1b3RlQ2hhcn0sICoke3F1b3RlQ2hhcn1gKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgcmVsdHlwZTogZXJyLmVycm5vID09PSBFUl9ST1dfSVNfUkVGRVJFTkNFRCA/ICdwYXJlbnQnIDogJ2NoaWxkJyxcbiAgICAgICAgICB0YWJsZTogbWF0Y2ggPyBtYXRjaFs0XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoICYmIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZHNbMF1dIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBpbmRleDogbWF0Y2ggPyBtYXRjaFsyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKHJlc3VsdFNldCA9PiAoe1xuICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgIH0pKTtcbiAgfVxuXG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuXG4gICAgbGV0IGN1cnJJdGVtO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgZGF0YS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFjdXJySXRlbSB8fCBjdXJySXRlbS5uYW1lICE9PSBpdGVtLktleV9uYW1lKSB7XG4gICAgICAgIGN1cnJJdGVtID0ge1xuICAgICAgICAgIHByaW1hcnk6IGl0ZW0uS2V5X25hbWUgPT09ICdQUklNQVJZJyxcbiAgICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICAgIG5hbWU6IGl0ZW0uS2V5X25hbWUsXG4gICAgICAgICAgdGFibGVOYW1lOiBpdGVtLlRhYmxlLFxuICAgICAgICAgIHVuaXF1ZTogaXRlbS5Ob25fdW5pcXVlICE9PSAxLFxuICAgICAgICAgIHR5cGU6IGl0ZW0uSW5kZXhfdHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQucHVzaChjdXJySXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJJdGVtLmZpZWxkc1tpdGVtLlNlcV9pbl9pbmRleCAtIDFdID0ge1xuICAgICAgICBhdHRyaWJ1dGU6IGl0ZW0uQ29sdW1uX25hbWUsXG4gICAgICAgIGxlbmd0aDogaXRlbS5TdWJfcGFydCB8fCB1bmRlZmluZWQsXG4gICAgICAgIG9yZGVyOiBpdGVtLkNvbGxhdGlvbiA9PT0gJ0EnID8gJ0FTQycgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycy9iYXNlLWVycm9yJyk7XG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGlzIGNsb3NlZCB3aGlsZSBhbiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqL1xuY2xhc3MgQXN5bmNRdWV1ZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVBc3luY1F1ZXVlRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydHMuQXN5bmNRdWV1ZUVycm9yID0gQXN5bmNRdWV1ZUVycm9yO1xuXG5jbGFzcyBBc3luY1F1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZWplY3RDdXJyZW50ID0gKCkgPT4ge307XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMucmVqZWN0Q3VycmVudChuZXcgQ29ubmVjdGlvbkVycm9yKG5ldyBBc3luY1F1ZXVlRXJyb3IoJ3RoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIHRoaXMgcXVlcnkgY291bGQgZmluaXNoIGV4ZWN1dGluZycpKSk7XG4gIH1cbiAgZW5xdWV1ZShhc3luY0Z1bmN0aW9uKSB7XG4gICAgLy8gVGhpcyBvdXRlciBwcm9taXNlIG1pZ2h0IHNlZW1zIHN1cGVyZmxvdXMgc2luY2UgZG93biBiZWxvdyB3ZSByZXR1cm4gYXN5bmNGdW5jdGlvbigpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5cbiAgICAvLyBIb3dldmVyLCB0aGlzIGVuc3VyZXMgdGhhdCB0aGlzLnByZXZpb3VzIHdpbGwgbmV2ZXIgYmUgYSByZWplY3RlZCBwcm9taXNlIHNvIHRoZSBxdWV1ZSB3aWxsXG4gICAgLy8gYWx3YXlzIGtlZXAgZ29pbmcsIHdoaWxlIHN0aWxsIGNvbW11bmljYXRpbmcgcmVqZWN0aW9uIGZyb20gYXN5bmNGdW5jdGlvbiB0byB0aGUgdXNlci5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMucHJldmlvdXMudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVqZWN0Q3VycmVudCA9IHJlamVjdDtcbiAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihuZXcgQXN5bmNRdWV1ZUVycm9yKCd0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGlzIHF1ZXJ5IGNvdWxkIGJlIGV4ZWN1dGVkJykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzeW5jRnVuY3Rpb24oKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQXN5bmNRdWV1ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgQXN5bmNRdWV1ZSA9IHJlcXVpcmUoJy4vYXN5bmMtcXVldWUnKS5kZWZhdWx0O1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubXNzcWw7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ21zc3FsJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246bXNzcWwnKTtcbmNvbnN0IGRlYnVnVGVkaW91cyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246bXNzcWw6dGVkaW91cycpO1xuXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMTQzMztcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoJ3RlZGlvdXMnKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cblxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuXG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgIHNlcnZlcjogY29uZmlnLmhvc3QsXG4gICAgICBhdXRoZW50aWNhdGlvbjoge1xuICAgICAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICB1c2VyTmFtZTogY29uZmlnLnVzZXJuYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkIHx8IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwb3J0OiBwYXJzZUludChjb25maWcucG9ydCwgMTApLFxuICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICB0cnVzdFNlcnZlckNlcnRpZmljYXRlOiB0cnVlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgIC8vIG9ubHkgc2V0IHBvcnQgaWYgbm8gaW5zdGFuY2UgbmFtZSB3YXMgcHJvdmlkZWRcbiAgICAgIGlmIChcbiAgICAgICAgY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMgJiZcbiAgICAgICAgY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMuaW5zdGFuY2VOYW1lXG4gICAgICApIHtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25Db25maWcub3B0aW9ucy5wb3J0O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zLmF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbkNvbmZpZy5hdXRoZW50aWNhdGlvbiwgY29uZmlnLmRpYWxlY3RPcHRpb25zLmF1dGhlbnRpY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uQ29uZmlnLm9wdGlvbnMsIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyB0aGlzLmxpYi5Db25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0ZSA9PT0gY29ubmVjdGlvbi5TVEFURS5JTklUSUFMSVpFRCkge1xuICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24ucXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgICAgICBjb25uZWN0aW9uLmxpYiA9IHRoaXMubGliO1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG5cbiAgICAgICAgICBkZWJ1ZygnY29ubmVjdGlvbiBhY3F1aXJlZCcpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZW5kSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIHdhcyBjbG9zZWQgYnkgcmVtb3RlIHNlcnZlcicpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBlcnJvciA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2VuZCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogUGVybWFuZW50bHkgYXR0YWNoIHRoaXMgZXZlbnQgYmVmb3JlIGNvbm5lY3Rpb24gaXMgZXZlbiBhY3F1aXJlZFxuICAgICAgICAgKiB0ZWRpb3VzIHNvbWV0aW1lIGVtaXRzIGVycm9yIGV2ZW4gYWZ0ZXIgY29ubmVjdCh3aXRoIGVycm9yKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgd2UgZG9udCBhdHRhY2ggdGhpcyBldmVuIHRoYXQgdW5leHBlY3RlZCBlcnJvciBldmVudCB3aWxsIGNyYXNoIG5vZGUgcHJvY2Vzc1xuICAgICAgICAgKlxuICAgICAgICAgKiBFLmcuIGNvbm5lY3RUaW1lb3V0IGlzIHNldCBoaWdoZXIgdGhhbiByZXF1ZXN0VGltZW91dFxuICAgICAgICAgKi9cbiAgICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFU09DS0VUJzpcbiAgICAgICAgICAgIGNhc2UgJ0VDT05OUkVTRVQnOlxuICAgICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5vbignZGVidWcnLCBkZWJ1Z1RlZGlvdXMubG9nLmJpbmQoZGVidWdUZWRpb3VzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWVycm9yLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSAnRVNPQ0tFVCc6XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3QgRUhPU1RVTlJFQUNIJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3QgRU5FVFVOUkVBQ0gnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY29ubmVjdCBFQUREUk5PVEFWQUlMJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2dldGFkZHJpbmZvIEVOT1RGT1VORCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3QgRUNPTk5SRUZVU0VEJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgY2FzZSAnRVJfQUNDRVNTX0RFTklFRF9FUlJPUic6XG4gICAgICAgIGNhc2UgJ0VMT0dJTic6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnJvcik7XG4gICAgICAgIGNhc2UgJ0VJTlZBTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgLy8gRG9uJ3QgZGlzY29ubmVjdCBhIGNvbm5lY3Rpb24gdGhhdCBpcyBhbHJlYWR5IGRpc2Nvbm5lY3RlZFxuICAgIGlmIChjb25uZWN0aW9uLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ucXVldWUuY2xvc2UoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbm5lY3Rpb24ub24oJ2VuZCcsIHJlc29sdmUpO1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5sb2dnZWRJbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVR5cGVzID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodW5kZWZpbmVkLCAnaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4Nzc1MiUyOHY9c3FsLjExMCUyOS5hc3B4Jyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdW5zdXBwb3J0ZWQgTVNTUUwgb3B0aW9ucywgaS5lLiwgTEVOR1RILCBVTlNJR05FRCBhbmQgWkVST0ZJTEwsIGZvciB0aGUgaW50ZWdlciBkYXRhIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVR5cGUgVGhlIGJhc2UgaW50ZWdlciBkYXRhIHR5cGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl9sZW5ndGggfHwgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggfHwgZGF0YVR5cGUuX3Vuc2lnbmVkIHx8IGRhdGFUeXBlLl96ZXJvZmlsbCkge1xuICAgICAgd2FybihgTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIG9wdGlvbnMuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB0eXBlczogW2hleCwgLi4uXVxuICAgKlxuICAgKiBAc2VlIGhleCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS90ZWRpb3VzanMvdGVkaW91cy9ibG9iL21hc3Rlci9zcmMvZGF0YS10eXBlLnRzXG4gICAqL1xuXG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm1zc3FsID0gWzQzXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5tc3NxbCA9IFsyMzEsIDE3M107XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm1zc3FsID0gWzE3NV07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxODc3NDUodj1zcWwuMTEwKS5hc3B4XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm1zc3FsID0gWzMwXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm1zc3FsID0gWzM0XTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5tc3NxbCA9IFszOF07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm1zc3FsID0gWzQxXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm1zc3FsID0gWzQwXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubXNzcWwgPSBbMTA0XTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubXNzcWwgPSBbMTY1XTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubXNzcWwgPSBbMTA2XTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5tc3NxbCA9IFsxMDldO1xuICAvLyBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubXNzcWwgPSBbMjQwXTsgLy8gbm90IHlldCBzdXBwb3J0ZWRcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm1zc3FsID0gZmFsc2U7XG5cbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSAndGlueScpIHsgLy8gdGlueSA9IDJeOFxuICAgICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiB3aXRoIHRoZSBgbGVuZ3RoYCA9IGB0aW55YCBvcHRpb24uIGBWQVJCSU5BUlkoMjU2KWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgICAgcmV0dXJuICdWQVJCSU5BUlkoMjU2KSc7XG4gICAgICAgIH1cbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIHdpdGggdGhlIGBsZW5ndGhgIG9wdGlvbi4gYFZBUkJJTkFSWShNQVgpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnVkFSQklOQVJZKE1BWCknO1xuICAgIH1cbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgcmV0dXJuIGAweCR7aGV4fWA7XG4gICAgfVxuICB9XG5cblxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICghdGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgTlZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gQkxPQi5wcm90b3R5cGUuX3N0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fYmluYXJ5ID8gQnVmZmVyLmZyb20odmFsdWUpIDogdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIFNUUklORy5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIC8vIFRFWFQgaXMgZGVwcmVjYXRlZCBpbiBtc3NxbCBhbmQgaXQgd291bGQgbm9ybWFsbHkgYmUgc2F2ZWQgYXMgYSBub24tdW5pY29kZSBzdHJpbmcuXG4gICAgICAvLyBVc2luZyB1bmljb2RlIGlzIGp1c3QgZnV0dXJlIHByb29mXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gJ3RpbnknKSB7IC8vIHRpbnkgPSAyXjhcbiAgICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCB0aGUgYGxlbmd0aGAgPSBgdGlueWAgb3B0aW9uLiBgTlZBUkNIQVIoMjU2KWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgICAgcmV0dXJuICdOVkFSQ0hBUigyNTYpJztcbiAgICAgICAgfVxuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCB0aGUgYGxlbmd0aGAgb3B0aW9uLiBgTlZBUkNIQVIoTUFYKWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ05WQVJDSEFSKE1BWCknO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0JJVCc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnQ0hBUigzNiknO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIE5PVyBleHRlbmRzIEJhc2VUeXBlcy5OT1cge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdHRVREQVRFKCknO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0RBVEVUSU1FT0ZGU0VUJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICAvLyBNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IGFueSBvcHRpb25zIGZvciByZWFsXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBSRUFMIHdpdGggb3B0aW9ucy4gUGxhaW4gYFJFQUxgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgLy8gTVNTUUwgZG9lcyBvbmx5IHN1cHBvcnQgbGVuZ3RocyBhcyBvcHRpb24uXG4gICAgICAvLyBWYWx1ZXMgYmV0d2VlbiAxLTI0IHJlc3VsdCBpbiA3IGRpZ2l0cyBwcmVjaXNpb24gKDQgYnl0ZXMgc3RvcmFnZSBzaXplKVxuICAgICAgLy8gVmFsdWVzIGJldHdlZW4gMjUtNTMgcmVzdWx0IGluIDE1IGRpZ2l0cyBwcmVjaXNpb24gKDggYnl0ZXMgc3RvcmFnZSBzaXplKVxuICAgICAgLy8gSWYgZGVjaW1hbHMgYXJlIHByb3ZpZGVkIHJlbW92ZSB0aGVzZSBhbmQgcHJpbnQgYSB3YXJuaW5nXG4gICAgICBpZiAodGhpcy5fZGVjaW1hbHMpIHtcbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB3aXRoIGRlY2ltYWxzLiBQbGFpbiBgRkxPQVRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB1bnNpZ25lZC4gYFVOU0lHTkVEYCB3YXMgcmVtb3ZlZC4nKTtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB6ZXJvZmlsbC4gYFpFUk9GSUxMYCB3YXMgcmVtb3ZlZC4nKTtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ1ZBUkNIQVIoMjU1KSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBCTE9CLFxuICAgIEJPT0xFQU4sXG4gICAgRU5VTSxcbiAgICBTVFJJTkcsXG4gICAgVVVJRCxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIE5PVyxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIFJFQUwsXG4gICAgRkxPQVQsXG4gICAgVEVYVFxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QnKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm1zc3FsO1xuY29uc3QgeyBNU1NxbFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuL3F1ZXJ5LWludGVyZmFjZScpO1xuXG5jbGFzcyBNc3NxbERpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNU1NxbFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblxuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgJ0RFRkFVTFQnOiB0cnVlLFxuICAnREVGQVVMVCBWQUxVRVMnOiB0cnVlLFxuICAnTElNSVQgT04gVVBEQVRFJzogdHJ1ZSxcbiAgJ09SREVSIE5VTExTJzogZmFsc2UsXG4gIGxvY2s6IGZhbHNlLFxuICB0cmFuc2FjdGlvbnM6IHRydWUsXG4gIG1pZ3JhdGlvbnM6IGZhbHNlLFxuICByZXR1cm5WYWx1ZXM6IHtcbiAgICBvdXRwdXQ6IHRydWVcbiAgfSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgYXV0b0luY3JlbWVudDoge1xuICAgIGlkZW50aXR5SW5zZXJ0OiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgdXBkYXRlOiBmYWxzZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IGZhbHNlLFxuICAgIHdoZXJlOiB0cnVlXG4gIH0sXG4gIE5VTUVSSUM6IHRydWUsXG4gIHRtcFRhYmxlVHJpZ2dlcjogdHJ1ZVxufSk7XG5cbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSAnMTIuMC4yMDAwJzsgLy8gU1FMIFNlcnZlciAyMDE0IEV4cHJlc3Ncbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9ICdtc3NxbCc7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gJ1snO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSAnXSc7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblxubW9kdWxlLmV4cG9ydHMgPSBNc3NxbERpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IFRhYmxlSGludHMgPSByZXF1aXJlKCcuLi8uLi90YWJsZS1oaW50cycpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvcnMnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHRocm93TWV0aG9kVW5kZWZpbmVkID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtZXRob2QgXCIke21ldGhvZE5hbWV9XCIgaXMgbm90IGRlZmluZWQhIFBsZWFzZSBhZGQgaXQgdG8geW91ciBzcWwgZGlhbGVjdC5gKTtcbn07XG5cbmNsYXNzIE1TU1FMUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyBjb2xsYXRlOiBudWxsLCAuLi5vcHRpb25zIH07XG5cbiAgICBjb25zdCBjb2xsYXRpb24gPSBvcHRpb25zLmNvbGxhdGUgPyBgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCA6ICcnO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICdJRiBOT1QgRVhJU1RTIChTRUxFQ1QgKiBGUk9NIHN5cy5kYXRhYmFzZXMgV0hFUkUgbmFtZSA9Jywgd3JhcFNpbmdsZVF1b3RlKGRhdGFiYXNlTmFtZSksICcpJyxcbiAgICAgICdCRUdJTicsXG4gICAgICAnQ1JFQVRFIERBVEFCQVNFJywgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIGAke2NvbGxhdGlvbn07YCxcbiAgICAgICdFTkQ7J1xuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdJRiBFWElTVFMgKFNFTEVDVCAqIEZST00gc3lzLmRhdGFiYXNlcyBXSEVSRSBuYW1lID0nLCB3cmFwU2luZ2xlUXVvdGUoZGF0YWJhc2VOYW1lKSwgJyknLFxuICAgICAgJ0JFR0lOJyxcbiAgICAgICdEUk9QIERBVEFCQVNFJywgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSwgJzsnLFxuICAgICAgJ0VORDsnXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdJRiBOT1QgRVhJU1RTIChTRUxFQ1Qgc2NoZW1hX25hbWUnLFxuICAgICAgJ0ZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhJyxcbiAgICAgICdXSEVSRSBzY2hlbWFfbmFtZSA9Jywgd3JhcFNpbmdsZVF1b3RlKHNjaGVtYSksICcpJyxcbiAgICAgICdCRUdJTicsXG4gICAgICBcIkVYRUMgc3BfZXhlY3V0ZXNxbCBOJ0NSRUFURSBTQ0hFTUFcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBcIjsnXCIsXG4gICAgICAnRU5EOydcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgLy8gTWltaWNzIFBvc3RncmVzIENBU0NBREUsIHdpbGwgZHJvcCBvYmplY3RzIGJlbG9uZ2luZyB0byB0aGUgc2NoZW1hXG4gICAgY29uc3QgcXVvdGVkU2NoZW1hID0gd3JhcFNpbmdsZVF1b3RlKHNjaGVtYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICdJRiBFWElTVFMgKFNFTEVDVCBzY2hlbWFfbmFtZScsXG4gICAgICAnRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEnLFxuICAgICAgJ1dIRVJFIHNjaGVtYV9uYW1lID0nLCBxdW90ZWRTY2hlbWEsICcpJyxcbiAgICAgICdCRUdJTicsXG4gICAgICAnREVDTEFSRSBAaWQgSU5ULCBAbXNfc3FsIE5WQVJDSEFSKDIwMDApOycsXG4gICAgICAnREVDTEFSRSBAY2FzY2FkZSBUQUJMRSAoJyxcbiAgICAgICdpZCBJTlQgTk9UIE5VTEwgSURFTlRJVFkgUFJJTUFSWSBLRVksJyxcbiAgICAgICdtc19zcWwgTlZBUkNIQVIoMjAwMCkgTk9UIE5VTEwgKTsnLFxuICAgICAgJ0lOU0VSVCBJTlRPIEBjYXNjYWRlICggbXNfc3FsICknLFxuICAgICAgXCJTRUxFQ1QgQ0FTRSBXSEVOIG8udHlwZSBJTiAoJ0YnLCdQSycpXCIsXG4gICAgICBcIlRIRU4gTidBTFRFUiBUQUJMRSBbJysgcy5uYW1lICsgTiddLlsnICsgcC5uYW1lICsgTiddIERST1AgQ09OU1RSQUlOVCBbJyArIG8ubmFtZSArIE4nXSdcIixcbiAgICAgIFwiRUxTRSBOJ0RST1AgVEFCTEUgWycrIHMubmFtZSArIE4nXS5bJyArIG8ubmFtZSArIE4nXScgRU5EXCIsXG4gICAgICAnRlJPTSBzeXMub2JqZWN0cyBvJyxcbiAgICAgICdKT0lOIHN5cy5zY2hlbWFzIHMgb24gby5zY2hlbWFfaWQgPSBzLnNjaGVtYV9pZCcsXG4gICAgICAnTEVGVCBPVVRFUiBKT0lOIHN5cy5vYmplY3RzIHAgb24gby5wYXJlbnRfb2JqZWN0X2lkID0gcC5vYmplY3RfaWQnLFxuICAgICAgXCJXSEVSRSBvLnR5cGUgSU4gKCdGJywgJ1BLJywgJ1UnKSBBTkQgcy5uYW1lID0gXCIsIHF1b3RlZFNjaGVtYSxcbiAgICAgICdPUkRFUiBCWSBvLnR5cGUgQVNDOycsXG4gICAgICAnU0VMRUNUIFRPUCAxIEBpZCA9IGlkLCBAbXNfc3FsID0gbXNfc3FsIEZST00gQGNhc2NhZGUgT1JERVIgQlkgaWQ7JyxcbiAgICAgICdXSElMRSBAaWQgSVMgTk9UIE5VTEwnLFxuICAgICAgJ0JFR0lOJyxcbiAgICAgICdCRUdJTiBUUlkgRVhFQyBzcF9leGVjdXRlc3FsIEBtc19zcWw7IEVORCBUUlknLFxuICAgICAgJ0JFR0lOIENBVENIIEJSRUFLOyBUSFJPVzsgRU5EIENBVENIOycsXG4gICAgICAnREVMRVRFIEZST00gQGNhc2NhZGUgV0hFUkUgaWQgPSBAaWQ7JyxcbiAgICAgICdTRUxFQ1QgQGlkID0gTlVMTCwgQG1zX3NxbCA9IE5VTEw7JyxcbiAgICAgICdTRUxFQ1QgVE9QIDEgQGlkID0gaWQsIEBtc19zcWwgPSBtc19zcWwgRlJPTSBAY2FzY2FkZSBPUkRFUiBCWSBpZDsnLFxuICAgICAgJ0VORCcsXG4gICAgICBcIkVYRUMgc3BfZXhlY3V0ZXNxbCBOJ0RST1AgU0NIRU1BXCIsIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksIFwiOydcIixcbiAgICAgICdFTkQ7J1xuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ1NFTEVDVCBcIm5hbWVcIiBhcyBcInNjaGVtYV9uYW1lXCIgRlJPTSBzeXMuc2NoZW1hcyBhcyBzJyxcbiAgICAgICdXSEVSRSBcInNcIi5cIm5hbWVcIiBOT1QgSU4gKCcsXG4gICAgICBcIidJTkZPUk1BVElPTl9TQ0hFTUEnLCAnZGJvJywgJ2d1ZXN0JywgJ3N5cycsICdhcmNoaXZlJ1wiLFxuICAgICAgJyknLCAnQU5EJywgJ1wic1wiLlwibmFtZVwiIE5PVCBMSUtFJywgXCInZGJfJSdcIlxuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIC8vIFVzZXMgc3RyaW5nIG1hbmlwdWxhdGlvbiB0byBjb252ZXJ0IHRoZSBNUyBNYWouTWluLlBhdGNoLkJ1aWxkIHRvIHNlbXZlciBNYWouTWluLlBhdGNoXG4gICAgcmV0dXJuIFtcbiAgICAgICdERUNMQVJFIEBtc192ZXIgTlZBUkNIQVIoMjApOycsXG4gICAgICBcIlNFVCBAbXNfdmVyID0gUkVWRVJTRShDT05WRVJUKE5WQVJDSEFSKDIwKSwgU0VSVkVSUFJPUEVSVFkoJ1Byb2R1Y3RWZXJzaW9uJykpKTtcIixcbiAgICAgIFwiU0VMRUNUIFJFVkVSU0UoU1VCU1RSSU5HKEBtc192ZXIsIENIQVJJTkRFWCgnLicsIEBtc192ZXIpKzEsIDIwKSkgQVMgJ3ZlcnNpb24nXCJcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXSxcbiAgICAgIGZvcmVpZ25LZXlzID0ge30sXG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMgPSBbXTtcblxuICAgIGxldCBjb21tZW50U3RyID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBsZXQgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdDT01NRU5UICcpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChDT01NRU5ULiopJC8pO1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gY29tbWVudE1hdGNoWzJdLnJlcGxhY2UoJ0NPTU1FTlQnLCAnJykudHJpbSgpO1xuICAgICAgICAgIGNvbW1lbnRTdHIgKz0gdGhpcy5jb21tZW50VGVtcGxhdGUoY29tbWVudFRleHQsIHRhYmxlTmFtZSwgYXR0cik7XG4gICAgICAgICAgLy8gcmVtb3ZlIGNvbW1lbnQgcmVsYXRlZCBzdWJzdHJpbmcgZnJvbSBkYXRhVHlwZVxuICAgICAgICAgIGRhdGFUeXBlID0gY29tbWVudE1hdGNoWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKSB7XG4gICAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcblxuICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgICAgICAvLyBNU1NRTCBkb2Vzbid0IHN1cHBvcnQgaW5saW5lIFJFRkVSRU5DRVMgZGVjbGFyYXRpb25zOiBtb3ZlIHRvIHRoZSBlbmRcbiAgICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnJyl9YCk7XG4gICAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICcnKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICAgIC8vIE1TU1FMIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgUkVGRVJFTkNFUyBkZWNsYXJhdGlvbnM6IG1vdmUgdG8gdGhlIGVuZFxuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcChwayA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oJywgJyk7XG5cbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKCdfJyl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYENPTlNUUkFJTlQgJHtcbiAgICAgICAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSlcbiAgICAgICAgICB9IFVOSVFVRSAoJHtcbiAgICAgICAgICAgIGNvbHVtbnMuZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oJywgJylcbiAgICAgICAgICB9KWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgSUYgT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlTmFtZX0nLCAnVScpIElTIE5VTExgLFxuICAgICAgYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX0gKCR7YXR0cmlidXRlc0NsYXVzZVBhcnRzLmpvaW4oJywgJyl9KWAsXG4gICAgICAnOycsXG4gICAgICBjb21tZW50U3RyXG4gICAgXSk7XG4gIH1cblxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEpIHtcbiAgICBsZXQgc3FsID0gW1xuICAgICAgJ1NFTEVDVCcsXG4gICAgICBcImMuQ09MVU1OX05BTUUgQVMgJ05hbWUnLFwiLFxuICAgICAgXCJjLkRBVEFfVFlQRSBBUyAnVHlwZScsXCIsXG4gICAgICBcImMuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIIEFTICdMZW5ndGgnLFwiLFxuICAgICAgXCJjLklTX05VTExBQkxFIGFzICdJc051bGwnLFwiLFxuICAgICAgXCJDT0xVTU5fREVGQVVMVCBBUyAnRGVmYXVsdCcsXCIsXG4gICAgICBcInBrLkNPTlNUUkFJTlRfVFlQRSBBUyAnQ29uc3RyYWludCcsXCIsXG4gICAgICBcIkNPTFVNTlBST1BFUlRZKE9CSkVDVF9JRChjLlRBQkxFX1NDSEVNQSsnLicrYy5UQUJMRV9OQU1FKSwgYy5DT0xVTU5fTkFNRSwgJ0lzSWRlbnRpdHknKSBhcyAnSXNJZGVudGl0eScsXCIsXG4gICAgICBcIkNBU1QocHJvcC52YWx1ZSBBUyBOVkFSQ0hBUikgQVMgJ0NvbW1lbnQnXCIsXG4gICAgICAnRlJPTScsXG4gICAgICAnSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyB0JyxcbiAgICAgICdJTk5FUiBKT0lOJyxcbiAgICAgICdJTkZPUk1BVElPTl9TQ0hFTUEuQ09MVU1OUyBjIE9OIHQuVEFCTEVfTkFNRSA9IGMuVEFCTEVfTkFNRSBBTkQgdC5UQUJMRV9TQ0hFTUEgPSBjLlRBQkxFX1NDSEVNQScsXG4gICAgICAnTEVGVCBKT0lOIChTRUxFQ1QgdGMudGFibGVfc2NoZW1hLCB0Yy50YWJsZV9uYW1lLCAnLFxuICAgICAgJ2N1LmNvbHVtbl9uYW1lLCB0Yy5DT05TVFJBSU5UX1RZUEUgJyxcbiAgICAgICdGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UUyB0YyAnLFxuICAgICAgJ0pPSU4gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0UgIGN1ICcsXG4gICAgICAnT04gdGMudGFibGVfc2NoZW1hPWN1LnRhYmxlX3NjaGVtYSBhbmQgdGMudGFibGVfbmFtZT1jdS50YWJsZV9uYW1lICcsXG4gICAgICAnYW5kIHRjLmNvbnN0cmFpbnRfbmFtZT1jdS5jb25zdHJhaW50X25hbWUgJyxcbiAgICAgICdhbmQgdGMuQ09OU1RSQUlOVF9UWVBFPVxcJ1BSSU1BUlkgS0VZXFwnKSBwayAnLFxuICAgICAgJ09OIHBrLnRhYmxlX3NjaGVtYT1jLnRhYmxlX3NjaGVtYSAnLFxuICAgICAgJ0FORCBway50YWJsZV9uYW1lPWMudGFibGVfbmFtZSAnLFxuICAgICAgJ0FORCBway5jb2x1bW5fbmFtZT1jLmNvbHVtbl9uYW1lICcsXG4gICAgICAnSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBBUyBzYycsXG4gICAgICBcIk9OIHNjLm9iamVjdF9pZCA9IG9iamVjdF9pZCh0LnRhYmxlX3NjaGVtYSArICcuJyArIHQudGFibGVfbmFtZSkgQU5EIHNjLm5hbWUgPSBjLmNvbHVtbl9uYW1lXCIsXG4gICAgICAnTEVGVCBKT0lOIHN5cy5leHRlbmRlZF9wcm9wZXJ0aWVzIHByb3AgT04gcHJvcC5tYWpvcl9pZCA9IHNjLm9iamVjdF9pZCcsXG4gICAgICAnQU5EIHByb3AubWlub3JfaWQgPSBzYy5jb2x1bW5faWQnLFxuICAgICAgXCJBTkQgcHJvcC5uYW1lID0gJ01TX0Rlc2NyaXB0aW9uJ1wiLFxuICAgICAgJ1dIRVJFIHQuVEFCTEVfTkFNRSA9Jywgd3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSlcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGlmIChzY2hlbWEpIHtcbiAgICAgIHNxbCArPSBgQU5EIHQuVEFCTEVfU0NIRU1BID0ke3dyYXBTaW5nbGVRdW90ZShzY2hlbWEpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIHJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcikge1xuICAgIHJldHVybiBgRVhFQyBzcF9yZW5hbWUgJHt0aGlzLnF1b3RlVGFibGUoYmVmb3JlKX0sICR7dGhpcy5xdW90ZVRhYmxlKGFmdGVyKX07YDtcbiAgfVxuXG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgVEFCTEVfTkFNRSwgVEFCTEVfU0NIRU1BIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnO1wiO1xuICB9XG5cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVUYmwgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgSUYgT0JKRUNUX0lEKCcke3F1b3RlVGJsfScsICdVJykgSVMgTk9UIE5VTExgLFxuICAgICAgJ0RST1AgVEFCTEUnLFxuICAgICAgcXVvdGVUYmwsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgLy8gRklYTUU6IGF0dHJpYnV0ZVRvU1FMIFNIT1VMRCBiZSB1c2luZyBhdHRyaWJ1dGVzIGluIGFkZENvbHVtblF1ZXJ5XG4gICAgLy8gICAgICAgIGJ1dCBpbnN0ZWFkIHdlIG5lZWQgdG8gcGFzcyB0aGUga2V5IGFsb25nIGFzIHRoZSBmaWVsZCBoZXJlXG4gICAgZGF0YVR5cGUuZmllbGQgPSBrZXk7XG4gICAgbGV0IGNvbW1lbnRTdHIgPSAnJztcblxuICAgIGlmIChkYXRhVHlwZS5jb21tZW50ICYmIF8uaXNTdHJpbmcoZGF0YVR5cGUuY29tbWVudCkpIHtcbiAgICAgIGNvbW1lbnRTdHIgPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShkYXRhVHlwZS5jb21tZW50LCB0YWJsZSwga2V5KTtcbiAgICAgIC8vIGF0dHJpYnV0ZVRvU1FMIHdpbGwgdHJ5IHRvIGluY2x1ZGUgYENPTU1FTlQgJ0NvbW1lbnQgVGV4dCdgIHdoZW4gaXQgcmV0dXJucyBpZiB0aGUgY29tbWVudCBrZXlcbiAgICAgIC8vIGlzIHByZXNlbnQuIFRoaXMgaXMgbmVlZGVkIGZvciBjcmVhdGVUYWJsZSBzdGF0ZW1lbnQgd2hlcmUgdGhhdCBwYXJ0IGlzIGV4dHJhY3RlZCB3aXRoIHJlZ2V4LlxuICAgICAgLy8gSGVyZSB3ZSBjYW4gaW50ZXJjZXB0IHRoZSBvYmplY3QgYW5kIHJlbW92ZSBjb21tZW50IHByb3BlcnR5IHNpbmNlIHdlIGhhdmUgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgIGRlbGV0ZSBkYXRhVHlwZVsnY29tbWVudCddO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgJ0FERCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwgeyBjb250ZXh0OiAnYWRkQ29sdW1uJyB9KSxcbiAgICAgICc7JyxcbiAgICAgIGNvbW1lbnRTdHJcbiAgICBdKTtcbiAgfVxuXG4gIGNvbW1lbnRUZW1wbGF0ZShjb21tZW50LCB0YWJsZSwgY29sdW1uKSB7XG4gICAgcmV0dXJuICcgRVhFQyBzcF9hZGRleHRlbmRlZHByb3BlcnR5ICcgK1xuICAgICAgICBgQG5hbWUgPSBOJ01TX0Rlc2NyaXB0aW9uJywgQHZhbHVlID0gJHt0aGlzLmVzY2FwZShjb21tZW50KX0sIGAgK1xuICAgICAgICAnQGxldmVsMHR5cGUgPSBOXFwnU2NoZW1hXFwnLCBAbGV2ZWwwbmFtZSA9IFxcJ2Rib1xcJywgJyArXG4gICAgICAgIGBAbGV2ZWwxdHlwZSA9IE4nVGFibGUnLCBAbGV2ZWwxbmFtZSA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGUpfSwgYCArXG4gICAgICAgIGBAbGV2ZWwydHlwZSA9IE4nQ29sdW1uJywgQGxldmVsMm5hbWUgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbil9O2A7XG4gIH1cblxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnRFJPUCBDT0xVTU4nLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXSxcbiAgICAgIGNvbnN0cmFpbnRTdHJpbmcgPSBbXTtcbiAgICBsZXQgY29tbWVudFN0cmluZyA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHF1b3RlZEF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnQ09NTUVOVCAnKSkge1xuICAgICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBkZWZpbml0aW9uLm1hdGNoKC9eKC4rKSAoQ09NTUVOVC4qKSQvKTtcbiAgICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50TWF0Y2hbMl0ucmVwbGFjZSgnQ09NTUVOVCcsICcnKS50cmltKCk7XG4gICAgICAgIGNvbW1lbnRTdHJpbmcgKz0gdGhpcy5jb21tZW50VGVtcGxhdGUoY29tbWVudFRleHQsIHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50IHJlbGF0ZWQgc3Vic3RyaW5nIGZyb20gZGF0YVR5cGVcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNvbW1lbnRNYXRjaFsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgY29uc3RyYWludFN0cmluZy5wdXNoKGBGT1JFSUdOIEtFWSAoJHtxdW90ZWRBdHRyTmFtZX0pICR7ZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sICcnKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHJpbmcucHVzaChgJHtxdW90ZWRBdHRyTmFtZX0gJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJTdHJpbmcubGVuZ3RoICYmIGBBTFRFUiBDT0xVTU4gJHthdHRyU3RyaW5nLmpvaW4oJywgJyl9YCxcbiAgICAgIGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoICYmIGBBREQgJHtjb25zdHJhaW50U3RyaW5nLmpvaW4oJywgJyl9YCxcbiAgICAgICc7JyxcbiAgICAgIGNvbW1lbnRTdHJpbmdcbiAgICBdKTtcbiAgfVxuXG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG5ld05hbWUgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVswXTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnRVhFQyBzcF9yZW5hbWUnLFxuICAgICAgYCcke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfS4ke2F0dHJCZWZvcmV9JyxgLFxuICAgICAgYCcke25ld05hbWV9JyxgLFxuICAgICAgXCInQ09MVU1OJ1wiLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBidWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgY29uc3QgdHVwbGVzID0gW107XG4gICAgY29uc3QgYWxsQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IGFsbFF1ZXJpZXMgPSBbXTtcblxuICAgIGxldCBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gZmFsc2UsXG4gICAgICBvdXRwdXRGcmFnbWVudCA9ICcnO1xuXG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBlbXB0eVF1ZXJ5ID0gYElOU0VSVCBJTlRPICR7cXVvdGVkVGFibGV9JHtvdXRwdXRGcmFnbWVudH0gREVGQVVMVCBWQUxVRVNgO1xuXG4gICAgYXR0clZhbHVlSGFzaGVzLmZvckVhY2goYXR0clZhbHVlSGFzaCA9PiB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGVtcHR5IG9iamVjdHMgd2l0aCBwcmltYXJ5IGtleXNcbiAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGF0dHJWYWx1ZUhhc2gpO1xuICAgICAgY29uc3QgZmlyc3RBdHRyID0gYXR0cmlidXRlc1tmaWVsZHNbMF1dO1xuICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEgJiYgZmlyc3RBdHRyICYmIGZpcnN0QXR0ci5hdXRvSW5jcmVtZW50ICYmIGF0dHJWYWx1ZUhhc2hbZmllbGRzWzBdXSA9PT0gbnVsbCkge1xuICAgICAgICBhbGxRdWVyaWVzLnB1c2goZW1wdHlRdWVyeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsIGNhc2VcbiAgICAgIF8uZm9yT3duKGF0dHJWYWx1ZUhhc2gsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gJiYgYXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWxsQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIGF0dHJpYnV0ZXNba2V5XSAmJiBhdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChhbGxBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJWYWx1ZUhhc2hlcy5mb3JFYWNoKGF0dHJWYWx1ZUhhc2ggPT4ge1xuICAgICAgICB0dXBsZXMucHVzaChgKCR7XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5tYXAoa2V5ID0+XG4gICAgICAgICAgICB0aGlzLmVzY2FwZShhdHRyVmFsdWVIYXNoW2tleV0pKS5qb2luKCcsJylcbiAgICAgICAgfSlgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBxdW90ZWRBdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbignLCcpO1xuICAgICAgYWxsUXVlcmllcy5wdXNoKHR1cGxlU3RyID0+IGBJTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlfSAoJHtxdW90ZWRBdHRyaWJ1dGVzfSkke291dHB1dEZyYWdtZW50fSBWQUxVRVMgJHt0dXBsZVN0cn07YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgYmF0Y2ggPSBNYXRoLmZsb29yKDI1MCAvIChhbGxBdHRyaWJ1dGVzLmxlbmd0aCArIDEpKSArIDE7XG4gICAgd2hpbGUgKG9mZnNldCA8IE1hdGgubWF4KHR1cGxlcy5sZW5ndGgsIDEpKSB7XG4gICAgICBjb25zdCB0dXBsZVN0ciA9IHR1cGxlcy5zbGljZShvZmZzZXQsIE1hdGgubWluKHR1cGxlcy5sZW5ndGgsIG9mZnNldCArIGJhdGNoKSk7XG4gICAgICBsZXQgZ2VuZXJhdGVkUXVlcnkgPSBhbGxRdWVyaWVzLm1hcCh2ID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYgOiB2KHR1cGxlU3RyKSkuam9pbignOycpO1xuICAgICAgaWYgKG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIpIHtcbiAgICAgICAgZ2VuZXJhdGVkUXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPTjsgJHtnZW5lcmF0ZWRRdWVyeX07IFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT0ZGO2A7XG4gICAgICB9XG4gICAgICBjb21tYW5kcy5wdXNoKGdlbmVyYXRlZFF1ZXJ5KTtcbiAgICAgIG9mZnNldCArPSBiYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLmpvaW4oJzsnKTtcbiAgfVxuXG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBzdXBlci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgY29uc3QgdXBkYXRlQXJncyA9IGBVUERBVEUgVE9QKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgICBzcWwucXVlcnkgPSBzcWwucXVlcnkucmVwbGFjZSgnVVBEQVRFJywgdXBkYXRlQXJncyk7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICB1cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YXJnZXRUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fdGFyZ2V0YCk7XG4gICAgY29uc3Qgc291cmNlVGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3NvdXJjZWApO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzQXR0cnMgPSBbXTtcbiAgICBjb25zdCBpZGVudGl0eUF0dHJzID0gW107XG4gICAgY29uc3QgdW5pcXVlQXR0cnMgPSBbXTtcbiAgICBjb25zdCB0YWJsZU5hbWVRdW90ZWQgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IGZhbHNlO1xuXG4gICAgLy9PYnRhaW4gcHJpbWFyeUtleXMsIHVuaXF1ZWtleXMgYW5kIGlkZW50aXR5IGF0dHJzIGZyb20gcmF3QXR0cmlidXRlcyBhcyBtb2RlbCBpcyBub3QgcGFzc2VkXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5wcmltYXJ5S2V5KSB7XG4gICAgICAgIHByaW1hcnlLZXlzQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udW5pcXVlKSB7XG4gICAgICAgIHVuaXF1ZUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgaWRlbnRpdHlBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vQWRkIHVuaXF1ZSBpbmRleGVzIGRlZmluZWQgYnkgaW5kZXhlcyBvcHRpb24gdG8gdW5pcXVlQXR0cnNcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1vZGVsLl9pbmRleGVzKSB7XG4gICAgICBpZiAoaW5kZXgudW5pcXVlICYmIGluZGV4LmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycgPyBmaWVsZCA6IGZpZWxkLm5hbWUgfHwgZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIGlmICghdW5pcXVlQXR0cnMuaW5jbHVkZXMoZmllbGROYW1lKSAmJiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgIHVuaXF1ZUF0dHJzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVLZXlzID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzUXVvdGVkID0gaW5zZXJ0S2V5cy5tYXAoa2V5ID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpLmpvaW4oJywgJyk7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzRXNjYXBlZCA9IGluc2VydEtleXMubWFwKGtleSA9PiB0aGlzLmVzY2FwZShpbnNlcnRWYWx1ZXNba2V5XSkpLmpvaW4oJywgJyk7XG4gICAgY29uc3Qgc291cmNlVGFibGVRdWVyeSA9IGBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgOyAvL1ZpcnR1YWwgVGFibGVcbiAgICBsZXQgam9pbkNvbmRpdGlvbjtcblxuICAgIC8vSURFTlRJVFlfSU5TRVJUIENvbmRpdGlvblxuICAgIGlkZW50aXR5QXR0cnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZVZhbHVlc1trZXldICYmIHVwZGF0ZVZhbHVlc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJREVOVElUWV9JTlNFUlQgQ29sdW1uIENhbm5vdCBiZSB1cGRhdGVkLCBvbmx5IGluc2VydGVkXG4gICAgICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMwMTc2MjU0LzIyNTQzNjBcbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL0ZpbHRlciBOVUxMIENsYXVzZXNcbiAgICBjb25zdCBjbGF1c2VzID0gd2hlcmVbT3Aub3JdLmZpbHRlcihjbGF1c2UgPT4ge1xuICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgIC8qXG4gICAgICAgKiBFeGNsdWRlIE5VTEwgQ29tcG9zaXRlIFBLL1VLLiBQYXJ0aWFsIENvbXBvc2l0ZSBjbGF1c2VzIHNob3VsZCBhbHNvIGJlIGV4Y2x1ZGVkIGFzIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIGEgc2luZ2xlIHJvd1xuICAgICAgICovXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGF1c2Vba2V5XSA9PT0gJ3VuZGVmaW5lZCcgfHwgY2xhdXNlW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogR2VuZXJhdGUgT04gY29uZGl0aW9uIHVzaW5nIFBLKHMpLlxuICAgICAqIElmIG5vdCwgZ2VuZXJhdGUgdXNpbmcgVUsocykuIEVsc2UgdGhyb3cgZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdCBnZXRKb2luU25pcHBldCA9IGFycmF5ID0+IHtcbiAgICAgIHJldHVybiBhcnJheS5tYXAoa2V5ID0+IHtcbiAgICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7c291cmNlVGFibGVBbGlhc30uJHtrZXl9YDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY2xhdXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWFyeSBLZXkgb3IgVW5pcXVlIGtleSBzaG91bGQgYmUgcGFzc2VkIHRvIHVwc2VydCBxdWVyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIHByaW1hcnkga2V5IGF0dHJpYnV0ZSBpbiBjbGF1c2VzIC0tIE1vZGVsIGNhbiBoYXZlIHR3byBzZXBhcmF0ZSB1bmlxdWUga2V5c1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2xhdXNlc1trZXldKTtcbiAgICAgICAgaWYgKHByaW1hcnlLZXlzQXR0cnMuaW5jbHVkZXMoa2V5c1swXSkpIHtcbiAgICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQocHJpbWFyeUtleXNBdHRycykuam9pbignIEFORCAnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFqb2luQ29uZGl0aW9uKSB7XG4gICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldCh1bmlxdWVBdHRycykuam9pbignIEFORCAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIElERU5USVRZX0lOU0VSVCBDb2x1bW4gZnJvbSB1cGRhdGVcbiAgICBjb25zdCB1cGRhdGVTbmlwcGV0ID0gdXBkYXRlS2V5cy5maWx0ZXIoa2V5ID0+ICFpZGVudGl0eUF0dHJzLmluY2x1ZGVzKGtleSkpXG4gICAgICAubWFwKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lc2NhcGUodXBkYXRlVmFsdWVzW2tleV0pO1xuICAgICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHt2YWx1ZX1gO1xuICAgICAgfSkuam9pbignLCAnKTtcblxuICAgIGNvbnN0IGluc2VydFNuaXBwZXQgPSBgKCR7aW5zZXJ0S2V5c1F1b3RlZH0pIFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7XG4gICAgbGV0IHF1ZXJ5ID0gYE1FUkdFIElOVE8gJHt0YWJsZU5hbWVRdW90ZWR9IFdJVEgoSE9MRExPQ0spIEFTICR7dGFyZ2V0VGFibGVBbGlhc30gVVNJTkcgKCR7c291cmNlVGFibGVRdWVyeX0pIEFTICR7c291cmNlVGFibGVBbGlhc30oJHtpbnNlcnRLZXlzUXVvdGVkfSkgT04gJHtqb2luQ29uZGl0aW9ufWA7XG4gICAgcXVlcnkgKz0gYCBXSEVOIE1BVENIRUQgVEhFTiBVUERBVEUgU0VUICR7dXBkYXRlU25pcHBldH0gV0hFTiBOT1QgTUFUQ0hFRCBUSEVOIElOU0VSVCAke2luc2VydFNuaXBwZXR9IE9VVFBVVCAkYWN0aW9uLCBJTlNFUlRFRC4qO2A7XG4gICAgaWYgKG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIpIHtcbiAgICAgIHF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHt0YWJsZU5hbWVRdW90ZWR9IE9OOyAke3F1ZXJ5fSBTRVQgSURFTlRJVFlfSU5TRVJUICR7dGFibGVOYW1lUXVvdGVkfSBPRkY7YDtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgVFJVTkNBVEUgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuICB9XG5cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3Qgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0RFTEVURScsXG4gICAgICBvcHRpb25zLmxpbWl0ICYmIGBUT1AoJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYCxcbiAgICAgICdGUk9NJyxcbiAgICAgIHRhYmxlLFxuICAgICAgd2hlcmVDbGF1c2UgJiYgYFdIRVJFICR7d2hlcmVDbGF1c2V9YCxcbiAgICAgICc7JyxcbiAgICAgICdTRUxFQ1QgQEBST1dDT1VOVCBBUyBBRkZFQ1RFRFJPV1MnLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRVhFQyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lID0gTicke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSc7YDtcbiAgfVxuXG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRVhFQyBzcF9oZWxwY29uc3RyYWludCBAb2JqbmFtZSA9ICR7dGhpcy5lc2NhcGUodGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSkpfTtgO1xuICB9XG5cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKCdfJyl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBEUk9QIElOREVYICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSl9IE9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSl9YDtcbiAgfVxuXG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBzZWxmIHJlZmVyZW50aWFsIGNvbnN0cmFpbnRzXG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUuTW9kZWwgJiYgYXR0cmlidXRlLk1vZGVsLnRhYmxlTmFtZSA9PT0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IHNlbGYgcmVmZXJlbmNpYWwgY29uc3RyYWludHMsICdcbiAgICAgICAgICArICd3ZSB3aWxsIHJlbW92ZSBpdCBidXQgd2UgcmVjb21tZW5kIHJlc3RydWN0dXJpbmcgeW91ciBxdWVyeScpO1xuICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSAnJztcbiAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRlbXBsYXRlO1xuXG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG5cbiAgICAgIC8vIGVudW1zIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1NxbCgpO1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuZmllbGQpfSBJTigke2F0dHJpYnV0ZS52YWx1ZXMubWFwKHZhbHVlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pLmpvaW4oJywgJykgfSkpYDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZygpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIE5PVCBOVUxMJztcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGUucHJpbWFyeUtleSAmJiAhVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIE5VTEwnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBJREVOVElUWSgxLDEpJztcbiAgICB9XG5cbiAgICAvLyBCbG9icy90ZXh0cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHRWYWx1ZVxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSAhPT0gJ1RFWFQnICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiZcbiAgICAgICAgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIFVOSVFVRSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIFBSSU1BUlkgS0VZJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKCdpZCcpfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50ICYmIHR5cGVvZiBhdHRyaWJ1dGUuY29tbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke2F0dHJpYnV0ZS5jb21tZW50fWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fSxcbiAgICAgIGV4aXN0aW5nQ29uc3RyYWludHMgPSBbXTtcbiAgICBsZXQga2V5LFxuICAgICAgYXR0cmlidXRlO1xuXG4gICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ29uc3RyYWludHMuaW5jbHVkZXMoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAvLyBubyBjYXNjYWRpbmcgY29uc3RyYWludHMgdG8gYSB0YWJsZSBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9ICcnO1xuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nQ29uc3RyYWludHMucHVzaChhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKTtcblxuICAgICAgICAgIC8vIE5PVEU6IHRoaXMgcmVhbGx5IGp1c3QgZGlzYWJsZXMgY2FzY2FkaW5nIHVwZGF0ZXMgZm9yIGFsbFxuICAgICAgICAgIC8vICAgICAgIGRlZmluaXRpb25zLiBDYW4gYmUgbWFkZSBtb3JlIHJvYnVzdCB0byBzdXBwb3J0IHRoZVxuICAgICAgICAgIC8vICAgICAgIGZldyBjYXNlcyB3aGVyZSBNU1NRTCBhY3R1YWxseSBzdXBwb3J0cyB0aGVtXG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICYmICFhdHRyaWJ1dGUuZmllbGQpIGF0dHJpYnV0ZS5maWVsZCA9IGtleTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY3JlYXRlVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgnY3JlYXRlVHJpZ2dlcicpO1xuICB9XG5cbiAgZHJvcFRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ2Ryb3BUcmlnZ2VyJyk7XG4gIH1cblxuICByZW5hbWVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdyZW5hbWVUcmlnZ2VyJyk7XG4gIH1cblxuICBjcmVhdGVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgnY3JlYXRlRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGRyb3BGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgnZHJvcEZ1bmN0aW9uJyk7XG4gIH1cblxuICByZW5hbWVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgncmVuYW1lRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBjb21tb24gU1FMIHByZWZpeCBmb3IgRm9yZWlnbktleXNRdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGFsb2dOYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeChjYXRhbG9nTmFtZSkge1xuICAgIHJldHVybiBgJHsnU0VMRUNUICcgK1xuICAgICAgICAnY29uc3RyYWludF9uYW1lID0gT0JKLk5BTUUsICcgK1xuICAgICAgICAnY29uc3RyYWludE5hbWUgPSBPQkouTkFNRSwgJ30ke1xuICAgICAgY2F0YWxvZ05hbWUgPyBgY29uc3RyYWludENhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogJydcbiAgICB9Y29uc3RyYWludFNjaGVtYSA9IFNDSEVNQV9OQU1FKE9CSi5TQ0hFTUFfSUQpLCBgICtcbiAgICAgICAgJ3RhYmxlTmFtZSA9IFRCLk5BTUUsICcgK1xuICAgICAgICBgdGFibGVTY2hlbWEgPSBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpLCAke1xuICAgICAgICAgIGNhdGFsb2dOYW1lID8gYHRhYmxlQ2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiAnJ1xuICAgICAgICB9Y29sdW1uTmFtZSA9IENPTC5OQU1FLCBgICtcbiAgICAgICAgYHJlZmVyZW5jZWRUYWJsZVNjaGVtYSA9IFNDSEVNQV9OQU1FKFJUQi5TQ0hFTUFfSUQpLCAke1xuICAgICAgICAgIGNhdGFsb2dOYW1lID8gYHJlZmVyZW5jZWRDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6ICcnXG4gICAgICAgIH1yZWZlcmVuY2VkVGFibGVOYW1lID0gUlRCLk5BTUUsIGAgK1xuICAgICAgICAncmVmZXJlbmNlZENvbHVtbk5hbWUgPSBSQ09MLk5BTUUgJyArXG4gICAgICAnRlJPTSBzeXMuZm9yZWlnbl9rZXlfY29sdW1ucyBGS0MgJyArXG4gICAgICAgICdJTk5FUiBKT0lOIHN5cy5vYmplY3RzIE9CSiBPTiBPQkouT0JKRUNUX0lEID0gRktDLkNPTlNUUkFJTlRfT0JKRUNUX0lEICcgK1xuICAgICAgICAnSU5ORVIgSk9JTiBzeXMudGFibGVzIFRCIE9OIFRCLk9CSkVDVF9JRCA9IEZLQy5QQVJFTlRfT0JKRUNUX0lEICcgK1xuICAgICAgICAnSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBDT0wgT04gQ09MLkNPTFVNTl9JRCA9IFBBUkVOVF9DT0xVTU5fSUQgQU5EIENPTC5PQkpFQ1RfSUQgPSBUQi5PQkpFQ1RfSUQgJyArXG4gICAgICAgICdJTk5FUiBKT0lOIHN5cy50YWJsZXMgUlRCIE9OIFJUQi5PQkpFQ1RfSUQgPSBGS0MuUkVGRVJFTkNFRF9PQkpFQ1RfSUQgJyArXG4gICAgICAgICdJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIFJDT0wgT04gUkNPTC5DT0xVTU5fSUQgPSBSRUZFUkVOQ0VEX0NPTFVNTl9JRCBBTkQgUkNPTC5PQkpFQ1RfSUQgPSBSVEIuT0JKRUNUX0lEJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyBhbGwgZm9yZWlnbiBrZXlzIGRldGFpbHMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0YWxvZ05hbWUgZGF0YWJhc2UgbmFtZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgY2F0YWxvZ05hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgbGV0IHNxbCA9IGAke3RoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoY2F0YWxvZ05hbWUpXG4gICAgfSBXSEVSRSBUQi5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWA7XG5cbiAgICBpZiAodGFibGUuc2NoZW1hKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIHRoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoKSxcbiAgICAgICdXSEVSRScsXG4gICAgICBgVEIuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gLFxuICAgICAgJ0FORCcsXG4gICAgICBgQ09MLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKGF0dHJpYnV0ZU5hbWUpfWAsXG4gICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpfWBcbiAgICBdKTtcbiAgfVxuXG4gIGdldFByaW1hcnlLZXlDb25zdHJhaW50UXVlcnkodGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUIEsuVEFCTEVfTkFNRSBBUyB0YWJsZU5hbWUsJyxcbiAgICAgICdLLkNPTFVNTl9OQU1FIEFTIGNvbHVtbk5hbWUsJyxcbiAgICAgICdLLkNPTlNUUkFJTlRfTkFNRSBBUyBjb25zdHJhaW50TmFtZScsXG4gICAgICAnRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFMgQVMgQycsXG4gICAgICAnSk9JTiBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSBBUyBLJyxcbiAgICAgICdPTiBDLlRBQkxFX05BTUUgPSBLLlRBQkxFX05BTUUnLFxuICAgICAgJ0FORCBDLkNPTlNUUkFJTlRfQ0FUQUxPRyA9IEsuQ09OU1RSQUlOVF9DQVRBTE9HJyxcbiAgICAgICdBTkQgQy5DT05TVFJBSU5UX1NDSEVNQSA9IEsuQ09OU1RSQUlOVF9TQ0hFTUEnLFxuICAgICAgJ0FORCBDLkNPTlNUUkFJTlRfTkFNRSA9IEsuQ09OU1RSQUlOVF9OQU1FJyxcbiAgICAgICdXSEVSRSBDLkNPTlNUUkFJTlRfVFlQRSA9IFxcJ1BSSU1BUlkgS0VZXFwnJyxcbiAgICAgIGBBTkQgSy5DT0xVTU5fTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKGF0dHJpYnV0ZU5hbWUpfWAsXG4gICAgICBgQU5EIEsuVEFCTEVfTkFNRSA9ICR7dGFibGVOYW1lfWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0RST1AnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSlcbiAgICBdKTtcbiAgfVxuXG4gIGdldERlZmF1bHRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUIG5hbWUgRlJPTSBzeXMuZGVmYXVsdF9jb25zdHJhaW50cycsXG4gICAgICBgV0hFUkUgUEFSRU5UX09CSkVDVF9JRCA9IE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZX0nLCAnVScpYCxcbiAgICAgIGBBTkQgUEFSRU5UX0NPTFVNTl9JRCA9IChTRUxFQ1QgY29sdW1uX2lkIEZST00gc3lzLmNvbHVtbnMgV0hFUkUgTkFNRSA9ICgnJHthdHRyaWJ1dGVOYW1lfScpYCxcbiAgICAgIGBBTkQgb2JqZWN0X2lkID0gT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlfScsICdVJykpYCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0RST1AgQ09OU1RSQUlOVCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihjb25zdHJhaW50TmFtZSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkoKSB7XG5cbiAgfVxuXG4gIGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoMTApLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRSBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cblxuICAgIHJldHVybiAnQkVHSU4gVFJBTlNBQ1RJT047JztcbiAgfVxuXG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuICdDT01NSVQgVFJBTlNBQ1RJT047JztcbiAgfVxuXG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1JPTExCQUNLIFRSQU5TQUNUSU9OOyc7XG4gIH1cblxuICBzZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcywgdGFibGVzLCBtYWluVGFibGVBcywgd2hlcmUpIHtcbiAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIHsgbW9kZWxOYW1lOiBtb2RlbCAmJiBtb2RlbC5uYW1lLCBhczogbWFpblRhYmxlQXMgfSk7XG5cbiAgICBjb25zdCBkYlZlcnNpb24gPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbjtcbiAgICBjb25zdCBpc1NRTFNlcnZlcjIwMDggPSBzZW12ZXIudmFsaWQoZGJWZXJzaW9uKSAmJiBzZW12ZXIubHQoZGJWZXJzaW9uLCAnMTEuMC4wJyk7XG5cbiAgICBpZiAoaXNTUUxTZXJ2ZXIyMDA4ICYmIG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAvLyBGb3IgZWFybGllciB2ZXJzaW9ucyBvZiBTUUwgc2VydmVyLCB3ZSBuZWVkIHRvIG5lc3Qgc2V2ZXJhbCBxdWVyaWVzXG4gICAgICAvLyBpbiBvcmRlciB0byBlbXVsYXRlIHRoZSBPRkZTRVQgYmVoYXZpb3IuXG4gICAgICAvL1xuICAgICAgLy8gMS4gVGhlIG91dGVybW9zdCBxdWVyeSBzZWxlY3RzIGFsbCBpdGVtcyBmcm9tIHRoZSBpbm5lciBxdWVyeSBibG9jay5cbiAgICAgIC8vICAgIFRoaXMgaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBTUUwgc2VydmVyIHdpdGggdGhlIHVzZSBvZiBjb21wdXRlZFxuICAgICAgLy8gICAgY29sdW1ucyAoZS5nLiBTRUxFQ1QgUk9XX05VTUJFUigpLi4uQVMgeCkgaW4gV0hFUkUgY2xhdXNlcy5cbiAgICAgIC8vIDIuIFRoZSBuZXh0IHF1ZXJ5IGhhbmRsZXMgdGhlIExJTUlUIGFuZCBPRkZTRVQgYmVoYXZpb3IgYnkgZ2V0dGluZ1xuICAgICAgLy8gICAgdGhlIFRPUCBOIHJvd3Mgb2YgdGhlIHF1ZXJ5IHdoZXJlIHRoZSByb3cgbnVtYmVyIGlzID4gT0ZGU0VUXG4gICAgICAvLyAzLiBUaGUgaW5uZXJtb3N0IHF1ZXJ5IGlzIHRoZSBhY3R1YWwgc2V0IHdlIHdhbnQgaW5mb3JtYXRpb24gZnJvbVxuXG4gICAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgaXNTdWJRdWVyeSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICAgIGxldCBvcmRlcnMgPSB7IG1haW5RdWVyeU9yZGVyOiBbXSB9O1xuICAgICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgaXNTdWJRdWVyeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlcnMubWFpblF1ZXJ5T3JkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9yZGVycy5tYWluUXVlcnlPcmRlci5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLnByaW1hcnlLZXlGaWVsZCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0bXBUYWJsZSA9IG1haW5UYWJsZUFzIHx8ICdPZmZzZXRUYWJsZSc7XG5cbiAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgJ1NFTEVDVCBUT1AgMTAwIFBFUkNFTlQnLFxuICAgICAgICBhdHRyaWJ1dGVzLmpvaW4oJywgJyksXG4gICAgICAgICdGUk9NICgnLFxuICAgICAgICBbXG4gICAgICAgICAgJ1NFTEVDVCcsXG4gICAgICAgICAgb3B0aW9ucy5saW1pdCAmJiBgVE9QICR7b3B0aW9ucy5saW1pdH1gLFxuICAgICAgICAgICcqIEZST00gKCcsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ1NFTEVDVCBST1dfTlVNQkVSKCkgT1ZFUiAoJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJ09SREVSIEJZJyxcbiAgICAgICAgICAgICAgb3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oJywgJylcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBgKSBhcyByb3dfbnVtLCAqIEZST00gJHt0YWJsZXN9IEFTICR7dG1wVGFibGV9YCxcbiAgICAgICAgICAgIHdoZXJlICYmIGBXSEVSRSAke3doZXJlfWBcbiAgICAgICAgICBdLFxuICAgICAgICAgIGApIEFTICR7dG1wVGFibGV9IFdIRVJFIHJvd19udW0gPiAke29mZnNldH1gXG4gICAgICAgIF0sXG4gICAgICAgIGApIEFTICR7dG1wVGFibGV9YFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCcsXG4gICAgICBpc1NRTFNlcnZlcjIwMDggJiYgb3B0aW9ucy5saW1pdCAmJiBgVE9QICR7b3B0aW9ucy5saW1pdH1gLFxuICAgICAgYXR0cmlidXRlcy5qb2luKCcsICcpLFxuICAgICAgYEZST00gJHt0YWJsZXN9YCxcbiAgICAgIG1haW5UYWJsZUFzICYmIGBBUyAke21haW5UYWJsZUFzfWAsXG4gICAgICBvcHRpb25zLnRhYmxlSGludCAmJiBUYWJsZUhpbnRzW29wdGlvbnMudGFibGVIaW50XSAmJiBgV0lUSCAoJHtUYWJsZUhpbnRzW29wdGlvbnMudGFibGVIaW50XX0pYFxuICAgIF0pO1xuICB9XG5cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucywgbW9kZWwpIHtcbiAgICAvLyBTa2lwIGhhbmRsaW5nIG9mIGxpbWl0IGFuZCBvZmZzZXQgYXMgcG9zdGZpeGVzIGZvciBvbGRlciBTUUwgU2VydmVyIHZlcnNpb25zXG4gICAgaWYgKHNlbXZlci52YWxpZCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbikgJiYgc2VtdmVyLmx0KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCAnMTEuMC4wJykpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgIGNvbnN0IGlzU3ViUXVlcnkgPSBvcHRpb25zLnN1YlF1ZXJ5ID09PSB1bmRlZmluZWRcbiAgICAgID8gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uXG4gICAgICA6IG9wdGlvbnMuc3ViUXVlcnk7XG5cbiAgICBsZXQgZnJhZ21lbnQgPSAnJztcbiAgICBsZXQgb3JkZXJzID0ge307XG5cbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgaXNTdWJRdWVyeSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGltaXQgfHwgb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgIGlmICghb3B0aW9ucy5vcmRlciB8fCAhb3B0aW9ucy5vcmRlci5sZW5ndGggfHwgb3B0aW9ucy5pbmNsdWRlICYmICFvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGFibGVQa0ZyYWdtZW50ID0gYCR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMudGFibGVBcyB8fCBtb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5wcmltYXJ5S2V5RmllbGQpfWA7XG4gICAgICAgIGlmICghb3B0aW9ucy5vcmRlciB8fCAhb3B0aW9ucy5vcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICBmcmFnbWVudCArPSBgIE9SREVSIEJZICR7dGFibGVQa0ZyYWdtZW50fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3JkZXJGaWVsZE5hbWVzID0gXy5tYXAob3B0aW9ucy5vcmRlciwgb3JkZXIgPT4gb3JkZXJbMF0pO1xuICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXlGaWVsZEFscmVhZHlQcmVzZW50ID0gXy5pbmNsdWRlcyhvcmRlckZpZWxkTmFtZXMsIG1vZGVsLnByaW1hcnlLZXlGaWVsZCk7XG5cbiAgICAgICAgICBpZiAoIXByaW1hcnlLZXlGaWVsZEFscmVhZHlQcmVzZW50KSB7XG4gICAgICAgICAgICBmcmFnbWVudCArPSBvcHRpb25zLm9yZGVyICYmICFpc1N1YlF1ZXJ5ID8gJywgJyA6ICcgT1JERVIgQlkgJztcbiAgICAgICAgICAgIGZyYWdtZW50ICs9IHRhYmxlUGtGcmFnbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBPRkZTRVQgJHt0aGlzLmVzY2FwZShvZmZzZXQpfSBST1dTYDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gIH1cbn1cblxuLy8gcHJpdmF0ZSBtZXRob2RzXG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgXCInXCIpLCBcIidcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTVNTUUxRdWVyeUdlbmVyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3JzJyk7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UnKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIHRoYXQgU2VxdWVsaXplIHVzZXMgdG8gdGFsayB3aXRoIE1TU1FMIGRhdGFiYXNlXG4gKi9cbmNsYXNzIE1TU3FsUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIC8qKlxuICAqIEEgd3JhcHBlciB0aGF0IGZpeGVzIE1TU1FMJ3MgaW5hYmlsaXR5IHRvIGNsZWFubHkgcmVtb3ZlIGNvbHVtbnMgZnJvbSBleGlzdGluZyB0YWJsZXMgaWYgdGhleSBoYXZlIGEgZGVmYXVsdCBjb25zdHJhaW50LlxuICAqXG4gICogQG92ZXJyaWRlXG4gICovXG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfHwge30gfTtcblxuICAgIGNvbnN0IGZpbmRDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXREZWZhdWx0Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdHMwXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGZpbmRDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0czAubGVuZ3RoKSB7XG4gICAgICAvLyBObyBkZWZhdWx0IGNvbnN0cmFpbnQgZm91bmQgLS0gd2UgY2FuIGNsZWFubHkgcmVtb3ZlIHRoZSBjb2x1bW5cbiAgICAgIGNvbnN0IGRyb3BDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0czBbMF0ubmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmRGb3JlaWduS2V5U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShmaW5kRm9yZWlnbktleVNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAvLyBObyBmb3JlaWduIGtleSBjb25zdHJhaW50cyBmb3VuZCwgc28gd2UgY2FuIHJlbW92ZSB0aGUgY29sdW1uXG4gICAgICBjb25zdCBkcm9wRm9yZWlnbktleVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdHNbMF0uY29uc3RyYWludF9uYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BGb3JlaWduS2V5U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy9DaGVjayBpZiB0aGUgY3VycmVudCBjb2x1bW4gaXMgYSBwcmltYXJ5S2V5XG4gICAgY29uc3QgcHJpbWFyeUtleUNvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldFByaW1hcnlLZXlDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0XSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHByaW1hcnlLZXlDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZHJvcENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCByZXN1bHRbMF0uY29uc3RyYWludE5hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHJlbW92ZVNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgd2hlcmVzID0gW107XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoIVV0aWxzLmlzV2hlcmVFbXB0eSh3aGVyZSkpIHtcbiAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICB9XG5cbiAgICAvLyBMZXRzIGNvbWJpbmUgdW5pcXVlIGtleXMgYW5kIGluZGV4ZXMgaW50byBvbmVcbiAgICBsZXQgaW5kZXhlcyA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykubWFwKGl0ZW0gPT4gaXRlbS5maWVsZHMpO1xuICAgIGluZGV4ZXMgPSBpbmRleGVzLmNvbmNhdChPYmplY3QudmFsdWVzKG1vZGVsLl9pbmRleGVzKS5maWx0ZXIoaXRlbSA9PiBpdGVtLnVuaXF1ZSkubWFwKGl0ZW0gPT4gaXRlbS5maWVsZHMpKTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgaWYgKF8uaW50ZXJzZWN0aW9uKGF0dHJpYnV0ZXMsIGluZGV4KS5sZW5ndGggPT09IGluZGV4Lmxlbmd0aCkge1xuICAgICAgICB3aGVyZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4KSB7XG4gICAgICAgICAgd2hlcmVbZmllbGRdID0gaW5zZXJ0VmFsdWVzW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hlcmUgPSB7IFtPcC5vcl06IHdoZXJlcyB9O1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydHMuTVNTcWxRdWVyeUludGVyZmFjZSA9IE1TU3FsUXVlcnlJbnRlcmZhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeScpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ21zc3FsJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnc3FsOm1zc3FsJyk7XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGFOdW0pIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYU51bSkpIHJldHVybiAwO1xuICBsZXQgZSA9IDE7XG4gIHdoaWxlIChNYXRoLnJvdW5kKGFOdW0gKiBlKSAvIGUgIT09IGFOdW0pIGUgKj0gMTA7XG4gIHJldHVybiBNYXRoLmxvZzEwKGUpO1xufVxuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiAnaWQnO1xuICB9XG5cbiAgZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUsIFRZUEVTKSB7XG4gICAgY29uc3QgcGFyYW1UeXBlID0geyB0eXBlOiBUWVBFUy5WYXJDaGFyLCB0eXBlT3B0aW9uczoge30gfTtcbiAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLk5WYXJDaGFyO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4ICYmIHZhbHVlIDw9IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkJpZ0ludDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5OdW1lcmljO1xuICAgICAgICAvL0RlZmF1bHQgdG8gYSByZWFzb25hYmxlIG51bWVyaWMgcHJlY2lzaW9uL3NjYWxlIHBlbmRpbmcgbW9yZSBzb3BoaXN0aWNhdGVkIGxvZ2ljXG4gICAgICAgIHBhcmFtVHlwZS50eXBlT3B0aW9ucyA9IHsgcHJlY2lzaW9uOiAzMCwgc2NhbGU6IGdldFNjYWxlKHZhbHVlKSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuQml0O1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5WYXJCaW5hcnk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbVR5cGU7XG4gIH1cblxuICBhc3luYyBfcnVuKGNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG5cbiAgICBjb25zdCBxdWVyeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFRSQU5TQUNUSU9OIFNVUFBPUlRcbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aCgnQkVHSU4gVFJBTlNBQ1RJT04nKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5iZWdpblRyYW5zYWN0aW9uKGVycm9yID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUsIGNvbm5lY3Rpb24ubGliLklTT0xBVElPTl9MRVZFTFtvcHRpb25zLmlzb2xhdGlvbkxldmVsXSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoJ0NPTU1JVCBUUkFOU0FDVElPTicpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNvbW1pdFRyYW5zYWN0aW9uKGVycm9yID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aCgnUk9MTEJBQ0sgVFJBTlNBQ1RJT04nKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5yb2xsYmFja1RyYW5zYWN0aW9uKGVycm9yID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKCdTQVZFIFRSQU5TQUNUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2F2ZVRyYW5zYWN0aW9uKGVycm9yID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3dzID0gW107XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGNvbm5lY3Rpb24ubGliLlJlcXVlc3Qoc3FsLCAoZXJyLCByb3dDb3VudCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKFtyb3dzLCByb3dDb3VudF0pKTtcblxuICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgXy5mb3JPd24ocGFyYW1ldGVycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbVR5cGUgPSB0aGlzLmdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlLCBjb25uZWN0aW9uLmxpYi5UWVBFUyk7XG4gICAgICAgICAgcmVxdWVzdC5hZGRQYXJhbWV0ZXIoa2V5LCBwYXJhbVR5cGUudHlwZSwgdmFsdWUsIHBhcmFtVHlwZS50eXBlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9uKCdyb3cnLCBjb2x1bW5zID0+IHtcbiAgICAgICAgcm93cy5wdXNoKGNvbHVtbnMpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbm5lY3Rpb24uZXhlY1NxbChyZXF1ZXN0KTtcbiAgICB9KTtcblxuICAgIGxldCByb3dzLCByb3dDb3VudDtcblxuICAgIHRyeSB7XG4gICAgICBbcm93cywgcm93Q291bnRdID0gYXdhaXQgcXVlcnk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIuc3FsID0gc3FsO1xuICAgICAgZXJyLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuXG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycik7XG4gICAgfVxuXG4gICAgY29tcGxldGUoKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3MpKSB7XG4gICAgICByb3dzID0gcm93cy5tYXAoY29sdW1ucyA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgY29uc3QgdHlwZWlkID0gY29sdW1uLm1ldGFkYXRhLnR5cGUuaWQ7XG4gICAgICAgICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQodHlwZWlkKTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBjb2x1bW4udmFsdWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiAhIXBhcnNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm93W2NvbHVtbi5tZXRhZGF0YS5jb2xOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJvd3MsIHJvd0NvdW50KTtcbiAgfVxuXG4gIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnF1ZXVlLmVucXVldWUoKCkgPT4gdGhpcy5fcnVuKHRoaXMuY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzKSk7XG4gIH1cblxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSB7fTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICBpZiAodmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaW5kUGFyYW1ba2V5XSA9IHZhbHVlc1trZXldO1xuICAgICAgICByZXR1cm4gYEAke2tleX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG5cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIFRoZSByZXN1bHQgb2YgdGhlIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0NvdW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBleGFtcGxlXG4gICAqIEV4YW1wbGU6XG4gICAqICBxdWVyeS5mb3JtYXRSZXN1bHRzKFtcbiAgICogICAge1xuICAgKiAgICAgIGlkOiAxLCAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgYXR0cjI6ICdzbmFmdScsICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBUYXNrcy5pZDogMSwgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICAgIFRhc2tzLnRpdGxlOiAndGFzaycgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgIH1cbiAgICogIF0pXG4gICAqL1xuICBmb3JtYXRSZXN1bHRzKGRhdGEsIHJvd0NvdW50KSB7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgaWYgKF9yZXN1bHQuRGVmYXVsdCkge1xuICAgICAgICAgIF9yZXN1bHQuRGVmYXVsdCA9IF9yZXN1bHQuRGVmYXVsdC5yZXBsYWNlKFwiKCdcIiwgJycpLnJlcGxhY2UoXCInKVwiLCAnJykucmVwbGFjZSgvJy9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuSXNOdWxsID09PSAnWUVTJyA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LkNvbnN0cmFpbnQgPT09ICdQUklNQVJZIEtFWScsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogX3Jlc3VsdC5Jc0lkZW50aXR5ID09PSAxLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlLmluY2x1ZGVzKCdDSEFSJylcbiAgICAgICAgICAmJiBfcmVzdWx0Lkxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoX3Jlc3VsdC5MZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlICs9ICcoTUFYKSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUgKz0gYCgke19yZXN1bHQuTGVuZ3RofSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd0NvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXSA/IGRhdGFbMF0uQUZGRUNURURST1dTIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgZGF0YVswXS4kYWN0aW9uID09PSAnSU5TRVJUJ107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW2RhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcChyZXN1bHRTZXQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSkge1xuICAgIC8vQ29udmVydCBzbmFrZV9jYXNlIGtleXMgdG8gY2FtZWxDYXNlIGFzIGl0J3MgZ2VuZXJhdGVkIGJ5IHN0b3JlZCBwcm9jZWR1cmVcbiAgICByZXR1cm4gZGF0YS5zbGljZSgxKS5tYXAocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICBjb25zdHJhaW50W18uY2FtZWxDYXNlKGtleSldID0gcmVzdWx0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICB9KTtcbiAgfVxuXG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIGxldCBtYXRjaDtcblxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1Zpb2xhdGlvbiBvZiAoPzpVTklRVUV8UFJJTUFSWSkgS0VZIGNvbnN0cmFpbnQgJyhbXiddKiknLiBDYW5ub3QgaW5zZXJ0IGR1cGxpY2F0ZSBrZXkgaW4gb2JqZWN0ICcuKicuKDo/IFRoZSBkdXBsaWNhdGUga2V5IHZhbHVlIGlzIFxcKCguKilcXCkuKT8vKTtcbiAgICBtYXRjaCA9IG1hdGNoIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9DYW5ub3QgaW5zZXJ0IGR1cGxpY2F0ZSBrZXkgcm93IGluIG9iamVjdCAuKiB3aXRoIHVuaXF1ZSBpbmRleCAnKC4qKScvKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbbWF0Y2hbMV1dO1xuICAgICAgbGV0IG1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBlcnJvcic7XG5cbiAgICAgIGlmICh1bmlxdWVLZXkgJiYgISF1bmlxdWVLZXkubXNnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoWzNdLnNwbGl0KCcsJykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbbWF0Y2hbMV1dID0gbWF0Y2hbM107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgIHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksXG4gICAgICAgICAgJ3VuaXF1ZSB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkRCLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgJ25vdF91bmlxdWUnXG4gICAgICAgICkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9GYWlsZWQgb24gc3RlcCAnKC4qKScuQ291bGQgbm90IGNyZWF0ZSBjb25zdHJhaW50LiBTZWUgcHJldmlvdXMgZXJyb3JzLi8pIHx8XG4gICAgICBlcnIubWVzc2FnZS5tYXRjaCgvVGhlIERFTEVURSBzdGF0ZW1lbnQgY29uZmxpY3RlZCB3aXRoIHRoZSBSRUZFUkVOQ0UgY29uc3RyYWludCBcIiguKilcIi4gVGhlIGNvbmZsaWN0IG9jY3VycmVkIGluIGRhdGFiYXNlIFwiKC4qKVwiLCB0YWJsZSBcIiguKilcIiwgY29sdW1uICcoLiopJy4vKSB8fFxuICAgICAgZXJyLm1lc3NhZ2UubWF0Y2goL1RoZSAoPzpJTlNFUlR8TUVSR0V8VVBEQVRFKSBzdGF0ZW1lbnQgY29uZmxpY3RlZCB3aXRoIHRoZSBGT1JFSUdOIEtFWSBjb25zdHJhaW50IFwiKC4qKVwiLiBUaGUgY29uZmxpY3Qgb2NjdXJyZWQgaW4gZGF0YWJhc2UgXCIoLiopXCIsIHRhYmxlIFwiKC4qKVwiLCBjb2x1bW4gJyguKiknLi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgZmllbGRzOiBudWxsLFxuICAgICAgICBpbmRleDogbWF0Y2hbMV0sXG4gICAgICAgIHBhcmVudDogZXJyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9Db3VsZCBub3QgZHJvcCBjb25zdHJhaW50LiBTZWUgcHJldmlvdXMgZXJyb3JzLi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgY29uc3RyYWludCA9IGVyci5zcWwubWF0Y2goLyg/OmNvbnN0cmFpbnR8aW5kZXgpIFxcWyguKz8pXFxdL2kpO1xuICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnQgPyBjb25zdHJhaW50WzFdIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IHRhYmxlID0gZXJyLnNxbC5tYXRjaCgvdGFibGUgXFxbKC4rPylcXF0vaSk7XG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBtYXRjaFsxXSxcbiAgICAgICAgY29uc3RyYWludCxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHBhcmVudDogZXJyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gIH1cblxuICBpc1Nob3dPckRlc2NyaWJlUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNlbGVjdCBjLmNvbHVtbl9uYW1lIGFzICduYW1lJywgYy5kYXRhX3R5cGUgYXMgJ3R5cGUnLCBjLmlzX251bGxhYmxlIGFzICdpc251bGwnXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3NlbGVjdCB0YWJsZW5hbWUgPSB0Lm5hbWUsIG5hbWUgPSBpbmQubmFtZSwnKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWUnKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lJyk7XG4gIH1cblxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICAvLyBHcm91cCBieSBpbmRleCBuYW1lLCBhbmQgY29sbGVjdCBhbGwgZmllbGRzXG4gICAgZGF0YSA9IGRhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmICghKGl0ZW0uaW5kZXhfbmFtZSBpbiBhY2MpKSB7XG4gICAgICAgIGFjY1tpdGVtLmluZGV4X25hbWVdID0gaXRlbTtcbiAgICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5pbmRleF9rZXlzLnNwbGl0KCcsJykuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICBsZXQgY29sdW1uTmFtZSA9IGNvbHVtbi50cmltKCk7XG4gICAgICAgIGlmIChjb2x1bW5OYW1lLmluY2x1ZGVzKCcoLSknKSkge1xuICAgICAgICAgIGNvbHVtbk5hbWUgPSBjb2x1bW5OYW1lLnJlcGxhY2UoJygtKScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjY1tpdGVtLmluZGV4X25hbWVdLmZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgbGVuZ3RoOiB1bmRlZmluZWQsXG4gICAgICAgICAgb3JkZXI6IGNvbHVtbi5pbmNsdWRlcygnKC0pJykgPyAnREVTQycgOiAnQVNDJyxcbiAgICAgICAgICBjb2xsYXRlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBpdGVtLmluZGV4X2tleXM7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBfLm1hcChkYXRhLCBpdGVtID0+ICh7XG4gICAgICBwcmltYXJ5OiBpdGVtLmluZGV4X25hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdwaycpLFxuICAgICAgZmllbGRzOiBpdGVtLmZpZWxkcyxcbiAgICAgIG5hbWU6IGl0ZW0uaW5kZXhfbmFtZSxcbiAgICAgIHRhYmxlTmFtZTogdW5kZWZpbmVkLFxuICAgICAgdW5pcXVlOiBpdGVtLmluZGV4X2Rlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3VuaXF1ZScpLFxuICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgfSkpO1xuICB9XG5cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgLy8gYWRkIHRoZSBpbnNlcnRlZCByb3cgaWQgdG8gdGhlIGluc3RhbmNlXG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50QXR0cmlidXRlID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGlkID0gbnVsbDtcbiAgICAgIGxldCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSBudWxsO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSkgJiZcbiAgICAgICAgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZDtcblxuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlXTtcbiAgICAgIGlkID0gaWQgfHwgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzICYmIHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXNdO1xuXG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdID0gaWQ7XG5cbiAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0c1swXSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0c1swXSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVzdWx0c1swXVtrZXldO1xuICBcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcbiAgXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5teXNxbDtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246bXlzcWwnKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnbXlzcWwnKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogTXlTUUwgQ29ubmVjdGlvbiBNYW5hZ2VyXG4gKlxuICogR2V0IGNvbm5lY3Rpb25zLCB2YWxpZGF0ZSBhbmQgZGlzY29ubmVjdCB0aGVtLlxuICogQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciBwb29saW5nIHVzZSBpdCB0byBoYW5kbGUgTXlTUUwgc3BlY2lmaWMgY29ubmVjdGlvbnNcbiAqIFVzZSBodHRwczovL2dpdGh1Yi5jb20vc2lkb3JhcmVzL25vZGUtbXlzcWwyIHRvIGNvbm5lY3Qgd2l0aCBNeVNRTCBzZXJ2ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoJ215c3FsMicpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuXG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG5cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG5cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3Qgd2l0aCBNeVNRTCBkYXRhYmFzZSBiYXNlZCBvbiBjb25maWcsIEhhbmRsZSBhbnkgZXJyb3JzIGluIGNvbm5lY3Rpb25cbiAgICogU2V0IHRoZSBwb29sIGhhbmRsZXJzIG9uIGNvbm5lY3Rpb24uZXJyb3JcbiAgICogQWxzbyBzZXQgcHJvcGVyIHRpbWV6b25lIG9uY2UgY29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgZmxhZ3M6ICctRk9VTkRfUk9XUycsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIHRpbWV6b25lOiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lLFxuICAgICAgdHlwZUNhc3Q6IENvbm5lY3Rpb25NYW5hZ2VyLl90eXBlY2FzdC5iaW5kKHRoaXMpLFxuICAgICAgYmlnTnVtYmVyU3RyaW5nczogZmFsc2UsXG4gICAgICBzdXBwb3J0QmlnTnVtYmVyczogdHJ1ZSxcbiAgICAgIC4uLmNvbmZpZy5kaWFsZWN0T3B0aW9uc1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMubGliLmNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZSA9PiB7XG4gICAgICAgICAgLy8gY2xlYW4gdXAgY29ubmVjdCAmIGVycm9yIGV2ZW50IGlmIHRoZXJlIGlzIGVycm9yXG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gY2xlYW4gdXAgZXJyb3IgZXZlbnQgaWYgY29ubmVjdGVkXG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbm5lY3Rpb24ub25jZSBmb3IgZXJyb3IgZXZlbnQgaGFuZGxpbmcgaGVyZVxuICAgICAgICAvLyBteXNxbDIgZW1pdCBlcnJvciB0d28gdGltZXMgaW4gY2FzZSBoYW5kc2hha2Ugd2FzIGZhaWxlZFxuICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyBwcm90b2NvbF9sb3N0IGFuZCBzZWNvbmQgaXMgdGltZW91dFxuICAgICAgICAvLyBpZiB3ZSB3aWxsIHVzZSBgb25jZS5lcnJvcmAgbm9kZSBwcm9jZXNzIHdpbGwgY3Jhc2ggb24gMm5kIGVycm9yIGVtaXRcbiAgICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gYWNxdWlyZWQnKTtcbiAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICBjYXNlICdFU09DS0VUJzpcbiAgICAgICAgICBjYXNlICdFQ09OTlJFU0VUJzpcbiAgICAgICAgICBjYXNlICdFUElQRSc6XG4gICAgICAgICAgY2FzZSAnUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUJzpcbiAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgICAvLyBzZXQgdGltZXpvbmUgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAgICAvLyBidXQgbmFtZWQgdGltZXpvbmUgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQgaW4gbXlzcWwsIHNvIGdldCBpdHMgb2Zmc2V0IGZpcnN0XG4gICAgICAgIGxldCB0ek9mZnNldCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmU7XG4gICAgICAgIHR6T2Zmc2V0ID0gL1xcLy8udGVzdCh0ek9mZnNldCkgPyBtb21lbnRUei50eih0ek9mZnNldCkuZm9ybWF0KCdaJykgOiB0ek9mZnNldDtcbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5KGNiID0+IGNvbm5lY3Rpb24ucXVlcnkoYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYCwgY2IpKSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSAnRUNPTk5SRUZVU0VEJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRVJfQUNDRVNTX0RFTklFRF9FUlJPUic6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFTk9URk9VTkQnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRUhPU1RVTlJFQUNIJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFSU5WQUwnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgLy8gRG9uJ3QgZGlzY29ubmVjdCBjb25uZWN0aW9ucyB3aXRoIENMT1NFRCBzdGF0ZVxuICAgIGlmIChjb25uZWN0aW9uLl9jbG9zaW5nKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KGNhbGxiYWNrID0+IGNvbm5lY3Rpb24uZW5kKGNhbGxiYWNrKSkoKTtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvblxuICAgICAgJiYgIWNvbm5lY3Rpb24uX2ZhdGFsRXJyb3JcbiAgICAgICYmICFjb25uZWN0aW9uLl9wcm90b2NvbEVycm9yXG4gICAgICAmJiAhY29ubmVjdGlvbi5fY2xvc2luZ1xuICAgICAgJiYgIWNvbm5lY3Rpb24uc3RyZWFtLmRlc3Ryb3llZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgd2t4ID0gcmVxdWlyZSgnd2t4Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gQmFzZVR5cGVzID0+IHtcbiAgQmFzZVR5cGVzLkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSAnaHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2RhdGEtdHlwZXMuaHRtbCc7XG5cbiAgLyoqXG4gICAqIHR5cGVzOiBbYnVmZmVyX3R5cGUsIC4uLl1cbiAgICpcbiAgICogQHNlZSBidWZmZXJfdHlwZSBoZXJlIGh0dHBzOi8vZGV2Lm15c3FsLmNvbS9kb2MvcmVmbWFuLzUuNy9lbi9jLWFwaS1wcmVwYXJlZC1zdGF0ZW1lbnQtdHlwZS1jb2Rlcy5odG1sXG4gICAqIEBzZWUgaGV4IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3NpZG9yYXJlcy9ub2RlLW15c3FsMi9ibG9iL21hc3Rlci9saWIvY29uc3RhbnRzL3R5cGVzLmpzXG4gICAqL1xuXG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm15c3FsID0gWydEQVRFVElNRSddO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm15c3FsID0gWydWQVJfU1RSSU5HJ107XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm15c3FsID0gWydTVFJJTkcnXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubXlzcWwgPSBbJ0JMT0InXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubXlzcWwgPSBbJ1RJTlknXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm15c3FsID0gWydTSE9SVCddO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm15c3FsID0gWydJTlQyNCddO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5teXNxbCA9IFsnTE9ORyddO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm15c3FsID0gWydMT05HTE9ORyddO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubXlzcWwgPSBbJ0ZMT0FUJ107XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm15c3FsID0gWydUSU1FJ107XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5teXNxbCA9IFsnREFURSddO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5teXNxbCA9IFsnVElOWSddO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5teXNxbCA9IFsnVElOWUJMT0InLCAnQkxPQicsICdMT05HQkxPQiddO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5teXNxbCA9IFsnTkVXREVDSU1BTCddO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5teXNxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5teXNxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5teXNxbCA9IFsnRE9VQkxFJ107XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubXlzcWwgPSBbJ0RPVUJMRSddO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubXlzcWwgPSBbJ0dFT01FVFJZJ107XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLm15c3FsID0gWydKU09OJ107XG5cbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gc3VwZXIudG9TcWwoKTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICBkZWZpbml0aW9uICs9ICcgVU5TSUdORUQnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gJyBaRVJPRklMTCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aCA/IGBEQVRFVElNRSgke3RoaXMuX2xlbmd0aH0pYCA6ICdEQVRFVElNRSc7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICAvLyBGcmFjdGlvbmFsIERBVEVUSU1FcyBvbmx5IHN1cHBvcnRlZCBvbiBNeVNRTCA1LjYuNCtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzLlNTUycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzJyk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9tZW50LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnQudHoodmFsdWUsIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYCR7dmFsdWV9ICR7b3B0aW9ucy50aW1lem9uZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0NIQVIoMzYpIEJJTkFSWSc7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgU1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTID0gWydQT0lOVCcsICdMSU5FU1RSSU5HJywgJ1BPTFlHT04nXTtcblxuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgICAgc3VwZXIodHlwZSwgc3JpZCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy5rZXk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChTVVBQT1JURURfR0VPTUVUUllfVFlQRVMuaW5jbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3VwcG9ydGVkIGdlb21ldHJ5IHR5cGVzIGFyZTogJHtTVVBQT1JURURfR0VPTUVUUllfVFlQRVMuam9pbignLCAnKX1gKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcigpO1xuICAgICAgLy8gRW1wdHkgYnVmZmVyLCBNeVNRTCBkb2Vzbid0IHN1cHBvcnQgUE9JTlQgRU1QVFlcbiAgICAgIC8vIGNoZWNrLCBodHRwczovL2Rldi5teXNxbC5jb20vd29ya2xvZy90YXNrLz9pZD0yMzgxXG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgZGlzY2FyZCB0aGUgZmlyc3QgNCBieXRlc1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSg0KTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UodmFsdWUpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNxbFR5cGU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYEVOVU0oJHt0aGlzLnZhbHVlcy5tYXAodmFsdWUgPT4gb3B0aW9ucy5lc2NhcGUodmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ3doZXJlJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBFTlVNLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgVVVJRCxcbiAgICBHRU9NRVRSWSxcbiAgICBERUNJTUFMLFxuICAgIEpTT046IEpTT05UWVBFXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKCcuLi9hYnN0cmFjdCcpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubXlzcWw7XG5jb25zdCB7IE15U1FMUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4vcXVlcnktaW50ZXJmYWNlJyk7XG5cbmNsYXNzIE15c3FsRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE15U1FMUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuXG5NeXNxbERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICAnVkFMVUVTICgpJzogdHJ1ZSxcbiAgJ0xJTUlUIE9OIFVQREFURSc6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGZvclNoYXJlOiAnTE9DSyBJTiBTSEFSRSBNT0RFJyxcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IGZhbHNlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogJyBJR05PUkUnLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiAnIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFJ1xuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwYXJzZXI6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogMVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZSxcbiAgICBjaGVjazogZmFsc2VcbiAgfSxcbiAgaW5kZXhWaWFBbHRlcjogdHJ1ZSxcbiAgaW5kZXhIaW50czogdHJ1ZSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgR0VPTUVUUlk6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIFJFR0VYUDogdHJ1ZVxufSk7XG5cbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSAnNS43LjAnO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeUdlbmVyYXRvciA9IFF1ZXJ5R2VuZXJhdG9yO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLm5hbWUgPSAnbXlzcWwnO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnYCc7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IE15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE15c3FsRGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3JzJyk7XG5cblxuY29uc3QgSlNPTl9GVU5DVElPTl9SRUdFWCA9IC9eXFxzKigoPzpbYS16XStfKXswLDJ9anNvbmI/KD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuY29uc3QgSlNPTl9PUEVSQVRPUl9SRUdFWCA9IC9eXFxzKigtPj4/fEA+fDxAfFxcP1t8Jl0/fFxcfHsyfXwjLSkvaTtcbmNvbnN0IFRPS0VOX0NBUFRVUkVfUkVHRVggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcbmNvbnN0IEZPUkVJR05fS0VZX0ZJRUxEUyA9IFtcbiAgJ0NPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50X25hbWUnLFxuICAnQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnROYW1lJyxcbiAgJ0NPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRTY2hlbWEnLFxuICAnQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludENhdGFsb2cnLFxuICAnVEFCTEVfTkFNRSBhcyB0YWJsZU5hbWUnLFxuICAnVEFCTEVfU0NIRU1BIGFzIHRhYmxlU2NoZW1hJyxcbiAgJ1RBQkxFX1NDSEVNQSBhcyB0YWJsZUNhdGFsb2cnLFxuICAnQ09MVU1OX05BTUUgYXMgY29sdW1uTmFtZScsXG4gICdSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVTY2hlbWEnLFxuICAnUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZycsXG4gICdSRUZFUkVOQ0VEX1RBQkxFX05BTUUgYXMgcmVmZXJlbmNlZFRhYmxlTmFtZScsXG4gICdSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIGFzIHJlZmVyZW5jZWRDb2x1bW5OYW1lJ1xuXS5qb2luKCcsJyk7XG5cbmNvbnN0IHR5cGVXaXRob3V0RGVmYXVsdCA9IG5ldyBTZXQoWydCTE9CJywgJ1RFWFQnLCAnR0VPTUVUUlknLCAnSlNPTiddKTtcblxuY2xhc3MgTXlTUUxRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLk9wZXJhdG9yTWFwID0ge1xuICAgICAgLi4udGhpcy5PcGVyYXRvck1hcCxcbiAgICAgIFtPcC5yZWdleHBdOiAnUkVHRVhQJyxcbiAgICAgIFtPcC5ub3RSZWdleHBdOiAnTk9UIFJFR0VYUCdcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdDUkVBVEUgREFUQUJBU0UgSUYgTk9UIEVYSVNUUycsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJBQ1RFUiBTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNoYXJzZXQpfWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYERFRkFVTFQgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIERBVEFCQVNFIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSl9O2A7XG4gIH1cblxuICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgcmV0dXJuICdTSE9XIFRBQkxFUyc7XG4gIH1cblxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiAnU0hPVyBUQUJMRVMnO1xuICB9XG5cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiAnU0VMRUNUIFZFUlNJT04oKSBhcyBgdmVyc2lvbmAnO1xuICB9XG5cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgZW5naW5lOiAnSW5ub0RCJyxcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICByb3dGb3JtYXQ6IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW107XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSB7fTtcbiAgICBjb25zdCBhdHRyU3RyID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpIHtcbiAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcblxuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICAgIC8vIE15U1FMIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgUkVGRVJFTkNFUyBkZWNsYXJhdGlvbnM6IG1vdmUgdG8gdGhlIGVuZFxuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICcnKX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICcnKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIC8vIE15U1FMIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgUkVGRVJFTkNFUyBkZWNsYXJhdGlvbnM6IG1vdmUgdG8gdGhlIGVuZFxuICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNDbGF1c2UgPSBhdHRyU3RyLmpvaW4oJywgJyk7XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAocGsgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKCcsICcpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbignXycpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgVU5JUVVFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gKCR7Y29sdW1ucy5maWVsZHMubWFwKGZpZWxkID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUycsXG4gICAgICB0YWJsZSxcbiAgICAgIGAoJHthdHRyaWJ1dGVzQ2xhdXNlfSlgLFxuICAgICAgYEVOR0lORT0ke29wdGlvbnMuZW5naW5lfWAsXG4gICAgICBvcHRpb25zLmNvbW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ3N0cmluZycgJiYgYENPTU1FTlQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbW1lbnQpfWAsXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUlNFVD0ke29wdGlvbnMuY2hhcnNldH1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBDT0xMQVRFICR7b3B0aW9ucy5jb2xsYXRlfWAsXG4gICAgICBvcHRpb25zLmluaXRpYWxBdXRvSW5jcmVtZW50ICYmIGBBVVRPX0lOQ1JFTUVOVD0ke29wdGlvbnMuaW5pdGlhbEF1dG9JbmNyZW1lbnR9YCxcbiAgICAgIG9wdGlvbnMucm93Rm9ybWF0ICYmIGBST1dfRk9STUFUPSR7b3B0aW9ucy5yb3dGb3JtYXR9YCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZShcbiAgICAgIHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlclxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGBTSE9XIEZVTEwgQ09MVU1OUyBGUk9NICR7dGFibGV9O2A7XG4gIH1cblxuICBzaG93VGFibGVzUXVlcnkoZGF0YWJhc2UpIHtcbiAgICBsZXQgcXVlcnkgPSAnU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSBcXCdCQVNFIFRBQkxFXFwnJztcbiAgICBpZiAoZGF0YWJhc2UpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoZGF0YWJhc2UpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ICs9ICcgQU5EIFRBQkxFX1NDSEVNQSBOT1QgSU4gKFxcJ01ZU1FMXFwnLCBcXCdJTkZPUk1BVElPTl9TQ0hFTUFcXCcsIFxcJ1BFUkZPUk1BTkNFX1NDSEVNQVxcJywgXFwnU1lTXFwnKSc7XG4gICAgfVxuICAgIHJldHVybiBgJHtxdWVyeX07YDtcbiAgfVxuXG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICAnQUREJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7XG4gICAgICAgIGNvbnRleHQ6ICdhZGRDb2x1bW4nLFxuICAgICAgICB0YWJsZU5hbWU6IHRhYmxlLFxuICAgICAgICBmb3JlaWduS2V5OiBrZXlcbiAgICAgIH0pLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnRFJPUCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRTdHJpbmcgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgJycpO1xuICAgICAgICBjb25zdHJhaW50U3RyaW5nLnB1c2goYEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSkgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0cmluZy5wdXNoKGBcXGAke2F0dHJpYnV0ZU5hbWV9XFxgIFxcYCR7YXR0cmlidXRlTmFtZX1cXGAgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJTdHJpbmcubGVuZ3RoICYmIGBDSEFOR0UgJHthdHRyU3RyaW5nLmpvaW4oJywgJyl9YCxcbiAgICAgIGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoICYmIGBBREQgJHtjb25zdHJhaW50U3RyaW5nLmpvaW4oJywgJyl9YCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICBhdHRyU3RyaW5nLnB1c2goYFxcYCR7YXR0ckJlZm9yZX1cXGAgXFxgJHthdHRyTmFtZX1cXGAgJHtkZWZpbml0aW9ufWApO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdDSEFOR0UnLFxuICAgICAgYXR0clN0cmluZy5qb2luKCcsICcpLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICAvLyBQYXJzZSBuZXN0ZWQgb2JqZWN0XG4gICAgICBpZiAoc210aC5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHNtdGguY29uZGl0aW9ucykubWFwKGNvbmRpdGlvbiA9PlxuICAgICAgICAgIGAke3RoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29uZGl0aW9uLnBhdGhbMF0sIF8udGFpbChjb25kaXRpb24ucGF0aCkpfSA9ICcke2NvbmRpdGlvbi52YWx1ZX0nYFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb25zLmpvaW4oJyBBTkQgJyk7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5wYXRoKSB7XG4gICAgICAgIGxldCBzdHI7XG5cbiAgICAgICAgLy8gQWxsb3cgc3BlY2lmeWluZyBjb25kaXRpb25zIHVzaW5nIHRoZSBzcWxpdGUganNvbiBmdW5jdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHNtdGgucGF0aCkpIHtcbiAgICAgICAgICBzdHIgPSBzbXRoLnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxzbyBzdXBwb3J0IGpzb24gcHJvcGVydHkgYWNjZXNzb3JzXG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBfLnRvUGF0aChzbXRoLnBhdGgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhdGhzLnNoaWZ0KCk7XG4gICAgICAgICAgc3RyID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KCcgPSAlcycsIHRoaXMuZXNjYXBlKHNtdGgudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKC90aW1lc3RhbXAvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gJ2RhdGV0aW1lJztcbiAgICAgIH0gZWxzZSBpZiAoc210aC5qc29uICYmIC9ib29sZWFuL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIC8vIHRydWUgb3IgZmFsc2UgY2Fubm90IGJlIGNhc3RlZCBhcyBib29sZWFucyB3aXRoaW4gYSBKU09OIHN0cnVjdHVyZVxuICAgICAgICBzbXRoLnR5cGUgPSAnY2hhcic7XG4gICAgICB9IGVsc2UgaWYgKC9kb3VibGUgcHJlY2lzaW9uL2kudGVzdChzbXRoLnR5cGUpIHx8IC9ib29sZWFuL2kudGVzdChzbXRoLnR5cGUpIHx8IC9pbnRlZ2VyL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9ICdkZWNpbWFsJztcbiAgICAgIH0gZWxzZSBpZiAoL3RleHQvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gJ2NoYXInO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuXG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIC8vIHRydWUvZmFsc2UgYXJlIHN0b3JlZCBhcyBzdHJpbmdzIGluIG15c3FsXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8gbnVsbCBpcyBzdG9yZWQgYXMgYSBzdHJpbmcgaW4gbXlzcWxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBsZXQgbGltaXQgPSAnJztcbiAgICBsZXQgcXVlcnkgPSBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGxpbWl0ID0gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfWA7XG4gICAgfVxuXG4gICAgd2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICBxdWVyeSArPSBgIFdIRVJFICR7d2hlcmV9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnkgKyBsaW1pdDtcbiAgfVxuXG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYFNIT1cgSU5ERVggRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuZGF0YWJhc2UgJiYgYEZST00gXFxgJHtvcHRpb25zLmRhdGFiYXNlfVxcYGBcbiAgICBdKTtcbiAgfVxuXG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hO1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCBDT05TVFJBSU5UX0NBVEFMT0cgQVMgY29uc3RyYWludENhdGFsb2csJyxcbiAgICAgICdDT05TVFJBSU5UX05BTUUgQVMgY29uc3RyYWludE5hbWUsJyxcbiAgICAgICdDT05TVFJBSU5UX1NDSEVNQSBBUyBjb25zdHJhaW50U2NoZW1hLCcsXG4gICAgICAnQ09OU1RSQUlOVF9UWVBFIEFTIGNvbnN0cmFpbnRUeXBlLCcsXG4gICAgICAnVEFCTEVfTkFNRSBBUyB0YWJsZU5hbWUsJyxcbiAgICAgICdUQUJMRV9TQ0hFTUEgQVMgdGFibGVTY2hlbWEnLFxuICAgICAgJ2Zyb20gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTJyxcbiAgICAgIGBXSEVSRSB0YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nYCxcbiAgICAgIGNvbnN0cmFpbnROYW1lICYmIGBBTkQgY29uc3RyYWludF9uYW1lID0gJyR7Y29uc3RyYWludE5hbWV9J2AsXG4gICAgICBzY2hlbWFOYW1lICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKCdfJyl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0RST1AgSU5ERVgnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKSxcbiAgICAgICdPTicsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKVxuICAgIF0pO1xuICB9XG5cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlU3RyaW5nID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoeyBlc2NhcGU6IHRoaXMuZXNjYXBlLmJpbmQodGhpcykgfSk7XG4gICAgbGV0IHRlbXBsYXRlID0gYXR0cmlidXRlU3RyaW5nO1xuXG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIE5PVCBOVUxMJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgYXV0b19pbmNyZW1lbnQnO1xuICAgIH1cblxuICAgIC8vIEJMT0IvVEVYVC9HRU9NRVRSWS9KU09OIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICghdHlwZVdpdGhvdXREZWZhdWx0LmhhcyhhdHRyaWJ1dGVTdHJpbmcpXG4gICAgICAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlXG4gICAgICAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgVU5JUVVFJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgUFJJTUFSWSBLRVknO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmNvbW1lbnQpfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5maXJzdCkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBGSVJTVCc7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYWZ0ZXIpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQUZURVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuYWZ0ZXIpfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09ICdhZGRDb2x1bW4nICYmIG9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIGNvbnN0IGZrTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGAke29wdGlvbnMudGFibGVOYW1lfV8ke2F0dHJOYW1lfV9mb3JlaWduX2lkeGApO1xuXG4gICAgICAgIHRlbXBsYXRlICs9IGAsIEFERCBDT05TVFJBSU5UICR7ZmtOYW1lfSBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pYDtcbiAgICAgIH1cblxuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoJ2lkJyl9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgc3RhdG1lbWVudCBpcyBqc29uIGZ1bmN0aW9uIG9yIHNpbXBsZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICBzdG10ICBUaGUgc3RhdGVtZW50IHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgICB0cnVlIGlmIHRoZSBnaXZlbiBzdGF0ZW1lbnQgaXMganNvbiBmdW5jdGlvblxuICAgKiBAdGhyb3dzICB7RXJyb3J9ICAgICAgICAgdGhyb3cgaWYgdGhlIHN0YXRlbWVudCBsb29rcyBsaWtlIGpzb24gZnVuY3Rpb24gYnV0IGhhcyBpbnZhbGlkIHRva2VuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0gSlNPTl9GVU5DVElPTl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZignKCcpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0gSlNPTl9PUEVSQVRPUl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gVE9LRU5fQ0FQVFVSRV9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSAnKCcpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnKScpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnOycpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW52YWxpZCBqc29uIHN0YXRlbWVudFxuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgKGhhc0ludmFsaWRUb2tlbiB8fCBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0cnVlIGlmIHRoZSBzdGF0ZW1lbnQgaGFzIHZhbGlkIGpzb24gZnVuY3Rpb25cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIGFsbCBmb3JlaWduIGtleXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YWJsZSAgVGhlIHRhYmxlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNjaGVtYU5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYS5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIHNjaGVtYU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCcsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICBgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSB3aGVyZSBUQUJMRV9OQU1FID0gJyR7dGFibGVOYW1lfSdgLFxuICAgICAgYEFORCBDT05TVFJBSU5UX05BTUUhPSdQUklNQVJZJyBBTkQgQ09OU1RSQUlOVF9TQ0hFTUE9JyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgICdBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMJyxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIHRoZSBmb3JlaWduIGtleSBjb25zdHJhaW50IG9mIGEgZ2l2ZW4gY29sdW1uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHRhYmxlICBUaGUgdGFibGUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY29sdW1uTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sdW1uLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkU2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSA/IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpIDogJyc7XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uTmFtZSA9IHdyYXBTaW5nbGVRdW90ZShjb2x1bW5OYW1lKTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QnLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgJ0ZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0UnLFxuICAgICAgJ1dIRVJFICgnLFxuICAgICAgW1xuICAgICAgICBgUkVGRVJFTkNFRF9UQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWBcbiAgICAgIF0sXG4gICAgICAnKSBPUiAoJyxcbiAgICAgIFtcbiAgICAgICAgYFRBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBDT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gLFxuICAgICAgICAnQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTCdcbiAgICAgIF0sXG4gICAgICAnKSdcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmVtb3ZlcyBhIGZvcmVpZ24ga2V5IGZyb20gYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBmb3JlaWduS2V5IFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBjb25zdHJhaW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnRFJPUCBGT1JFSUdOIEtFWScsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG59XG5cbi8vIHByaXZhdGUgbWV0aG9kc1xuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKGlkZW50aWZpZXIsICdcXCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNeVNRTFF1ZXJ5R2VuZXJhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZScpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSB0aGF0IFNlcXVlbGl6ZSB1c2VzIHRvIHRhbGsgd2l0aCBNeVNRTC9NYXJpYURCIGRhdGFiYXNlXG4gKi9cbmNsYXNzIE15U1FMUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgdGhhdCBmaXhlcyBNeVNRTCdzIGluYWJpbGl0eSB0byBjbGVhbmx5IHJlbW92ZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzIGlmIHRoZXkgaGF2ZSBhIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgICB9LCBjb2x1bW5OYW1lKSxcbiAgICAgIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH1cbiAgICApO1xuXG4gICAgLy9FeGNsdWRlIHByaW1hcnkga2V5IGNvbnN0cmFpbnRcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggJiYgcmVzdWx0c1swXS5jb25zdHJhaW50X25hbWUgIT09ICdQUklNQVJZJykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoY29uc3RyYWludCA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50X25hbWUpLFxuICAgICAgICB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9XG4gICAgICApKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGNvbHVtbk5hbWUpLFxuICAgICAgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcblxuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCBtb2RlbC5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0NvbnN0cmFpbnRzUXVlcnkoXG4gICAgICB0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgICB9LCBjb25zdHJhaW50TmFtZSk7XG5cbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLFxuICAgICAgdHlwZTogdGhpcy5zZXF1ZWxpemUuUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFMgfSk7XG5cbiAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludHNbMF07XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICghY29uc3RyYWludCB8fCAhY29uc3RyYWludC5jb25zdHJhaW50VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKFxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZTogYENvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gb24gdGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50TmFtZSxcbiAgICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSAnRk9SRUlHTiBLRVknKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUluZGV4UXVlcnkoY29uc3RyYWludC50YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0cy5NeVNRTFF1ZXJ5SW50ZXJmYWNlID0gTXlTUUxRdWVyeUludGVyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5Jyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcblxuY29uc3QgRVJfRFVQX0VOVFJZID0gMTA2MjtcbmNvbnN0IEVSX0RFQURMT0NLID0gMTIxMztcbmNvbnN0IEVSX1JPV19JU19SRUZFUkVOQ0VEID0gMTQ1MTtcbmNvbnN0IEVSX05PX1JFRkVSRU5DRURfUk9XID0gMTQ1MjtcblxuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdzcWw6bXlzcWwnKTtcblxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbiwgc2VxdWVsaXplLCB7IHNob3dXYXJuaW5nczogZmFsc2UsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBbXTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzXykgPT4ge1xuICAgICAgaWYgKHZhbHVlc19ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJpbmRQYXJhbS5wdXNoKHZhbHVlc19ba2V5XSk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtLmxlbmd0aCA+IDAgPyBiaW5kUGFyYW0gOiB1bmRlZmluZWRdO1xuICB9XG5cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcblxuICAgIGNvbnN0IHNob3dXYXJuaW5ncyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc2hvd1dhcm5pbmdzIHx8IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcblxuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBkZWJ1ZygncGFyYW1ldGVycyglaiknLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cztcblxuICAgIHRyeSB7XG4gICAgICBpZiAocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC5leGVjdXRlKHNxbCwgcGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSlcbiAgICAgICAgICAgIC5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC5xdWVyeSh7IHNxbCB9LCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKVxuICAgICAgICAgICAgLnNldE1heExpc3RlbmVycygxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgZXJyb3IuZXJybm8gPT09IEVSX0RFQURMT0NLKSB7XG4gICAgICAgIC8vIE15U1FMIGF1dG9tYXRpY2FsbHkgcm9sbHMtYmFjayB0cmFuc2FjdGlvbnMgaW4gdGhlIGV2ZW50IG9mIGEgZGVhZGxvY2suXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIHN0aWxsIGluaXRpYXRlIGEgbWFudWFsIHJvbGxiYWNrIHRvIGVuc3VyZSB0aGUgY29ubmVjdGlvbiBnZXRzIHJlbGVhc2VkIC0gc2VlICMxMzEwMi5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvcHRpb25zLnRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgLSBzaW5jZSBNeVNRTCBhdXRvbWF0aWNhbGx5IHJvbGxlZCBiYWNrLCB3ZSdyZVxuICAgICAgICAgIC8vIG5vdCB0aGF0IHdvcnJpZWQgYWJvdXQgdGhpcyByZWR1bmRhbnQgcm9sbGJhY2sgZmFpbGluZy5cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgPSAncm9sbGJhY2snO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChzaG93V2FybmluZ3MgJiYgcmVzdWx0cyAmJiByZXN1bHRzLndhcm5pbmdTdGF0dXMgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1dhcm5pbmdzKHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgZXhlY3V0aW9uLlxuICAgKlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgcXVlcnkuZm9ybWF0UmVzdWx0cyhbXG4gICAqICAgIHtcbiAgICogICAgICBpZDogMSwgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIGF0dHIyOiAnc25hZnUnLCAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgVGFza3MuaWQ6IDEsICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgICBUYXNrcy50aXRsZTogJ3Rhc2snIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICB9XG4gICAqICBdKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gVGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgZXhlY3V0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuXG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gaGFuZGxlIGJ1bGtDcmVhdGUgQUkgcHJpbWFyeSBrZXlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1Jlc3VsdFNldEhlYWRlcidcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgZGF0YS5hZmZlY3RlZFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBbdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGRdOiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBlbnVtUmVnZXggPSAvXmVudW0vaTtcbiAgICAgICAgcmVzdWx0W19yZXN1bHQuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IGVudW1SZWdleC50ZXN0KF9yZXN1bHQuVHlwZSkgPyBfcmVzdWx0LlR5cGUucmVwbGFjZShlbnVtUmVnZXgsICdFTlVNJykgOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTnVsbCA9PT0gJ1lFUycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXkgPT09ICdQUkknLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCAnRXh0cmEnKVxuICAgICAgICAgICAgJiYgX3Jlc3VsdC5FeHRyYS50b0xvd2VyQ2FzZSgpID09PSAnYXV0b19pbmNyZW1lbnQnLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudCA/IF9yZXN1bHQuQ29tbWVudCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhLmFmZmVjdGVkUm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93cyA9PT0gMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICAvLyBNeVNRTCByZXR1cm5zIHJvdyBkYXRhIGFuZCBtZXRhZGF0YSAoYWZmZWN0ZWQgcm93cyBldGMpIGluIGEgc2luZ2xlIG9iamVjdCAtIGxldCdzIHN0YW5kYXJpemUgaXQsIHNvcnRhXG4gICAgICByZXR1cm4gW2RhdGEsIGRhdGFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBsb2dXYXJuaW5ncyhyZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FybmluZ1Jlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bignU0hPVyBXQVJOSU5HUycpO1xuICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYE15U1FMIFdhcm5pbmdzICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8ICdkZWZhdWx0J30pOiBgO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBfd2FybmluZ1JvdyBvZiB3YXJuaW5nUmVzdWx0cykge1xuICAgICAgaWYgKF93YXJuaW5nUm93ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIF93YXJuaW5nUm93W1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF93YXJuaW5nUmVzdWx0IG9mIF93YXJuaW5nUm93KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3dhcm5pbmdSZXN1bHQsICdNZXNzYWdlJykpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKF93YXJuaW5nUmVzdWx0Lk1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgX29iamVjdEtleSBvZiBfd2FybmluZ1Jlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goW19vYmplY3RLZXksIF93YXJuaW5nUmVzdWx0W19vYmplY3RLZXldXS5qb2luKCc6ICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlcXVlbGl6ZS5sb2cod2FybmluZ01lc3NhZ2UgKyBtZXNzYWdlcy5qb2luKCc7ICcpLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBjb25zdCBlcnJDb2RlID0gZXJyLmVycm5vIHx8IGVyci5jb2RlO1xuXG4gICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICBjYXNlIEVSX0RVUF9FTlRSWToge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9EdXBsaWNhdGUgZW50cnkgJyhbXFxzXFxTXSopJyBmb3Iga2V5ICc/KCgufFxccykqPyknPyQvKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGVycm9yJztcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdCgnLScpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmaWVsZEtleSA9IG1hdGNoID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsID0gbWF0Y2ggPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbZmllbGRLZXldO1xuXG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBpZiAodW5pcXVlS2V5Lm1zZykgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbZmllbGRLZXldID0gZmllbGRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgICAgdGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSxcbiAgICAgICAgICAgICd1bmlxdWUgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5EQixcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICAgJ25vdF91bmlxdWUnXG4gICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSBFUl9ST1dfSVNfUkVGRVJFTkNFRDpcbiAgICAgIGNhc2UgRVJfTk9fUkVGRVJFTkNFRF9ST1c6IHtcbiAgICAgICAgLy8gZS5nLiBDT05TVFJBSU5UIGBleGFtcGxlX2NvbnN0cmFpbnRfbmFtZWAgRk9SRUlHTiBLRVkgKGBleGFtcGxlX2lkYCkgUkVGRVJFTkNFUyBgZXhhbXBsZXNgIChgaWRgKVxuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKFxuICAgICAgICAgIC9DT05TVFJBSU5UIChbYFwiXSkoLiopXFwxIEZPUkVJR04gS0VZIFxcKFxcMSguKilcXDFcXCkgUkVGRVJFTkNFUyBcXDEoLiopXFwxIFxcKFxcMSguKilcXDFcXCkvXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHF1b3RlQ2hhciA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnYCc7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG1hdGNoID8gbWF0Y2hbM10uc3BsaXQobmV3IFJlZ0V4cChgJHtxdW90ZUNoYXJ9LCAqJHtxdW90ZUNoYXJ9YCkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIHJlbHR5cGU6IFN0cmluZyhlcnJDb2RlKSA9PT0gU3RyaW5nKEVSX1JPV19JU19SRUZFUkVOQ0VEKSA/ICdwYXJlbnQnIDogJ2NoaWxkJyxcbiAgICAgICAgICB0YWJsZTogbWF0Y2ggPyBtYXRjaFs0XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoICYmIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZHNbMF1dIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBpbmRleDogbWF0Y2ggPyBtYXRjaFsyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIC8vIEdyb3VwIGJ5IGluZGV4IG5hbWUsIGFuZCBjb2xsZWN0IGFsbCBmaWVsZHNcbiAgICBkYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoaXRlbS5LZXlfbmFtZSBpbiBhY2MpKSB7XG4gICAgICAgIGFjY1tpdGVtLktleV9uYW1lXSA9IGl0ZW07XG4gICAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICB9XG5cbiAgICAgIGFjY1tpdGVtLktleV9uYW1lXS5maWVsZHNbaXRlbS5TZXFfaW5faW5kZXggLSAxXSA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBpdGVtLkNvbHVtbl9uYW1lLFxuICAgICAgICBsZW5ndGg6IGl0ZW0uU3ViX3BhcnQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBvcmRlcjogaXRlbS5Db2xsYXRpb24gPT09ICdBJyA/ICdBU0MnIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgZGVsZXRlIGl0ZW0uY29sdW1uX25hbWU7XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIF8ubWFwKGRhdGEsIGl0ZW0gPT4gKHtcbiAgICAgIHByaW1hcnk6IGl0ZW0uS2V5X25hbWUgPT09ICdQUklNQVJZJyxcbiAgICAgIGZpZWxkczogaXRlbS5maWVsZHMsXG4gICAgICBuYW1lOiBpdGVtLktleV9uYW1lLFxuICAgICAgdGFibGVOYW1lOiBpdGVtLlRhYmxlLFxuICAgICAgdW5pcXVlOiBpdGVtLk5vbl91bmlxdWUgIT09IDEsXG4gICAgICB0eXBlOiBpdGVtLkluZGV4X3R5cGVcbiAgICB9KSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0b3JlcyA9IG5ldyBNYXAoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWFsZWN0ID0+IHtcbiAgaWYgKCFzdG9yZXMuaGFzKGRpYWxlY3QpKSB7XG4gICAgc3RvcmVzLnNldChkaWFsZWN0LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIHN0b3Jlcy5nZXQoZGlhbGVjdCkuY2xlYXIoKTtcbiAgICB9LFxuICAgIHJlZnJlc2goZGF0YVR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBkYXRhVHlwZS50eXBlc1tkaWFsZWN0XSkge1xuICAgICAgICBzdG9yZXMuZ2V0KGRpYWxlY3QpLnNldCh0eXBlLCBkYXRhVHlwZS5wYXJzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQodHlwZSkge1xuICAgICAgcmV0dXJuIHN0b3Jlcy5nZXQoZGlhbGVjdCkuZ2V0KHR5cGUpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjpwZycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDU0MzI7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcblxuICAgIGNvbnN0IHBnTGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoJ3BnJyk7XG4gICAgdGhpcy5saWIgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlID8gcGdMaWIubmF0aXZlIDogcGdMaWI7XG5cbiAgICB0aGlzLl9jbGVhckR5bmFtaWNPSURzKCk7XG4gICAgdGhpcy5fY2xlYXJUeXBlUGFyc2VyKCk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMucG9zdGdyZXMpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoaXMgYXMgYSBtZXRob2Qgc28gdGhhdCB0aGUgcGFyc2luZyBtYXkgYmUgdXBkYXRlZCB3aGVuIHRoZSB1c2VyIGhhcyBhZGRlZCBhZGRpdGlvbmFsLCBjdXN0b20gdHlwZXNcbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgY29uc3QgYXJyYXlQYXJzZXJCdWlsZGVyID0gcGFyc2VyID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PiB0aGlzLmxpYi50eXBlcy5hcnJheVBhcnNlci5jcmVhdGUodmFsdWUsIHBhcnNlcikucGFyc2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlUGFyc2VyQnVpbGRlciA9IHBhcnNlciA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgPT4gZGF0YVR5cGUucGFyc2UodmFsdWUsIHsgcGFyc2VyIH0pO1xuICAgIH07XG5cbiAgICAvLyBTZXQgcmFuZ2UgcGFyc2Vyc1xuICAgIGlmIChkYXRhVHlwZS5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3JhbmdlJykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMubmFtZU9pZE1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMubmFtZU9pZE1hcFtuYW1lXTtcbiAgICAgICAgaWYgKCEgZW50cnkucmFuZ2VPaWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IHJhbmdlUGFyc2VyID0gcmFuZ2VQYXJzZXJCdWlsZGVyKHRoaXMuZ2V0VHlwZVBhcnNlcihlbnRyeS5vaWQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlSYW5nZVBhcnNlciA9IGFycmF5UGFyc2VyQnVpbGRlcihyYW5nZVBhcnNlcik7XG5cbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGVudHJ5LnJhbmdlT2lkLCByYW5nZVBhcnNlcik7XG4gICAgICAgIGlmICghIGVudHJ5LmFycmF5UmFuZ2VPaWQpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoZW50cnkuYXJyYXlSYW5nZU9pZCwgYXJyYXlSYW5nZVBhcnNlcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHBhcnNlcnMgZm9yIG5vcm1hbCBvciBlbnVtIGRhdGEgdHlwZXNcbiAgICBjb25zdCBwYXJzZXIgPSB2YWx1ZSA9PiBkYXRhVHlwZS5wYXJzZSh2YWx1ZSk7XG4gICAgY29uc3QgYXJyYXlQYXJzZXIgPSBhcnJheVBhcnNlckJ1aWxkZXIocGFyc2VyKTtcblxuICAgIC8vIFNldCBlbnVtIHBhcnNlcnNcbiAgICBpZiAoZGF0YVR5cGUua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdlbnVtJykge1xuICAgICAgdGhpcy5lbnVtT2lkcy5vaWRzLmZvckVhY2gob2lkID0+IHtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KG9pZCwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbnVtT2lkcy5hcnJheU9pZHMuZm9yRWFjaChhcnJheU9pZCA9PiB7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChhcnJheU9pZCwgYXJyYXlQYXJzZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IHBhcnNlcnMgZm9yIG5vcm1hbCBkYXRhIHR5cGVzXG4gICAgZGF0YVR5cGUudHlwZXMucG9zdGdyZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGlmICghIHRoaXMubmFtZU9pZE1hcFtuYW1lXSkgcmV0dXJuO1xuICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KHRoaXMubmFtZU9pZE1hcFtuYW1lXS5vaWQsIHBhcnNlcik7XG5cbiAgICAgIGlmICghIHRoaXMubmFtZU9pZE1hcFtuYW1lXS5hcnJheU9pZCkgcmV0dXJuO1xuICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KHRoaXMubmFtZU9pZE1hcFtuYW1lXS5hcnJheU9pZCwgYXJyYXlQYXJzZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICB0aGlzLm9pZFBhcnNlck1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldFR5cGVQYXJzZXIob2lkLCAuLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMub2lkUGFyc2VyTWFwLmdldChvaWQpKSByZXR1cm4gdGhpcy5vaWRQYXJzZXJNYXAuZ2V0KG9pZCk7XG5cbiAgICByZXR1cm4gdGhpcy5saWIudHlwZXMuZ2V0VHlwZVBhcnNlcihvaWQsIC4uLmFyZ3MpO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25maWcudXNlciA9IGNvbmZpZy51c2VybmFtZTtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gXy5waWNrKGNvbmZpZywgW1xuICAgICAgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdkYXRhYmFzZScsICdwb3J0J1xuICAgIF0pO1xuXG4gICAgY29ubmVjdGlvbkNvbmZpZy50eXBlcyA9IHtcbiAgICAgIGdldFR5cGVQYXJzZXI6IENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUeXBlUGFyc2VyLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgXy5tZXJnZShjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICBfLnBpY2soY29uZmlnLmRpYWxlY3RPcHRpb25zLCBbXG4gICAgICAgIC8vIHNlZSBbaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMy9zdGF0aWMvcnVudGltZS1jb25maWctbG9nZ2luZy5odG1sI0dVQy1BUFBMSUNBVElPTi1OQU1FXVxuICAgICAgICAgICdhcHBsaWNhdGlvbl9uYW1lJyxcbiAgICAgICAgICAvLyBjaG9vc2UgdGhlIFNTTCBtb2RlIHdpdGggdGhlIFBHU1NMTU9ERSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgICAgICAgIC8vIG9iamVjdCBmb3JtYXQ6IFtodHRwczovL2dpdGh1Yi5jb20vYnJpYW5jL25vZGUtcG9zdGdyZXMvYmxvYi9lZTE5ZTc0ZmZhNjMwOWM5YzVlOGUwMTc0NjI2MWE4ZjY1MTY2MWY4L2xpYi9jb25uZWN0aW9uLmpzI0w3OV1cbiAgICAgICAgICAvLyBzZWUgYWxzbyBbaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMy9zdGF0aWMvbGlicHEtc3NsLmh0bWxdXG4gICAgICAgICAgJ3NzbCcsXG4gICAgICAgICAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIHZhbHVlcyBhY2NlcHRlZCBieSB0aGUgY29ycmVzcG9uZGluZyBzZXJ2ZXIsXG4gICAgICAgICAgLy8geW91IGNhbiB1c2UgXCJhdXRvXCIgdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBlbmNvZGluZyBmcm9tIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgbG9jYWxlIGluIHRoZSBjbGllbnQgKExDX0NUWVBFIGVudmlyb25tZW50IHZhcmlhYmxlIG9uIFVuaXggc3lzdGVtcylcbiAgICAgICAgICAnY2xpZW50X2VuY29kaW5nJyxcbiAgICAgICAgICAvLyAhISBETyBOT1QgU0VUIFRISVMgVE8gVFJVRSAhIVxuICAgICAgICAgIC8vICh1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcpXG4gICAgICAgICAgLy8gc2VlIFtodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL21lc3NhZ2UtaWQvZmxhdC9iYzk1NDlhNTA3MDYwNDA4NTJ1Mjc2MzNmNDFpYjFlNmIwOWY4MzM5ZDg0NUBtYWlsLmdtYWlsLmNvbSNiYzk1NDlhNTA3MDYwNDA4NTJ1Mjc2MzNmNDFpYjFlNmIwOWY4MzM5ZDg0NUBtYWlsLmdtYWlsLmNvbV1cbiAgICAgICAgICAnYmluYXJ5JyxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBoZWxwIHdpdGggYmFja2VuZHMgaW5jb3JyZWN0bHkgY29uc2lkZXJpbmcgaWRsZSBjbGllbnRzIHRvIGJlIGRlYWQgYW5kIHByZW1hdHVyZWx5IGRpc2Nvbm5lY3RpbmcgdGhlbS5cbiAgICAgICAgICAvLyB0aGlzIGZlYXR1cmUgaGFzIGJlZW4gYWRkZWQgaW4gcGcgbW9kdWxlIHY2LjAuMCwgY2hlY2sgcGcvQ0hBTkdFTE9HLm1kXG4gICAgICAgICAgJ2tlZXBBbGl2ZScsXG4gICAgICAgICAgLy8gVGltZXMgb3V0IHF1ZXJpZXMgYWZ0ZXIgYSBzZXQgdGltZSBpbiBtaWxsaXNlY29uZHMuIEFkZGVkIGluIHBnIHY3LjNcbiAgICAgICAgICAnc3RhdGVtZW50X3RpbWVvdXQnLFxuICAgICAgICAgIC8vIFRlcm1pbmF0ZSBhbnkgc2Vzc2lvbiB3aXRoIGFuIG9wZW4gdHJhbnNhY3Rpb24gdGhhdCBoYXMgYmVlbiBpZGxlIGZvciBsb25nZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy4gQWRkZWQgaW4gcGcgdjcuMTcuMCBvbmx5IHN1cHBvcnRlZCBpbiBwb3N0Z3JlcyA+PSAxMFxuICAgICAgICAgICdpZGxlX2luX3RyYW5zYWN0aW9uX3Nlc3Npb25fdGltZW91dCdcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVzcG9uZGVkID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgdGhpcy5saWIuQ2xpZW50KGNvbm5lY3Rpb25Db25maWcpO1xuXG4gICAgICBjb25zdCBwYXJhbWV0ZXJIYW5kbGVyID0gbWVzc2FnZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnc2VydmVyX3ZlcnNpb24nOlxuICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBzZW12ZXIuY29lcmNlKG1lc3NhZ2UucGFyYW1ldGVyVmFsdWUpLnZlcnNpb247XG4gICAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLnZhbGlkKHZlcnNpb24pXG4gICAgICAgICAgICAgICAgPyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgOiB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3MnOlxuICAgICAgICAgICAgY29ubmVjdGlvblsnc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzJ10gPSBtZXNzYWdlLnBhcmFtZXRlclZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGRlYnVnKCdjb25uZWN0aW9uIHRpbWVvdXQnKTtcbiAgICAgICAgaWYgKCFyZXNwb25kZWQpIHtcbiAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uVGltZWRPdXRFcnJvcihuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGltZWQgb3V0JykpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSWYgd2UgZGlkbid0IGV2ZXIgaGVhciBmcm9tIHRoZSBjbGllbnQuY29ubmVjdCgpIGNhbGxiYWNrIHRoZSBjb25uZWN0aW9uIHRpbWVvdXRcbiAgICAgIC8vIG5vZGUtcG9zdGdyZXMgZG9lcyBub3QgdHJlYXQgdGhpcyBhcyBhbiBlcnJvciBzaW5jZSBubyBhY3RpdmUgcXVlcnkgd2FzIGV2ZXIgZW1pdHRlZFxuICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCBlbmRIYW5kbGVyKTtcblxuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlKSB7XG4gICAgICAgIC8vIFJlY2VpdmUgdmFyaW91cyBzZXJ2ZXIgcGFyYW1ldGVycyBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdGlvbi5vbigncGFyYW1ldGVyU3RhdHVzJywgcGFyYW1ldGVySGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChlcnIgPT4ge1xuICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSkge1xuICAgICAgICAgIC8vIHJlbW92ZSBwYXJhbWV0ZXIgaGFuZGxlclxuICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcigncGFyYW1ldGVyU3RhdHVzJywgcGFyYW1ldGVySGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ0VDT05OUkVGVVNFRCc6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnRU5PVEZPVU5EJzpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnRUhPU1RVTlJFQUNIJzpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ0VJTlZBTCc6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gYWNxdWlyZWQnKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxldCBxdWVyeSA9ICcnO1xuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5ncyAhPT0gZmFsc2UgJiYgY29ubmVjdGlvblsnc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzJ10gIT09ICdvbicpIHtcbiAgICAgIC8vIERpc2FibGUgZXNjYXBlIGNoYXJhY3RlcnMgaW4gc3RyaW5nc1xuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2lzc3Vlcy8zNTQ1IChzZWN1cml0eSBpc3N1ZSlcbiAgICAgIC8vIHNlZSBodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvc3RhdGljL3J1bnRpbWUtY29uZmlnLWNvbXBhdGlibGUuaHRtbCNHVUMtU1RBTkRBUkQtQ09ORk9STUlORy1TVFJJTkdTXG4gICAgICBxdWVyeSArPSAnU0VUIHN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5ncz1vbjsnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgcXVlcnkgKz0gYFNFVCBjbGllbnRfbWluX21lc3NhZ2VzIFRPICR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlc307YDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICBjb25zdCBpc1pvbmUgPSAhIW1vbWVudC50ei56b25lKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgaWYgKGlzWm9uZSkge1xuICAgICAgICBxdWVyeSArPSBgU0VUIFRJTUUgWk9ORSAnJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lfSc7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5ICs9IGBTRVQgVElNRSBaT05FIElOVEVSVkFMICcke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmV9JyBIT1VSIFRPIE1JTlVURTtgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgYXdhaXQgY29ubmVjdGlvbi5xdWVyeShxdWVyeSk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5hbWVPaWRNYXApLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgdGhpcy5lbnVtT2lkcy5vaWRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgdGhpcy5lbnVtT2lkcy5hcnJheU9pZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoRHluYW1pY09JRHMoY29ubmVjdGlvbik7XG4gICAgfVxuICAgIC8vIERvbid0IGxldCBhIFBvc3RncmVzIHJlc3RhcnQgKG9yIGVycm9yKSB0byB0YWtlIGRvd24gdGhlIHdob2xlIGFwcFxuICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgY29ubmVjdGlvbi5faW52YWxpZCA9IHRydWU7XG4gICAgICBkZWJ1ZyhgY29ubmVjdGlvbiBlcnJvciAke2Vycm9yLmNvZGUgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5fZW5kaW5nKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBFTkRJTkcgc3RhdGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KGNhbGxiYWNrID0+IGNvbm5lY3Rpb24uZW5kKGNhbGxiYWNrKSkoKTtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gIWNvbm5lY3Rpb24uX2ludmFsaWQgJiYgIWNvbm5lY3Rpb24uX2VuZGluZztcbiAgfVxuXG4gIGFzeW5jIF9yZWZyZXNoRHluYW1pY09JRHMoY29ubmVjdGlvbikge1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uO1xuICAgIGNvbnN0IHN1cHBvcnRlZFZlcnNpb24gPSAnOC4zLjAnO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHN1cHBvcnRlZCB2ZXJzaW9uXG4gICAgaWYgKCAoZGF0YWJhc2VWZXJzaW9uICYmIHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCBzdXBwb3J0ZWRWZXJzaW9uKSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IChjb25uZWN0aW9uIHx8IHRoaXMuc2VxdWVsaXplKS5xdWVyeShcbiAgICAgICdXSVRIIHJhbmdlcyBBUyAoJyArXG4gICAgICAnICBTRUxFQ1QgcGdfcmFuZ2Uucm5ndHlwaWQsIHBnX3R5cGUudHlwbmFtZSBBUyBybmd0eXBuYW1lLCcgK1xuICAgICAgJyAgICAgICAgIHBnX3R5cGUudHlwYXJyYXkgQVMgcm5ndHlwYXJyYXksIHBnX3JhbmdlLnJuZ3N1YnR5cGUnICtcbiAgICAgICcgICAgRlJPTSBwZ19yYW5nZSBMRUZUIE9VVEVSIEpPSU4gcGdfdHlwZSBPTiBwZ190eXBlLm9pZCA9IHBnX3JhbmdlLnJuZ3R5cGlkJyArXG4gICAgICAnKScgK1xuICAgICAgJ1NFTEVDVCBwZ190eXBlLnR5cG5hbWUsIHBnX3R5cGUudHlwdHlwZSwgcGdfdHlwZS5vaWQsIHBnX3R5cGUudHlwYXJyYXksJyArXG4gICAgICAnICAgICAgIHJhbmdlcy5ybmd0eXBuYW1lLCByYW5nZXMucm5ndHlwaWQsIHJhbmdlcy5ybmd0eXBhcnJheScgK1xuICAgICAgJyAgRlJPTSBwZ190eXBlIExFRlQgT1VURVIgSk9JTiByYW5nZXMgT04gcGdfdHlwZS5vaWQgPSByYW5nZXMucm5nc3VidHlwZScgK1xuICAgICAgJyBXSEVSRSAocGdfdHlwZS50eXB0eXBlIElOKFxcJ2JcXCcsIFxcJ2VcXCcpKTsnXG4gICAgKTtcblxuICAgIGxldCByZXN1bHQgPSBBcnJheS5pc0FycmF5KHJlc3VsdHMpID8gcmVzdWx0cy5wb3AoKSA6IHJlc3VsdHM7XG5cbiAgICAvLyBXaGVuIHNlYXJjaFBhdGggaXMgcHJlcGVuZGVkIHRoZW4gdHdvIHN0YXRlbWVudHMgYXJlIGV4ZWN1dGVkIGFuZCB0aGUgcmVzdWx0IGlzXG4gICAgLy8gYW4gYXJyYXkgb2YgdGhvc2UgdHdvIHN0YXRlbWVudHMuIEZpcnN0IG9uZSBpcyB0aGUgU0VUIHNlYXJjaF9wYXRoIGFuZCBzZWNvbmQgaXNcbiAgICAvLyB0aGUgU0VMRUNUIHF1ZXJ5IHJlc3VsdC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICBpZiAocmVzdWx0WzBdLmNvbW1hbmQgPT09ICdTRVQnKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdOYW1lT2lkTWFwID0ge307XG4gICAgY29uc3QgbmV3RW51bU9pZHMgPSB7IG9pZHM6IFtdLCBhcnJheU9pZHM6IFtdIH07XG5cbiAgICBmb3IgKGNvbnN0IHJvdyBvZiByZXN1bHQucm93cykge1xuICAgICAgLy8gTWFwcGluZyBlbnVtcywgaGFuZGxlZCBzZXBhcmF0ZWRseVxuICAgICAgaWYgKHJvdy50eXB0eXBlID09PSAnZScpIHtcbiAgICAgICAgbmV3RW51bU9pZHMub2lkcy5wdXNoKHJvdy5vaWQpO1xuICAgICAgICBpZiAocm93LnR5cGFycmF5KSBuZXdFbnVtT2lkcy5hcnJheU9pZHMucHVzaChyb3cudHlwYXJyYXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFwcGluZyBiYXNlIHR5cGVzIGFuZCB0aGVpciBhcnJheXNcbiAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdID0geyBvaWQ6IHJvdy5vaWQgfTtcbiAgICAgIGlmIChyb3cudHlwYXJyYXkpIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLmFycmF5T2lkID0gcm93LnR5cGFycmF5O1xuXG4gICAgICAvLyBNYXBwaW5nIHJhbmdlcyhvZiBiYXNlIHR5cGVzKSBhbmQgdGhlaXIgYXJyYXlzXG4gICAgICBpZiAocm93LnJuZ3R5cGlkKSB7XG4gICAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLnJhbmdlT2lkID0gcm93LnJuZ3R5cGlkO1xuICAgICAgICBpZiAocm93LnJuZ3R5cGFycmF5KSBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5hcnJheVJhbmdlT2lkID0gcm93LnJuZ3R5cGFycmF5O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcGxhY2UgYWxsIE9JRCBtYXBwaW5ncy4gQXZvaWRzIHRlbXBvcmFyeSBlbXB0eSBPSUQgbWFwcGluZ3MuXG4gICAgdGhpcy5uYW1lT2lkTWFwID0gbmV3TmFtZU9pZE1hcDtcbiAgICB0aGlzLmVudW1PaWRzID0gbmV3RW51bU9pZHM7XG5cbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcy5wb3N0Z3Jlcyk7XG4gIH1cblxuICBfY2xlYXJEeW5hbWljT0lEcygpIHtcbiAgICB0aGlzLm5hbWVPaWRNYXAgPSB7fTtcbiAgICB0aGlzLmVudW1PaWRzID0geyBvaWRzOiBbXSwgYXJyYXlPaWRzOiBbXSB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB3a3ggPSByZXF1aXJlKCd3a3gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHlwZXMgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh1bmRlZmluZWQsICdodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS40L3N0YXRpYy9kYXRhdHlwZS5odG1sJyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdW5zdXBwb3J0ZWQgUG9zdGdyZXMgb3B0aW9ucywgaS5lLiwgTEVOR1RILCBVTlNJR05FRCBhbmQgWkVST0ZJTEwsIGZvciB0aGUgaW50ZWdlciBkYXRhIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVR5cGUgVGhlIGJhc2UgaW50ZWdlciBkYXRhIHR5cGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl9sZW5ndGggfHwgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggfHwgZGF0YVR5cGUuX3Vuc2lnbmVkIHx8IGRhdGFUeXBlLl96ZXJvZmlsbCkge1xuICAgICAgd2FybihgUG9zdGdyZXNTUUwgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIExFTkdUSCwgVU5TSUdORUQgb3IgWkVST0ZJTEwuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB0eXBlczpcbiAgICoge1xuICAgKiAgIG9pZHM6IFtvaWRdLFxuICAgKiAgIGFycmF5X29pZHM6IFtvaWRdXG4gICAqIH1cbiAgICpcbiAgICogQHNlZSBvaWQgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vbGliL3BxL2Jsb2IvbWFzdGVyL29pZC90eXBlcy5nb1xuICAgKi9cblxuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5wb3N0Z3JlcyA9IFsndXVpZCddO1xuICBCYXNlVHlwZXMuQ0lEUi50eXBlcy5wb3N0Z3JlcyA9IFsnY2lkciddO1xuICBCYXNlVHlwZXMuSU5FVC50eXBlcy5wb3N0Z3JlcyA9IFsnaW5ldCddO1xuICBCYXNlVHlwZXMuTUFDQUREUi50eXBlcy5wb3N0Z3JlcyA9IFsnbWFjYWRkciddO1xuICBCYXNlVHlwZXMuVFNWRUNUT1IudHlwZXMucG9zdGdyZXMgPSBbJ3RzdmVjdG9yJ107XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLnBvc3RncmVzID0gWydqc29uJ107XG4gIEJhc2VUeXBlcy5KU09OQi50eXBlcy5wb3N0Z3JlcyA9IFsnanNvbmInXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMucG9zdGdyZXMgPSBbJ3RpbWUnXTtcblxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGxvd2VyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobG93ZXIgPT09ICdpbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID09PSAnLWluZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnaW5maW5pdHknKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gJy1pbmZpbml0eScpIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMucG9zdGdyZXMgPSBbJ2RhdGUnXTtcblxuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG51bWVyaWNcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMucG9zdGdyZXMgPSBbJ251bWVyaWMnXTtcblxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuICdCWVRFQSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLnBvc3RncmVzID0gWyd2YXJjaGFyJ107XG5cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybignUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCBvcHRpb25zLiBQbGFpbiBgVEVYVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnVEVYVCc7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMucG9zdGdyZXMgPSBbJ3RleHQnXTtcblxuICBjbGFzcyBDSVRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuQ0lURVhUIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuQ0lURVhULnR5cGVzLnBvc3RncmVzID0gWydjaXRleHQnXTtcblxuICBjbGFzcyBDSEFSIGV4dGVuZHMgQmFzZVR5cGVzLkNIQVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gJ0JZVEVBJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLnBvc3RncmVzID0gWydjaGFyJywgJ2JwY2hhciddO1xuXG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0JPT0xFQU4nO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIEJpdCBmaWVsZHMgYXJlIHJldHVybmVkIGFzIGJ1ZmZlcnNcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gT25seSB0YWtlIGFjdGlvbiBvbiB2YWxpZCBib29sZWFuIHN0cmluZ3MuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICd0JyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ2YnID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIE9ubHkgdGFrZSBhY3Rpb24gb24gdmFsaWQgYm9vbGVhbiBpbnRlZ2Vycy5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgPyB0cnVlIDogdmFsdWUgPT09IDAgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQk9PTEVBTi5wYXJzZSA9IEJPT0xFQU4ucHJvdG90eXBlLl9zYW5pdGl6ZTtcblxuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5wb3N0Z3JlcyA9IFsnYm9vbCddO1xuXG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ1RJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSc7XG4gICAgfVxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICctSW5maW5pdHknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIXZhbHVlICYmIHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbG93ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsb3dlciA9PT0gJ2luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgPT09ICctaW5maW5pdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLnBvc3RncmVzID0gWyd0aW1lc3RhbXB0eiddO1xuXG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gaW50MlxuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5wb3N0Z3JlcyA9IFsnaW50MiddO1xuXG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBpbnQyXG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5wb3N0Z3JlcyA9IFsnaW50MiddO1xuXG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgSU5URUdFUi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH07XG5cbiAgLy8gaW50NFxuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5wb3N0Z3JlcyA9IFsnaW50NCddO1xuXG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGludDhcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5wb3N0Z3JlcyA9IFsnaW50OCddO1xuXG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZmxvYXQ0XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLnBvc3RncmVzID0gWydmbG9hdDQnXTtcblxuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmbG9hdDhcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5wb3N0Z3JlcyA9IFsnZmxvYXQ4J107XG5cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgLy8gUE9TVEdSRVMgZG9lcyBvbmx5IHN1cHBvcnQgbGVuZ3RocyBhcyBwYXJhbWV0ZXIuXG4gICAgICAvLyBWYWx1ZXMgYmV0d2VlbiAxLTI0IHJlc3VsdCBpbiBSRUFMXG4gICAgICAvLyBWYWx1ZXMgYmV0d2VlbiAyNS01MyByZXN1bHQgaW4gRE9VQkxFIFBSRUNJU0lPTlxuICAgICAgLy8gSWYgZGVjaW1hbHMgYXJlIHByb3ZpZGVkIHJlbW92ZSB0aGVzZSBhbmQgcHJpbnQgYSB3YXJuaW5nXG4gICAgICBpZiAodGhpcy5fZGVjaW1hbHMpIHtcbiAgICAgICAgd2FybignUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHdpdGggZGVjaW1hbHMuIFBsYWluIGBGTE9BVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGVjaW1hbHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgd2FybignUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHVuc2lnbmVkLiBgVU5TSUdORURgIHdhcyByZW1vdmVkLicpO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKCdQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgemVyb2ZpbGwuIGBaRVJPRklMTGAgd2FzIHJlbW92ZWQuJyk7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWxldGUgRkxPQVQucGFyc2U7IC8vIEZsb2F0IGhhcyBubyBzZXBhcmF0ZSB0eXBlIGluIFBHXG5cbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybignUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0IgKEJZVEVBKSB3aXRoIG9wdGlvbnMuIFBsYWluIGBCWVRFQWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnQllURUEnO1xuICAgIH1cbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgLy8gYnl0ZWEgaGV4IGZvcm1hdCBodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9zdGF0aWMvZGF0YXR5cGUtYmluYXJ5Lmh0bWxcbiAgICAgIHJldHVybiBgRSdcXFxcXFxcXHgke2hleH0nYDtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5wb3N0Z3JlcyA9IFsnYnl0ZWEnXTtcblxuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy50eXBlfWA7XG4gICAgICAgIGlmICh0aGlzLnNyaWQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuc3JpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZShiKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmVzY2FwZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpfSlgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX0pYDtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMucG9zdGdyZXMgPSBbJ2dlb21ldHJ5J107XG5cblxuICBjbGFzcyBHRU9HUkFQSFkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPR1JBUEhZIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAnR0VPR1JBUEhZJztcbiAgICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgaWYgKHRoaXMuc3JpZCkge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5zcmlkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnaGV4Jyk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKGIpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuZXNjYXBlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSl9KWA7XG4gICAgfVxuICAgIGJpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9KWA7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkdFT0dSQVBIWS50eXBlcy5wb3N0Z3JlcyA9IFsnZ2VvZ3JhcGh5J107XG5cbiAgbGV0IGhzdG9yZTtcblxuICBjbGFzcyBIU1RPUkUgZXh0ZW5kcyBCYXNlVHlwZXMuSFNUT1JFIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICAvLyBBbGwgZGF0YXR5cGUgZmlsZXMgYXJlIGxvYWRlZCBhdCBpbXBvcnQgLSBtYWtlIHN1cmUgd2UgZG9uJ3QgbG9hZCB0aGUgaHN0b3JlIHBhcnNlciBiZWZvcmUgYSBoc3RvcmUgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoJy4vaHN0b3JlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIF92YWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgLy8gQWxsIGRhdGF0eXBlIGZpbGVzIGFyZSBsb2FkZWQgYXQgaW1wb3J0IC0gbWFrZSBzdXJlIHdlIGRvbid0IGxvYWQgdGhlIGhzdG9yZSBwYXJzZXIgYmVmb3JlIGEgaHN0b3JlIGlzIGluc3RhbnRpYXRlZFxuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKCcuL2hzdG9yZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhzdG9yZS5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYCcke3RoaXMuX3ZhbHVlKHZhbHVlKX0nYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgLy8gQWxsIGRhdGF0eXBlIGZpbGVzIGFyZSBsb2FkZWQgYXQgaW1wb3J0IC0gbWFrZSBzdXJlIHdlIGRvbid0IGxvYWQgdGhlIGhzdG9yZSBwYXJzZXIgYmVmb3JlIGEgaHN0b3JlIGlzIGluc3RhbnRpYXRlZFxuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKCcuL2hzdG9yZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhzdG9yZS5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgSFNUT1JFLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuICBCYXNlVHlwZXMuSFNUT1JFLnR5cGVzLnBvc3RncmVzID0gWydoc3RvcmUnXTtcblxuICBjbGFzcyBSQU5HRSBleHRlbmRzIEJhc2VUeXBlcy5SQU5HRSB7XG4gICAgX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVJbmNsdXNpdml0eSA9IFt0cnVlLCBmYWxzZV07XG4gICAgICBjb25zdCB2YWx1ZXNTdHJpbmdpZmllZCA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAndmFsdWUnKSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmNsdXNpdmUnKSkge1xuICAgICAgICAgICAgdmFsdWVJbmNsdXNpdml0eVtpbmRleF0gPSB2YWx1ZS5pbmNsdXNpdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIFwidW5ib3VuZGVkXCIgYm91bmRzIHVuY2hhbmdlZFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQXJyYXkubWFwIGRvZXMgbm90IHByZXNlcnZlIGV4dHJhIGFycmF5IHByb3BlcnRpZXNcbiAgICAgIHZhbHVlc1N0cmluZ2lmaWVkLmluY2x1c2l2ZSA9IHZhbHVlSW5jbHVzaXZpdHk7XG4gICAgICByZXR1cm4gcmFuZ2Uuc3RyaW5naWZ5KHZhbHVlc1N0cmluZ2lmaWVkKTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9Jzo6JHt0aGlzLnRvQ2FzdFR5cGUoKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBgJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9Ojoke3RoaXMudG9DYXN0VHlwZSgpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMuc3VidHlwZXNbdGhpcy5fc3VidHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgdG9DYXN0VHlwZSgpIHtcbiAgICAgIHJldHVybiBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMuY2FzdFR5cGVzW3RoaXMuX3N1YnR5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucyA9IHsgcGFyc2VyOiB2YWwgPT4gdmFsIH0pIHtcbiAgICAgIHJldHVybiByYW5nZS5wYXJzZSh2YWx1ZSwgb3B0aW9ucy5wYXJzZXIpO1xuICAgIH1cbiAgfVxuICBjb25zdCByYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKTtcblxuICBSQU5HRS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbiAgQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzID0ge1xuICAgIHN1YnR5cGVzOiB7XG4gICAgICBpbnRlZ2VyOiAnaW50NHJhbmdlJyxcbiAgICAgIGRlY2ltYWw6ICdudW1yYW5nZScsXG4gICAgICBkYXRlOiAndHN0enJhbmdlJyxcbiAgICAgIGRhdGVvbmx5OiAnZGF0ZXJhbmdlJyxcbiAgICAgIGJpZ2ludDogJ2ludDhyYW5nZSdcbiAgICB9LFxuICAgIGNhc3RUeXBlczoge1xuICAgICAgaW50ZWdlcjogJ2ludDQnLFxuICAgICAgZGVjaW1hbDogJ251bWVyaWMnLFxuICAgICAgZGF0ZTogJ3RpbWVzdGFtcHR6JyxcbiAgICAgIGRhdGVvbmx5OiAnZGF0ZScsXG4gICAgICBiaWdpbnQ6ICdpbnQ4J1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiBXaHkgYXJlIGJhc2UgdHlwZXMgYmVpbmcgbWFuaXB1bGF0ZWQ/P1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uIF92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCh2YWx1ZSA9PiB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJpbmRQYXJhbSAmJiB0aGlzLnR5cGUgJiYgdGhpcy50eXBlLl92YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLl92YWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnR5cGUuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlLmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX3N0cmluZ2lmeSA9IGZ1bmN0aW9uIF9zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgbGV0IHN0ciA9IGBBUlJBWVske3RoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykuam9pbignLCcpfV1gO1xuXG4gICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuICAgICAgbGV0IGNhc3RLZXkgPSB0aGlzLnRvU3FsKCk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgaW5zdGFuY2VvZiBCYXNlVHlwZXMuRU5VTSkge1xuICAgICAgICBjYXN0S2V5ID0gYCR7VXRpbHMuYWRkVGlja3MoXG4gICAgICAgICAgVXRpbHMuZ2VuZXJhdGVFbnVtTmFtZShvcHRpb25zLmZpZWxkLk1vZGVsLmdldFRhYmxlTmFtZSgpLCBvcHRpb25zLmZpZWxkLmZpZWxkTmFtZSksXG4gICAgICAgICAgJ1wiJ1xuICAgICAgICApIH1bXWA7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBgOjoke2Nhc3RLZXl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl9iaW5kUGFyYW0gPSBmdW5jdGlvbiBfYmluZFBhcmFtKHZhbHVlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpKTtcbiAgfTtcblxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLnBvc3RncmVzID0gW251bGxdO1xuXG4gIHJldHVybiB7XG4gICAgREVDSU1BTCxcbiAgICBCTE9CLFxuICAgIFNUUklORyxcbiAgICBDSEFSLFxuICAgIFRFWFQsXG4gICAgQ0lURVhULFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgQk9PTEVBTixcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFJFQUwsXG4gICAgJ0RPVUJMRSBQUkVDSVNJT04nOiBET1VCTEUsXG4gICAgRkxPQVQsXG4gICAgR0VPTUVUUlksXG4gICAgR0VPR1JBUEhZLFxuICAgIEhTVE9SRSxcbiAgICBSQU5HRSxcbiAgICBFTlVNXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoc3RvcmUgPSByZXF1aXJlKCdwZy1oc3RvcmUnKSh7IHNhbml0aXplOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBoc3RvcmUuc3RyaW5naWZ5KGRhdGEpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBoc3RvcmUucGFyc2UodmFsdWUpO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKCcuLi9hYnN0cmFjdCcpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykucG9zdGdyZXM7XG5jb25zdCB7IFBvc3RncmVzUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4vcXVlcnktaW50ZXJmYWNlJyk7XG5cbmNsYXNzIFBvc3RncmVzRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IFBvc3RncmVzUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuXG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICAnREVGQVVMVCBWQUxVRVMnOiB0cnVlLFxuICAnRVhDRVBUSU9OJzogdHJ1ZSxcbiAgJ09OIERVUExJQ0FURSBLRVknOiBmYWxzZSxcbiAgJ09SREVSIE5VTExTJzogdHJ1ZSxcbiAgcmV0dXJuVmFsdWVzOiB7XG4gICAgcmV0dXJuaW5nOiB0cnVlXG4gIH0sXG4gIGJ1bGtEZWZhdWx0OiB0cnVlLFxuICBzY2hlbWFzOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBsb2NrT2Y6IHRydWUsXG4gIGxvY2tLZXk6IHRydWUsXG4gIGxvY2tPdXRlckpvaW5GYWlsdXJlOiB0cnVlLFxuICBza2lwTG9ja2VkOiB0cnVlLFxuICBmb3JTaGFyZTogJ0ZPUiBTSEFSRScsXG4gIGluZGV4OiB7XG4gICAgY29uY3VycmVudGx5OiB0cnVlLFxuICAgIHVzaW5nOiAyLFxuICAgIHdoZXJlOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IHRydWUsXG4gICAgb3BlcmF0b3I6IHRydWVcbiAgfSxcbiAgaW5zZXJ0czoge1xuICAgIG9uQ29uZmxpY3REb05vdGhpbmc6ICcgT04gQ09ORkxJQ1QgRE8gTk9USElORycsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6ICcgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVCdcbiAgfSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgQVJSQVk6IHRydWUsXG4gIFJBTkdFOiB0cnVlLFxuICBHRU9NRVRSWTogdHJ1ZSxcbiAgUkVHRVhQOiB0cnVlLFxuICBHRU9HUkFQSFk6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIEpTT05COiB0cnVlLFxuICBIU1RPUkU6IHRydWUsXG4gIFRTVkVDVE9SOiB0cnVlLFxuICBkZWZlcnJhYmxlQ29uc3RyYWludHM6IHRydWUsXG4gIHNlYXJjaFBhdGg6IHRydWVcbn0pO1xuXG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gJzkuNS4wJztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gJ3Bvc3RncmVzJztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBQb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zdGdyZXNEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLlBvc3RncmVzRGlhbGVjdCA9IFBvc3RncmVzRGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jbGFzcyBQb3N0Z3Jlc1F1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIHNldFNlYXJjaFBhdGgoc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiBgU0VUIHNlYXJjaF9wYXRoIHRvICR7c2VhcmNoUGF0aH07YDtcbiAgfVxuXG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgZGF0YWJhc2U6IHRoaXMucXVvdGVUYWJsZShkYXRhYmFzZU5hbWUpLFxuICAgICAgZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2RpbmcgPyBgIEVOQ09ESU5HID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmVuY29kaW5nKX1gIDogJycsXG4gICAgICBjb2xsYXRpb246IG9wdGlvbnMuY29sbGF0ZSA/IGAgTENfQ09MTEFURSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gIDogJycsXG4gICAgICBjdHlwZTogb3B0aW9ucy5jdHlwZSA/IGAgTENfQ1RZUEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY3R5cGUpfWAgOiAnJyxcbiAgICAgIHRlbXBsYXRlOiBvcHRpb25zLnRlbXBsYXRlID8gYCBURU1QTEFURSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy50ZW1wbGF0ZSl9YCA6ICcnXG4gICAgfTtcblxuICAgIHJldHVybiBgQ1JFQVRFIERBVEFCQVNFICR7dmFsdWVzLmRhdGFiYXNlfSR7dmFsdWVzLmVuY29kaW5nfSR7dmFsdWVzLmNvbGxhdGlvbn0ke3ZhbHVlcy5jdHlwZX0ke3ZhbHVlcy50ZW1wbGF0ZX07YDtcbiAgfVxuXG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUoZGF0YWJhc2VOYW1lKX07YDtcbiAgfVxuXG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSBfLmdldCh0aGlzLCAnc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uJywgMCk7XG5cbiAgICBpZiAoZGF0YWJhc2VWZXJzaW9uICYmIHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCAnOS4yLjAnKSkge1xuICAgICAgcmV0dXJuIGBDUkVBVEUgU0NIRU1BIElGIE5PVCBFWElTVFMgJHtzY2hlbWF9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBDUkVBVEUgU0NIRU1BICR7c2NoZW1hfTtgO1xuICB9XG5cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYERST1AgU0NIRU1BIElGIEVYSVNUUyAke3NjaGVtYX0gQ0FTQ0FERTtgO1xuICB9XG5cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1Qgc2NoZW1hX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgV0hFUkUgc2NoZW1hX25hbWUgPD4gJ2luZm9ybWF0aW9uX3NjaGVtYScgQU5EIHNjaGVtYV9uYW1lICE9ICdwdWJsaWMnIEFORCBzY2hlbWFfbmFtZSAhfiBFJ15wZ18nO1wiO1xuICB9XG5cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiAnU0hPVyBTRVJWRVJfVkVSU0lPTic7XG4gIH1cblxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIC8vUG9zdGdyZXMgOS4wIGRvZXMgbm90IHN1cHBvcnQgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMsIDkuMSBhbmQgYWJvdmUgZG9cbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSBfLmdldCh0aGlzLCAnc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uJywgMCk7XG4gICAgY29uc3QgYXR0clN0ciA9IFtdO1xuICAgIGxldCBjb21tZW50cyA9ICcnO1xuICAgIGxldCBjb2x1bW5Db21tZW50cyA9ICcnO1xuXG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcblxuICAgIGlmIChvcHRpb25zLmNvbW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1lbnRzICs9IGA7IENPTU1FTlQgT04gVEFCTEUgJHtxdW90ZWRUYWJsZX0gSVMgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbW1lbnQpfWA7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHF1b3RlZEF0dHIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKTtcbiAgICAgIGNvbnN0IGkgPSBhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ0NPTU1FTlQgJyk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgLy8gTW92ZSBjb21tZW50IHRvIGEgc2VwYXJhdGUgcXVlcnlcbiAgICAgICAgY29uc3QgZXNjYXBlZENvbW1lbnRUZXh0ID0gdGhpcy5lc2NhcGUoYXR0cmlidXRlc1thdHRyXS5zdWJzdHJpbmcoaSArIDgpKTtcbiAgICAgICAgY29sdW1uQ29tbWVudHMgKz0gYDsgQ09NTUVOVCBPTiBDT0xVTU4gJHtxdW90ZWRUYWJsZX0uJHtxdW90ZWRBdHRyfSBJUyAke2VzY2FwZWRDb21tZW50VGV4dH1gO1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gYXR0cmlidXRlc1thdHRyXS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyLCBhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJTdHIucHVzaChgJHtxdW90ZWRBdHRyfSAke2RhdGFUeXBlfWApO1xuICAgIH1cblxuXG4gICAgbGV0IGF0dHJpYnV0ZXNDbGF1c2UgPSBhdHRyU3RyLmpvaW4oJywgJyk7XG5cbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCBjb2x1bW5zID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoZmllbGQgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwa3MgPSBfLnJlZHVjZShhdHRyaWJ1dGVzLCAoYWNjLCBhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pLmpvaW4oJywnKTtcblxuICAgIGlmIChwa3MubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBQUklNQVJZIEtFWSAoJHtwa3N9KWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBDUkVBVEUgVEFCTEUgJHtkYXRhYmFzZVZlcnNpb24gPT09IDAgfHwgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sICc5LjEuMCcpID8gJ0lGIE5PVCBFWElTVFMgJyA6ICcnfSR7cXVvdGVkVGFibGV9ICgke2F0dHJpYnV0ZXNDbGF1c2V9KSR7Y29tbWVudHN9JHtjb2x1bW5Db21tZW50c307YDtcbiAgfVxuXG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0ke29wdGlvbnMuY2FzY2FkZSA/ICcgQ0FTQ0FERScgOiAnJ307YDtcbiAgfVxuXG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgV0hFUkUgdGFibGVfc2NoZW1hID0gJ3B1YmxpYycgQU5EIHRhYmxlX3R5cGUgTElLRSAnJVRBQkxFJyBBTkQgdGFibGVfbmFtZSAhPSAnc3BhdGlhbF9yZWZfc3lzJztcIjtcbiAgfVxuXG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGlmICghc2NoZW1hKSBzY2hlbWEgPSAncHVibGljJztcblxuICAgIHJldHVybiAnU0VMRUNUICcgK1xuICAgICAgJ3BrLmNvbnN0cmFpbnRfdHlwZSBhcyBcIkNvbnN0cmFpbnRcIiwnICtcbiAgICAgICdjLmNvbHVtbl9uYW1lIGFzIFwiRmllbGRcIiwgJyArXG4gICAgICAnYy5jb2x1bW5fZGVmYXVsdCBhcyBcIkRlZmF1bHRcIiwnICtcbiAgICAgICdjLmlzX251bGxhYmxlIGFzIFwiTnVsbFwiLCAnICtcbiAgICAgICcoQ0FTRSBXSEVOIGMudWR0X25hbWUgPSBcXCdoc3RvcmVcXCcgVEhFTiBjLnVkdF9uYW1lIEVMU0UgYy5kYXRhX3R5cGUgRU5EKSB8fCAoQ0FTRSBXSEVOIGMuY2hhcmFjdGVyX21heGltdW1fbGVuZ3RoIElTIE5PVCBOVUxMIFRIRU4gXFwnKFxcJyB8fCBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCB8fCBcXCcpXFwnIEVMU0UgXFwnXFwnIEVORCkgYXMgXCJUeXBlXCIsICcgK1xuICAgICAgJyhTRUxFQ1QgYXJyYXlfYWdnKGUuZW51bWxhYmVsKSBGUk9NIHBnX2NhdGFsb2cucGdfdHlwZSB0IEpPSU4gcGdfY2F0YWxvZy5wZ19lbnVtIGUgT04gdC5vaWQ9ZS5lbnVtdHlwaWQgV0hFUkUgdC50eXBuYW1lPWMudWR0X25hbWUpIEFTIFwic3BlY2lhbFwiLCAnICtcbiAgICAgICcoU0VMRUNUIHBnZC5kZXNjcmlwdGlvbiBGUk9NIHBnX2NhdGFsb2cucGdfc3RhdGlvX2FsbF90YWJsZXMgQVMgc3QgSU5ORVIgSk9JTiBwZ19jYXRhbG9nLnBnX2Rlc2NyaXB0aW9uIHBnZCBvbiAocGdkLm9iam9pZD1zdC5yZWxpZCkgV0hFUkUgYy5vcmRpbmFsX3Bvc2l0aW9uPXBnZC5vYmpzdWJpZCBBTkQgYy50YWJsZV9uYW1lPXN0LnJlbG5hbWUpIEFTIFwiQ29tbWVudFwiICcgK1xuICAgICAgJ0ZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgYyAnICtcbiAgICAgICdMRUZUIEpPSU4gKFNFTEVDVCB0Yy50YWJsZV9zY2hlbWEsIHRjLnRhYmxlX25hbWUsICcgK1xuICAgICAgJ2N1LmNvbHVtbl9uYW1lLCB0Yy5jb25zdHJhaW50X3R5cGUgJyArXG4gICAgICAnRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVfQ09OU1RSQUlOVFMgdGMgJyArXG4gICAgICAnSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuS0VZX0NPTFVNTl9VU0FHRSAgY3UgJyArXG4gICAgICAnT04gdGMudGFibGVfc2NoZW1hPWN1LnRhYmxlX3NjaGVtYSBhbmQgdGMudGFibGVfbmFtZT1jdS50YWJsZV9uYW1lICcgK1xuICAgICAgJ2FuZCB0Yy5jb25zdHJhaW50X25hbWU9Y3UuY29uc3RyYWludF9uYW1lICcgK1xuICAgICAgJ2FuZCB0Yy5jb25zdHJhaW50X3R5cGU9XFwnUFJJTUFSWSBLRVlcXCcpIHBrICcgK1xuICAgICAgJ09OIHBrLnRhYmxlX3NjaGVtYT1jLnRhYmxlX3NjaGVtYSAnICtcbiAgICAgICdBTkQgcGsudGFibGVfbmFtZT1jLnRhYmxlX25hbWUgJyArXG4gICAgICAnQU5EIHBrLmNvbHVtbl9uYW1lPWMuY29sdW1uX25hbWUgJyArXG4gICAgICBgV0hFUkUgYy50YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfSBBTkQgYy50YWJsZV9zY2hlbWEgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9IGA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgc3RhdG1lbWVudCBpcyBqc29uIGZ1bmN0aW9uIG9yIHNpbXBsZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICBzdG10ICBUaGUgc3RhdGVtZW50IHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgICB0cnVlIGlmIHRoZSBnaXZlbiBzdGF0ZW1lbnQgaXMganNvbiBmdW5jdGlvblxuICAgKiBAdGhyb3dzICB7RXJyb3J9ICAgICAgICAgdGhyb3cgaWYgdGhlIHN0YXRlbWVudCBsb29rcyBsaWtlIGpzb24gZnVuY3Rpb24gYnV0IGhhcyBpbnZhbGlkIHRva2VuXG4gICAqL1xuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvc3RhdGljL2Z1bmN0aW9ucy1qc29uLmh0bWxcbiAgICBjb25zdCBqc29uRnVuY3Rpb25SZWdleCA9IC9eXFxzKigoPzpbYS16XStfKXswLDJ9anNvbmI/KD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuICAgIGNvbnN0IGpzb25PcGVyYXRvclJlZ2V4ID0gL15cXHMqKC0+Pj98Iz4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG4gICAgY29uc3QgdG9rZW5DYXB0dXJlUmVnZXggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcblxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBqc29uRnVuY3Rpb25SZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZignKCcpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0ganNvbk9wZXJhdG9yUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG9wZXJhdG9yTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gb3BlcmF0b3JNYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IHRva2VuQ2FwdHVyZVJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcoJykge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcpJykge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICc7Jykge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnZhbGlkIGpzb24gc3RhdGVtZW50XG4gICAgaGFzSW52YWxpZFRva2VuIHw9IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzO1xuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgaGFzSW52YWxpZFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhdGVtZW50IGhhcyB2YWxpZCBqc29uIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuXG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIC8vIFBhcnNlIG5lc3RlZCBvYmplY3RcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoY29uZGl0aW9uID0+XG4gICAgICAgICAgYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbignIEFORCAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbXRoLnBhdGgpIHtcbiAgICAgICAgbGV0IHN0cjtcblxuICAgICAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIGNvbmRpdGlvbnMgdXNpbmcgdGhlIHBvc3RncmVzIGpzb24gc3ludGF4XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzbXRoLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gc210aC5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsc28gc3VwcG9ydCBqc29uIHByb3BlcnR5IGFjY2Vzc29yc1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoc210aC5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc210aC52YWx1ZSkge1xuICAgICAgICAgIHN0ciArPSB1dGlsLmZvcm1hdCgnID0gJXMnLCB0aGlzLmVzY2FwZShzbXRoLnZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kLmNhbGwodGhpcywgc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuXG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGRiRGF0YVR5cGUgPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgeyBjb250ZXh0OiAnYWRkQ29sdW1uJywgdGFibGUsIGtleSB9KTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZS50eXBlIHx8IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGUsIGtleSwgZGJEYXRhVHlwZSk7XG4gICAgY29uc3QgcXVvdGVkS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGUpKTtcblxuICAgIGxldCBxdWVyeSA9IGBBTFRFUiBUQUJMRSAke3F1b3RlZFRhYmxlfSBBREQgQ09MVU1OICR7cXVvdGVkS2V5fSAke2RlZmluaXRpb259O2A7XG5cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgcXVlcnkgPSB0aGlzLnBnRW51bSh0YWJsZSwga2V5LCBkYXRhVHlwZSkgKyBxdWVyeTtcbiAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLnR5cGUgJiYgZGF0YVR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucGdFbnVtKHRhYmxlLCBrZXksIGRhdGFUeXBlLnR5cGUpICsgcXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUpKTtcbiAgICBjb25zdCBxdW90ZWRBdHRyaWJ1dGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX0gRFJPUCBDT0xVTU4gJHtxdW90ZWRBdHRyaWJ1dGVOYW1lfTtgO1xuICB9XG5cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVlcnkgPSBzdWJRdWVyeSA9PiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gQUxURVIgQ09MVU1OICR7c3ViUXVlcnl9O2A7XG4gICAgY29uc3Qgc3FsID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIGxldCBhdHRyU3FsID0gJyc7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdOT1QgTlVMTCcpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFNFVCBOT1QgTlVMTGApO1xuXG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoJ05PVCBOVUxMJywgJycpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBEUk9QIE5PVCBOVUxMYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdERUZBVUxUJykpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gU0VUIERFRkFVTFQgJHtkZWZpbml0aW9uLm1hdGNoKC9ERUZBVUxUIChbXjtdKykvKVsxXX1gKTtcblxuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8oREVGQVVMVFteO10rKS8sICcnKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gRFJPUCBERUZBVUxUYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLnN0YXJ0c1dpdGgoJ0VOVU0oJykpIHtcbiAgICAgICAgYXR0clNxbCArPSB0aGlzLnBnRW51bSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC9eRU5VTVxcKC4rXFwpLywgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgeyBzY2hlbWE6IGZhbHNlIH0pKTtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBgIFVTSU5HICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfTo6JHt0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKX0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24ubWF0Y2goL1VOSVFVRTsqJC8pKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoL1VOSVFVRTsqJC8sICcnKTtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgQUREIFVOSVFVRSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pYCkucmVwbGFjZSgnQUxURVIgQ09MVU1OJywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgJycpO1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGBBREQgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9KSAke2RlZmluaXRpb259YCkucmVwbGFjZSgnQUxURVIgQ09MVU1OJywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gVFlQRSAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG5cbiAgICAgIHNxbC5wdXNoKGF0dHJTcWwpO1xuICAgIH1cblxuICAgIHJldHVybiBzcWwuam9pbignJyk7XG4gIH1cblxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcblxuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyU3RyaW5nLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckJlZm9yZSl9IFRPICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRU5BTUUgQ09MVU1OICR7YXR0clN0cmluZy5qb2luKCcsICcpfTtgO1xuICB9XG5cbiAgZm4oZm5OYW1lLCB0YWJsZU5hbWUsIHBhcmFtZXRlcnMsIGJvZHksIHJldHVybnMsIGxhbmd1YWdlKSB7XG4gICAgZm5OYW1lID0gZm5OYW1lIHx8ICd0ZXN0ZnVuYyc7XG4gICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCAncGxwZ3NxbCc7XG4gICAgcmV0dXJucyA9IHJldHVybnMgPyBgUkVUVVJOUyAke3JldHVybnN9YCA6ICcnO1xuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8ICcnO1xuXG4gICAgcmV0dXJuIGBDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTiBwZ190ZW1wLiR7Zm5OYW1lfSgke3BhcmFtZXRlcnN9KSAke3JldHVybnN9IEFTICRmdW5jJCBCRUdJTiAke2JvZHl9IEVORDsgJGZ1bmMkIExBTkdVQUdFICR7bGFuZ3VhZ2V9OyBTRUxFQ1QgKiBGUk9NIHBnX3RlbXAuJHtmbk5hbWV9KCk7YDtcbiAgfVxuXG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICBgVFJVTkNBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHkgPyAnIFJFU1RBUlQgSURFTlRJVFknIDogJycsXG4gICAgICBvcHRpb25zLmNhc2NhZGUgPyAnIENBU0NBREUnIDogJydcbiAgICBdLmpvaW4oJycpO1xuICB9XG5cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgPyBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9YCA6ICcnO1xuICAgIGxldCBwcmltYXJ5S2V5cyA9ICcnO1xuICAgIGxldCBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9ICcnO1xuXG4gICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGAgV0hFUkUgJHt3aGVyZUNsYXVzZX1gO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IExJTUlUIGRlbGV0ZSB3aXRob3V0IGEgbW9kZWwuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBrcyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcChwayA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihway5maWVsZCkpLmpvaW4oJywnKTtcblxuICAgICAgcHJpbWFyeUtleXMgPSBtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGggPiAxID8gYCgke3Brc30pYCA6IHBrcztcbiAgICAgIHByaW1hcnlLZXlzU2VsZWN0aW9uID0gcGtzO1xuXG4gICAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGFibGV9IFdIRVJFICR7cHJpbWFyeUtleXN9IElOIChTRUxFQ1QgJHtwcmltYXJ5S2V5c1NlbGVjdGlvbn0gRlJPTSAke3RhYmxlfSR7d2hlcmVDbGF1c2V9JHtsaW1pdH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RhYmxlfSR7d2hlcmVDbGF1c2V9YDtcbiAgfVxuXG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgbGV0IHNjaGVtYUpvaW4gPSAnJztcbiAgICBsZXQgc2NoZW1hV2hlcmUgPSAnJztcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtYUpvaW4gPSAnLCBwZ19uYW1lc3BhY2Ugcyc7XG4gICAgICBzY2hlbWFXaGVyZSA9IGAgQU5EIHMub2lkID0gdC5yZWxuYW1lc3BhY2UgQU5EIHMubnNwbmFtZSA9ICcke3RhYmxlTmFtZS5zY2hlbWF9J2A7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgQVJDQU5FIVxuICAgIHJldHVybiAnU0VMRUNUIGkucmVsbmFtZSBBUyBuYW1lLCBpeC5pbmRpc3ByaW1hcnkgQVMgcHJpbWFyeSwgaXguaW5kaXN1bmlxdWUgQVMgdW5pcXVlLCBpeC5pbmRrZXkgQVMgaW5ka2V5LCAnICtcbiAgICAgICdhcnJheV9hZ2coYS5hdHRudW0pIGFzIGNvbHVtbl9pbmRleGVzLCBhcnJheV9hZ2coYS5hdHRuYW1lKSBBUyBjb2x1bW5fbmFtZXMsIHBnX2dldF9pbmRleGRlZihpeC5pbmRleHJlbGlkKSAnICtcbiAgICAgIGBBUyBkZWZpbml0aW9uIEZST00gcGdfY2xhc3MgdCwgcGdfY2xhc3MgaSwgcGdfaW5kZXggaXgsIHBnX2F0dHJpYnV0ZSBhJHtzY2hlbWFKb2lufSBgICtcbiAgICAgICdXSEVSRSB0Lm9pZCA9IGl4LmluZHJlbGlkIEFORCBpLm9pZCA9IGl4LmluZGV4cmVsaWQgQU5EIGEuYXR0cmVsaWQgPSB0Lm9pZCBBTkQgJyArXG4gICAgICBgdC5yZWxraW5kID0gJ3InIGFuZCB0LnJlbG5hbWUgPSAnJHt0YWJsZU5hbWV9JyR7c2NoZW1hV2hlcmV9IGAgK1xuICAgICAgJ0dST1VQIEJZIGkucmVsbmFtZSwgaXguaW5kZXhyZWxpZCwgaXguaW5kaXNwcmltYXJ5LCBpeC5pbmRpc3VuaXF1ZSwgaXguaW5ka2V5IE9SREVSIEJZIGkucmVsbmFtZTsnO1xuICB9XG5cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgLy9Qb3N0Z3JlcyBjb252ZXJ0cyBjYW1lbENhc2VkIGFsaWFzIHRvIGxvd2VyY2FzZSB1bmxlc3MgcXVvdGVkXG4gICAgcmV0dXJuIFtcbiAgICAgICdTRUxFQ1QgY29uc3RyYWludF9jYXRhbG9nIEFTIFwiY29uc3RyYWludENhdGFsb2dcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfc2NoZW1hIEFTIFwiY29uc3RyYWludFNjaGVtYVwiLCcsXG4gICAgICAnY29uc3RyYWludF9uYW1lIEFTIFwiY29uc3RyYWludE5hbWVcIiwnLFxuICAgICAgJ3RhYmxlX2NhdGFsb2cgQVMgXCJ0YWJsZUNhdGFsb2dcIiwnLFxuICAgICAgJ3RhYmxlX3NjaGVtYSBBUyBcInRhYmxlU2NoZW1hXCIsJyxcbiAgICAgICd0YWJsZV9uYW1lIEFTIFwidGFibGVOYW1lXCIsJyxcbiAgICAgICdjb25zdHJhaW50X3R5cGUgQVMgXCJjb25zdHJhaW50VHlwZVwiLCcsXG4gICAgICAnaXNfZGVmZXJyYWJsZSBBUyBcImlzRGVmZXJyYWJsZVwiLCcsXG4gICAgICAnaW5pdGlhbGx5X2RlZmVycmVkIEFTIFwiaW5pdGlhbGx5RGVmZXJyZWRcIicsXG4gICAgICAnZnJvbSBJTkZPUk1BVElPTl9TQ0hFTUEudGFibGVfY29uc3RyYWludHMnLFxuICAgICAgYFdIRVJFIHRhYmxlX25hbWU9JyR7dGFibGVOYW1lfSc7YFxuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKCdfJyl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBEUk9QIElOREVYIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpfWA7XG4gIH1cblxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gJyc7XG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICBpZiAob3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSAnIExJTUlUICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9ICcgT0ZGU0VUICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCB0eXBlO1xuICAgIGlmIChcbiAgICAgIGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHxcbiAgICAgIGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIGF0dHJpYnV0ZS50eXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTVxuICAgICkge1xuICAgICAgY29uc3QgZW51bVR5cGUgPSBhdHRyaWJ1dGUudHlwZS50eXBlIHx8IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgbGV0IHZhbHVlcyA9IGF0dHJpYnV0ZS52YWx1ZXM7XG5cbiAgICAgIGlmIChlbnVtVHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gZW51bVR5cGUudmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHR5cGUgPSBgRU5VTSgke3ZhbHVlcy5tYXAodmFsdWUgPT4gdGhpcy5lc2NhcGUodmFsdWUpKS5qb2luKCcsICcpfSlgO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgICAgIHR5cGUgKz0gJ1tdJztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgZm9yIEVOVU0gaGF2ZW4ndCBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgIH1cblxuICAgIGxldCBzcWwgPSB0eXBlLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgJ2FsbG93TnVsbCcpICYmICFhdHRyaWJ1dGUuYWxsb3dOdWxsKSB7XG4gICAgICBzcWwgKz0gJyBOT1QgTlVMTCc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnRJZGVudGl0eSkge1xuICAgICAgICBzcWwgKz0gJyBHRU5FUkFURUQgQlkgREVGQVVMVCBBUyBJREVOVElUWSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgKz0gJyBTRVJJQUwnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHNxbCArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlLCBhdHRyaWJ1dGUpfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHNxbCArPSAnIFVOSVFVRSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICBzcWwgKz0gJyBQUklNQVJZIEtFWSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBsZXQgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKTtcbiAgICAgIGxldCBzY2hlbWE7XG5cbiAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICghYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgfHwgdHlwZW9mIGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsID09ICdzdHJpbmcnKVxuICAgICAgICAmJiBvcHRpb25zLnRhYmxlXG4gICAgICAgICYmIG9wdGlvbnMudGFibGUuc2NoZW1hXG4gICAgICApIHtcbiAgICAgICAgc2NoZW1hID0gb3B0aW9ucy50YWJsZS5zY2hlbWE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgICAgICB0YWJsZU5hbWU6IHJlZmVyZW5jZXNUYWJsZSxcbiAgICAgICAgICBfc2NoZW1hOiBzY2hlbWFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVmZXJlbmNlc0tleTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoJ2lkJyk7XG4gICAgICB9XG5cbiAgICAgIHNxbCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzVGFibGV9ICgke3JlZmVyZW5jZXNLZXl9KWA7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgc3FsICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICBzcWwgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMuZGVmZXJyYWJsZSkge1xuICAgICAgICBzcWwgKz0gYCAke2F0dHJpYnV0ZS5yZWZlcmVuY2VzLmRlZmVycmFibGUudG9TdHJpbmcodGhpcyl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQgJiYgdHlwZW9mIGF0dHJpYnV0ZS5jb21tZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMuY29udGV4dCA9PT0gJ2FkZENvbHVtbicgfHwgb3B0aW9ucy5jb250ZXh0ID09PSAnY2hhbmdlQ29sdW1uJykpIHtcbiAgICAgICAgY29uc3QgcXVvdGVkQXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMua2V5KTtcbiAgICAgICAgY29uc3QgZXNjYXBlZENvbW1lbnRUZXh0ID0gdGhpcy5lc2NhcGUoYXR0cmlidXRlLmNvbW1lbnQpO1xuICAgICAgICBzcWwgKz0gYDsgQ09NTUVOVCBPTiBDT0xVTU4gJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy50YWJsZSl9LiR7cXVvdGVkQXR0cn0gSVMgJHtlc2NhcGVkQ29tbWVudFRleHR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZvciBjcmVhdGVUYWJsZSBldmVudCB3aGljaCBkb2VzIGl0J3Mgb3duIHBhcnNpbmdcbiAgICAgICAgLy8gVE9ETzogY2VudHJhbGl6ZSBjcmVhdGlvbiBvZiBjb21tZW50IHN0YXRlbWVudHMgaGVyZVxuICAgICAgICBzcWwgKz0gYCBDT01NRU5UICR7YXR0cmlidXRlLmNvbW1lbnR9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kZWZlcnJhYmxlLnRvU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsIHR5cGUpIHtcbiAgICBsZXQgY29sdW1uRnJhZ21lbnQgPSAnQUxMJztcblxuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICBjb2x1bW5GcmFnbWVudCA9IGNvbHVtbnMubWFwKGNvbHVtbiA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihjb2x1bW4pKS5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIHJldHVybiBgU0VUIENPTlNUUkFJTlRTICR7Y29sdW1uRnJhZ21lbnR9ICR7dHlwZX1gO1xuICB9XG5cbiAgc2V0RGVmZXJyZWRRdWVyeShjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsICdERUZFUlJFRCcpO1xuICB9XG5cbiAgc2V0SW1tZWRpYXRlUXVlcnkoY29sdW1ucykge1xuICAgIHJldHVybiB0aGlzLnNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCAnSU1NRURJQVRFJyk7XG4gIH1cblxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIHsga2V5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjcmVhdGVUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIGV2ZW50VHlwZSwgZmlyZU9uU3BlYywgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgb3B0aW9uc0FycmF5KSB7XG4gICAgY29uc3QgZGVjb2RlZEV2ZW50VHlwZSA9IHRoaXMuZGVjb2RlVHJpZ2dlckV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgIGNvbnN0IGV2ZW50U3BlYyA9IHRoaXMuZXhwYW5kVHJpZ2dlckV2ZW50U3BlYyhmaXJlT25TcGVjKTtcbiAgICBjb25zdCBleHBhbmRlZE9wdGlvbnMgPSB0aGlzLmV4cGFuZE9wdGlvbnMob3B0aW9uc0FycmF5KTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChmdW5jdGlvblBhcmFtcyk7XG5cbiAgICByZXR1cm4gYENSRUFURSAke3RoaXMudHJpZ2dlckV2ZW50VHlwZUlzQ29uc3RyYWludChldmVudFR5cGUpfVRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmlnZ2VyTmFtZSl9ICR7ZGVjb2RlZEV2ZW50VHlwZX0gJHtcbiAgICAgIGV2ZW50U3BlY30gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0ke2V4cGFuZGVkT3B0aW9ucyA/IGAgJHtleHBhbmRlZE9wdGlvbnN9YCA6ICcnfSBFWEVDVVRFIFBST0NFRFVSRSAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KTtgO1xuICB9XG5cbiAgZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBUUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJpZ2dlck5hbWUpfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRVNUUklDVDtgO1xuICB9XG5cbiAgcmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSkge1xuICAgIHJldHVybiBgQUxURVIgVFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKG9sZFRyaWdnZXJOYW1lKX0gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIFRPICR7dGhpcy5xdW90ZUlkZW50aWZpZXIobmV3VHJpZ2dlck5hbWUpfTtgO1xuICB9XG5cbiAgY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSB8fCAhcmV0dXJuVHlwZSB8fCAhbGFuZ3VhZ2UgfHwgIWJvZHkpIHRocm93IG5ldyBFcnJvcignY3JlYXRlRnVuY3Rpb24gbWlzc2luZyBzb21lIHBhcmFtZXRlcnMuIERpZCB5b3UgcGFzcyBmdW5jdGlvbk5hbWUsIHJldHVyblR5cGUsIGxhbmd1YWdlIGFuZCBib2R5PycpO1xuXG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICBjb25zdCB2YXJpYWJsZUxpc3QgPSBvcHRpb25zICYmIG9wdGlvbnMudmFyaWFibGVzID8gdGhpcy5fZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3Qob3B0aW9ucy52YXJpYWJsZXMpIDogJyc7XG4gICAgY29uc3QgZXhwYW5kZWRPcHRpb25zQXJyYXkgPSB0aGlzLmV4cGFuZE9wdGlvbnMob3B0aW9uc0FycmF5KTtcblxuICAgIGNvbnN0IHN0YXRlbWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZSA/ICdDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTicgOiAnQ1JFQVRFIEZVTkNUSU9OJztcblxuICAgIHJldHVybiBgJHtzdGF0ZW1lbnR9ICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFVFVSTlMgJHtyZXR1cm5UeXBlfSBBUyAkZnVuYyQgJHt2YXJpYWJsZUxpc3R9IEJFR0lOICR7Ym9keX0gRU5EOyAkZnVuYyQgbGFuZ3VhZ2UgJyR7bGFuZ3VhZ2V9JyR7ZXhwYW5kZWRPcHRpb25zQXJyYXl9O2A7XG4gIH1cblxuICBkcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSkgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBmdW5jdGlvbk5hbWUnKTtcbiAgICAvLyBSRVNUUklDVCBpcyAoY3VycmVudGx5LCBhcyBvZiA5LjIpIGRlZmF1bHQgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICByZXR1cm4gYERST1AgRlVOQ1RJT04gJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVTVFJJQ1Q7YDtcbiAgfVxuXG4gIHJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUpIHtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIHJldHVybiBgQUxURVIgRlVOQ1RJT04gJHtvbGRGdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVOQU1FIFRPICR7bmV3RnVuY3Rpb25OYW1lfTtgO1xuICB9XG5cbiAgcGdFc2NhcGVBbmRRdW90ZSh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoVXRpbHMucmVtb3ZlVGlja3ModGhpcy5lc2NhcGUodmFsKSwgXCInXCIpKTtcbiAgfVxuXG4gIF9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3Q6IGZ1bmN0aW9uIHBhcmFtZXRlcnMgYXJyYXkgcmVxdWlyZWQsIGluY2x1ZGluZyBhbiBlbXB0eSBvbmUgZm9yIG5vIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IFtdO1xuICAgIHBhcmFtcy5mb3JFYWNoKGN1clBhcmFtID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtRGVmID0gW107XG4gICAgICBpZiAoY3VyUGFyYW0udHlwZSkge1xuICAgICAgICBpZiAoY3VyUGFyYW0uZGlyZWN0aW9uKSB7IHBhcmFtRGVmLnB1c2goY3VyUGFyYW0uZGlyZWN0aW9uKTsgfVxuICAgICAgICBpZiAoY3VyUGFyYW0ubmFtZSkgeyBwYXJhbURlZi5wdXNoKGN1clBhcmFtLm5hbWUpOyB9XG4gICAgICAgIHBhcmFtRGVmLnB1c2goY3VyUGFyYW0udHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uIG9yIHRyaWdnZXIgdXNlZCB3aXRoIGEgcGFyYW1ldGVyIHdpdGhvdXQgYW55IHR5cGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgam9pbmVkID0gcGFyYW1EZWYuam9pbignICcpO1xuICAgICAgaWYgKGpvaW5lZCkgcGFyYW1MaXN0LnB1c2goam9pbmVkKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcmFtTGlzdC5qb2luKCcsICcpO1xuICB9XG5cbiAgX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0KHZhcmlhYmxlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJpYWJsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ19leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdDogZnVuY3Rpb24gdmFyaWFibGVzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFibGVEZWZpbml0aW9ucyA9IFtdO1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKHZhcmlhYmxlID0+IHtcbiAgICAgIGlmICghdmFyaWFibGUubmFtZSB8fCAhdmFyaWFibGUudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uIHZhcmlhYmxlIG11c3QgaGF2ZSBhIG5hbWUgYW5kIHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIGxldCB2YXJpYWJsZURlZmluaXRpb24gPSBgREVDTEFSRSAke3ZhcmlhYmxlLm5hbWV9ICR7dmFyaWFibGUudHlwZX1gO1xuICAgICAgaWYgKHZhcmlhYmxlLmRlZmF1bHQpIHtcbiAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uICs9IGAgOj0gJHt2YXJpYWJsZS5kZWZhdWx0fWA7XG4gICAgICB9XG4gICAgICB2YXJpYWJsZURlZmluaXRpb24gKz0gJzsnO1xuICAgICAgdmFyaWFibGVEZWZpbml0aW9ucy5wdXNoKHZhcmlhYmxlRGVmaW5pdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlRGVmaW5pdGlvbnMuam9pbignICcpO1xuICB9XG5cbiAgZXhwYW5kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBfLmlzRW1wdHkob3B0aW9ucykgP1xuICAgICAgJycgOiBvcHRpb25zLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGRlY29kZVRyaWdnZXJFdmVudFR5cGUoZXZlbnRTcGVjaWZpZXIpIHtcbiAgICBjb25zdCBFVkVOVF9ERUNPREVSID0ge1xuICAgICAgJ2FmdGVyJzogJ0FGVEVSJyxcbiAgICAgICdiZWZvcmUnOiAnQkVGT1JFJyxcbiAgICAgICdpbnN0ZWFkX29mJzogJ0lOU1RFQUQgT0YnLFxuICAgICAgJ2FmdGVyX2NvbnN0cmFpbnQnOiAnQUZURVInXG4gICAgfTtcblxuICAgIGlmICghRVZFTlRfREVDT0RFUltldmVudFNwZWNpZmllcl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmlnZ2VyIGV2ZW50IHNwZWNpZmllZDogJHtldmVudFNwZWNpZmllcn1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRVZFTlRfREVDT0RFUltldmVudFNwZWNpZmllcl07XG4gIH1cblxuICB0cmlnZ2VyRXZlbnRUeXBlSXNDb25zdHJhaW50KGV2ZW50U3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIGV2ZW50U3BlY2lmaWVyID09PSAnYWZ0ZXJfY29uc3RyYWludCcgPyAnQ09OU1RSQUlOVCAnIDogJyc7XG4gIH1cblxuICBleHBhbmRUcmlnZ2VyRXZlbnRTcGVjKGZpcmVPblNwZWMpIHtcbiAgICBpZiAoXy5pc0VtcHR5KGZpcmVPblNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHRhYmxlIGNoYW5nZSBldmVudHMgc3BlY2lmaWVkIHRvIHRyaWdnZXIgb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy5tYXAoZmlyZU9uU3BlYywgKGZpcmVWYWx1ZSwgZmlyZUtleSkgPT4ge1xuICAgICAgY29uc3QgRVZFTlRfTUFQID0ge1xuICAgICAgICAnaW5zZXJ0JzogJ0lOU0VSVCcsXG4gICAgICAgICd1cGRhdGUnOiAnVVBEQVRFJyxcbiAgICAgICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICAgICAndHJ1bmNhdGUnOiAnVFJVTkNBVEUnXG4gICAgICB9O1xuXG4gICAgICBpZiAoIUVWRU5UX01BUFtmaXJlVmFsdWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VUcmlnZ2VyRXZlbnRTcGVjOiB1bmRlZmluZWQgdHJpZ2dlciBldmVudCAke2ZpcmVLZXl9YCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBldmVudFNwZWMgPSBFVkVOVF9NQVBbZmlyZVZhbHVlXTtcbiAgICAgIGlmIChldmVudFNwZWMgPT09ICdVUERBVEUnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpcmVWYWx1ZSkgJiYgZmlyZVZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBldmVudFNwZWMgKz0gYCBPRiAke2ZpcmVWYWx1ZS5qb2luKCcsICcpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50U3BlYztcbiAgICB9KS5qb2luKCcgT1IgJyk7XG4gIH1cblxuICBwZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0ciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgdGFibGVEZXRhaWxzID0gdGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgbGV0IGVudW1OYW1lID0gVXRpbHMuYWRkVGlja3MoVXRpbHMuZ2VuZXJhdGVFbnVtTmFtZSh0YWJsZURldGFpbHMudGFibGVOYW1lLCBhdHRyKSwgJ1wiJyk7XG5cbiAgICAvLyBwZ0xpc3RFbnVtcyByZXF1aXJlcyB0aGUgZW51bSBuYW1lIG9ubHksIHdpdGhvdXQgdGhlIHNjaGVtYVxuICAgIGlmIChvcHRpb25zLnNjaGVtYSAhPT0gZmFsc2UgJiYgdGFibGVEZXRhaWxzLnNjaGVtYSkge1xuICAgICAgZW51bU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZURldGFpbHMuc2NoZW1hKSArIHRhYmxlRGV0YWlscy5kZWxpbWl0ZXIgKyBlbnVtTmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW51bU5hbWU7XG4gIH1cblxuICBwZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGVudW1OYW1lID0gJyc7XG4gICAgY29uc3QgdGFibGVEZXRhaWxzID0gdGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGFibGVEZXRhaWxzLnRhYmxlTmFtZSAmJiBhdHRyTmFtZSkge1xuICAgICAgZW51bU5hbWUgPSBgIEFORCB0LnR5cG5hbWU9JHt0aGlzLnBnRW51bU5hbWUodGFibGVEZXRhaWxzLnRhYmxlTmFtZSwgYXR0ck5hbWUsIHsgc2NoZW1hOiBmYWxzZSB9KS5yZXBsYWNlKC9cIi9nLCBcIidcIil9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1NFTEVDVCB0LnR5cG5hbWUgZW51bV9uYW1lLCBhcnJheV9hZ2coZS5lbnVtbGFiZWwgT1JERVIgQlkgZW51bXNvcnRvcmRlcikgZW51bV92YWx1ZSBGUk9NIHBnX3R5cGUgdCAnICtcbiAgICAgICdKT0lOIHBnX2VudW0gZSBPTiB0Lm9pZCA9IGUuZW51bXR5cGlkICcgK1xuICAgICAgJ0pPSU4gcGdfY2F0YWxvZy5wZ19uYW1lc3BhY2UgbiBPTiBuLm9pZCA9IHQudHlwbmFtZXNwYWNlICcgK1xuICAgICAgYFdIRVJFIG4ubnNwbmFtZSA9ICcke3RhYmxlRGV0YWlscy5zY2hlbWF9JyR7ZW51bU5hbWV9IEdST1VQIEJZIDFgO1xuICB9XG5cbiAgcGdFbnVtKHRhYmxlTmFtZSwgYXR0ciwgZGF0YVR5cGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIsIG9wdGlvbnMpO1xuICAgIGxldCB2YWx1ZXM7XG5cbiAgICBpZiAoZGF0YVR5cGUudmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBgRU5VTSgke2RhdGFUeXBlLnZhbHVlcy5tYXAodmFsdWUgPT4gdGhpcy5lc2NhcGUodmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBkYXRhVHlwZS50b1N0cmluZygpLm1hdGNoKC9eRU5VTVxcKC4rXFwpLylbMF07XG4gICAgfVxuXG4gICAgbGV0IHNxbCA9IGBDUkVBVEUgVFlQRSAke2VudW1OYW1lfSBBUyAke3ZhbHVlc307YDtcbiAgICBpZiAoISFvcHRpb25zICYmIG9wdGlvbnMuZm9yY2UgPT09IHRydWUpIHtcbiAgICAgIHNxbCA9IHRoaXMucGdFbnVtRHJvcCh0YWJsZU5hbWUsIGF0dHIpICsgc3FsO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgcGdFbnVtQWRkKHRhYmxlTmFtZSwgYXR0ciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpO1xuICAgIGxldCBzcWwgPSBgQUxURVIgVFlQRSAke2VudW1OYW1lfSBBREQgVkFMVUUgYDtcblxuICAgIGlmIChzZW12ZXIuZ3RlKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCAnOS4zLjAnKSkge1xuICAgICAgc3FsICs9ICdJRiBOT1QgRVhJU1RTICc7XG4gICAgfVxuICAgIHNxbCArPSB0aGlzLmVzY2FwZSh2YWx1ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5iZWZvcmUpIHtcbiAgICAgIHNxbCArPSBgIEJFRk9SRSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuYmVmb3JlKX1gO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hZnRlcikge1xuICAgICAgc3FsICs9IGAgQUZURVIgJHt0aGlzLmVzY2FwZShvcHRpb25zLmFmdGVyKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICBwZ0VudW1Ecm9wKHRhYmxlTmFtZSwgYXR0ciwgZW51bU5hbWUpIHtcbiAgICBlbnVtTmFtZSA9IGVudW1OYW1lIHx8IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpO1xuICAgIHJldHVybiBgRFJPUCBUWVBFIElGIEVYSVNUUyAke2VudW1OYW1lfTsgYDtcbiAgfVxuXG4gIGZyb21BcnJheSh0ZXh0KSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXnsvLCAnJykucmVwbGFjZSgvfSQvLCAnJyk7XG4gICAgbGV0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKC8oXCIoPzpcXFxcLnxbXlwiXFxcXFxcXFxdKSpcInxbXixdKikoPzpcXHMqLFxccyp8XFxzKiQpL2lnKTtcblxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5tYXAobSA9PiBtLnJlcGxhY2UoL1wiLCQvLCAnJykucmVwbGFjZSgvLCQvLCAnJykucmVwbGFjZSgvKF5cInxcIiQpL2csICcnKSk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCAtMSk7XG4gIH1cblxuICBkYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyLCBkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkge1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICcnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1NFUklBTCcpKSB7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ0JJR0lOVCcpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnU0VSSUFMJywgJ0JJR1NFUklBTCcpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ0JJR0lOVCcsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1NNQUxMSU5UJykpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdTRVJJQUwnLCAnU01BTExTRVJJQUwnKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdTTUFMTElOVCcsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnSU5URUdFUicsICcnKTtcbiAgICAgIH1cbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnTk9UIE5VTEwnLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFUeXBlLnN0YXJ0c1dpdGgoJ0VOVU0oJykpIHtcbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgvXkVOVU1cXCguK1xcKS8sIHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVR5cGU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgYWxsIGZvcmVpZ24ga2V5cyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhYmxlTmFtZSAgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gJ1NFTEVDVCBjb25uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgcGdfY2F0YWxvZy5wZ19nZXRfY29uc3RyYWludGRlZihyLm9pZCwgdHJ1ZSkgYXMgY29uZGVmIEZST00gcGdfY2F0YWxvZy5wZ19jb25zdHJhaW50IHIgJyArXG4gICAgICBgV0hFUkUgci5jb25yZWxpZCA9IChTRUxFQ1Qgb2lkIEZST00gcGdfY2xhc3MgV0hFUkUgcmVsbmFtZSA9ICcke3RhYmxlTmFtZX0nIExJTUlUIDEpIEFORCByLmNvbnR5cGUgPSAnZicgT1JERVIgQlkgMTtgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGNvbW1vbiBTUUwgcHJlZml4IGZvciBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKSB7XG4gICAgcmV0dXJuICdTRUxFQ1QgJyArXG4gICAgICAnRElTVElOQ1QgdGMuY29uc3RyYWludF9uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgJyArXG4gICAgICAndGMuY29uc3RyYWludF9zY2hlbWEgYXMgY29uc3RyYWludF9zY2hlbWEsICcgK1xuICAgICAgJ3RjLmNvbnN0cmFpbnRfY2F0YWxvZyBhcyBjb25zdHJhaW50X2NhdGFsb2csICcgK1xuICAgICAgJ3RjLnRhYmxlX25hbWUgYXMgdGFibGVfbmFtZSwnICtcbiAgICAgICd0Yy50YWJsZV9zY2hlbWEgYXMgdGFibGVfc2NoZW1hLCcgK1xuICAgICAgJ3RjLnRhYmxlX2NhdGFsb2cgYXMgdGFibGVfY2F0YWxvZywnICtcbiAgICAgICdrY3UuY29sdW1uX25hbWUgYXMgY29sdW1uX25hbWUsJyArXG4gICAgICAnY2N1LnRhYmxlX3NjaGVtYSAgQVMgcmVmZXJlbmNlZF90YWJsZV9zY2hlbWEsJyArXG4gICAgICAnY2N1LnRhYmxlX2NhdGFsb2cgIEFTIHJlZmVyZW5jZWRfdGFibGVfY2F0YWxvZywnICtcbiAgICAgICdjY3UudGFibGVfbmFtZSAgQVMgcmVmZXJlbmNlZF90YWJsZV9uYW1lLCcgK1xuICAgICAgJ2NjdS5jb2x1bW5fbmFtZSBBUyByZWZlcmVuY2VkX2NvbHVtbl9uYW1lICcgK1xuICAgICAgJ0ZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlX2NvbnN0cmFpbnRzIEFTIHRjICcgK1xuICAgICAgJ0pPSU4gaW5mb3JtYXRpb25fc2NoZW1hLmtleV9jb2x1bW5fdXNhZ2UgQVMga2N1ICcgK1xuICAgICAgJ09OIHRjLmNvbnN0cmFpbnRfbmFtZSA9IGtjdS5jb25zdHJhaW50X25hbWUgJyArXG4gICAgICAnSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuY29uc3RyYWludF9jb2x1bW5fdXNhZ2UgQVMgY2N1ICcgK1xuICAgICAgJ09OIGNjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWUgJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyBhbGwgZm9yZWlnbiBrZXlzIGRldGFpbHMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQXMgZm9yIGdldEZvcmVpZ25LZXlzUXVlcnkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5LCBzbyBhZGQgYSBuZXcgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGFsb2dOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWFOYW1lXG4gICAqL1xuICBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5KHRhYmxlTmFtZSwgY2F0YWxvZ05hbWUsIHNjaGVtYU5hbWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpXG4gICAgfVdIRVJFIGNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWScgQU5EIHRjLnRhYmxlX25hbWUgPSAnJHt0YWJsZU5hbWV9JyR7XG4gICAgICBjYXRhbG9nTmFtZSA/IGAgQU5EIHRjLnRhYmxlX2NhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nYCA6ICcnXG4gICAgfSR7c2NoZW1hTmFtZSA/IGAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICcke3NjaGVtYU5hbWV9J2AgOiAnJ31gO1xuICB9XG5cbiAgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICByZXR1cm4gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpXG4gICAgfVdIRVJFIGNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWScgQU5EIHRjLnRhYmxlX25hbWU9JyR7dGFibGVOYW1lfScgQU5EICBrY3UuY29sdW1uX25hbWUgPSAnJHtjb2x1bW5OYW1lfScke1xuICAgICAgc2NoZW1hID8gYCBBTkQgdGMudGFibGVfc2NoZW1hID0gJyR7c2NoZW1hfSdgIDogJyd9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmVtb3ZlcyBhIGZvcmVpZ24ga2V5IGZyb20gYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBmb3JlaWduS2V5IFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBjb25zdHJhaW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IERST1AgQ09OU1RSQUlOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpfTtgO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zdGdyZXNRdWVyeUdlbmVyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIHRoYXQgU2VxdWVsaXplIHVzZXMgdG8gdGFsayB3aXRoIFBvc3RncmVzIGRhdGFiYXNlXG4gKi9cbmNsYXNzIFBvc3RncmVzUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBFbnN1cmUgZW51bSBhbmQgdGhlaXIgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICBOYW1lIG9mIHRhYmxlIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyBPYmplY3QgcmVwcmVzZW50aW5nIGEgbGlzdCBvZiBub3JtYWxpemVkIHRhYmxlIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge01vZGVsfSAgW21vZGVsXVxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhc3luYyBlbnN1cmVFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGtleUxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgbGV0IHNxbCA9ICcnO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXlzW2ldXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHxcbiAgICAgICAgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiB0eXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSAvL0FSUkFZIHN1YiB0eXBlIGlzIEVOVU1cbiAgICAgICkge1xuICAgICAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnTGlzdEVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlLmZpZWxkIHx8IGtleXNbaV0sIG9wdGlvbnMpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgICAgIHNxbCxcbiAgICAgICAgICB7IC4uLm9wdGlvbnMsIHBsYWluOiB0cnVlLCByYXc6IHRydWUsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUIH1cbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBwcm9taXNlcyA9IFtdO1xuICAgIGxldCBlbnVtSWR4ID0gMDtcblxuICAgIC8vIFRoaXMgbGl0dGxlIGZ1bmN0aW9uIGFsbG93cyB1cyB0byByZS11c2UgdGhlIHNhbWUgY29kZSB0aGF0IHByZXBlbmRzIG9yIGFwcGVuZHMgbmV3IHZhbHVlIHRvIGVudW0gYXJyYXlcbiAgICBjb25zdCBhZGRFbnVtVmFsdWUgPSAoZmllbGQsIHZhbHVlLCByZWxhdGl2ZVZhbHVlLCBwb3NpdGlvbiA9ICdiZWZvcmUnLCBzcGxpY2VTdGFydCA9IHByb21pc2VzLmxlbmd0aCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICB2YWx1ZU9wdGlvbnMuYmVmb3JlID0gbnVsbDtcbiAgICAgIHZhbHVlT3B0aW9ucy5hZnRlciA9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgIHZhbHVlT3B0aW9ucy5hZnRlciA9IHJlbGF0aXZlVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWVPcHRpb25zLmJlZm9yZSA9IHJlbGF0aXZlVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2VzLnNwbGljZShzcGxpY2VTdGFydCwgMCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1BZGQoXG4gICAgICAgICAgdGFibGVOYW1lLCBmaWVsZCwgdmFsdWUsIHZhbHVlT3B0aW9uc1xuICAgICAgICApLCB2YWx1ZU9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXlzW2ldXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcbiAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZS50eXBlIHx8IHR5cGU7XG4gICAgICBjb25zdCBmaWVsZCA9IGF0dHJpYnV0ZS5maWVsZCB8fCBrZXlzW2ldO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fFxuICAgICAgICB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIGVudW1UeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gLy9BUlJBWSBzdWIgdHlwZSBpcyBFTlVNXG4gICAgICApIHtcbiAgICAgICAgLy8gSWYgdGhlIGVudW0gdHlwZSBkb2Vzbid0IGV4aXN0IHRoZW4gY3JlYXRlIGl0XG4gICAgICAgIGlmICghcmVzdWx0c1tlbnVtSWR4XSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtKHRhYmxlTmFtZSwgZmllbGQsIGVudW1UeXBlLCBvcHRpb25zKSwgeyAuLi5vcHRpb25zLCByYXc6IHRydWUgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFyZXN1bHRzW2VudW1JZHhdICYmICEhbW9kZWwpIHtcbiAgICAgICAgICBjb25zdCBlbnVtVmFscyA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJlc3VsdHNbZW51bUlkeF0uZW51bV92YWx1ZSk7XG4gICAgICAgICAgY29uc3QgdmFscyA9IGVudW1UeXBlLnZhbHVlcztcblxuICAgICAgICAgIC8vIEdvaW5nIHRocm91Z2ggYWxyZWFkeSBleGlzdGluZyB2YWx1ZXMgYWxsb3dzIHVzIHRvIG1ha2UgcXVlcmllcyB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXNcbiAgICAgICAgICAvLyBXZSB3aWxsIHByZXBlbmQgYWxsIG5ldyB2YWx1ZXMgYmV0d2VlbiB0aGUgb2xkIG9uZXMsIGJ1dCBrZWVwIGluIG1pbmQgLSB3ZSBjYW4ndCBjaGFuZ2Ugb3JkZXIgb2YgYWxyZWFkeSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgICAvLyBUaGVuIHdlIGFwcGVuZCB0aGUgcmVzdCBvZiBuZXcgdmFsdWVzIEFGVEVSIHRoZSBsYXRlc3QgYWxyZWFkeSBleGlzdGluZyB2YWx1ZVxuICAgICAgICAgIC8vIEUuZy46IFsxLDJdIC0+IFswLDIsMV0gPT0+IFsxLDAsMl1cbiAgICAgICAgICAvLyBFLmcuOiBbMSwyLDNdIC0+IFsyLDEsMyw0XSA9PT4gWzEsMiwzLDRdXG4gICAgICAgICAgLy8gRS5nLjogWzFdIC0+IFswLDIsM10gPT0+IFsxLDAsMiwzXVxuICAgICAgICAgIGxldCBsYXN0T2xkRW51bVZhbHVlO1xuICAgICAgICAgIGxldCByaWdodGVzdFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgZm9yIChsZXQgb2xkSW5kZXggPSAwOyBvbGRJbmRleCA8IGVudW1WYWxzLmxlbmd0aDsgb2xkSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgZW51bVZhbCA9IGVudW1WYWxzW29sZEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0lkeCA9IHZhbHMuaW5kZXhPZihlbnVtVmFsKTtcbiAgICAgICAgICAgIGxhc3RPbGRFbnVtVmFsdWUgPSBlbnVtVmFsO1xuXG4gICAgICAgICAgICBpZiAobmV3SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWVzQmVmb3JlID0gdmFscy5zbGljZSgwLCBuZXdJZHgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXNMZW5ndGggPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyB3ZSBnbyBpbiByZXZlcnNlIG9yZGVyIHNvIHdlIGNvdWxkIHN0b3Agd2hlbiB3ZSBtZWV0IG9sZCB2YWx1ZVxuICAgICAgICAgICAgZm9yIChsZXQgcmV2ZXJzZUlkeCA9IG5ld1ZhbHVlc0JlZm9yZS5sZW5ndGggLSAxOyByZXZlcnNlSWR4ID49IDA7IHJldmVyc2VJZHgtLSkge1xuICAgICAgICAgICAgICBpZiAofmVudW1WYWxzLmluZGV4T2YobmV3VmFsdWVzQmVmb3JlW3JldmVyc2VJZHhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWRkRW51bVZhbHVlKGZpZWxkLCBuZXdWYWx1ZXNCZWZvcmVbcmV2ZXJzZUlkeF0sIGxhc3RPbGRFbnVtVmFsdWUsICdiZWZvcmUnLCBwcm9taXNlc0xlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIGRldGVjdCB0aGUgbW9zdCAncmlnaHQnIHBvc2l0aW9uIG9mIG9sZCB2YWx1ZSBpbiBuZXcgZW51bSBhcnJheSBzbyB3ZSBjYW4gYXBwZW5kIG5ldyB2YWx1ZXMgdG8gaXRcbiAgICAgICAgICAgIGlmIChuZXdJZHggPiByaWdodGVzdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ZXN0UG9zaXRpb24gPSBuZXdJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3RPbGRFbnVtVmFsdWUgJiYgcmlnaHRlc3RQb3NpdGlvbiA8IHZhbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRW51bVZhbHVlcyA9IHZhbHMuc2xpY2UocmlnaHRlc3RQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcmV2ZXJzZUlkeCA9IHJlbWFpbmluZ0VudW1WYWx1ZXMubGVuZ3RoIC0gMTsgcmV2ZXJzZUlkeCA+PSAwOyByZXZlcnNlSWR4LS0pIHtcbiAgICAgICAgICAgICAgYWRkRW51bVZhbHVlKGZpZWxkLCByZW1haW5pbmdFbnVtVmFsdWVzW3JldmVyc2VJZHhdLCBsYXN0T2xkRW51bVZhbHVlLCAnYWZ0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbnVtSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlc1xuICAgICAgLnJlZHVjZShhc3luYyAocHJvbWlzZSwgYXN5bmNGdW5jdGlvbikgPT4gYXdhaXQgYXN5bmNGdW5jdGlvbihhd2FpdCBwcm9taXNlKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuXG4gICAgLy8gSWYgRU5VTSBwcm9jZXNzZWQsIHRoZW4gcmVmcmVzaCBPSURzXG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5fcmVmcmVzaER5bmFtaWNPSURzKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTXG4gICAgfTtcblxuICAgIC8vIHBvc3RncmVzIG5lZWRzIHNvbWUgc3BlY2lhbCB0cmVhdG1lbnQgYXMgdGhvc2UgZmllbGQgbmFtZXMgcmV0dXJuZWQgYXJlIGFsbCBsb3dlcmNhc2VcbiAgICAvLyBpbiBvcmRlciB0byBrZWVwIHNhbWUgcmVzdWx0IHdpdGggb3RoZXIgZGlhbGVjdHMuXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBxdWVyeU9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQubWFwKFV0aWxzLmNhbWVsaXplT2JqZWN0S2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBzcGVjaWZpZWQgZW51bSBmcm9tIGRhdGFiYXNlIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VudW1OYW1lXSAgRW51bSBuYW1lIHRvIGRyb3BcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BFbnVtKGVudW1OYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AobnVsbCwgbnVsbCwgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VzY2FwZUFuZFF1b3RlKGVudW1OYW1lKSksXG4gICAgICB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCBlbnVtcyBmcm9tIGRhdGFiYXNlIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEFsbEVudW1zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGVudW1zID0gYXdhaXQgdGhpcy5wZ0xpc3RFbnVtcyhudWxsLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChlbnVtcy5tYXAocmVzdWx0ID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKG51bGwsIG51bGwsIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFc2NhcGVBbmRRdW90ZShyZXN1bHQuZW51bV9uYW1lKSksXG4gICAgICB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9XG4gICAgKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIGVudW1zIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhYmxlTmFtZV0gIFRhYmxlIHdob3NlIGVudW0gdG8gbGlzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBwZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnTGlzdEVudW1zKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLCBwbGFpbjogZmFsc2UsIHJhdzogdHJ1ZSwgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgcG9zdGdyZXMgaGFzIGEgc3BlY2lhbCBjYXNlIGZvciBlbnVtcywgd2Ugc2hvdWxkIGRyb3AgdGhlIHJlbGF0ZWRcbiAgICogZW51bSB0eXBlIHdpdGhpbiB0aGUgdGFibGUgYW5kIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBzdXBlci5kcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IGluc3RhbmNlVGFibGUgPSB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwodGFibGVOYW1lLCB7IGF0dHJpYnV0ZTogJ3RhYmxlTmFtZScgfSk7XG5cbiAgICBpZiAoIWluc3RhbmNlVGFibGUpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgd2hlbiBtb2RlbCBpcyBub3QgYXZhaWxhYmxlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0VGFibGVOYW1lID0gKCFvcHRpb25zIHx8ICFvcHRpb25zLnNjaGVtYSB8fCBvcHRpb25zLnNjaGVtYSA9PT0gJ3B1YmxpYycgPyAnJyA6IGAke29wdGlvbnMuc2NoZW1hfV9gKSArIHRhYmxlTmFtZTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZVRhYmxlLnJhd0F0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGtleUxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgaWYgKGluc3RhbmNlVGFibGUucmF3QXR0cmlidXRlc1trZXlzW2ldXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKGdldFRhYmxlTmFtZSwga2V5c1tpXSk7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydHNTZWFyY2hQYXRoID0gZmFsc2U7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG59XG5cbmV4cG9ydHMuUG9zdGdyZXNRdWVyeUludGVyZmFjZSA9IFBvc3RncmVzUXVlcnlJbnRlcmZhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeScpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcblxuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdzcWw6cGcnKTtcblxuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICAvKipcbiAgICogUmV3cml0ZSBxdWVyeSB3aXRoIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcWxcbiAgICogQHBhcmFtIHtBcnJheXxvYmplY3R9IHZhbHVlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhbGVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3Qgc3RyaW5nUmVwbGFjZUZ1bmMgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpIDogdmFsdWU7XG5cbiAgICBsZXQgYmluZFBhcmFtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGJpbmRQYXJhbSA9IHZhbHVlcy5tYXAoc3RyaW5nUmVwbGFjZUZ1bmMpO1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaW5kUGFyYW0gPSBbXTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMpID0+IHtcbiAgICAgICAgaWYgKHNlZW5ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlZW5ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgICBiaW5kUGFyYW0ucHVzaChzdHJpbmdSZXBsYWNlRnVuYyh2YWx1ZXNba2V5XSkpO1xuICAgICAgICAgIHNlZW5ba2V5XSA9IGAkJHtpfWA7XG4gICAgICAgICAgcmV0dXJuIGAkJHtpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuXG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IHRoaXM7XG5cbiAgICBpZiAoIV8uaXNFbXB0eSh0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCkpIHtcbiAgICAgIHNxbCA9IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3Iuc2V0U2VhcmNoUGF0aCh0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCkgKyBzcWw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiB0aGlzLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMpIHtcbiAgICAgIF8udG9QYWlycyh0aGlzLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMpXG4gICAgICAgIC8vIFNvcnRpbmcgdG8gcmVwbGFjZSB0aGUgbG9uZ2VzdCBhbGlhc2VzIGZpcnN0IHRvIHByZXZlbnQgYWxpYXMgY29sbGlzaW9uXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdLmxlbmd0aCAtIGFbMV0ubGVuZ3RoKVxuICAgICAgICAuZm9yRWFjaCgoW2FsaWFzLCBvcmlnaW5hbF0pID0+IHtcbiAgICAgICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKF8uZXNjYXBlUmVnRXhwKG9yaWdpbmFsKSwgJ2cnKTtcblxuICAgICAgICAgIHNxbCA9IHNxbC5yZXBsYWNlKHJlZywgYWxpYXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNxbCA9IHNxbDtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmxlbmd0aFxuICAgICAgPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uZWN0aW9uLnF1ZXJ5KHNxbCwgcGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkpXG4gICAgICA6IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm5lY3Rpb24ucXVlcnkoc3FsLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKSk7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuXG4gICAgbGV0IHF1ZXJ5UmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHF1ZXJ5UmVzdWx0ID0gYXdhaXQgcXVlcnk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBzZXQgdGhlIGNsaWVudCBzbyB0aGF0IGl0IHdpbGwgYmUgcmVhcGVkIGlmIHRoZSBjb25uZWN0aW9uIHJlc2V0cyB3aGlsZSBleGVjdXRpbmdcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uX2ludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlcnIuc3FsID0gc3FsO1xuICAgICAgZXJyLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnIpO1xuICAgIH1cblxuICAgIGNvbXBsZXRlKCk7XG5cbiAgICBsZXQgcm93cyA9IEFycmF5LmlzQXJyYXkocXVlcnlSZXN1bHQpXG4gICAgICA/IHF1ZXJ5UmVzdWx0LnJlZHVjZSgoYWxsUm93cywgcikgPT4gYWxsUm93cy5jb25jYXQoci5yb3dzIHx8IFtdKSwgW10pXG4gICAgICA6IHF1ZXJ5UmVzdWx0LnJvd3M7XG4gICAgY29uc3Qgcm93Q291bnQgPSBBcnJheS5pc0FycmF5KHF1ZXJ5UmVzdWx0KVxuICAgICAgPyBxdWVyeVJlc3VsdC5yZWR1Y2UoXG4gICAgICAgIChjb3VudCwgcikgPT4gTnVtYmVyLmlzRmluaXRlKHIucm93Q291bnQpID8gY291bnQgKyByLnJvd0NvdW50IDogY291bnQsXG4gICAgICAgIDBcbiAgICAgIClcbiAgICAgIDogcXVlcnlSZXN1bHQucm93Q291bnQgfHwgMDtcblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgdGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nKSB7XG4gICAgICByb3dzID0gcm93c1xuICAgICAgICAubWFwKHJvdyA9PiBfLnRvUGFpcnMocm93KVxuICAgICAgICAgIC5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nLmdldChrZXkpO1xuICAgICAgICAgICAgYWNjW21hcHBpbmcgfHwga2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCB7fSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1RhYmxlTmFtZVF1ZXJ5ID0gc3FsLnN0YXJ0c1dpdGgoJ1NFTEVDVCB0YWJsZV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcycpO1xuICAgIGNvbnN0IGlzUmVsTmFtZVF1ZXJ5ID0gc3FsLnN0YXJ0c1dpdGgoJ1NFTEVDVCByZWxuYW1lIEZST00gcGdfY2xhc3MgV0hFUkUgb2lkIElOJyk7XG5cbiAgICBpZiAoaXNSZWxOYW1lUXVlcnkpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4gKHtcbiAgICAgICAgbmFtZTogcm93LnJlbG5hbWUsXG4gICAgICAgIHRhYmxlTmFtZTogcm93LnJlbG5hbWUuc3BsaXQoJ18nKVswXVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoaXNUYWJsZU5hbWVRdWVyeSkge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiBPYmplY3QudmFsdWVzKHJvdykpO1xuICAgIH1cblxuICAgIGlmIChyb3dzWzBdICYmIHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcih7XG4gICAgICAgICAgc3FsLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgY29kZTogJzIzNTA1JyxcbiAgICAgICAgICBkZXRhaWw6IHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGRlbGV0ZSByb3cuc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IC9PTiAuKj8gKD86VVNJTkcgLio/XFxzKT9cXCgoW15dKilcXCkvZ2kuZXhlYyhyb3cuZGVmaW5pdGlvbilbMV0uc3BsaXQoJywnKTtcblxuICAgICAgICAvLyBNYXAgY29sdW1uIGluZGV4IGluIHRhYmxlIHRvIGNvbHVtbiBuYW1lXG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBfLnppcE9iamVjdChcbiAgICAgICAgICByb3cuY29sdW1uX2luZGV4ZXMsXG4gICAgICAgICAgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocm93LmNvbHVtbl9uYW1lcylcbiAgICAgICAgKTtcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5faW5kZXhlcztcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5fbmFtZXM7XG5cbiAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICBsZXQgYXR0cmlidXRlO1xuXG4gICAgICAgIC8vIEluZGtleSBpcyB0aGUgb3JkZXIgb2YgYXR0cmlidXRlcyBpbiB0aGUgaW5kZXgsIHNwZWNpZmllZCBieSBhIHN0cmluZyBvZiBhdHRyaWJ1dGUgaW5kZXhlc1xuICAgICAgICByb3cuZmllbGRzID0gcm93LmluZGtleS5zcGxpdCgnICcpLm1hcCgoaW5kS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGZpZWxkID0gY29sdW1uc1tpbmRLZXldO1xuICAgICAgICAgIC8vIGZvciBmdW5jdGlvbmFsIGluZGljZXMgaW5kS2V5ID0gMFxuICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cmlidXRlOiBmaWVsZCxcbiAgICAgICAgICAgIGNvbGxhdGU6IGF0dHJpYnV0ZS5tYXRjaCgvQ09MTEFURSBcIiguKj8pXCIvKSA/IC9DT0xMQVRFIFwiKC4qPylcIi8uZXhlYyhhdHRyaWJ1dGUpWzFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JkZXI6IGF0dHJpYnV0ZS5pbmNsdWRlcygnREVTQycpID8gJ0RFU0MnIDogYXR0cmlidXRlLmluY2x1ZGVzKCdBU0MnKSA/ICdBU0MnIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGVuZ3RoOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgbGV0IGRlZlBhcnRzO1xuICAgICAgICBpZiAocm93LmNvbmRlZiAhPT0gdW5kZWZpbmVkICYmIChkZWZQYXJ0cyA9IHJvdy5jb25kZWYubWF0Y2goL0ZPUkVJR04gS0VZIFxcKCguKylcXCkgUkVGRVJFTkNFUyAoLispXFwoKC4rKVxcKSggT04gKFVQREFURXxERUxFVEUpIChDQVNDQURFfFJFU1RSSUNUKSk/KCBPTiAoVVBEQVRFfERFTEVURSkgKENBU0NBREV8UkVTVFJJQ1QpKT8vKSkpIHtcbiAgICAgICAgICByb3cuaWQgPSByb3cuY29uc3RyYWludF9uYW1lO1xuICAgICAgICAgIHJvdy50YWJsZSA9IGRlZlBhcnRzWzJdO1xuICAgICAgICAgIHJvdy5mcm9tID0gZGVmUGFydHNbMV07XG4gICAgICAgICAgcm93LnRvID0gZGVmUGFydHNbM107XG4gICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgZm9yIChpID0gNTsgaSA8PSA4OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICgvKFVQREFURXxERUxFVEUpLy50ZXN0KGRlZlBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICByb3dbYG9uXyR7ZGVmUGFydHNbaV0udG9Mb3dlckNhc2UoKX1gXSA9IGRlZlBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHJvd3M7XG4gICAgICAvLyBQb3N0Z3JlcyB3aWxsIHRyZWF0IHRhYmxlcyBhcyBjYXNlLWluc2Vuc2l0aXZlLCBzbyBmaXggdGhlIGNhc2VcbiAgICAgIC8vIG9mIHRoZSByZXR1cm5lZCB2YWx1ZXMgdG8gbWF0Y2ggYXR0cmlidXRlc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcgPT09IGZhbHNlICYmIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYXR0cnNNYXAgPSBfLnJlZHVjZSh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChtLCB2LCBrKSA9PiB7XG4gICAgICAgICAgbVtrLnRvTG93ZXJDYXNlKCldID0gaztcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXN1bHQgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgIHJldHVybiBfLm1hcEtleXMocm93LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXR0ciA9IGF0dHJzTWFwW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldEF0dHIgPT09ICdzdHJpbmcnICYmIHRhcmdldEF0dHIgIT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0QXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuREVTQ1JJQkUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICByZXN1bHRbcm93LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiByb3cuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogcm93Lk51bGwgPT09ICdZRVMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogcm93LkRlZmF1bHQsXG4gICAgICAgICAgY29tbWVudDogcm93LkNvbW1lbnQsXG4gICAgICAgICAgc3BlY2lhbDogcm93LnNwZWNpYWwgPyB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyb3cuc3BlY2lhbCkgOiBbXSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiByb3cuQ29uc3RyYWludCA9PT0gJ1BSSU1BUlkgS0VZJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS50eXBlID09PSAnQk9PTEVBTicpIHtcbiAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSB7ICdmYWxzZSc6IGZhbHNlLCAndHJ1ZSc6IHRydWUgfVtyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWVdO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5yZXBsYWNlKC8nL2csICcnKTtcblxuICAgICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUuaW5jbHVkZXMoJzo6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLnNwbGl0KCc6OicpO1xuICAgICAgICAgICAgaWYgKHNwbGl0WzFdLnRvTG93ZXJDYXNlKCkgIT09ICdyZWdjbGFzcyknKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHNwbGl0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcm93c1swXS5zZXJ2ZXJfdmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5CVUxLVVBEQVRFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChyb3dDb3VudCwgMTApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocm93cyk7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkJVTEtERUxFVEUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQocm93Q291bnQsIDEwKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcm93c1swXSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocm93c1swXSwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcm93c1swXVtrZXldO1xuXG4gICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgbnVsbFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmluc3RhbmNlIHx8IHJvd3MgJiYgKHRoaXMub3B0aW9ucy5wbGFpbiAmJiByb3dzWzBdIHx8IHJvd3MpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcm93Q291bnRcbiAgICAgIF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyb3dzLCBxdWVyeVJlc3VsdF07XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB0YWJsZTtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGZpZWxkcztcbiAgICBsZXQgZXJyb3JzO1xuICAgIGxldCBtZXNzYWdlO1xuXG4gICAgY29uc3QgY29kZSA9IGVyci5jb2RlIHx8IGVyci5zcWxTdGF0ZTtcbiAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJyLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2VQcmltYXJ5O1xuICAgIGNvbnN0IGVyckRldGFpbCA9IGVyci5kZXRhaWwgfHwgZXJyLm1lc3NhZ2VEZXRhaWw7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgJzIzNTAzJzpcbiAgICAgICAgaW5kZXggPSBlcnJNZXNzYWdlLm1hdGNoKC92aW9sYXRlcyBmb3JlaWduIGtleSBjb25zdHJhaW50IFwiKC4rPylcIi8pO1xuICAgICAgICBpbmRleCA9IGluZGV4ID8gaW5kZXhbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHRhYmxlID0gZXJyTWVzc2FnZS5tYXRjaCgvb24gdGFibGUgXCIoLis/KVwiLyk7XG4gICAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHsgbWVzc2FnZTogZXJyTWVzc2FnZSwgZmllbGRzOiBudWxsLCBpbmRleCwgdGFibGUsIHBhcmVudDogZXJyIH0pO1xuICAgICAgY2FzZSAnMjM1MDUnOlxuICAgICAgICAvLyB0aGVyZSBhcmUgbXVsdGlwbGUgZGlmZmVyZW50IGZvcm1hdHMgb2YgZXJyb3IgbWVzc2FnZXMgZm9yIHRoaXMgZXJyb3IgY29kZVxuICAgICAgICAvLyB0aGlzIHJlZ2V4IHNob3VsZCBjaGVjayBhdCBsZWFzdCB0d29cbiAgICAgICAgaWYgKGVyckRldGFpbCAmJiAobWF0Y2ggPSBlcnJEZXRhaWwucmVwbGFjZSgvXCIvZywgJycpLm1hdGNoKC9LZXkgXFwoKC4qPylcXCk9XFwoKC4qPylcXCkvKSkpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdChtYXRjaFsxXS5zcGxpdCgnLCAnKSwgbWF0Y2hbMl0uc3BsaXQoJywgJykpO1xuICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICAgIG1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBlcnJvcic7XG5cbiAgICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICAgICAgdGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSxcbiAgICAgICAgICAgICAgJ3VuaXF1ZSB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkRCLFxuICAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICdub3RfdW5pcXVlJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXMpIHtcbiAgICAgICAgICAgIF8uZm9yT3duKHRoaXMubW9kZWwudW5pcXVlS2V5cywgY29uc3RyYWludCA9PiB7XG4gICAgICAgICAgICAgIGlmIChfLmlzRXF1YWwoY29uc3RyYWludC5maWVsZHMsIE9iamVjdC5rZXlzKGZpZWxkcykpICYmICEhY29uc3RyYWludC5tc2cpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gY29uc3RyYWludC5tc2c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGVyck1lc3NhZ2UsXG4gICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJzIzUDAxJzpcbiAgICAgICAgbWF0Y2ggPSBlcnJEZXRhaWwubWF0Y2goL0tleSBcXCgoLio/KVxcKT1cXCgoLio/KVxcKS8pO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KG1hdGNoWzFdLnNwbGl0KCcsICcpLCBtYXRjaFsyXS5zcGxpdCgnLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSA9ICdFeGNsdXNpb24gY29uc3RyYWludCBlcnJvcic7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRXhjbHVzaW9uQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGNvbnN0cmFpbnQ6IGVyci5jb25zdHJhaW50LFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB0YWJsZTogZXJyLnRhYmxlLFxuICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICc0MjcwNCc6XG4gICAgICAgIGlmIChlcnIuc3FsICYmIC8oQ09OU1RSQUlOVHxJTkRFWCkvZ2kudGVzdChlcnIuc3FsKSkge1xuICAgICAgICAgIG1lc3NhZ2UgPSAnVW5rbm93biBjb25zdHJhaW50IGVycm9yJztcbiAgICAgICAgICBpbmRleCA9IGVyck1lc3NhZ2UubWF0Y2goLyg/OmNvbnN0cmFpbnR8aW5kZXgpIFwiKC4rPylcIi9pKTtcbiAgICAgICAgICBpbmRleCA9IGluZGV4ID8gaW5kZXhbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgdGFibGUgPSBlcnJNZXNzYWdlLm1hdGNoKC9yZWxhdGlvbiBcIiguKz8pXCIvaSk7XG4gICAgICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBpbmRleCxcbiAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGlzRm9yZWlnbktleXNRdWVyeSgpIHtcbiAgICByZXR1cm4gL1NFTEVDVCBjb25uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgcGdfY2F0YWxvZ1xcLnBnX2dldF9jb25zdHJhaW50ZGVmXFwoclxcLm9pZCwgdHJ1ZVxcKSBhcyBjb25kZWYgRlJPTSBwZ19jYXRhbG9nXFwucGdfY29uc3RyYWludCByIFdIRVJFIHJcXC5jb25yZWxpZCA9IFxcKFNFTEVDVCBvaWQgRlJPTSBwZ19jbGFzcyBXSEVSRSByZWxuYW1lID0gJy4qJyBMSU1JVCAxXFwpIEFORCByXFwuY29udHlwZSA9ICdmJyBPUkRFUiBCWSAxOy8udGVzdCh0aGlzLnNxbCk7XG4gIH1cblxuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiAnaWQnO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVJhbmdlQm91bmQoYm91bmQpIHtcbiAgaWYgKGJvdW5kID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnIDtcbiAgfVxuICBpZiAoYm91bmQgPT09IEluZmluaXR5IHx8IGJvdW5kID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gYm91bmQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib3VuZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmFuZ2VCb3VuZChib3VuZCwgcGFyc2VUeXBlKSB7XG4gIGlmICghYm91bmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYm91bmQgPT09ICdpbmZpbml0eScpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKGJvdW5kID09PSAnLWluZmluaXR5Jykge1xuICAgIHJldHVybiAtSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlVHlwZShib3VuZCk7XG5cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgdGhyb3cgbmV3IEVycm9yKCdyYW5nZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiAnZW1wdHknO1xuICBpZiAoZGF0YS5sZW5ndGggIT09IDIpIHRocm93IG5ldyBFcnJvcigncmFuZ2UgYXJyYXkgbGVuZ3RoIG11c3QgYmUgMCAoZW1wdHkpIG9yIDIgKGxvd2VyIGFuZCB1cHBlciBib3VuZHMpJyk7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCAnaW5jbHVzaXZlJykpIHtcbiAgICBpZiAoZGF0YS5pbmNsdXNpdmUgPT09IGZhbHNlKSBkYXRhLmluY2x1c2l2ZSA9IFtmYWxzZSwgZmFsc2VdO1xuICAgIGVsc2UgaWYgKCFkYXRhLmluY2x1c2l2ZSkgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgIGVsc2UgaWYgKGRhdGEuaW5jbHVzaXZlID09PSB0cnVlKSBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCB0cnVlXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCBmYWxzZV07XG4gIH1cblxuICBfLmVhY2goZGF0YSwgKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luY2x1c2l2ZScpKSBkYXRhLmluY2x1c2l2ZVtpbmRleF0gPSAhIXZhbHVlLmluY2x1c2l2ZTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICd2YWx1ZScpKSBkYXRhW2luZGV4XSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbG93ZXJCb3VuZCA9IHN0cmluZ2lmeVJhbmdlQm91bmQoZGF0YVswXSk7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBzdHJpbmdpZnlSYW5nZUJvdW5kKGRhdGFbMV0pO1xuXG4gIHJldHVybiBgJHsoZGF0YS5pbmNsdXNpdmVbMF0gPyAnWycgOiAnKCcpICsgbG93ZXJCb3VuZH0sJHt1cHBlckJvdW5kfSR7ZGF0YS5pbmNsdXNpdmVbMV0gPyAnXScgOiAnKSd9YDtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5mdW5jdGlvbiBwYXJzZSh2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmICh2YWx1ZSA9PT0gJ2VtcHR5Jykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSB2YWx1ZVxuICAgIC5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSlcbiAgICAuc3BsaXQoJywnLCAyKTtcblxuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMikgcmV0dXJuIHZhbHVlO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwYXJzZVJhbmdlQm91bmQoaXRlbSwgcGFyc2VyKSxcbiAgICAgIGluY2x1c2l2ZTogaW5kZXggPT09IDAgPyB2YWx1ZVswXSA9PT0gJ1snIDogdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICddJ1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246c3FsaXRlJyk7XG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykuc3FsaXRlO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ3NxbGl0ZScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcblxuICAgIC8vIFdlIGF0dGVtcHQgdG8gcGFyc2UgZmlsZSBsb2NhdGlvbiBmcm9tIGEgY29ubmVjdGlvbiB1cmlcbiAgICAvLyBidXQgd2Ugc2hvdWxkbid0IG1hdGNoIHNlcXVlbGl6ZSBkZWZhdWx0IGhvc3QuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdCA9PT0gJ2xvY2FsaG9zdCcpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3Q7XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9O1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoJ3NxbGl0ZTMnKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcyk7XG4gIH1cblxuICBhc3luYyBfb25Qcm9jZXNzRXhpdCgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuY29ubmVjdGlvbnMpXG4gICAgICAgIC5tYXAoY29ubmVjdGlvbiA9PiBwcm9taXNpZnkoY2FsbGJhY2sgPT4gdGhpcy5jb25uZWN0aW9uc1tjb25uZWN0aW9uXS5jbG9zZShjYWxsYmFjaykpKCkpXG4gICAgKTtcbiAgICByZXR1cm4gc3VwZXIuX29uUHJvY2Vzc0V4aXQuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGlzIGFzIGEgbWV0aG9kIHNvIHRoYXQgdGhlIHBhcnNpbmcgbWF5IGJlIHVwZGF0ZWQgd2hlbiB0aGUgdXNlciBoYXMgYWRkZWQgYWRkaXRpb25hbCwgY3VzdG9tIHR5cGVzXG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG5cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51dWlkID0gb3B0aW9ucy51dWlkIHx8ICdkZWZhdWx0JztcbiAgICBvcHRpb25zLnN0b3JhZ2UgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0b3JhZ2UgfHwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0IHx8ICc6bWVtb3J5Oic7XG4gICAgb3B0aW9ucy5pbk1lbW9yeSA9IG9wdGlvbnMuc3RvcmFnZSA9PT0gJzptZW1vcnk6JyA/IDEgOiAwO1xuXG4gICAgY29uc3QgZGlhbGVjdE9wdGlvbnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3RPcHRpb25zO1xuICAgIGNvbnN0IGRlZmF1bHRSZWFkV3JpdGVNb2RlID0gdGhpcy5saWIuT1BFTl9SRUFEV1JJVEUgfCB0aGlzLmxpYi5PUEVOX0NSRUFURTtcblxuICAgIG9wdGlvbnMucmVhZFdyaXRlTW9kZSA9IGRpYWxlY3RPcHRpb25zICYmIGRpYWxlY3RPcHRpb25zLm1vZGUgfHwgZGVmYXVsdFJlYWRXcml0ZU1vZGU7XG5cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5NZW1vcnkgJiYgKG9wdGlvbnMucmVhZFdyaXRlTW9kZSAmIHRoaXMubGliLk9QRU5fQ1JFQVRFKSAhPT0gMCkge1xuICAgICAgLy8gYXV0b21hdGljIHBhdGggcHJvdmlzaW9uIGZvciBgb3B0aW9ucy5zdG9yYWdlYFxuICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnN0b3JhZ2UpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0gPSBuZXcgdGhpcy5saWIuRGF0YWJhc2UoXG4gICAgICAgIG9wdGlvbnMuc3RvcmFnZSxcbiAgICAgICAgb3B0aW9ucy5yZWFkV3JpdGVNb2RlLFxuICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgZGVidWcoYGNvbm5lY3Rpb24gYWNxdWlyZWQgJHtvcHRpb25zLnV1aWR9YCk7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLnBhc3N3b3JkKSB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGRlZmluZSBhbmQgdXNlIHBhc3N3b3JkIGZvciBzcWxpdGUgZW5jcnlwdGlvbiBwbHVnaW4gbGlrZSBzcWxjaXBoZXJcbiAgICAgIGNvbm5lY3Rpb24ucnVuKGBQUkFHTUEgS0VZPSR7dGhpcy5zZXF1ZWxpemUuZXNjYXBlKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wYXNzd29yZCl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmZvcmVpZ25LZXlzICE9PSBmYWxzZSkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBkZWZpbmUgYW5kIHVzZSBmb3JlaWduIGtleSBjb25zdHJhaW50cyB1bmxlc3NcbiAgICAgIC8vIGV4cGxpY2l0bHkgZGlzYWxsb3dlZC4gSXQncyBzdGlsbCBvcHQtaW4gcGVyIHJlbGF0aW9uXG4gICAgICBjb25uZWN0aW9uLnJ1bignUFJBR01BIEZPUkVJR05fS0VZUz1PTicpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG5cbiAgcmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbiwgZm9yY2UpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5maWxlbmFtZSA9PT0gJzptZW1vcnk6JyAmJiBmb3JjZSAhPT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGNvbm5lY3Rpb24udXVpZCkge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgZGVidWcoYGNvbm5lY3Rpb24gcmVsZWFzZWQgJHtjb25uZWN0aW9uLnV1aWR9YCk7XG4gICAgICBkZWxldGUgdGhpcy5jb25uZWN0aW9uc1tjb25uZWN0aW9uLnV1aWRdO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHlwZXMgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh1bmRlZmluZWQsICdodHRwczovL3d3dy5zcWxpdGUub3JnL2RhdGF0eXBlMy5odG1sJyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdW5zdXBwb3J0ZWQgU1FMaXRlIG9wdGlvbnMsIGkuZS4sIFVOU0lHTkVEIGFuZCBaRVJPRklMTCwgZm9yIHRoZSBpbnRlZ2VyIGRhdGEgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHlwZSBUaGUgYmFzZSBpbnRlZ2VyIGRhdGEgdHlwZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX3plcm9maWxsIHx8IGRhdGFUeXBlLl91bnNpZ25lZCkge1xuICAgICAgd2FybihgU1FMaXRlIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBVTlNJR05FRCBvciBaRVJPRklMTC4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9zcWxpdGUub3JnL2RhdGF0eXBlMy5odG1sXG4gICAqL1xuXG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLnNxbGl0ZSA9IFsnREFURVRJTUUnXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5zcWxpdGUgPSBbJ1ZBUkNIQVInLCAnVkFSQ0hBUiBCSU5BUlknXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMuc3FsaXRlID0gWydDSEFSJywgJ0NIQVIgQklOQVJZJ107XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLnNxbGl0ZSA9IFsnVEVYVCddO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5zcWxpdGUgPSBbJ1RJTllJTlQnXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLnNxbGl0ZSA9IFsnU01BTExJTlQnXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5zcWxpdGUgPSBbJ01FRElVTUlOVCddO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5zcWxpdGUgPSBbJ0lOVEVHRVInXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5zcWxpdGUgPSBbJ0JJR0lOVCddO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMuc3FsaXRlID0gWydGTE9BVCddO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5zcWxpdGUgPSBbJ1RJTUUnXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLnNxbGl0ZSA9IFsnREFURSddO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5zcWxpdGUgPSBbJ1RJTllJTlQnXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMuc3FsaXRlID0gWydUSU5ZQkxPQicsICdCTE9CJywgJ0xPTkdCTE9CJ107XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLnNxbGl0ZSA9IFsnREVDSU1BTCddO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5zcWxpdGUgPSBbJ1VVSUQnXTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMuc3FsaXRlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLnNxbGl0ZSA9IFsnUkVBTCddO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLnNxbGl0ZSA9IFsnRE9VQkxFIFBSRUNJU0lPTiddO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMuc3FsaXRlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLnNxbGl0ZSA9IFsnSlNPTicsICdKU09OQiddO1xuXG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIHN0YXRpYyBwYXJzZShkYXRhKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHN0YXRpYyBwYXJzZShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWRhdGUuaW5jbHVkZXMoJysnKSkge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdC4gRGF0ZXMgaW5zZXJ0ZWQgYnkgc2VxdWVsaXplIDwgMi4wZGV2MTIgd2lsbCBub3QgaGF2ZSBhIHRpbWVzdGFtcCBzZXRcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUgKyBvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTsgLy8gV2UgYWxyZWFkeSBoYXZlIGEgdGltZXpvbmUgc3RvcmVkIGluIHRoZSBzdHJpbmdcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYFZBUkNIQVIgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oJ1NRTGl0ZSBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCBvcHRpb25zLiBQbGFpbiBgVEVYVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnVEVYVCc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQ0lURVhUIGV4dGVuZHMgQmFzZVR5cGVzLkNJVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ1RFWFQgQ09MTEFURSBOT0NBU0UnO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIENIQVIgZXh0ZW5kcyBCYXNlVHlwZXMuQ0hBUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgQ0hBUiBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBOVU1CRVIgZXh0ZW5kcyBCYXNlVHlwZXMuTlVNQkVSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICByZXN1bHQgKz0gJyBVTlNJR05FRCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgWkVST0ZJTEwnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMuX2xlbmd0aH1gO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlY2ltYWxzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fZGVjaW1hbHN9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTUVESVVNSU5UIGV4dGVuZHMgQmFzZVR5cGVzLk1FRElVTUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gIH1cblxuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgfVxuXG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7IH1cblxuICBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnTmFOJykge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZmxvYXRpbmcgb2YgW0ZMT0FULCBET1VCTEUsIFJFQUxdKSB7XG4gICAgZmxvYXRpbmcucGFyc2UgPSBwYXJzZUZsb2F0aW5nO1xuICB9XG5cblxuICBmb3IgKGNvbnN0IG51bSBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTCwgVElOWUlOVCwgU01BTExJTlQsIE1FRElVTUlOVCwgSU5URUdFUiwgQklHSU5UXSkge1xuICAgIG51bS5wcm90b3R5cGUudG9TcWwgPSBOVU1CRVIucHJvdG90eXBlLnRvU3FsO1xuICB9XG5cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnVEVYVCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFNUUklORyxcbiAgICBDSEFSLFxuICAgIE5VTUJFUixcbiAgICBGTE9BVCxcbiAgICBSRUFMLFxuICAgICdET1VCTEUgUFJFQ0lTSU9OJzogRE9VQkxFLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgTUVESVVNSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIFRFWFQsXG4gICAgRU5VTSxcbiAgICBKU09OOiBKU09OVFlQRSxcbiAgICBDSVRFWFRcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0Jyk7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5zcWxpdGU7XG5jb25zdCB7IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuL3F1ZXJ5LWludGVyZmFjZScpO1xuXG5jbGFzcyBTcWxpdGVEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBTUUxpdGVRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5cblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICAnREVGQVVMVCc6IGZhbHNlLFxuICAnREVGQVVMVCBWQUxVRVMnOiB0cnVlLFxuICAnVU5JT04gQUxMJzogZmFsc2UsXG4gICdSSUdIVCBKT0lOJzogZmFsc2UsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiAnIE9SIElHTk9SRScsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6ICcgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVCdcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICB1c2luZzogZmFsc2UsXG4gICAgd2hlcmU6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogdHJ1ZVxuICB9LFxuICB0cmFuc2FjdGlvbk9wdGlvbnM6IHtcbiAgICB0eXBlOiB0cnVlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgYWRkQ29uc3RyYWludDogZmFsc2UsXG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlXG4gIH0sXG4gIGpvaW5UYWJsZURlcGVuZGVudDogZmFsc2UsXG4gIGdyb3VwZWRMaW1pdDogZmFsc2UsXG4gIEpTT046IHRydWVcbn0pO1xuXG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9ICczLjguMCc7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9ICdzcWxpdGUnO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ2AnO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBTcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBTcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5cbm1vZHVsZS5leHBvcnRzID0gU3FsaXRlRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLlNxbGl0ZURpYWxlY3QgPSBTcWxpdGVEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFNxbGl0ZURpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IE15U3FsUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9teXNxbC9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3InKTtcblxuY2xhc3MgU1FMaXRlUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBNeVNxbFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9J3RhYmxlJyBhbmQgbmFtZSE9J3NxbGl0ZV9zZXF1ZW5jZSc7XCI7XG4gIH1cblxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9J3RhYmxlJyBhbmQgbmFtZSE9J3NxbGl0ZV9zZXF1ZW5jZSc7XCI7XG4gIH1cblxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuICdTRUxFQ1Qgc3FsaXRlX3ZlcnNpb24oKSBhcyBgdmVyc2lvbmAnO1xuICB9XG5cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW107XG4gICAgY29uc3QgbmVlZHNNdWx0aXBsZVByaW1hcnlLZXlzID0gT2JqZWN0LnZhbHVlcyhhdHRyaWJ1dGVzKS5maWx0ZXIoZGVmaW5pdGlvbiA9PiBkZWZpbml0aW9uLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKS5sZW5ndGggPiAxO1xuICAgIGNvbnN0IGF0dHJBcnJheSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICBjb25zdCBjb250YWluc0F1dG9JbmNyZW1lbnQgPSBkYXRhVHlwZS5pbmNsdWRlcygnQVVUT0lOQ1JFTUVOVCcpO1xuXG4gICAgICAgIGxldCBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpIHtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ0lOVCcpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IElOVEVHRVIgaXMgYWxsb3dlZCBmb3IgcHJpbWFyeSBrZXksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9pc3N1ZXMvOTY5IChubyBsZW5naHQsIHVuc2lnbmVkIGV0YylcbiAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gY29udGFpbnNBdXRvSW5jcmVtZW50ID8gJ0lOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVCcgOiAnSU5URUdFUiBQUklNQVJZIEtFWSc7XG5cbiAgICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnIFJFRkVSRU5DRVMnKSkge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyArPSBkYXRhVHlwZS5zdWJzdHIoZGF0YVR5cGUuaW5kZXhPZignIFJFRkVSRU5DRVMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZWRzTXVsdGlwbGVQcmltYXJ5S2V5cykge1xuICAgICAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnTk9UIE5VTEwnKSkge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlLnJlcGxhY2UoJyBQUklNQVJZIEtFWScsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGUucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnTk9UIE5VTEwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0ckFycmF5LnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGVTdHJpbmd9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgYXR0clN0ciA9IGF0dHJBcnJheS5qb2luKCcsICcpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKHBrID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbignLCAnKTtcblxuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIGNvbHVtbnMgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGF0dHJTdHIgKz0gYCwgVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyU3RyICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cblxuICAgIGNvbnN0IHNxbCA9IGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAke3RhYmxlfSAoJHthdHRyU3RyfSk7YDtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCk7XG4gIH1cblxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBzdGF0bWVtZW50IGlzIGpzb24gZnVuY3Rpb24gb3Igc2ltcGxlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gIHN0bXQgIFRoZSBzdGF0ZW1lbnQgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgIHRydWUgaWYgdGhlIGdpdmVuIHN0YXRlbWVudCBpcyBqc29uIGZ1bmN0aW9uXG4gICAqIEB0aHJvd3MgIHtFcnJvcn0gICAgICAgICB0aHJvdyBpZiB0aGUgc3RhdGVtZW50IGxvb2tzIGxpa2UganNvbiBmdW5jdGlvbiBidXQgaGFzIGludmFsaWQgdG9rZW5cbiAgICovXG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vc3FsaXRlLm9yZy9qc29uMS5odG1sXG4gICAgY29uc3QganNvbkZ1bmN0aW9uUmVnZXggPSAvXlxccyooanNvbig/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbiAgICBjb25zdCB0b2tlbkNhcHR1cmVSZWdleCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcblxuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IGpzb25GdW5jdGlvblJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKCcoJyk7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSB0b2tlbkNhcHR1cmVSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSAnKCcpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnKScpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnOycpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW52YWxpZCBqc29uIHN0YXRlbWVudFxuICAgIGhhc0ludmFsaWRUb2tlbiB8PSBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cztcbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIGhhc0ludmFsaWRUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlIHN0YXRlbWVudCBoYXMgdmFsaWQganNvbiBmdW5jdGlvblxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cblxuICAvL3NxbGl0ZSBjYW4ndCBjYXN0IHRvIGRhdGV0aW1lIHNvIHdlIG5lZWQgdG8gY29udmVydCBkYXRlIHZhbHVlcyB0byB0aGVpciBJU08gc3RyaW5nc1xuICBfdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWwgPT4gdmFsLnRvSVNPU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuXG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmICgvdGltZXN0YW1wL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9ICdkYXRldGltZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEFic3RyYWN0UXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZC5jYWxsKHRoaXMsIHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cblxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBhdHRyaWJ1dGVzW2tleV0gPSBkYXRhVHlwZTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCB7IGNvbnRleHQ6ICdhZGRDb2x1bW4nIH0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9ICR7ZmllbGRzW2tleV19YDtcblxuICAgIGNvbnN0IHNxbCA9IGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZSl9IEFERCAke2F0dHJpYnV0ZX07YDtcblxuICAgIHJldHVybiB0aGlzLnJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKTtcbiAgfVxuXG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gJ1NFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9XFwndGFibGVcXCcgYW5kIG5hbWUhPVxcJ3NxbGl0ZV9zZXF1ZW5jZVxcJzsnO1xuICB9XG5cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcblxuICAgIGF0dHJWYWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goYXR0clZhbHVlSGFzaCwgb3B0aW9ucy5vbWl0TnVsbCwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSB8fCB0aGlzLmJpbmRQYXJhbShiaW5kKTtcblxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2goYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyVmFsdWVIYXNoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJWYWx1ZUhhc2hba2V5XTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnVVBEQVRFJyB9KX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdVUERBVEUnIH0sIGJpbmRQYXJhbSl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5O1xuICAgIGNvbnN0IHdoZXJlT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgYmluZFBhcmFtIH07XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgcXVlcnkgPSBgVVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKCcsJyl9IFdIRVJFIHJvd2lkIElOIChTRUxFQ1Qgcm93aWQgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX0gTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBgVVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKCcsJyl9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcXVlcnksIGJpbmQgfTtcbiAgfVxuXG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHkgPyBgOyBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSgnc3FsaXRlX3NlcXVlbmNlJyl9IFdIRVJFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoJ25hbWUnKX0gPSAke1V0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLCAnYCcpLCBcIidcIil9O2AgOiAnJ1xuICAgIF0uam9pbignJyk7XG4gIH1cblxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgbGV0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcblxuICAgIGlmICh3aGVyZUNsYXVzZSkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgV0hFUkUgJHt3aGVyZUNsYXVzZX1gO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGBXSEVSRSByb3dpZCBJTiAoU0VMRUNUIHJvd2lkIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt3aGVyZUNsYXVzZX0gTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7d2hlcmVDbGF1c2V9YDtcbiAgfVxuXG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGRhdGFUeXBlLmZpZWxkIHx8IG5hbWU7XG5cbiAgICAgIGlmIChfLmlzT2JqZWN0KGRhdGFUeXBlKSkge1xuICAgICAgICBsZXQgc3FsID0gZGF0YVR5cGUudHlwZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsICdhbGxvd051bGwnKSAmJiAhZGF0YVR5cGUuYWxsb3dOdWxsKSB7XG4gICAgICAgICAgc3FsICs9ICcgTk9UIE5VTEwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShkYXRhVHlwZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gVE9ETyB0aG9yb3VnaGx5IGNoZWNrIHRoYXQgRGF0YVR5cGVzLk5PVyB3aWxsIHByb3Blcmx5XG4gICAgICAgICAgLy8gZ2V0IHBvcHVsYXRlZCBvbiBhbGwgZGF0YWJhc2VzIGFzIERFRkFVTFQgdmFsdWVcbiAgICAgICAgICAvLyBpLmUuIG15c3FsIHJlcXVpcmVzOiBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QXG4gICAgICAgICAgc3FsICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGRhdGFUeXBlLmRlZmF1bHRWYWx1ZSwgZGF0YVR5cGUpfWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVR5cGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICAgICAgc3FsICs9ICcgVU5JUVVFJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhVHlwZS5wcmltYXJ5S2V5KSB7XG4gICAgICAgICAgc3FsICs9ICcgUFJJTUFSWSBLRVknO1xuXG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIHNxbCArPSAnIEFVVE9JTkNSRU1FTlQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhVHlwZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKGRhdGFUeXBlLnJlZmVyZW5jZXMubW9kZWwpO1xuXG4gICAgICAgICAgbGV0IHJlZmVyZW5jZXNLZXk7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YVR5cGUucmVmZXJlbmNlcy5rZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoJ2lkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3FsICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNUYWJsZX0gKCR7cmVmZXJlbmNlc0tleX0pYDtcblxuICAgICAgICAgIGlmIChkYXRhVHlwZS5vbkRlbGV0ZSkge1xuICAgICAgICAgICAgc3FsICs9IGAgT04gREVMRVRFICR7ZGF0YVR5cGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkYXRhVHlwZS5vblVwZGF0ZSkge1xuICAgICAgICAgICAgc3FsICs9IGAgT04gVVBEQVRFICR7ZGF0YVR5cGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBzcWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRhdGFUeXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgUFJBR01BIElOREVYX0xJU1QoJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0pYDtcbiAgfVxuXG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBsZXQgc3FsID0gYFNFTEVDVCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lPScke3RhYmxlTmFtZX0nYDtcblxuICAgIGlmIChjb25zdHJhaW50TmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIHNxbCBMSUtFICclJHtjb25zdHJhaW50TmFtZX0lJ2A7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3NxbH07YDtcbiAgfVxuXG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbignXycpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBgRFJPUCBJTkRFWCBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfWA7XG4gIH1cblxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0ge1xuICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyLFxuICAgICAgdGFibGVOYW1lXG4gICAgfTtcbiAgICByZXR1cm4gYFBSQUdNQSBUQUJMRV9JTkZPKCR7dGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHRhYmxlKSl9KTtgO1xuICB9XG5cbiAgZGVzY3JpYmVDcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgU0VMRUNUIHNxbCBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdGJsX25hbWU9JyR7dGFibGVOYW1lfSc7YDtcbiAgfVxuXG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuXG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuXG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKCcsICcpO1xuXG4gICAgLy8gVGVtcG9yYXJ5IHRhYmxlIGNhbm5vdCB3b3JrIGZvciBmb3JlaWduIGtleXMuXG4gICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlVGFibGVRdWVyeShiYWNrdXBUYWJsZU5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07YFxuICAgICAgKyBgRFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07JHtcbiAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH1JTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2BcbiAgICAgICsgYERST1AgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2A7XG4gIH1cblxuICBfYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVUYWJsZVNxbCkge1xuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG5cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG5cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbignLCAnKTtcblxuICAgIHJldHVybiBgJHtjcmVhdGVUYWJsZVNxbFxuICAgICAgLnJlcGxhY2UoYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX1gLCBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfWApXG4gICAgICAucmVwbGFjZShgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lLnJlcGxhY2UoL2AvZywgJ1wiJyl9YCwgYENSRUFURSBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX1gKVxuICAgIH1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O2BcbiAgICAgICsgYERST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9O2BcbiAgICAgICsgYEFMVEVSIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBSRU5BTUUgVE8gJHtxdW90ZWRUYWJsZU5hbWV9O2A7XG4gIH1cblxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBhdHRyaWJ1dGVzKSB7XG5cbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuXG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuXG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXNJbXBvcnQgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoYXR0ciA9PlxuICAgICAgYXR0ck5hbWVBZnRlciA9PT0gYXR0ciA/IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJOYW1lQmVmb3JlKX0gQVMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gIDogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cilcbiAgICApLmpvaW4oJywgJyk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXNFeHBvcnQgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbignLCAnKTtcblxuICAgIC8vIFRlbXBvcmFyeSB0YWJsZXMgZG9uJ3Qgc3VwcG9ydCBmb3JlaWduIGtleXMsIHNvIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHRhYmxlIHdpbGwgbm90IGFsbG93IGZvcmVpZ24ga2V5cyB0byBiZSBwcmVzZXJ2ZWRcbiAgICByZXR1cm4gYCR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KGJhY2t1cFRhYmxlTmFtZSwgYXR0cmlidXRlcylcbiAgICB9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzSW1wb3J0fSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtgXG4gICAgICArIGBEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTske1xuICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgfUlOU0VSVCBJTlRPICR7cXVvdGVkVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc0V4cG9ydH0gRlJPTSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YFxuICAgICAgKyBgRFJPUCBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YDtcbiAgfVxuXG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBCRUdJTiAke3RyYW5zYWN0aW9uLm9wdGlvbnMudHlwZX0gVFJBTlNBQ1RJT047YDtcbiAgfVxuXG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVQRUFUQUJMRV9SRUFEOlxuICAgICAgICByZXR1cm4gJy0tIFNRTGl0ZSBpcyBub3QgYWJsZSB0byBjaG9vc2UgdGhlIGlzb2xhdGlvbiBsZXZlbCBSRVBFQVRBQkxFIFJFQUQuJztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRUFEX1VOQ09NTUlUVEVEOlxuICAgICAgICByZXR1cm4gJ1BSQUdNQSByZWFkX3VuY29tbWl0dGVkID0gT047JztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRUFEX0NPTU1JVFRFRDpcbiAgICAgICAgcmV0dXJuICdQUkFHTUEgcmVhZF91bmNvbW1pdHRlZCA9IE9GRjsnO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlNFUklBTElaQUJMRTpcbiAgICAgICAgcmV0dXJuICctLSBTUUxpdGVcXCdzIGRlZmF1bHQgaXNvbGF0aW9uIGxldmVsIGlzIFNFUklBTElaQUJMRS4gTm90aGluZyB0byBkby4nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGlzb2xhdGlvbiBsZXZlbDogJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cblxuICByZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCkge1xuICAgIHJldHVybiBzcWwucmVwbGFjZSgvREVGQVVMVCAnP2ZhbHNlJz8vZywgJ0RFRkFVTFQgMCcpLnJlcGxhY2UoL0RFRkFVTFQgJz90cnVlJz8vZywgJ0RFRkFVTFQgMScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIGFsbCBmb3JlaWduIGtleXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBQUkFHTUEgZm9yZWlnbl9rZXlfbGlzdCgke3RhYmxlTmFtZX0pYDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNRTGl0ZVF1ZXJ5R2VuZXJhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlJyk7XG5jb25zdCB7IGNsb25lRGVlcCB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIHRoYXQgU2VxdWVsaXplIHVzZXMgdG8gdGFsayB3aXRoIFNRTGl0ZSBkYXRhYmFzZVxuICovXG5jbGFzcyBTUUxpdGVRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIEEgd3JhcHBlciB0aGF0IGZpeGVzIFNRTGl0ZSdzIGluYWJpbGl0eSB0byByZW1vdmUgY29sdW1ucyBmcm9tIGV4aXN0aW5nIHRhYmxlcy5cbiAgICogSXQgd2lsbCBjcmVhdGUgYSBiYWNrdXAgb2YgdGhlIHRhYmxlLCBkcm9wIHRoZSB0YWJsZSBhZnRlcndhcmRzIGFuZCBjcmVhdGUgYVxuICAgKiBuZXcgdGFibGUgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCB3aXRob3V0IHRoZSBvYnNvbGV0ZSBjb2x1bW4uXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGZpZWxkc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgdGhhdCBmaXhlcyBTUUxpdGUncyBpbmFiaWxpdHkgdG8gY2hhbmdlIGNvbHVtbnMgZnJvbSBleGlzdGluZyB0YWJsZXMuXG4gICAqIEl0IHdpbGwgY3JlYXRlIGEgYmFja3VwIG9mIHRoZSB0YWJsZSwgZHJvcCB0aGUgdGFibGUgYWZ0ZXJ3YXJkcyBhbmQgY3JlYXRlIGFcbiAgICogbmV3IHRhYmxlIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgd2l0aCBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIHJlc3BlY3RpdmUgY29sdW1uLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGRhdGFUeXBlT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKGZpZWxkc1thdHRyaWJ1dGVOYW1lXSwgdGhpcy5ub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgdGhhdCBmaXhlcyBTUUxpdGUncyBpbmFiaWxpdHkgdG8gcmVuYW1lIGNvbHVtbnMgZnJvbSBleGlzdGluZyB0YWJsZXMuXG4gICAqIEl0IHdpbGwgY3JlYXRlIGEgYmFja3VwIG9mIHRoZSB0YWJsZSwgZHJvcCB0aGUgdGFibGUgYWZ0ZXJ3YXJkcyBhbmQgY3JlYXRlIGFcbiAgICogbmV3IHRhYmxlIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgd2l0aCBhIHJlbmFtZWQgdmVyc2lvbiBvZiB0aGUgcmVzcGVjdGl2ZSBjb2x1bW4uXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgcmVuYW1lQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIG9wdGlvbnMpO1xuXG4gICAgZmllbGRzW2F0dHJOYW1lQWZ0ZXJdID0geyAuLi5maWVsZHNbYXR0ck5hbWVCZWZvcmVdIH07XG4gICAgZGVsZXRlIGZpZWxkc1thdHRyTmFtZUJlZm9yZV07XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcykgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGNyZWF0ZVRhYmxlU3FsO1xuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNob3dDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIC8vIHNxbGl0ZSBjYW4ndCBzaG93IG9ubHkgb25lIGNvbnN0cmFpbnQsIHNvIHdlIGZpbmQgaGVyZSB0aGUgb25lIHRvIHJlbW92ZVxuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50cy5maW5kKGNvbnN0YWludCA9PiBjb25zdGFpbnQuY29uc3RyYWludE5hbWUgPT09IGNvbnN0cmFpbnROYW1lKTtcblxuICAgIGlmICghY29uc3RyYWludCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYENvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gb24gdGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludE5hbWUsXG4gICAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUYWJsZVNxbCA9IGNvbnN0cmFpbnQuc3FsO1xuICAgIGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcihjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lKTtcbiAgICBsZXQgY29uc3RyYWludFNuaXBwZXQgPSBgLCBDT05TVFJBSU5UICR7Y29uc3RyYWludC5jb25zdHJhaW50TmFtZX0gJHtjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlfSAke2NvbnN0cmFpbnQuY29uc3RyYWludENvbmRpdGlvbn1gO1xuXG4gICAgaWYgKGNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUgPT09ICdGT1JFSUdOIEtFWScpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVRhYmxlTmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVUYWJsZShjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlTmFtZSk7XG4gICAgICBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzLm1hcChjb2x1bW5OYW1lID0+IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGNvbHVtbk5hbWUpKTtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzLmpvaW4oJywgJyk7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VUYWJsZU5hbWV9ICgke3JlZmVyZW5jZVRhYmxlS2V5c30pYDtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gVVBEQVRFICR7Y29uc3RyYWludC51cGRhdGVBY3Rpb259YDtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gREVMRVRFICR7Y29uc3RyYWludC5kZWxldGVBY3Rpb259YDtcbiAgICB9XG5cbiAgICBjcmVhdGVUYWJsZVNxbCA9IGNyZWF0ZVRhYmxlU3FsLnJlcGxhY2UoY29uc3RyYWludFNuaXBwZXQsICcnKTtcbiAgICBjcmVhdGVUYWJsZVNxbCArPSAnOyc7XG5cbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzLCBjcmVhdGVUYWJsZVNxbCk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcykgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgYWRkQ29uc3RyYWludCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkcyBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMuZmllbGRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RyYWludCB0eXBlIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy50eXBlJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IGNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRTbmlwcGV0ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlc2NyaWJlQ3JlYXRlVGFibGVTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlQ3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpO1xuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkZXNjcmliZUNyZWF0ZVRhYmxlU3FsLCB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNULCByYXc6IHRydWUgfSk7XG4gICAgbGV0IHNxbCA9IGNvbnN0cmFpbnRzWzBdLnNxbDtcbiAgICBjb25zdCBpbmRleCA9IHNxbC5sZW5ndGggLSAxO1xuICAgIC8vUmVwbGFjZSBlbmRpbmcgJyknIHdpdGggY29uc3RyYWludCBzbmlwcGV0IC0gU2ltdWxhdGVzIFN0cmluZy5yZXBsYWNlQXRcbiAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQzMTA5NFxuICAgIGNvbnN0IGNyZWF0ZVRhYmxlU3FsID0gYCR7c3FsLnN1YnN0cigwLCBpbmRleCl9LCAke2NvbnN0cmFpbnRTbmlwcGV0fSkke3NxbC5zdWJzdHIoaW5kZXggKyAxKX07YDtcblxuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzLCBjcmVhdGVUYWJsZVNxbCk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcykgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIGRhdGFiYXNlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAocm93ID0+ICh7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBjb2x1bW5OYW1lOiByb3cuZnJvbSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZU5hbWU6IHJvdy50YWJsZSxcbiAgICAgIHJlZmVyZW5jZWRDb2x1bW5OYW1lOiByb3cudG8sXG4gICAgICB0YWJsZUNhdGFsb2c6IGRhdGFiYXNlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZzogZGF0YWJhc2VcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBkcm9wQWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBza2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuXG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFRhYmxlcyhvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSgnUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9GRicsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoJ1BSQUdNQSBmb3JlaWduX2tleXMgPSBPTicsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hRGVsaW1pdGVyID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWEgfHwgbnVsbDtcbiAgICAgIHNjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyIHx8IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdvYmplY3QnICYmIHRhYmxlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYTtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcik7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5ERVNDUklCRSB9O1xuICAgIGNvbnN0IHNxbEluZGV4ZXMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICAgIC8qXG4gICAgICAgKiBJZiBubyBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LCB0aGVuIHRoZSB0YWJsZSBuYW1lIG1heSBiZSB3cm9uZy5cbiAgICAgICAqIFF1ZXJ5IGdlbmVyYXRvcnMgdGhhdCB1c2UgaW5mb3JtYXRpb25fc2NoZW1hIGZvciByZXRyaWV2aW5nIHRhYmxlIGluZm8gd2lsbCBqdXN0IHJldHVybiBhbiBlbXB0eSByZXN1bHQgc2V0LFxuICAgICAgICogaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgbGlrZSBidWlsdC1pbnMgZG8gKGUuZy4gREVTQ1JJQkUgb24gTXlTcWwpLlxuICAgICAgICovXG4gICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleGVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsSW5kZXhlcywgb3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW3Byb3BdLnVuaXF1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgaWYgKGluZGV4LnVuaXF1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhW2ZpZWxkLmF0dHJpYnV0ZV0udW5pcXVlID0gaW5kZXgudW5pcXVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5IG9mIGZvcmVpZ25LZXlzKSB7XG4gICAgICAgIGRhdGFbZm9yZWlnbktleS5jb2x1bW5OYW1lXS5yZWZlcmVuY2VzID0ge1xuICAgICAgICAgIG1vZGVsOiBmb3JlaWduS2V5LnJlZmVyZW5jZWRUYWJsZU5hbWUsXG4gICAgICAgICAga2V5OiBmb3JlaWduS2V5LnJlZmVyZW5jZWRDb2x1bW5OYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsICYmIGUub3JpZ2luYWwuY29kZSA9PT0gJ0VSX05PX1NVQ0hfVEFCTEUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLlNRTGl0ZVF1ZXJ5SW50ZXJmYWNlID0gU1FMaXRlUXVlcnlJbnRlcmZhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeScpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnc3FsaXRlJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnc3FsOnNxbGl0ZScpO1xuXG5cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuICdsYXN0SUQnO1xuICB9XG5cbiAgLyoqXG4gICAqIHJld3JpdGUgcXVlcnkgd2l0aCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsXG4gICAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSB2YWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWxlY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGxldCBiaW5kUGFyYW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgYmluZFBhcmFtID0ge307XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBiaW5kUGFyYW1bYCQke2kgKyAxfWBdID0gdjtcbiAgICAgIH0pO1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaW5kUGFyYW0gPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWVzKSkge1xuICAgICAgICAgIGJpbmRQYXJhbVtgJCR7a31gXSA9IHZhbHVlc1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH1cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuXG4gIF9jb2xsZWN0TW9kZWxzKGluY2x1ZGUsIHByZWZpeCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuXG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgX2luY2x1ZGUgb2YgaW5jbHVkZSkge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgIGtleSA9IF9pbmNsdWRlLmFzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IGAke3ByZWZpeH0uJHtfaW5jbHVkZS5hc31gO1xuICAgICAgICB9XG4gICAgICAgIHJldFtrZXldID0gX2luY2x1ZGUubW9kZWw7XG5cbiAgICAgICAgaWYgKF9pbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgICBfLm1lcmdlKHJldCwgdGhpcy5fY29sbGVjdE1vZGVscyhfaW5jbHVkZS5pbmNsdWRlLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBfaGFuZGxlUXVlcnlSZXNwb25zZShtZXRhRGF0YSwgY29sdW1uVHlwZXMsIGVyciwgcmVzdWx0cykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGVyci5zcWwgPSB0aGlzLnNxbDtcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgICAvLyBhZGQgdGhlIGluc2VydGVkIHJvdyBpZCB0byB0aGUgaW5zdGFuY2VcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gaGFuZGxlIGJ1bGtDcmVhdGUgQUkgcHJpbWFyeSBrZXlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1ldGFEYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTdGF0ZW1lbnQnXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbFxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXSAtIG1ldGFEYXRhLmNoYW5nZXMgKyAxO1xuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkOyBpIDwgc3RhcnRJZCArIG1ldGFEYXRhLmNoYW5nZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBbdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGRdOiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cy5tYXAocm93ID0+IHJvdy5uYW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRzO1xuICAgICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLnNxbCkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQ29uc3RyYWludHNGcm9tU3FsKHJlc3VsdHNbMF0uc3FsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cyk7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGlzIGEgbWFwIG9mIHByZWZpeCBzdHJpbmdzIHRvIG1vZGVscywgZS5nLiB1c2VyLnByb2plY3RzIC0+IFByb2plY3QgbW9kZWxcbiAgICAgIGNvbnN0IHByZWZpeGVzID0gdGhpcy5fY29sbGVjdE1vZGVscyh0aGlzLm9wdGlvbnMuaW5jbHVkZSk7XG5cbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcChyZXN1bHQgPT4ge1xuICAgICAgICByZXR1cm4gXy5tYXBWYWx1ZXMocmVzdWx0LCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdGluZCA9IG5hbWUubGFzdEluZGV4T2YoJy4nKTtcblxuICAgICAgICAgICAgbW9kZWwgPSBwcmVmaXhlc1tuYW1lLnN1YnN0cigwLCBsYXN0aW5kKV07XG5cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihsYXN0aW5kICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsID0gdGhpcy5vcHRpb25zLm1vZGVsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1vZGVsLmdldFRhYmxlTmFtZSgpLnRvU3RyaW5nKCkucmVwbGFjZSgvYC9nLCAnJyk7XG4gICAgICAgICAgY29uc3QgdGFibGVUeXBlcyA9IGNvbHVtblR5cGVzW3RhYmxlTmFtZV0gfHwge307XG5cbiAgICAgICAgICBpZiAodGFibGVUeXBlcyAmJiAhKG5hbWUgaW4gdGFibGVUeXBlcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb2x1bW4gaXMgYWxpYXNlZFxuICAgICAgICAgICAgXy5mb3JPd24obW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuYW1lID09PSBrZXkgJiYgYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZS5maWVsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFibGVUeXBlcywgbmFtZSlcbiAgICAgICAgICAgID8gdGhpcy5hcHBseVBhcnNlcnModGFibGVUeXBlc1tuYW1lXSwgdmFsdWUpXG4gICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBJTkRFWF9MSVNUJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkocmVzdWx0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIElOREVYX0lORk8nKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIFRBQkxFX0lORk8nKSkge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgc3FsaXRlIHdheSBvZiBnZXR0aW5nIHRoZSBtZXRhZGF0YSBvZiBhIHRhYmxlXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgbGV0IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChfcmVzdWx0LmRmbHRfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2x1bW4gc2NoZW1hIG9taXRzIGFueSBcIkRFRkFVTFQgLi4uXCJcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoX3Jlc3VsdC5kZmx0X3ZhbHVlID09PSAnTlVMTCcpIHtcbiAgICAgICAgICAvLyBDb2x1bW4gc2NoZW1hIGlzIGEgXCJERUZBVUxUIE5VTExcIlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gX3Jlc3VsdC5kZmx0X3ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC50eXBlLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5ub3RudWxsID09PSAwLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LnBrICE9PSAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdFtfcmVzdWx0Lm5hbWVdLnR5cGUgPT09ICdUSU5ZSU5UKDEpJykge1xuICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9IHsgJzAnOiBmYWxzZSwgJzEnOiB0cnVlIH1bcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9IHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZS5yZXBsYWNlKC8nL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgZm9yZWlnbl9rZXlzOycpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgZm9yZWlnbl9rZXlzJykpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBmb3JlaWduX2tleV9saXN0JykpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAoW1F1ZXJ5VHlwZXMuQlVMS1VQREFURSwgUXVlcnlUeXBlcy5CVUxLREVMRVRFXS5pbmNsdWRlcyh0aGlzLm9wdGlvbnMudHlwZSkpIHtcbiAgICAgIHJldHVybiBtZXRhRGF0YS5jaGFuZ2VzO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVkVSU0lPTikge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlJBVykge1xuICAgICAgcmV0dXJuIFtyZXN1bHRzLCBtZXRhRGF0YV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIG51bGxdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0luc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBtZXRhRGF0YS5jaGFuZ2VzXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RGF0YWJhc2VNZXRob2QoKTtcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm4uc2VyaWFsaXplKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtblR5cGVzID0ge307XG4gICAgICBjb25zdCBleGVjdXRlU3FsID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoJy0tICcpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXM7XG4gICAgICAgIC8vIGNhbm5vdCB1c2UgYXJyb3cgZnVuY3Rpb24gaGVyZSBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBib3VuZCB0byB0aGUgc3RhdGVtZW50XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyRXhlY3V0ZShleGVjdXRpb25FcnJvciwgcmVzdWx0cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgLy8gYHRoaXNgIGlzIHBhc3NlZCBmcm9tIHNxbGl0ZSwgd2UgaGF2ZSBubyBjb250cm9sIG92ZXIgdGhpcy5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgICAgICAgIHJlc29sdmUocXVlcnkuX2hhbmRsZVF1ZXJ5UmVzcG9uc2UodGhpcywgY29sdW1uVHlwZXMsIGV4ZWN1dGlvbkVycm9yLCByZXN1bHRzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGNvbm5bbWV0aG9kXShzcWwsIHBhcmFtZXRlcnMsIGFmdGVyRXhlY3V0ZSk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5nZXREYXRhYmFzZU1ldGhvZCgpID09PSAnYWxsJykge1xuICAgICAgICBsZXQgdGFibGVOYW1lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy50YWJsZU5hbWVzKSB7XG4gICAgICAgICAgdGFibGVOYW1lcyA9IHRoaXMub3B0aW9ucy50YWJsZU5hbWVzO1xuICAgICAgICB9IGVsc2UgaWYgKC9GUk9NIGAoLio/KWAvaS5leGVjKHRoaXMuc3FsKSkge1xuICAgICAgICAgIHRhYmxlTmFtZXMucHVzaCgvRlJPTSBgKC4qPylgL2kuZXhlYyh0aGlzLnNxbClbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBtZXRhZGF0YSBmb3IgdGhlIHRhYmxlLCB0aGVyZSdzIG5vIG5lZWQgdG8gYXNrIGZvciBpdCBhZ2FpblxuICAgICAgICB0YWJsZU5hbWVzID0gdGFibGVOYW1lcy5maWx0ZXIodGFibGVOYW1lID0+ICEodGFibGVOYW1lIGluIGNvbHVtblR5cGVzKSAmJiB0YWJsZU5hbWUgIT09ICdzcWxpdGVfbWFzdGVyJyk7XG5cbiAgICAgICAgaWYgKCF0YWJsZU5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBleGVjdXRlU3FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFibGVOYW1lcy5tYXAodGFibGVOYW1lID0+XG4gICAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUucmVwbGFjZSgvYC9nLCAnJyk7XG4gICAgICAgICAgICBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdID0ge307XG5cbiAgICAgICAgICAgIGNvbm4uYWxsKGBQUkFHTUEgdGFibGVfaW5mbyhcXGAke3RhYmxlTmFtZX1cXGApYCwgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbHVtblR5cGVzW3RhYmxlTmFtZV1bcmVzdWx0Lm5hbWVdID0gcmVzdWx0LnR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVNxbCgpO1xuICAgIH0pKTtcbiAgfVxuXG4gIHBhcnNlQ29uc3RyYWludHNGcm9tU3FsKHNxbCkge1xuICAgIGxldCBjb25zdHJhaW50cyA9IHNxbC5zcGxpdCgnQ09OU1RSQUlOVCAnKTtcbiAgICBsZXQgcmVmZXJlbmNlVGFibGVOYW1lLCByZWZlcmVuY2VUYWJsZUtleXMsIHVwZGF0ZUFjdGlvbiwgZGVsZXRlQWN0aW9uO1xuICAgIGNvbnN0cmFpbnRzLnNwbGljZSgwLCAxKTtcbiAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLm1hcChjb25zdHJhaW50U3FsID0+IHtcbiAgICAgIC8vUGFyc2UgZm9yZWlnbiBrZXkgc25pcHBldHNcbiAgICAgIGlmIChjb25zdHJhaW50U3FsLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgLy9QYXJzZSBvdXQgdGhlIGNvbnN0cmFpbnQgY29uZGl0aW9uIGZvcm0gc3FsIHN0cmluZ1xuICAgICAgICB1cGRhdGVBY3Rpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9PTiBVUERBVEUgKENBU0NBREV8U0VUIE5VTEx8UkVTVFJJQ1R8Tk8gQUNUSU9OfFNFVCBERUZBVUxUKXsxfS8pO1xuICAgICAgICBkZWxldGVBY3Rpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9PTiBERUxFVEUgKENBU0NBREV8U0VUIE5VTEx8UkVTVFJJQ1R8Tk8gQUNUSU9OfFNFVCBERUZBVUxUKXsxfS8pO1xuXG4gICAgICAgIGlmICh1cGRhdGVBY3Rpb24pIHtcbiAgICAgICAgICB1cGRhdGVBY3Rpb24gPSB1cGRhdGVBY3Rpb25bMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsZXRlQWN0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlQWN0aW9uID0gZGVsZXRlQWN0aW9uWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmZXJlbmNlc1JlZ2V4ID0gL1JFRkVSRU5DRVMuK1xcKCg/OlteKShdK3xcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKlxcKS87XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvbmRpdGlvbnMgPSBjb25zdHJhaW50U3FsLm1hdGNoKHJlZmVyZW5jZXNSZWdleClbMF0uc3BsaXQoJyAnKTtcbiAgICAgICAgcmVmZXJlbmNlVGFibGVOYW1lID0gVXRpbHMucmVtb3ZlVGlja3MocmVmZXJlbmNlQ29uZGl0aW9uc1sxXSk7XG4gICAgICAgIGxldCBjb2x1bW5OYW1lcyA9IHJlZmVyZW5jZUNvbmRpdGlvbnNbMl07XG4gICAgICAgIGNvbHVtbk5hbWVzID0gY29sdW1uTmFtZXMucmVwbGFjZSgvXFwofFxcKS9nLCAnJykuc3BsaXQoJywgJyk7XG4gICAgICAgIHJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbHVtbk5hbWVzLm1hcChjb2x1bW4gPT4gVXRpbHMucmVtb3ZlVGlja3MoY29sdW1uKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRDb25kaXRpb24gPSBjb25zdHJhaW50U3FsLm1hdGNoKC9cXCgoPzpbXikoXSt8XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSpcXCkvKVswXTtcbiAgICAgIGNvbnN0cmFpbnRTcWwgPSBjb25zdHJhaW50U3FsLnJlcGxhY2UoL1xcKC4rXFwpLywgJycpO1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRTcWwuc3BsaXQoJyAnKTtcblxuICAgICAgaWYgKGNvbnN0cmFpbnRbMV0gPT09ICdQUklNQVJZJyB8fCBjb25zdHJhaW50WzFdID09PSAnRk9SRUlHTicpIHtcbiAgICAgICAgY29uc3RyYWludFsxXSArPSAnIEtFWSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0cmFpbnROYW1lOiBVdGlscy5yZW1vdmVUaWNrcyhjb25zdHJhaW50WzBdKSxcbiAgICAgICAgY29uc3RyYWludFR5cGU6IGNvbnN0cmFpbnRbMV0sXG4gICAgICAgIHVwZGF0ZUFjdGlvbixcbiAgICAgICAgZGVsZXRlQWN0aW9uLFxuICAgICAgICBzcWw6IHNxbC5yZXBsYWNlKC9cIi9nLCAnYCcpLCAvL1NxbGl0ZSByZXR1cm5zIGRvdWJsZSBxdW90ZXMgZm9yIHRhYmxlIG5hbWVcbiAgICAgICAgY29uc3RyYWludENvbmRpdGlvbixcbiAgICAgICAgcmVmZXJlbmNlVGFibGVOYW1lLFxuICAgICAgICByZWZlcmVuY2VUYWJsZUtleXNcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uc3RyYWludHM7XG4gIH1cblxuICBhcHBseVBhcnNlcnModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZS5pbmNsdWRlcygnKCcpKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwYXJ0XG4gICAgICB0eXBlID0gdHlwZS5zdWJzdHIoMCwgdHlwZS5pbmRleE9mKCcoJykpO1xuICAgIH1cbiAgICB0eXBlID0gdHlwZS5yZXBsYWNlKCdVTlNJR05FRCcsICcnKS5yZXBsYWNlKCdaRVJPRklMTCcsICcnKTtcbiAgICB0eXBlID0gdHlwZS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldCh0eXBlKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBwYXJzZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHZhbHVlLCB7IHRpbWV6b25lOiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmb3JtYXRFcnJvcihlcnIpIHtcblxuICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgIGNhc2UgJ1NRTElURV9DT05TVFJBSU5UJzoge1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmllbGRzID0gW107XG5cbiAgICAgICAgLy8gU3FsaXRlIHByZSAyLjIgYmVoYXZpb3IgLSBFcnJvcjogU1FMSVRFX0NPTlNUUkFJTlQ6IGNvbHVtbnMgeCwgeSBhcmUgbm90IHVuaXF1ZVxuICAgICAgICBsZXQgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvY29sdW1ucyAoLio/KSBhcmUvKTtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgZmllbGRzID0gbWF0Y2hbMV0uc3BsaXQoJywgJyk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBTcWxpdGUgcG9zdCAyLjIgYmVoYXZpb3IgLSBFcnJvcjogU1FMSVRFX0NPTlNUUkFJTlQ6IFVOSVFVRSBjb25zdHJhaW50IGZhaWxlZDogdGFibGUueCwgdGFibGUueVxuICAgICAgICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1VOSVFVRSBjb25zdHJhaW50IGZhaWxlZDogKC4qKS8pO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgZmllbGRzID0gbWF0Y2hbMV0uc3BsaXQoJywgJykubWFwKGNvbHVtbldpdGhUYWJsZSA9PiBjb2x1bW5XaXRoVGFibGUuc3BsaXQoJy4nKVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGxldCBtZXNzYWdlID0gJ1ZhbGlkYXRpb24gZXJyb3InO1xuXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgICAgdGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSxcbiAgICAgICAgICAgICd1bmlxdWUgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5EQixcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkXSxcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgICAnbm90X3VuaXF1ZSdcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgXy5mb3JPd24odGhpcy5tb2RlbC51bmlxdWVLZXlzLCBjb25zdHJhaW50ID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzRXF1YWwoY29uc3RyYWludC5maWVsZHMsIGZpZWxkcykgJiYgISFjb25zdHJhaW50Lm1zZykge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gY29uc3RyYWludC5tc2c7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1NRTElURV9CVVNZJzpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVGltZW91dEVycm9yKGVycik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICAvLyBTcWxpdGUgcmV0dXJucyBpbmRleGVzIHNvIHRoZSBvbmUgdGhhdCB3YXMgZGVmaW5lZCBsYXN0IGlzIHJldHVybmVkIGZpcnN0LiBMZXRzIHJldmVyc2UgdGhhdCFcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZGF0YS5yZXZlcnNlKCkubWFwKGFzeW5jIGl0ZW0gPT4ge1xuICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIGl0ZW0ucHJpbWFyeSA9IGZhbHNlO1xuICAgICAgaXRlbS51bmlxdWUgPSAhIWl0ZW0udW5pcXVlO1xuICAgICAgaXRlbS5jb25zdHJhaW50TmFtZSA9IGl0ZW0ubmFtZTtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBhd2FpdCB0aGlzLnJ1bihgUFJBR01BIElOREVYX0lORk8oXFxgJHtpdGVtLm5hbWV9XFxgKWApO1xuICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgICBpdGVtLmZpZWxkc1tjb2x1bW4uc2Vxbm9dID0ge1xuICAgICAgICAgIGF0dHJpYnV0ZTogY29sdW1uLm5hbWUsXG4gICAgICAgICAgbGVuZ3RoOiB1bmRlZmluZWQsXG4gICAgICAgICAgb3JkZXI6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KSk7XG4gIH1cblxuICBnZXREYXRhYmFzZU1ldGhvZCgpIHtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ0NSRUFURSBURU1QT1JBUlkgVEFCTEUnLnRvTG93ZXJDYXNlKCkpIHx8IHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtERUxFVEUpIHtcbiAgICAgIHJldHVybiAncnVuJztcbiAgICB9XG4gICAgcmV0dXJuICdhbGwnO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIG11bHRpcGxlIEVycm9yc1xuICpcbiAqIEBwYXJhbSB7RXJyb3JbXX0gW2Vycm9yc10gQXJyYXkgb2YgZXJyb3JzXG4gKlxuICogQHByb3BlcnR5IGVycm9ycyB7RXJyb3JbXX1cbiAqL1xuY2xhc3MgQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubmFtZSA9ICdBZ2dyZWdhdGVFcnJvcic7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYEFnZ3JlZ2F0ZUVycm9yIG9mOlxcbiR7XG4gICAgICB0aGlzLmVycm9ycy5tYXAoZXJyb3IgPT5cbiAgICAgICAgZXJyb3IgPT09IHRoaXNcbiAgICAgICAgICA/ICdbQ2lyY3VsYXIgQWdncmVnYXRlRXJyb3JdJ1xuICAgICAgICAgIDogZXJyb3IgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL1xcbiQvLCAnJykucmVwbGFjZSgvXi9tZywgJyAgJylcbiAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9eL21nLCAnICAgICcpLnN1YnN0cmluZygyKVxuICAgICAgICBcbiAgICAgICkuam9pbignXFxuJylcbiAgICB9XFxuYDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBhc3NvY2lhdGlvbiBpcyBpbXByb3Blcmx5IGNvbnN0cnVjdGVkIChzZWUgbWVzc2FnZSBmb3IgZGV0YWlscylcbiAqL1xuY2xhc3MgQXNzb2NpYXRpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQXNzb2NpYXRpb25FcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NvY2lhdGlvbkVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNlcXVlbGl6ZSBwcm92aWRlcyBhIGhvc3Qgb2YgY3VzdG9tIGVycm9yIGNsYXNzZXMsIHRvIGFsbG93IHlvdSB0byBkbyBlYXNpZXIgZGVidWdnaW5nLiBBbGwgb2YgdGhlc2UgZXJyb3JzIGFyZSBleHBvc2VkIG9uIHRoZSBzZXF1ZWxpemUgb2JqZWN0IGFuZCB0aGUgc2VxdWVsaXplIGNvbnN0cnVjdG9yLlxuICogQWxsIHNlcXVlbGl6ZSBlcnJvcnMgaW5oZXJpdCBmcm9tIHRoZSBiYXNlIEpTIGVycm9yIG9iamVjdC5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgZXJyb3JzIGNhbiBiZSBhY2Nlc3NlZCB1c2luZyBgU2VxdWVsaXplLlZhbGlkYXRpb25FcnJvcmBcbiAqIFRoZSBCYXNlIEVycm9yIGFsbCBTZXF1ZWxpemUgRXJyb3JzIGluaGVyaXQgZnJvbS5cbiAqL1xuY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUJhc2VFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGJ1bGsgb3BlcmF0aW9uIGZhaWxzLCBpdCByZXByZXNlbnQgcGVyIHJlY29yZCBsZXZlbCBlcnJvci5cbiAqIFVzZWQgd2l0aCBBZ2dyZWdhdGVFcnJvclxuICpcbiAqIEBwYXJhbSB7RXJyb3J9ICBlcnJvciAgIEVycm9yIGZvciBhIGdpdmVuIHJlY29yZC9pbnN0YW5jZVxuICogQHBhcmFtIHtvYmplY3R9IHJlY29yZCAgREFPIGluc3RhbmNlIHRoYXQgZXJyb3IgYmVsb25ncyB0b1xuICovXG5jbGFzcyBCdWxrUmVjb3JkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvciwgcmVjb3JkKSB7XG4gICAgc3VwZXIoZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUJ1bGtSZWNvcmRFcnJvcic7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcjtcbiAgICB0aGlzLnJlY29yZCA9IHJlY29yZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1bGtSZWNvcmRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBhbGwgY29ubmVjdGlvbiByZWxhdGVkIGVycm9ycy5cbiAqL1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50ID8gcGFyZW50Lm1lc3NhZ2UgOiAnJyk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUNvbm5lY3Rpb25FcnJvcic7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gc3BlY2lmaWMgZXJyb3Igd2hpY2ggdHJpZ2dlcmVkIHRoaXMgb25lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcmlnaW5hbCA9IHBhcmVudDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25FcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaXMgcmVmdXNlZCBkdWUgdG8gaW5zdWZmaWNpZW50IHByaXZpbGVnZXNcbiAqL1xuY2xhc3MgQWNjZXNzRGVuaWVkRXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVBY2Nlc3NEZW5pZWRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NEZW5pZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gY29ubmVjdGlvbiBpcyBub3QgYWNxdWlyZWQgZHVlIHRvIHRpbWVvdXRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaXMgcmVmdXNlZFxuICovXG5jbGFzcyBDb25uZWN0aW9uUmVmdXNlZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQ29ubmVjdGlvblJlZnVzZWRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUmVmdXNlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSB0aW1lcyBvdXRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVDb25uZWN0aW9uVGltZWRPdXRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uVGltZWRPdXRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaGFzIGEgaG9zdG5hbWUgdGhhdCB3YXMgbm90IGZvdW5kXG4gKi9cbmNsYXNzIEhvc3ROb3RGb3VuZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplSG9zdE5vdEZvdW5kRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSG9zdE5vdEZvdW5kRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGhhcyBhIGhvc3RuYW1lIHRoYXQgd2FzIG5vdCByZWFjaGFibGVcbiAqL1xuY2xhc3MgSG9zdE5vdFJlYWNoYWJsZUVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplSG9zdE5vdFJlYWNoYWJsZUVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvc3ROb3RSZWFjaGFibGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaGFzIGludmFsaWQgdmFsdWVzIGZvciBhbnkgb2YgdGhlIGNvbm5lY3Rpb24gcGFyYW1ldGVyc1xuICovXG5jbGFzcyBJbnZhbGlkQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplSW52YWxpZENvbm5lY3Rpb25FcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnZhbGlkQ29ubmVjdGlvbkVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFsbCBkYXRhYmFzZSByZWxhdGVkIGVycm9ycy5cbiAqL1xuY2xhc3MgRGF0YWJhc2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudC5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplRGF0YWJhc2VFcnJvcic7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFcnJvcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsID0gcGFyZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBTUUwgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3FsID0gcGFyZW50LnNxbDtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHNxbCB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmVudC5wYXJhbWV0ZXJzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YWJhc2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YWJhc2VFcnJvciA9IHJlcXVpcmUoJy4vLi4vZGF0YWJhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBleGNsdXNpb24gY29uc3RyYWludCBpcyB2aW9sYXRlZCBpbiB0aGUgZGF0YWJhc2VcbiAqL1xuY2xhc3MgRXhjbHVzaW9uQ29uc3RyYWludEVycm9yIGV4dGVuZHMgRGF0YWJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiAnJyB9O1xuXG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVFeGNsdXNpb25Db25zdHJhaW50RXJyb3InO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgJyc7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gb3B0aW9ucy5jb25zdHJhaW50O1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFeGNsdXNpb25Db25zdHJhaW50RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFiYXNlRXJyb3IgPSByZXF1aXJlKCcuLy4uL2RhdGFiYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBmb3JlaWduIGtleSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIGluIHRoZSBkYXRhYmFzZVxuICovXG5jbGFzcyBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yIGV4dGVuZHMgRGF0YWJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiAnJyB9O1xuXG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVGb3JlaWduS2V5Q29uc3RyYWludEVycm9yJztcblxuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8ICdEYXRhYmFzZSBFcnJvcic7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLnJlbHR5cGUgPSBvcHRpb25zLnJlbHR5cGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhYmFzZUVycm9yID0gcmVxdWlyZSgnLi8uLi9kYXRhYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgZGF0YWJhc2UgcXVlcnkgdGltZXMgb3V0IGJlY2F1c2Ugb2YgYSBkZWFkbG9ja1xuICovXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBEYXRhYmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplVGltZW91dEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVvdXRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YWJhc2VFcnJvciA9IHJlcXVpcmUoJy4vLi4vZGF0YWJhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBjb25zdHJhaW50IG5hbWUgaXMgbm90IGZvdW5kIGluIHRoZSBkYXRhYmFzZVxuICovXG5jbGFzcyBVbmtub3duQ29uc3RyYWludEVycm9yIGV4dGVuZHMgRGF0YWJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiAnJyB9O1xuXG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVVbmtub3duQ29uc3RyYWludEVycm9yJztcblxuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCAnVGhlIHNwZWNpZmllZCBjb25zdHJhaW50IGRvZXMgbm90IGV4aXN0JztcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBvcHRpb25zLmNvbnN0cmFpbnQ7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVua25vd25Db25zdHJhaW50RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGFuIGluY2x1ZGUgc3RhdGVtZW50IGlzIGltcHJvcGVybHkgY29uc3RydWN0ZWQgKHNlZSBtZXNzYWdlIGZvciBkZXRhaWxzKVxuICovXG5jbGFzcyBFYWdlckxvYWRpbmdFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplRWFnZXJMb2FkaW5nRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWFnZXJMb2FkaW5nRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgcmVjb3JkIHdhcyBub3QgZm91bmQsIFVzdWFsbHkgdXNlZCB3aXRoIHJlamVjdE9uRW1wdHkgbW9kZSAoc2VlIG1lc3NhZ2UgZm9yIGRldGFpbHMpXG4gKi9cbmNsYXNzIEVtcHR5UmVzdWx0RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUVtcHR5UmVzdWx0RXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW1wdHlSZXN1bHRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5CYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuZXhwb3J0cy5BZ2dyZWdhdGVFcnJvciA9IHJlcXVpcmUoJy4vYWdncmVnYXRlLWVycm9yJyk7XG5leHBvcnRzLkFzeW5jUXVldWVFcnJvciA9IHJlcXVpcmUoJy4uL2RpYWxlY3RzL21zc3FsL2FzeW5jLXF1ZXVlJykuQXN5bmNRdWV1ZUVycm9yO1xuZXhwb3J0cy5Bc3NvY2lhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbi1lcnJvcicpO1xuZXhwb3J0cy5CdWxrUmVjb3JkRXJyb3IgPSByZXF1aXJlKCcuL2J1bGstcmVjb3JkLWVycm9yJyk7XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1lcnJvcicpO1xuZXhwb3J0cy5EYXRhYmFzZUVycm9yID0gcmVxdWlyZSgnLi9kYXRhYmFzZS1lcnJvcicpO1xuZXhwb3J0cy5FYWdlckxvYWRpbmdFcnJvciA9IHJlcXVpcmUoJy4vZWFnZXItbG9hZGluZy1lcnJvcicpO1xuZXhwb3J0cy5FbXB0eVJlc3VsdEVycm9yID0gcmVxdWlyZSgnLi9lbXB0eS1yZXN1bHQtZXJyb3InKTtcbmV4cG9ydHMuSW5zdGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vaW5zdGFuY2UtZXJyb3InKTtcbmV4cG9ydHMuT3B0aW1pc3RpY0xvY2tFcnJvciA9IHJlcXVpcmUoJy4vb3B0aW1pc3RpYy1sb2NrLWVycm9yJyk7XG5leHBvcnRzLlF1ZXJ5RXJyb3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWVycm9yJyk7XG5leHBvcnRzLlNlcXVlbGl6ZVNjb3BlRXJyb3IgPSByZXF1aXJlKCcuL3NlcXVlbGl6ZS1zY29wZS1lcnJvcicpO1xuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24tZXJyb3InKTtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9ySXRlbSA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW07XG5cbmV4cG9ydHMuQWNjZXNzRGVuaWVkRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvcicpO1xuZXhwb3J0cy5Db25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvcicpO1xuZXhwb3J0cy5Db25uZWN0aW9uUmVmdXNlZEVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tcmVmdXNlZC1lcnJvcicpO1xuZXhwb3J0cy5Db25uZWN0aW9uVGltZWRPdXRFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvcicpO1xuZXhwb3J0cy5Ib3N0Tm90Rm91bmRFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvcicpO1xuZXhwb3J0cy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vaG9zdC1ub3QtcmVhY2hhYmxlLWVycm9yJyk7XG5leHBvcnRzLkludmFsaWRDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vaW52YWxpZC1jb25uZWN0aW9uLWVycm9yJyk7XG5cbmV4cG9ydHMuRXhjbHVzaW9uQ29uc3RyYWludEVycm9yID0gcmVxdWlyZSgnLi9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvcicpO1xuZXhwb3J0cy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yID0gcmVxdWlyZSgnLi9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yJyk7XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IHJlcXVpcmUoJy4vZGF0YWJhc2UvdGltZW91dC1lcnJvcicpO1xuZXhwb3J0cy5Vbmtub3duQ29uc3RyYWludEVycm9yID0gcmVxdWlyZSgnLi9kYXRhYmFzZS91bmtub3duLWNvbnN0cmFpbnQtZXJyb3InKTtcblxuZXhwb3J0cy5VbmlxdWVDb25zdHJhaW50RXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24vdW5pcXVlLWNvbnN0cmFpbnQtZXJyb3InKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzb21lIHByb2JsZW0gb2NjdXJyZWQgd2l0aCBJbnN0YW5jZSBtZXRob2RzIChzZWUgbWVzc2FnZSBmb3IgZGV0YWlscylcbiAqL1xuY2xhc3MgSW5zdGFuY2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplSW5zdGFuY2VFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBhIHN0YWxlIG1vZGVsIGluc3RhbmNlXG4gKi9cbmNsYXNzIE9wdGltaXN0aWNMb2NrRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IGBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBhIHN0YWxlIG1vZGVsIGluc3RhbmNlOiAke29wdGlvbnMubW9kZWxOYW1lfWA7XG4gICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplT3B0aW1pc3RpY0xvY2tFcnJvcic7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG9uIHdoaWNoIHRoZSB1cGRhdGUgd2FzIGF0dGVtcHRlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVsTmFtZSA9IG9wdGlvbnMubW9kZWxOYW1lO1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZXMgb2YgdGhlIGF0dGVtcHRlZCB1cGRhdGVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy53aGVyZSA9IG9wdGlvbnMud2hlcmU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpbWlzdGljTG9ja0Vycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHF1ZXJ5IGlzIHBhc3NlZCBpbnZhbGlkIG9wdGlvbnMgKHNlZSBtZXNzYWdlIGZvciBkZXRhaWxzKVxuICovXG5jbGFzcyBRdWVyeUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVRdWVyeUVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFNjb3BlIEVycm9yLiBUaHJvd24gd2hlbiB0aGUgc2VxdWVsaXplIGNhbm5vdCBxdWVyeSB0aGUgc3BlY2lmaWVkIHNjb3BlLlxuICovXG5jbGFzcyBTZXF1ZWxpemVTY29wZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplU2NvcGVFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZWxpemVTY29wZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIEVycm9yLiBUaHJvd24gd2hlbiB0aGUgc2VxdWVsaXplIHZhbGlkYXRpb24gaGFzIGZhaWxlZC4gVGhlIGVycm9yIGNvbnRhaW5zIGFuIGBlcnJvcnNgIHByb3BlcnR5LFxuICogd2hpY2ggaXMgYW4gYXJyYXkgd2l0aCAxIG9yIG1vcmUgVmFsaWRhdGlvbkVycm9ySXRlbXMsIG9uZSBmb3IgZWFjaCB2YWxpZGF0aW9uIHRoYXQgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7QXJyYXl9IFtlcnJvcnNdIEFycmF5IG9mIFZhbGlkYXRpb25FcnJvckl0ZW0gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSB2YWxpZGF0aW9uIGVycm9yc1xuICpcbiAqIEBwcm9wZXJ0eSBlcnJvcnMge1ZhbGlkYXRpb25FcnJvckl0ZW1zW119XG4gKi9cbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9ycykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9ICdWYWxpZGF0aW9uIEVycm9yJztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtWYWxpZGF0aW9uRXJyb3JJdGVtW119XG4gICAgICovXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnMgfHwgW107XG5cbiAgICAvLyBVc2UgcHJvdmlkZWQgZXJyb3IgbWVzc2FnZSBpZiBhdmFpbGFibGUuLi5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAgICAgLy8gLi4uIG90aGVyd2lzZSBjcmVhdGUgYSBjb25jYXRlbmF0ZWQgbWVzc2FnZSBvdXQgb2YgZXhpc3RpbmcgZXJyb3JzLlxuICAgIH0gZWxzZSBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMCAmJiB0aGlzLmVycm9yc1swXS5tZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmVycm9ycy5tYXAoZXJyID0+IGAke2Vyci50eXBlIHx8IGVyci5vcmlnaW59OiAke2Vyci5tZXNzYWdlfWApLmpvaW4oJyxcXG4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdmFsaWRhdGlvbiBlcnJvciBpdGVtcyBmb3IgdGhlIHBhdGggLyBmaWVsZCBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGJlIGNoZWNrZWQgZm9yIGVycm9yIGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxWYWxpZGF0aW9uRXJyb3JJdGVtPn0gVmFsaWRhdGlvbiBlcnJvciBpdGVtcyBmb3IgdGhlIHNwZWNpZmllZCBwYXRoXG4gICAqL1xuICBnZXQocGF0aCkge1xuICAgIHJldHVybiB0aGlzLmVycm9ycy5yZWR1Y2UoKHJlZHVjZWQsIGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IucGF0aCA9PT0gcGF0aCkge1xuICAgICAgICByZWR1Y2VkLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgfSwgW10pO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGlvbiBFcnJvciBJdGVtXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGBWYWxpZGF0aW9uRXJyb3IuZXJyb3JzYCBwcm9wZXJ0eS5cbiAqL1xuY2xhc3MgVmFsaWRhdGlvbkVycm9ySXRlbSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFZhbGlkYXRpb25FcnJvciBpdGVtLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGBWYWxpZGF0aW9uRXJyb3IuZXJyb3JzYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBBbiBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVGhlIHR5cGUvb3JpZ2luIG9mIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF0gVGhlIGZpZWxkIHRoYXQgdHJpZ2dlcmVkIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdIFRoZSB2YWx1ZSB0aGF0IGdlbmVyYXRlZCB0aGUgZXJyb3JcbiAgICogQHBhcmFtIHtNb2RlbH0gW2luc3RhbmNlXSB0aGUgREFPIGluc3RhbmNlIHRoYXQgY2F1c2VkIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsaWRhdG9yS2V5XSBhIHZhbGlkYXRpb24gXCJrZXlcIiwgdXNlZCBmb3IgaWRlbnRpZmljYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbk5hbWVdIHByb3BlcnR5IG5hbWUgb2YgdGhlIEJVSUxULUlOIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IGNhdXNlZCB0aGUgdmFsaWRhdGlvbiBlcnJvciAoZS5nLiBcImluXCIgb3IgXCJsZW5cIiksIGlmIGFwcGxpY2FibGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2ZuQXJnc10gcGFyYW1ldGVycyB1c2VkIHdpdGggdGhlIEJVSUxULUlOIHZhbGlkYXRvciBmdW5jdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgcGF0aCwgdmFsdWUsIGluc3RhbmNlLCB2YWxpZGF0b3JLZXksIGZuTmFtZSwgZm5BcmdzKSB7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZS9vcmlnaW4gb2YgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgdGhhdCB0cmlnZ2VyZWQgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IHBhdGggfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB0aGF0IGdlbmVyYXRlZCB0aGUgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBudWxsO1xuXG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIERBTyBpbnN0YW5jZSB0aGF0IGNhdXNlZCB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge01vZGVsIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgdmFsaWRhdGlvbiBcImtleVwiLCB1c2VkIGZvciBpZGVudGlmaWNhdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3JLZXkgPSB2YWxpZGF0b3JLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IG5hbWUgb2YgdGhlIEJVSUxULUlOIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IGNhdXNlZCB0aGUgdmFsaWRhdGlvbiBlcnJvciAoZS5nLiBcImluXCIgb3IgXCJsZW5cIiksIGlmIGFwcGxpY2FibGVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9yTmFtZSA9IGZuTmFtZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyB1c2VkIHdpdGggdGhlIEJVSUxULUlOIHZhbGlkYXRvciBmdW5jdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9yQXJncyA9IGZuQXJncyB8fCBbXTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zWyB0eXBlIF0pIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVHlwZSA9IGAke3R5cGV9YC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgcmVhbFR5cGUgPSBWYWxpZGF0aW9uRXJyb3JJdGVtLlR5cGVTdHJpbmdNYXBbIGxvd2VyY2FzZVR5cGUgXTtcblxuICAgICAgICBpZiAocmVhbFR5cGUgJiYgVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zWyByZWFsVHlwZSBdKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW4gPSByZWFsVHlwZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBkb2Vzbid0IG5lZWQgY2FwdHVyZVN0YWNrVHJhY2UgYmVjYXVzZSBpdCdzIG5vdCBhIHN1YmNsYXNzIG9mIEVycm9yXG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGEgbG93ZXJjYXNlLCB0cmltbWVkIHN0cmluZyBcImtleVwiIHRoYXQgaWRlbnRpZmllcyB0aGUgdmFsaWRhdG9yLlxuICAgKlxuICAgKiBOb3RlOiB0aGUgc3RyaW5nIHdpbGwgYmUgZW1wdHkgaWYgdGhlIGluc3RhbmNlIGhhcyBuZWl0aGVyIGEgdmFsaWQgYHZhbGlkYXRvcktleWAgcHJvcGVydHkgbm9yIGEgdmFsaWQgYHZhbGlkYXRvck5hbWVgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSAgIHtib29sZWFufSBbdXNlVHlwZUFzTlM9dHJ1ZV0gICAgICBjb250cm9scyB3aGV0aGVyIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBcIm5hbWVzcGFjZVwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZCBpZiB0aGUgdmFsaWRhdG9yJ3MgYHR5cGVgIGlzIG5vdCBvbmUgb2YgVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICBbTlNTZXBhcmF0b3I9Jy4nXSAgICAgICBhIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbmNhdGVuYXRpbmcgdGhlIG5hbWVzcGFjZSwgbXVzdCBiZSBub3QgYmUgZW1wdHksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyB0byBcIi5cIiAoZnVsbHN0b3ApLiBvbmx5IHVzZWQgYW5kIHZhbGlkYXRlZCBpZiB1c2VUeXBlQXNOUyBpcyBUUlVFLlxuICAgKiBAdGhyb3dzICB7RXJyb3J9ICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3duIGlmIE5TU2VwYXJhdG9yIGlzIGZvdW5kIHRvIGJlIGludmFsaWQuXG4gICAqIEByZXR1cm5zICB7c3RyaW5nfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VmFsaWRhdG9yS2V5KHVzZVR5cGVBc05TLCBOU1NlcGFyYXRvcikge1xuICAgIGNvbnN0IHVzZVRBTlMgPSB1c2VUeXBlQXNOUyA9PT0gdW5kZWZpbmVkIHx8ICEhdXNlVHlwZUFzTlM7XG4gICAgY29uc3QgTlNTZXAgPSBOU1NlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJy4nIDogTlNTZXBhcmF0b3I7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5vcmlnaW47XG4gICAgY29uc3Qga2V5ID0gdGhpcy52YWxpZGF0b3JLZXkgfHwgdGhpcy52YWxpZGF0b3JOYW1lO1xuICAgIGNvbnN0IHVzZU5TID0gdXNlVEFOUyAmJiB0eXBlICYmIFZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2luc1sgdHlwZSBdO1xuXG4gICAgaWYgKHVzZU5TICYmICh0eXBlb2YgTlNTZXAgIT09ICdzdHJpbmcnIHx8ICFOU1NlcC5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbmFtZXNwYWNlIHNlcGFyYXRvciBnaXZlbiwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiAodXNlTlMgPyBbdHlwZSwga2V5XS5qb2luKE5TU2VwKSA6IGtleSkudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgZGVmaW5lcyB2YWxpZCBWYWxpZGF0aW9uRXJyb3JJdGVtIGBvcmlnaW5gIHZhbHVlc1xuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkgQ09SRSAgICAgICB7c3RyaW5nfSAgc3BlY2lmaWVzIGVycm9ycyB0aGF0IG9yaWdpbmF0ZSBmcm9tIHRoZSBzZXF1ZWxpemUgXCJjb3JlXCJcbiAqIEBwcm9wZXJ0eSBEQiAgICAgICAgIHtzdHJpbmd9ICBzcGVjaWZpZXMgdmFsaWRhdGlvbiBlcnJvcnMgdGhhdCBvcmlnaW5hdGUgZnJvbSB0aGUgc3RvcmFnZSBlbmdpbmVcbiAqIEBwcm9wZXJ0eSBGVU5DVElPTiAgIHtzdHJpbmd9ICBzcGVjaWZpZXMgdmFsaWRhdGlvbiBlcnJvcnMgdGhhdCBvcmlnaW5hdGUgZnJvbSB2YWxpZGF0b3IgZnVuY3Rpb25zIChib3RoIGJ1aWx0LWluIGFuZCBjdXN0b20pIGRlZmluZWQgZm9yIGEgZ2l2ZW4gYXR0cmlidXRlXG4gKi9cblZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucyA9IHtcbiAgQ09SRTogJ0NPUkUnLFxuICBEQjogJ0RCJyxcbiAgRlVOQ1RJT046ICdGVU5DVElPTidcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBgVmFsaWRhdGlvbkVycm9ySXRlbWAgY2xhc3NcbiAqIHRoYXQgbWFwcyBjdXJyZW50IGB0eXBlYCBzdHJpbmdzIChhcyBnaXZlbiB0byBWYWxpZGF0aW9uRXJyb3JJdGVtLmNvbnN0cnVjdG9yKCkpIHRvXG4gKiBvdXIgbmV3IGBvcmlnaW5gIHZhbHVlcy5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5WYWxpZGF0aW9uRXJyb3JJdGVtLlR5cGVTdHJpbmdNYXAgPSB7XG4gICdub3RudWxsIHZpb2xhdGlvbic6ICdDT1JFJyxcbiAgJ3N0cmluZyB2aW9sYXRpb24nOiAnQ09SRScsXG4gICd1bmlxdWUgdmlvbGF0aW9uJzogJ0RCJyxcbiAgJ3ZhbGlkYXRpb24gZXJyb3InOiAnRlVOQ1RJT04nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvcjtcbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRpb25FcnJvckl0ZW0gPSBWYWxpZGF0aW9uRXJyb3JJdGVtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL3ZhbGlkYXRpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHVuaXF1ZSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIGluIHRoZSBkYXRhYmFzZVxuICovXG5jbGFzcyBVbmlxdWVDb25zdHJhaW50RXJyb3IgZXh0ZW5kcyBWYWxpZGF0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogJycgfTtcbiAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCAnVmFsaWRhdGlvbiBFcnJvcic7XG4gICAgb3B0aW9ucy5lcnJvcnMgPSBvcHRpb25zLmVycm9ycyB8fCB7fTtcbiAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UsIG9wdGlvbnMuZXJyb3JzKTtcblxuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVVbmlxdWVDb25zdHJhaW50RXJyb3InO1xuICAgIHRoaXMuZXJyb3JzID0gb3B0aW9ucy5lcnJvcnM7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMub3JpZ2luYWwgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLnNxbCA9IG9wdGlvbnMucGFyZW50LnNxbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXF1ZUNvbnN0cmFpbnRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2hvb2tzJyk7XG5cbmNvbnN0IGhvb2tUeXBlcyA9IHtcbiAgYmVmb3JlVmFsaWRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVmFsaWRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIHZhbGlkYXRpb25GYWlsZWQ6IHsgcGFyYW1zOiAzIH0sXG4gIGJlZm9yZUNyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZURlc3Ryb3k6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyRGVzdHJveTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlUmVzdG9yZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJSZXN0b3JlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVVcGRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVXBkYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVTYXZlOiB7IHBhcmFtczogMiwgcHJveGllczogWydiZWZvcmVVcGRhdGUnLCAnYmVmb3JlQ3JlYXRlJ10gfSxcbiAgYWZ0ZXJTYXZlOiB7IHBhcmFtczogMiwgcHJveGllczogWydhZnRlclVwZGF0ZScsICdhZnRlckNyZWF0ZSddIH0sXG4gIGJlZm9yZVVwc2VydDogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJVcHNlcnQ6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUJ1bGtDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyQnVsa0NyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQnVsa0Rlc3Ryb3k6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa0Rlc3Ryb3k6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtSZXN0b3JlOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtSZXN0b3JlOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrVXBkYXRlOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtVcGRhdGU6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmQ6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGw6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmRBZnRlck9wdGlvbnM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyRmluZDogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQ291bnQ6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZURlZmluZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJEZWZpbmU6IHsgcGFyYW1zOiAxLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZUluaXQ6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVySW5pdDogeyBwYXJhbXM6IDEsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlQXNzb2NpYXRlOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSB9LFxuICBhZnRlckFzc29jaWF0ZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUgfSxcbiAgYmVmb3JlQ29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJDb25uZWN0OiB7IHBhcmFtczogMiwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVEaXNjb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckRpc2Nvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZVN5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1N5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1N5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZVF1ZXJ5OiB7IHBhcmFtczogMiB9LFxuICBhZnRlclF1ZXJ5OiB7IHBhcmFtczogMiB9XG59O1xuZXhwb3J0cy5ob29rcyA9IGhvb2tUeXBlcztcblxuXG4vKipcbiAqIGdldCBhcnJheSBvZiBjdXJyZW50IGhvb2sgYW5kIGl0cyBwcm94aWVzIGNvbWJpbmVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvb2tUeXBlIGFueSBob29rIHR5cGUgQHNlZSB7QGxpbmsgaG9va1R5cGVzfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdldFByb3hpZWRIb29rcyA9IGhvb2tUeXBlID0+XG4gIGhvb2tUeXBlc1tob29rVHlwZV0ucHJveGllc1xuICAgID8gaG9va1R5cGVzW2hvb2tUeXBlXS5wcm94aWVzLmNvbmNhdChob29rVHlwZSlcbiAgICA6IFtob29rVHlwZV1cbjtcblxuZnVuY3Rpb24gZ2V0SG9va3MoaG9va2VkLCBob29rVHlwZSkge1xuICByZXR1cm4gKGhvb2tlZC5vcHRpb25zLmhvb2tzIHx8IHt9KVtob29rVHlwZV0gfHwgW107XG59XG5cbmNvbnN0IEhvb2tzID0ge1xuICAvKipcbiAgICogUHJvY2VzcyB1c2VyIHN1cHBsaWVkIGhvb2tzIGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGhvb2tzIGhvb2tzIGRlZmluaXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gICAqL1xuICBfc2V0dXBIb29rcyhob29rcykge1xuICAgIHRoaXMub3B0aW9ucy5ob29rcyA9IHt9O1xuICAgIF8ubWFwKGhvb2tzIHx8IHt9LCAoaG9va3NBcnJheSwgaG9va05hbWUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShob29rc0FycmF5KSkgaG9va3NBcnJheSA9IFtob29rc0FycmF5XTtcbiAgICAgIGhvb2tzQXJyYXkuZm9yRWFjaChob29rRm4gPT4gdGhpcy5hZGRIb29rKGhvb2tOYW1lLCBob29rRm4pKTtcbiAgICB9KTtcbiAgfSxcblxuICBhc3luYyBydW5Ib29rcyhob29rcywgLi4uaG9va0FyZ3MpIHtcbiAgICBpZiAoIWhvb2tzKSB0aHJvdyBuZXcgRXJyb3IoJ3J1bkhvb2tzIHJlcXVpcmVzIGF0IGxlYXN0IDEgYXJndW1lbnQnKTtcblxuICAgIGxldCBob29rVHlwZTtcblxuICAgIGlmICh0eXBlb2YgaG9va3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBob29rVHlwZSA9IGhvb2tzO1xuICAgICAgaG9va3MgPSBnZXRIb29rcyh0aGlzLCBob29rVHlwZSk7XG5cbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZSkge1xuICAgICAgICBob29rcyA9IGhvb2tzLmNvbmNhdChnZXRIb29rcyh0aGlzLnNlcXVlbGl6ZSwgaG9va1R5cGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICBob29rcyA9IFtob29rc107XG4gICAgfVxuXG4gICAgLy8gc3luY2hyb25vdXMgaG9va3NcbiAgICBpZiAoaG9va1R5cGVzW2hvb2tUeXBlXSAmJiBob29rVHlwZXNbaG9va1R5cGVdLnN5bmMpIHtcbiAgICAgIGZvciAobGV0IGhvb2sgb2YgaG9va3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBob29rID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGhvb2sgPSBob29rLmZuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoYHJ1bm5pbmcgaG9vayhzeW5jKSAke2hvb2tUeXBlfWApO1xuICAgICAgICBob29rLmFwcGx5KHRoaXMsIGhvb2tBcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhc3luY2hyb25vdXMgaG9va3MgKGRlZmF1bHQpXG4gICAgZm9yIChsZXQgaG9vayBvZiBob29rcykge1xuICAgICAgaWYgKHR5cGVvZiBob29rID09PSAnb2JqZWN0Jykge1xuICAgICAgICBob29rID0gaG9vay5mbjtcbiAgICAgIH1cblxuICAgICAgZGVidWcoYHJ1bm5pbmcgaG9vayAke2hvb2tUeXBlfWApO1xuICAgICAgYXdhaXQgaG9vay5hcHBseSh0aGlzLCBob29rQXJncyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBob29rIHRvIHRoZSBtb2RlbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgaG9va1R5cGUgaG9vayBuYW1lIEBzZWUge0BsaW5rIGhvb2tUeXBlc31cbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IFtuYW1lXSBQcm92aWRlIGEgbmFtZSBmb3IgdGhlIGhvb2sgZnVuY3Rpb24uIEl0IGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgaG9vayBsYXRlciBvciB0byBvcmRlciBob29rcyBiYXNlZCBvbiBzb21lIHNvcnQgb2YgcHJpb3JpdHkgc3lzdGVtIGluIHRoZSBmdXR1cmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICBmbiBUaGUgaG9vayBmdW5jdGlvblxuICAgKlxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAgICovXG4gIGFkZEhvb2soaG9va1R5cGUsIG5hbWUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IG5hbWU7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgYWRkaW5nIGhvb2sgJHtob29rVHlwZX1gKTtcbiAgICAvLyBjaGVjayBmb3IgcHJveGllcywgYWRkIHRoZW0gdG9vXG4gICAgaG9va1R5cGUgPSBnZXRQcm94aWVkSG9va3MoaG9va1R5cGUpO1xuXG4gICAgaG9va1R5cGUuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IGhvb2tzID0gZ2V0SG9va3ModGhpcywgdHlwZSk7XG4gICAgICBob29rcy5wdXNoKG5hbWUgPyB7IG5hbWUsIGZuIH0gOiBmbik7XG4gICAgICB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0gPSBob29rcztcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaG9vayBmcm9tIHRoZSBtb2RlbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9va1R5cGUgQHNlZSB7QGxpbmsgaG9va1R5cGVzfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gbmFtZSBuYW1lIG9mIGhvb2sgb3IgZnVuY3Rpb24gcmVmZXJlbmNlIHdoaWNoIHdhcyBhdHRhY2hlZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAgICovXG4gIHJlbW92ZUhvb2soaG9va1R5cGUsIG5hbWUpIHtcbiAgICBjb25zdCBpc1JlZmVyZW5jZSA9IHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmhhc0hvb2soaG9va1R5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkZWJ1ZyhgcmVtb3ZpbmcgaG9vayAke2hvb2tUeXBlfWApO1xuXG4gICAgLy8gY2hlY2sgZm9yIHByb3hpZXMsIGFkZCB0aGVtIHRvb1xuICAgIGhvb2tUeXBlID0gZ2V0UHJveGllZEhvb2tzKGhvb2tUeXBlKTtcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBob29rVHlwZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdID0gdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdLmZpbHRlcihob29rID0+IHtcbiAgICAgICAgaWYgKGlzUmVmZXJlbmNlICYmIHR5cGVvZiBob29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2sgIT09IG5hbWU7IC8vIGNoZWNrIGlmIHNhbWUgbWV0aG9kXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZmVyZW5jZSAmJiB0eXBlb2YgaG9vayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gaG9vay5uYW1lICE9PSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIG1vZGUgaGFzIGFueSBob29rcyBvZiB0aGlzIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvb2tUeXBlIEBzZWUge0BsaW5rIGhvb2tUeXBlc31cbiAgICpcbiAgICogQGFsaWFzIGhhc0hvb2tzXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICAgKi9cbiAgaGFzSG9vayhob29rVHlwZSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9va3NbaG9va1R5cGVdICYmICEhdGhpcy5vcHRpb25zLmhvb2tzW2hvb2tUeXBlXS5sZW5ndGg7XG4gIH1cbn07XG5Ib29rcy5oYXNIb29rcyA9IEhvb2tzLmhhc0hvb2s7XG5cblxuZnVuY3Rpb24gYXBwbHlUbyh0YXJnZXQsIGlzTW9kZWwgPSBmYWxzZSkge1xuICBfLm1peGluKHRhcmdldCwgSG9va3MpO1xuXG4gIGZvciAoY29uc3QgaG9vayBvZiBPYmplY3Qua2V5cyhob29rVHlwZXMpKSB7XG4gICAgaWYgKGlzTW9kZWwgJiYgaG9va1R5cGVzW2hvb2tdLm5vTW9kZWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0YXJnZXRbaG9va10gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkSG9vayhob29rLCBuYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0cy5hcHBseVRvID0gYXBwbHlUbztcblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlVmFsaWRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyVmFsaWRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biB3aGVuIHZhbGlkYXRpb24gZmFpbHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9ucywgZXJyb3IuIEVycm9yIGlzIHRoZVxuICogU2VxdWVsaXplVmFsaWRhdGlvbkVycm9yLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yLCBpdCB3aWxsIHJlcGxhY2UgdGhlIG9yaWdpbmFsIHZhbGlkYXRpb24gZXJyb3IuXG4gKiBAbmFtZSB2YWxpZGF0aW9uRmFpbGVkXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGNyZWF0aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlQ3JlYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgY3JlYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlckNyZWF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBjcmVhdGluZyBvciB1cGRhdGluZyBhIHNpbmdsZSBpbnN0YW5jZSwgSXQgcHJveGllcyBgYmVmb3JlQ3JlYXRlYCBhbmQgYGJlZm9yZVVwZGF0ZWBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVTYXZlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHVwc2VydGluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZVVwc2VydFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHVwc2VydGluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQgb2YgdXBzZXJ0KCksIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyVXBzZXJ0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGNyZWF0aW5nIG9yIHVwZGF0aW5nIGEgc2luZ2xlIGluc3RhbmNlLCBJdCBwcm94aWVzIGBhZnRlckNyZWF0ZWAgYW5kIGBhZnRlclVwZGF0ZWBcbiAqXG4gICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAgKiBAbmFtZSBhZnRlclNhdmVcbiAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBkZXN0cm95aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBiZWZvcmVEZXN0cm95XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgZGVzdHJveWluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKlxuICogQG5hbWUgYWZ0ZXJEZXN0cm95XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHJlc3RvcmluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKlxuICogQG5hbWUgYmVmb3JlUmVzdG9yZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHJlc3RvcmluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKlxuICogQG5hbWUgYWZ0ZXJSZXN0b3JlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHVwZGF0aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZVVwZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHVwZGF0aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyVXBkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGNyZWF0aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2VzLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVCdWxrQ3JlYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgY3JlYXRpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyQnVsa0NyZWF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBkZXN0cm95aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICpcbiAqIEBuYW1lIGJlZm9yZUJ1bGtEZXN0cm95XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgZGVzdHJveWluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBhZnRlckJ1bGtEZXN0cm95XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHJlc3RvcmluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBiZWZvcmVCdWxrUmVzdG9yZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHJlc3RvcmluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBhZnRlckJ1bGtSZXN0b3JlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHVwZGF0aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlQnVsa1VwZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHVwZGF0aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJCdWxrVXBkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgZmluZCAoc2VsZWN0KSBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUZpbmRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBmaW5kIChzZWxlY3QpIHF1ZXJ5LCBhZnRlciBhbnkgeyBpbmNsdWRlOiB7YWxsOiAuLi59IH0gb3B0aW9ucyBhcmUgZXhwYW5kZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgZmluZCAoc2VsZWN0KSBxdWVyeSwgYWZ0ZXIgYWxsIG9wdGlvbiBwYXJzaW5nIGlzIGNvbXBsZXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlRmluZEFmdGVyT3B0aW9uc1xuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGEgZmluZCAoc2VsZWN0KSBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlKHMpLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlckZpbmRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBjb3VudCBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUNvdW50XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgZGVmaW5lIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVEZWZpbmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBhIGRlZmluZSBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZmFjdG9yeVxuICogQG5hbWUgYWZ0ZXJEZWZpbmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgU2VxdWVsaXplKCkgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGNvbmZpZywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlSW5pdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIFNlcXVlbGl6ZSgpIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBzZXF1ZWxpemVcbiAqIEBuYW1lIGFmdGVySW5pdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGNvbm5lY3Rpb24gaXMgY3JlYXRlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGNvbmZpZyBwYXNzZWQgdG8gY29ubmVjdGlvblxuICogQG5hbWUgYmVmb3JlQ29ubmVjdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGEgY29ubmVjdGlvbiBpcyBjcmVhdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGNvbm5lY3Rpb24gb2JqZWN0IGFuZCB0aGUgY29uZmlnIHBhc3NlZCB0byBjb25uZWN0aW9uXG4gKiBAbmFtZSBhZnRlckNvbm5lY3RcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uIG9iamVjdFxuICogQG5hbWUgYmVmb3JlRGlzY29ubmVjdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGEgY29ubmVjdGlvbiBpcyBkaXNjb25uZWN0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCB0aGUgY29ubmVjdGlvbiBvYmplY3RcbiAqIEBuYW1lIGFmdGVyRGlzY29ubmVjdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBNb2RlbC5zeW5jIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zIHBhc3NlZCB0byBNb2RlbC5zeW5jXG4gKiBAbmFtZSBiZWZvcmVTeW5jXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgTW9kZWwuc3luYyBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9ucyBwYXNzZWQgdG8gTW9kZWwuc3luY1xuICogQG5hbWUgYWZ0ZXJTeW5jXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBzZXF1ZWxpemUuc3luYyBjYWxsXG4gKlxuICAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zIHBhc3NlZCB0byBzZXF1ZWxpemUuc3luY1xuICAqIEBuYW1lIGJlZm9yZUJ1bGtTeW5jXG4gICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAqL1xuXG4vKipcbiAgKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgc2VxdWVsaXplLnN5bmMgY2FsbFxuICpcbiAgKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9ucyBwYXNzZWQgdG8gc2VxdWVsaXplLnN5bmNcbiAgKiBAbmFtZSBhZnRlckJ1bGtTeW5jXG4gICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVudW0gb2YgaW5kZXggaGludHMgdG8gYmUgdXNlZCBpbiBteXNxbCBmb3IgcXVlcnlpbmcgd2l0aCBpbmRleCBoaW50c1xuICpcbiAqIEBwcm9wZXJ0eSBVU0VcbiAqIEBwcm9wZXJ0eSBGT1JDRVxuICogQHByb3BlcnR5IElHTk9SRVxuICovXG5jb25zdCBJbmRleEhpbnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgVVNFOiAnVVNFJyxcbiAgRk9SQ0U6ICdGT1JDRScsXG4gIElHTk9SRTogJ0lHTk9SRSdcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvJyk7XG5jb25zdCB2YWxpZGF0b3IgPSByZXF1aXJlKCcuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMnKS52YWxpZGF0b3I7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIEluc3RhbmNlIFZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0luc3RhbmNlfSBtb2RlbEluc3RhbmNlIFRoZSBtb2RlbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgSW5zdGFuY2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3Rvcihtb2RlbEluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC8vIGFzc2lnbiBkZWZpbmVkIGFuZCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgIW9wdGlvbnMuc2tpcCkge1xuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKG1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIG9wdGlvbnMuZmllbGRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5za2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLm1vZGVsSW5zdGFuY2UgPSBtb2RlbEluc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlcyBhIHJlZmVyZW5jZSB0byB2YWxpZGF0b3IuanMuIFRoaXMgYWxsb3dzIHlvdSB0byBhZGQgY3VzdG9tIHZhbGlkYXRpb25zIHVzaW5nIGB2YWxpZGF0b3IuZXh0ZW5kYFxuICAgICAqXG4gICAgICogQG5hbWUgdmFsaWRhdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcblxuICAgIC8qKlxuICAgICAqICBBbGwgZXJyb3JzIHdpbGwgYmUgc3RvcmVkIGhlcmUgZnJvbSB0aGUgdmFsaWRhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9IFdpbGwgY29udGFpbiBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBhdHRyaWJ1dGVzIHdoaWNoIHdpbGxcbiAgICAgKiAgIGJlIEFycmF5cyBvZiBFcnJvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59IEluZGljYXRlcyBpZiB2YWxpZGF0aW9ucyBhcmUgaW4gcHJvZ3Jlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGVudHJ5IHBvaW50IGZvciB0aGUgVmFsaWRhdGlvbiBtb2R1bGUsIGludm9rZSB0byBzdGFydCB0aGUgZGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3ZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLmluUHJvZ3Jlc3MpIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbnMgYWxyZWFkeSBpbiBwcm9ncmVzcy4nKTtcblxuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IHRydWU7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLl9wZXJBdHRyaWJ1dGVWYWxpZGF0b3JzKCksXG4gICAgICB0aGlzLl9jdXN0b21WYWxpZGF0b3JzKClcbiAgICBdKTtcblxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3IobnVsbCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIFZhbGlkYXRpb24gc2VxdWVuY2UgYW5kIHJ1biB2YWxpZGF0aW9uIGhvb2tzIGlmIGRlZmluZWRcbiAgICogICAtIEJlZm9yZSBWYWxpZGF0aW9uIE1vZGVsIEhvb2tzXG4gICAqICAgLSBWYWxpZGF0aW9uXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIHN1Y2Nlc3M6IEFmdGVyIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcbiAgICogICAtIE9uIHZhbGlkYXRpb24gZmFpbHVyZTogVmFsaWRhdGlvbiBGYWlsZWQgTW9kZWwgSG9va3NcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgKHRoaXMub3B0aW9ucy5ob29rcyA/IHRoaXMuX3ZhbGlkYXRlQW5kUnVuSG9va3MoKSA6IHRoaXMuX3ZhbGlkYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSB0aGUgVmFsaWRhdGlvbiBzZXF1ZW5jZSBhbmQgcnVuIGhvb2tzXG4gICAqICAgLSBCZWZvcmUgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gVmFsaWRhdGlvblxuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBzdWNjZXNzOiBBZnRlciBWYWxpZGF0aW9uIE1vZGVsIEhvb2tzXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIGZhaWx1cmU6IFZhbGlkYXRpb24gRmFpbGVkIE1vZGVsIEhvb2tzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3ZhbGlkYXRlQW5kUnVuSG9va3MoKSB7XG4gICAgY29uc3QgcnVuSG9va3MgPSB0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucnVuSG9va3MuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgIGF3YWl0IHJ1bkhvb2tzKCdiZWZvcmVWYWxpZGF0ZScsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl92YWxpZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IGF3YWl0IHJ1bkhvb2tzKCd2YWxpZGF0aW9uRmFpbGVkJywgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMsIGVycm9yKTtcbiAgICAgIHRocm93IG5ld0Vycm9yIHx8IGVycm9yO1xuICAgIH1cblxuICAgIGF3YWl0IHJ1bkhvb2tzKCdhZnRlclZhbGlkYXRlJywgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm1vZGVsSW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBydW4gYWxsIHRoZSB2YWxpZGF0b3JzIGRlZmluZWQgcGVyIGF0dHJpYnV0ZSAoYnVpbHQtaW4gdmFsaWRhdG9ycyBhbmQgY3VzdG9tIHZhbGlkYXRvcnMpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9wZXJBdHRyaWJ1dGVWYWxpZGF0b3JzKCkge1xuICAgIC8vIHByb21pc2lmeSBhbGwgYXR0cmlidXRlIGludm9jYXRpb25zXG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuXG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UucmF3QXR0cmlidXRlcywgKHJhd0F0dHJpYnV0ZSwgZmllbGQpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcC5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubW9kZWxJbnN0YW5jZS5kYXRhVmFsdWVzW2ZpZWxkXTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyYXdBdHRyaWJ1dGUuX2F1dG9HZW5lcmF0ZWQgJiYgIXJhd0F0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIC8vIHBlcmZvcm0gdmFsaWRhdGlvbnMgYmFzZWQgb24gc2NoZW1hXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlU2NoZW1hKHJhd0F0dHJpYnV0ZSwgZmllbGQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9ycywgZmllbGQpKSB7XG4gICAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLl9zaW5nbGVBdHRyVmFsaWRhdGUodmFsdWUsIGZpZWxkLCByYXdBdHRyaWJ1dGUuYWxsb3dOdWxsKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBydW4gYWxsIHRoZSBjdXN0b20gdmFsaWRhdG9ycyBkZWZpbmVkIGluIHRoZSBtb2RlbCdzIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9jdXN0b21WYWxpZGF0b3JzKCkge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBfLmVhY2godGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMudmFsaWRhdGUsICh2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcC5pbmNsdWRlcyh2YWxpZGF0b3JUeXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHByb20gPSB0aGlzLl9pbnZva2VDdXN0b21WYWxpZGF0b3IodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlKVxuICAgICAgICAvLyBlcnJvcnMgYXJlIGhhbmRsZWQgaW4gc2V0dGxpbmcsIHN0dWIgdGhpc1xuICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFscHJvbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYSBzaW5nbGUgYXR0cmlidXRlIHdpdGggYWxsIHRoZSBkZWZpbmVkIGJ1aWx0LWluIHZhbGlkYXRvcnMgYW5kIGN1c3RvbSB2YWxpZGF0b3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueXRoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dOdWxsIFdoZXRoZXIgb3Igbm90IHRoZSBzY2hlbWEgYWxsb3dzIG51bGwgdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UsIHdpbGwgYWx3YXlzIHJlc29sdmUsIGF1dG8gcG9wdWxhdGVzIGVycm9yIG9uIHRoaXMuZXJyb3IgbG9jYWwgb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIGFsbG93TnVsbCkge1xuICAgIC8vIElmIHZhbHVlIGlzIG51bGwgYW5kIGFsbG93TnVsbCBpcyBmYWxzZSwgbm8gdmFsaWRhdG9ycyBzaG91bGQgcnVuIChzZWUgIzkxNDMpXG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSAmJiAhYWxsb3dOdWxsKSB7XG4gICAgICAvLyBUaGUgc2NoZW1hIHZhbGlkYXRvciAoX3ZhbGlkYXRlU2NoZW1hKSBoYXMgYWxyZWFkeSBnZW5lcmF0ZWQgdGhlIHZhbGlkYXRpb24gZXJyb3IuIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcm9taXNpZnkgZWFjaCB2YWxpZGF0b3JcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9yc1tmaWVsZF0sICh0ZXN0LCB2YWxpZGF0b3JUeXBlKSA9PiB7XG5cbiAgICAgIGlmICh2YWxpZGF0b3JUeXBlID09PSAnaXNVcmwnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc1VSTCcgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzRW1haWwnKSB7XG4gICAgICAgIC8vIFByZXNlcnZlIGJhY2t3YXJkcyBjb21wYXQuIFZhbGlkYXRvci5qcyBub3cgZXhwZWN0cyB0aGUgc2Vjb25kIHBhcmFtIHRvIGlzVVJMIGFuZCBpc0VtYWlsIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdvYmplY3QnICYmIHRlc3QgIT09IG51bGwgJiYgdGVzdC5tc2cpIHtcbiAgICAgICAgICB0ZXN0ID0ge1xuICAgICAgICAgICAgbXNnOiB0ZXN0Lm1zZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRlc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDdXN0b20gdmFsaWRhdG9ycyBzaG91bGQgYWx3YXlzIHJ1biwgZXhjZXB0IGlmIHZhbHVlIGlzIG51bGwgYW5kIGFsbG93TnVsbCBpcyBmYWxzZSAoc2VlICM5MTQzKVxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLl9pbnZva2VDdXN0b21WYWxpZGF0b3IodGVzdCwgdmFsaWRhdG9yVHlwZSwgdHJ1ZSwgdmFsdWUsIGZpZWxkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdmFsdWUgaXMgbnVsbCwgYnVpbHQtaW4gdmFsaWRhdG9ycyBzaG91bGQgbm90IHJ1biAob25seSBjdXN0b20gdmFsaWRhdG9ycyBoYXZlIHRvIHJ1bikgKHNlZSAjOTEzNCkuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRvclByb21pc2UgPSB0aGlzLl9pbnZva2VCdWlsdGluVmFsaWRhdG9yKHZhbHVlLCB0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCk7XG4gICAgICAvLyBlcnJvcnMgYXJlIGhhbmRsZWQgaW4gc2V0dGxpbmcsIHN0dWIgdGhpc1xuICAgICAgdmFsaWRhdG9yUHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yUHJvbWlzZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgLmFsbCh2YWxpZGF0b3JzLm1hcCh2YWxpZGF0b3IgPT4gdmFsaWRhdG9yLmNhdGNoKHJlamVjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGlzQnVpbHRJbiA9ICEhcmVqZWN0aW9uLnZhbGlkYXRvck5hbWU7XG4gICAgICAgIHRoaXMuX3B1c2hFcnJvcihpc0J1aWx0SW4sIGZpZWxkLCByZWplY3Rpb24sIHZhbHVlLCByZWplY3Rpb24udmFsaWRhdG9yTmFtZSwgcmVqZWN0aW9uLnZhbGlkYXRvckFyZ3MpO1xuICAgICAgfSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuZCBpbnZva2UgYSBjdXN0b20gdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWxpZGF0b3IgVGhlIGN1c3RvbSB2YWxpZGF0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JUeXBlIHRoZSBjdXN0b20gdmFsaWRhdG9yIHR5cGUgKG5hbWUpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEF0dHJEZWZpbmVkIFNldCB0byB0cnVlIGlmIGN1c3RvbSB2YWxpZGF0b3Igd2FzIGRlZmluZWQgZnJvbSB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7Kn0gb3B0VmFsdWUgdmFsdWUgZm9yIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0RmllbGQgZmllbGQgZm9yIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICAgKi9cbiAgYXN5bmMgX2ludm9rZUN1c3RvbVZhbGlkYXRvcih2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUsIG9wdEF0dHJEZWZpbmVkLCBvcHRWYWx1ZSwgb3B0RmllbGQpIHtcbiAgICBsZXQgaXNBc3luYyA9IGZhbHNlO1xuXG4gICAgY29uc3QgdmFsaWRhdG9yQXJpdHkgPSB2YWxpZGF0b3IubGVuZ3RoO1xuICAgIC8vIGNoZWNrIGlmIHZhbGlkYXRvciBpcyBhc3luYyBhbmQgcmVxdWlyZXMgYSBjYWxsYmFja1xuICAgIGxldCBhc3luY0FyaXR5ID0gMTtcbiAgICBsZXQgZXJyb3JLZXkgPSB2YWxpZGF0b3JUeXBlO1xuICAgIGxldCBpbnZva2VBcmdzO1xuICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xuICAgICAgYXN5bmNBcml0eSA9IDI7XG4gICAgICBpbnZva2VBcmdzID0gb3B0VmFsdWU7XG4gICAgICBlcnJvcktleSA9IG9wdEZpZWxkO1xuICAgIH1cbiAgICBpZiAodmFsaWRhdG9yQXJpdHkgPT09IGFzeW5jQXJpdHkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0QXR0ckRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KHZhbGlkYXRvci5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZSwgaW52b2tlQXJncykpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSh2YWxpZGF0b3IuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEVycm9yKGZhbHNlLCBlcnJvcktleSwgZSwgb3B0VmFsdWUsIHZhbGlkYXRvclR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdmFsaWRhdG9yLmNhbGwodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEVycm9yKGZhbHNlLCBlcnJvcktleSwgZSwgb3B0VmFsdWUsIHZhbGlkYXRvclR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuZCBpbnZva2UgYSBidWlsZC1pbiB2YWxpZGF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55dGhpbmcuXG4gICAqIEBwYXJhbSB7Kn0gdGVzdCBUaGUgdGVzdCBjYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yVHlwZSBPbmUgb2Yga25vd24gdG8gU2VxdWVsaXplIHZhbGlkYXRvcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCBpcyBiZWluZyB2YWxpZGF0ZWRcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggc3BlY2lmaWMga2V5cyB0byBpbnZva2UgdGhlIHZhbGlkYXRvci5cbiAgICovXG4gIGFzeW5jIF9pbnZva2VCdWlsdGluVmFsaWRhdG9yKHZhbHVlLCB0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCkge1xuICAgIC8vIENhc3QgdmFsdWUgYXMgc3RyaW5nIHRvIHBhc3MgbmV3IFZhbGlkYXRvci5qcyBzdHJpbmcgcmVxdWlyZW1lbnRcbiAgICBjb25zdCB2YWx1ZVN0cmluZyA9IFN0cmluZyh2YWx1ZSk7XG4gICAgLy8gY2hlY2sgaWYgVmFsaWRhdG9yIGtub3dzIHRoYXQga2luZCBvZiB2YWxpZGF0aW9uIHRlc3RcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvclt2YWxpZGF0b3JUeXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbjogJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRvckFyZ3MgPSB0aGlzLl9leHRyYWN0VmFsaWRhdG9yQXJncyh0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCk7XG5cbiAgICBpZiAoIXZhbGlkYXRvclt2YWxpZGF0b3JUeXBlXSh2YWx1ZVN0cmluZywgLi4udmFsaWRhdG9yQXJncykpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHRlc3QubXNnIHx8IGBWYWxpZGF0aW9uICR7dmFsaWRhdG9yVHlwZX0gb24gJHtmaWVsZH0gZmFpbGVkYCksIHsgdmFsaWRhdG9yTmFtZTogdmFsaWRhdG9yVHlwZSwgdmFsaWRhdG9yQXJncyB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBleHRyYWN0IGFyZ3VtZW50cyBmb3IgdGhlIHZhbGlkYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB0ZXN0IFRoZSB0ZXN0IGNhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JUeXBlIE9uZSBvZiBrbm93biB0byBTZXF1ZWxpemUgdmFsaWRhdG9ycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9leHRyYWN0VmFsaWRhdG9yQXJncyh0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCkge1xuICAgIGxldCB2YWxpZGF0b3JBcmdzID0gdGVzdC5hcmdzIHx8IHRlc3Q7XG4gICAgY29uc3QgaXNMb2NhbGl6ZWRWYWxpZGF0b3IgPSB0eXBlb2YgdmFsaWRhdG9yQXJncyAhPT0gJ3N0cmluZycgJiYgKHZhbGlkYXRvclR5cGUgPT09ICdpc0FscGhhJyB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNBbHBoYW51bWVyaWMnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc01vYmlsZVBob25lJyk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsaWRhdG9yQXJncykpIHtcbiAgICAgIGlmICh2YWxpZGF0b3JUeXBlID09PSAnaXNJbW11dGFibGUnKSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJncywgZmllbGQsIHRoaXMubW9kZWxJbnN0YW5jZV07XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxpemVkVmFsaWRhdG9yIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc0lQJykge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW3ZhbGlkYXRvckFyZ3NdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0b3JBcmdzID0gdmFsaWRhdG9yQXJncy5zbGljZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRvckFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCB2YWxpZGF0ZSBhIHNpbmdsZSBmaWVsZCBhZ2FpbnN0IGl0cyBzY2hlbWEgZGVmaW5pdGlvbiAoaXNudWxsKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHJhd0F0dHJpYnV0ZSBBcyBkZWZpbmVkIGluIHRoZSBTY2hlbWEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBhbnl0aGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF92YWxpZGF0ZVNjaGVtYShyYXdBdHRyaWJ1dGUsIGZpZWxkLCB2YWx1ZSkge1xuICAgIGlmIChyYXdBdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGNvbnN0IGFzc29jaWF0aW9uID0gT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKS5maW5kKGFzc29jaWF0aW9uID0+IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvICYmIGFzc29jaWF0aW9uLmZvcmVpZ25LZXkgPT09IHJhd0F0dHJpYnV0ZS5maWVsZE5hbWUpO1xuICAgICAgaWYgKCFhc3NvY2lhdGlvbiB8fCAhdGhpcy5tb2RlbEluc3RhbmNlLmdldChhc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yKSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBfLmdldCh2YWxpZGF0b3JzLCAnbm90TnVsbC5tc2cnLCBgJHt0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0uJHtmaWVsZH0gY2Fubm90IGJlIG51bGxgKTtcblxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgIGVyck1zZyxcbiAgICAgICAgICAnbm90TnVsbCBWaW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuQ09SRSxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0aGlzLm1vZGVsSW5zdGFuY2UsXG4gICAgICAgICAgJ2lzX251bGwnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5TVFJJTkcgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVEVYVCB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5DSVRFWFQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBfLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgIGAke2ZpZWxkfSBjYW5ub3QgYmUgYW4gYXJyYXkgb3IgYW4gb2JqZWN0YCxcbiAgICAgICAgICAnc3RyaW5nIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5DT1JFLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMubW9kZWxJbnN0YW5jZSxcbiAgICAgICAgICAnbm90X2Ffc3RyaW5nJ1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYWxsIGVycm9ycyByZXRhaW5pbmcgdGhlIG9yaWdpbmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIGlzQnVpbHRpbiAgIC0gRGV0ZXJtaW5lcyBpZiBlcnJvciBpcyBmcm9tIGJ1aWx0aW4gdmFsaWRhdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIGVycm9yS2V5ICAgIC0gbmFtZSBvZiBpbnZhbGlkIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtFcnJvcnxzdHJpbmd9ICByYXdFcnJvciAgICAtIFRoZSBvcmlnaW5hbCBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSAgICAgICAtIFRoZSBkYXRhIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBmbk5hbWUgICAgICAtIE5hbWUgb2YgdGhlIHZhbGlkYXRvciwgaWYgYW55XG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgZm5BcmdzICAgICAgLSBBcmd1bWVudHMgZm9yIHRoZSB2YWxpZGF0b3IgW2Z1bmN0aW9uXSwgaWYgYW55XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHVzaEVycm9yKGlzQnVpbHRpbiwgZXJyb3JLZXksIHJhd0Vycm9yLCB2YWx1ZSwgZm5OYW1lLCBmbkFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gcmF3RXJyb3IubWVzc2FnZSB8fCByYXdFcnJvciB8fCAnVmFsaWRhdGlvbiBlcnJvcic7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAnVmFsaWRhdGlvbiBlcnJvcicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5GVU5DVElPTixcbiAgICAgIGVycm9yS2V5LFxuICAgICAgdmFsdWUsXG4gICAgICB0aGlzLm1vZGVsSW5zdGFuY2UsXG4gICAgICBmbk5hbWUsXG4gICAgICBpc0J1aWx0aW4gPyBmbk5hbWUgOiB1bmRlZmluZWQsXG4gICAgICBpc0J1aWx0aW4gPyBmbkFyZ3MgOiB1bmRlZmluZWRcbiAgICApO1xuXG4gICAgZXJyb3JbSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FXSA9IHJhd0Vycm9yO1xuXG4gICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn1cbi8qKlxuICogVGhlIGVycm9yIGtleSBmb3IgYXJndW1lbnRzIGFzIHBhc3NlZCBieSBjdXN0b20gdmFsaWRhdG9yc1xuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5JbnN0YW5jZVZhbGlkYXRvci5SQVdfS0VZX05BTUUgPSAnb3JpZ2luYWwnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluc3RhbmNlVmFsaWRhdG9yO1xubW9kdWxlLmV4cG9ydHMuSW5zdGFuY2VWYWxpZGF0b3IgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVG9wb3NvcnQgPSByZXF1aXJlKCd0b3Bvc29ydC1jbGFzcycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jbGFzcyBNb2RlbE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICB9XG5cbiAgYWRkTW9kZWwobW9kZWwpIHtcbiAgICB0aGlzLm1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbHNbbW9kZWwubmFtZV0gPSBtb2RlbDtcblxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIHJlbW92ZU1vZGVsKG1vZGVsVG9SZW1vdmUpIHtcbiAgICB0aGlzLm1vZGVscyA9IHRoaXMubW9kZWxzLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5uYW1lICE9PSBtb2RlbFRvUmVtb3ZlLm5hbWUpO1xuXG4gICAgZGVsZXRlIHRoaXMuc2VxdWVsaXplLm1vZGVsc1ttb2RlbFRvUmVtb3ZlLm5hbWVdO1xuICB9XG5cbiAgZ2V0TW9kZWwoYWdhaW5zdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIGF0dHJpYnV0ZTogJ25hbWUnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZChtb2RlbCA9PiBtb2RlbFtvcHRpb25zLmF0dHJpYnV0ZV0gPT09IGFnYWluc3QpO1xuICB9XG5cbiAgZ2V0IGFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbHM7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIE1vZGVscyBpbiBhbiBvcmRlciBzdWl0YWJsZSBmb3IgZS5nLiBjcmVhdGluZyB0YWJsZXMuXG4gICAqIFdpbGwgdGFrZSBmb3JlaWduIGtleSBjb25zdHJhaW50cyBpbnRvIGFjY291bnQgc28gdGhhdCBkZXBlbmRlbmNpZXMgYXJlIHZpc2l0ZWQgYmVmb3JlIGRlcGVuZGVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yIG1ldGhvZCB0byBleGVjdXRlIG9uIGVhY2ggbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBpdGVyYXRvciBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmb3JFYWNoTW9kZWwoaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbHMgPSB7fTtcbiAgICBjb25zdCBzb3J0ZXIgPSBuZXcgVG9wb3NvcnQoKTtcbiAgICBsZXQgc29ydGVkO1xuICAgIGxldCBkZXA7XG5cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxzKSB7XG4gICAgICBsZXQgZGVwcyA9IFtdO1xuICAgICAgbGV0IHRhYmxlTmFtZSA9IG1vZGVsLmdldFRhYmxlTmFtZSgpO1xuXG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIHRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuXG4gICAgICBtb2RlbHNbdGFibGVOYW1lXSA9IG1vZGVsO1xuXG4gICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgICAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgZGVwID0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWw7XG5cbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGRlcCkpIHtcbiAgICAgICAgICAgICAgZGVwID0gYCR7ZGVwLnNjaGVtYX0uJHtkZXAudGFibGVOYW1lfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXBzID0gZGVwcy5maWx0ZXIoZGVwID0+IHRhYmxlTmFtZSAhPT0gZGVwKTtcblxuICAgICAgc29ydGVyLmFkZCh0YWJsZU5hbWUsIGRlcHMpO1xuICAgIH1cblxuICAgIHNvcnRlZCA9IHNvcnRlci5zb3J0KCk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgc29ydGVkID0gc29ydGVkLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZCkge1xuICAgICAgaXRlcmF0b3IobW9kZWxzW25hbWVdLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Nb2RlbE1hbmFnZXIgPSBNb2RlbE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gTW9kZWxNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IERvdHRpZSA9IHJlcXVpcmUoJ2RvdHRpZScpO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10bycpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueScpO1xuY29uc3QgSW5zdGFuY2VWYWxpZGF0b3IgPSByZXF1aXJlKCcuL2luc3RhbmNlLXZhbGlkYXRvcicpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2Jhc2UnKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9oYXMtbWFueScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBIb29rcyA9IHJlcXVpcmUoJy4vaG9va3MnKTtcbmNvbnN0IGFzc29jaWF0aW9uc01peGluID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvbWl4aW4nKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMnKTtcbmNvbnN0IHsgbm9Eb3VibGVOZXN0ZWRHcm91cCB9ID0gcmVxdWlyZSgnLi91dGlscy9kZXByZWNhdGlvbnMnKTtcblxuXG4vLyBUaGlzIGxpc3Qgd2lsbCBxdWlja2x5IGJlY29tZSBkYXRlZCwgYnV0IGZhaWxpbmcgdG8gbWFpbnRhaW4gdGhpcyBsaXN0IGp1c3QgbWVhbnNcbi8vIHdlIHdvbid0IHRocm93IGEgd2FybmluZyB3aGVuIHdlIHNob3VsZC4gQXQgbGVhc3QgbW9zdCBjb21tb24gY2FzZXMgd2lsbCBmb3JldmVyIGJlIGNvdmVyZWRcbi8vIHNvIHdlIHN0b3AgdGhyb3dpbmcgZXJyb25lb3VzIHdhcm5pbmdzIHdoZW4gd2Ugc2hvdWxkbid0LlxuY29uc3QgdmFsaWRRdWVyeUtleXdvcmRzID0gbmV3IFNldChbJ3doZXJlJywgJ2F0dHJpYnV0ZXMnLCAncGFyYW5vaWQnLCAnaW5jbHVkZScsICdvcmRlcicsICdsaW1pdCcsICdvZmZzZXQnLFxuICAndHJhbnNhY3Rpb24nLCAnbG9jaycsICdyYXcnLCAnbG9nZ2luZycsICdiZW5jaG1hcmsnLCAnaGF2aW5nJywgJ3NlYXJjaFBhdGgnLCAncmVqZWN0T25FbXB0eScsICdwbGFpbicsXG4gICdzY29wZScsICdncm91cCcsICd0aHJvdWdoJywgJ2RlZmF1bHRzJywgJ2Rpc3RpbmN0JywgJ3ByaW1hcnknLCAnZXhjZXB0aW9uJywgJ3R5cGUnLCAnaG9va3MnLCAnZm9yY2UnLFxuICAnbmFtZSddKTtcblxuLy8gTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBpbXBsaWNpdGx5IHBhc3NlZCBpbnRvIHN1YnF1ZXJpZXMvaW5jbHVkZXMuXG5jb25zdCBub25DYXNjYWRpbmdPcHRpb25zID0gWydpbmNsdWRlJywgJ2F0dHJpYnV0ZXMnLCAnb3JpZ2luYWxBdHRyaWJ1dGVzJywgJ29yZGVyJywgJ3doZXJlJywgJ2xpbWl0JywgJ29mZnNldCcsICdwbGFpbicsICdncm91cCcsICdoYXZpbmcnXTtcblxuLyoqXG4gKiBBIE1vZGVsIHJlcHJlc2VudHMgYSB0YWJsZSBpbiB0aGUgZGF0YWJhc2UuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBhIGRhdGFiYXNlIHJvdy5cbiAqXG4gKiBNb2RlbCBpbnN0YW5jZXMgb3BlcmF0ZSB3aXRoIHRoZSBjb25jZXB0IG9mIGEgYGRhdGFWYWx1ZXNgIHByb3BlcnR5LCB3aGljaCBzdG9yZXMgdGhlIGFjdHVhbCB2YWx1ZXMgcmVwcmVzZW50ZWQgYnkgdGhlIGluc3RhbmNlLlxuICogQnkgZGVmYXVsdCwgdGhlIHZhbHVlcyBmcm9tIGRhdGFWYWx1ZXMgY2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSB0aGUgSW5zdGFuY2UsIHRoYXQgaXM6XG4gKiBgYGBqc1xuICogaW5zdGFuY2UuZmllbGRcbiAqIC8vIGlzIHRoZSBzYW1lIGFzXG4gKiBpbnN0YW5jZS5nZXQoJ2ZpZWxkJylcbiAqIC8vIGlzIHRoZSBzYW1lIGFzXG4gKiBpbnN0YW5jZS5nZXREYXRhVmFsdWUoJ2ZpZWxkJylcbiAqIGBgYFxuICogSG93ZXZlciwgaWYgZ2V0dGVycyBhbmQvb3Igc2V0dGVycyBhcmUgZGVmaW5lZCBmb3IgYGZpZWxkYCB0aGV5IHdpbGwgYmUgaW52b2tlZCwgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlIHZhbHVlIGZyb20gYGRhdGFWYWx1ZXNgLlxuICogQWNjZXNzaW5nIHByb3BlcnRpZXMgZGlyZWN0bHkgb3IgdXNpbmcgYGdldGAgaXMgcHJlZmVycmVkIGZvciByZWd1bGFyIHVzZSwgYGdldERhdGFWYWx1ZWAgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3VzdG9tIGdldHRlcnMuXG4gKlxuICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplI2RlZmluZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICogQG1peGVzIEhvb2tzXG4gKi9cbmNsYXNzIE1vZGVsIHtcbiAgc3RhdGljIGdldCBxdWVyeUludGVyZmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcXVlcnlHZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJbnRlcmZhY2UucXVlcnlHZW5lcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdGhlIHNlcXVlbGl6ZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemV9XG4gICAqXG4gICAqIEBwcm9wZXJ0eSBzZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZX1cbiAgICovXG4gIGdldCBzZXF1ZWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VxdWVsaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG5ldyBtb2RlbCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICBbdmFsdWVzPXt9XSBhbiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdIGluc3RhbmNlIGNvbnN0cnVjdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmF3PWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgdmFsdWVzIHdpbGwgaWdub3JlIGZpZWxkIGFuZCB2aXJ0dWFsIHNldHRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNOZXdSZWNvcmQ9dHJ1ZV0gSXMgdGhpcyBhIG5ldyByZWNvcmRcbiAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5pbmNsdWRlXSBhbiBhcnJheSBvZiBpbmNsdWRlIG9wdGlvbnMgLSBVc2VkIHRvIGJ1aWxkIHByZWZldGNoZWQvaW5jbHVkZWQgbW9kZWwgaW5zdGFuY2VzLiBTZWUgYHNldGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgaXNOZXdSZWNvcmQ6IHRydWUsXG4gICAgICBfc2NoZW1hOiB0aGlzLmNvbnN0cnVjdG9yLl9zY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiB0aGlzLmNvbnN0cnVjdG9yLl9zY2hlbWFEZWxpbWl0ZXIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoYXR0cmlidXRlID0+IEFycmF5LmlzQXJyYXkoYXR0cmlidXRlKSA/IGF0dHJpYnV0ZVsxXSA6IGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGF0YVZhbHVlcyA9IHt9O1xuICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IHt9O1xuICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBpbnN0YW5jZSBoYXMgbm90IHlldCBiZWVuIHBlcnNpc3RlZCB0byB0aGUgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc05ld1JlY29yZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNOZXdSZWNvcmQgPSBvcHRpb25zLmlzTmV3UmVjb3JkO1xuXG4gICAgdGhpcy5faW5pdFZhbHVlcyh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2luaXRWYWx1ZXModmFsdWVzLCBvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRzO1xuICAgIGxldCBrZXk7XG5cbiAgICB2YWx1ZXMgPSB7IC4uLnZhbHVlcyB9O1xuXG4gICAgaWYgKG9wdGlvbnMuaXNOZXdSZWNvcmQpIHtcbiAgICAgIGRlZmF1bHRzID0ge307XG5cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGRlZmF1bHRzID0gXy5tYXBWYWx1ZXModGhpcy5jb25zdHJ1Y3Rvci5fZGVmYXVsdFZhbHVlcywgdmFsdWVGbiA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kID8gdmFsdWUgOiBfLmNsb25lRGVlcCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgaWQgdG8gbnVsbCBpZiBub3QgcGFzc2VkIGFzIHZhbHVlLCBhIG5ld2x5IGNyZWF0ZWQgZGFvIGhhcyBubyBpZFxuICAgICAgLy8gcmVtb3ZpbmcgdGhpcyBicmVha3MgYnVsa0NyZWF0ZVxuICAgICAgLy8gZG8gYWZ0ZXIgZGVmYXVsdCB2YWx1ZXMgc2luY2UgaXQgbWlnaHQgaGF2ZSBVVUlEIGFzIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMuZm9yRWFjaChwcmltYXJ5S2V5QXR0cmlidXRlID0+IHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0cywgcHJpbWFyeUtleUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAodmFsdWVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNba2V5XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXQodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgdGhpcyBtZXRob2RcbiAgc3RhdGljIF9wYXJhbm9pZENsYXVzZShtb2RlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gQXBwbHkgb24gZWFjaCBpbmNsdWRlXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgaGFuZGxlZCBiZWZvcmUgaGFuZGxpbmcgd2hlcmUgY29uZGl0aW9ucyBiZWNhdXNlIG9mIGxvZ2ljIHdpdGggcmV0dXJuc1xuICAgIC8vIG90aGVyd2lzZSB0aGlzIGNvZGUgd2lsbCBuZXZlciBydW4gb24gaW5jbHVkZXMgb2YgYSBhbHJlYWR5IGNvbmRpdGlvbmFibGUgd2hlcmVcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX3BhcmFub2lkQ2xhdXNlKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHBhcmFub2lkIHdoZW4gZ3JvdXBlZExpbWl0IGlzIHVzZWRcbiAgICBpZiAoXy5nZXQob3B0aW9ucywgJ2dyb3VwZWRMaW1pdC5vbi5vcHRpb25zLnBhcmFub2lkJykpIHtcbiAgICAgIGNvbnN0IHRocm91Z2hNb2RlbCA9IF8uZ2V0KG9wdGlvbnMsICdncm91cGVkTGltaXQub24udGhyb3VnaC5tb2RlbCcpO1xuICAgICAgaWYgKHRocm91Z2hNb2RlbCkge1xuICAgICAgICBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhyb3VnaE1vZGVsLCBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsLm9wdGlvbnMudGltZXN0YW1wcyB8fCAhbW9kZWwub3B0aW9ucy5wYXJhbm9pZCB8fCBvcHRpb25zLnBhcmFub2lkID09PSBmYWxzZSkge1xuICAgICAgLy8gVGhpcyBtb2RlbCBpcyBub3QgcGFyYW5vaWQsIG5vdGhpbmcgdG8gZG8gaGVyZTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0T2JqZWN0ID0ge307XG5cbiAgICBsZXQgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG5cbiAgICBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBkZWxldGVkQXREZWZhdWx0VmFsdWUgfHwge1xuICAgICAgW09wLmVxXTogbnVsbFxuICAgIH07XG5cbiAgICBkZWxldGVkQXRPYmplY3RbZGVsZXRlZEF0QXR0cmlidXRlLmZpZWxkIHx8IGRlbGV0ZWRBdENvbF0gPSBkZWxldGVkQXREZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoVXRpbHMuaXNXaGVyZUVtcHR5KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0gZGVsZXRlZEF0T2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLndoZXJlID0geyBbT3AuYW5kXTogW2RlbGV0ZWRBdE9iamVjdCwgb3B0aW9ucy53aGVyZV0gfTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBfYWRkRGVmYXVsdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdGFpbCA9IHt9O1xuICAgIGxldCBoZWFkID0ge307XG5cbiAgICAvLyBBZGQgaWQgaWYgbm8gcHJpbWFyeSBrZXkgd2FzIG1hbnVhbGx5IGFkZGVkIHRvIGRlZmluaXRpb25cbiAgICAvLyBDYW4ndCB1c2UgdGhpcy5wcmltYXJ5S2V5cyBoZXJlLCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBiZWZvcmUgUEtzIGFyZSBpZGVudGlmaWVkXG4gICAgaWYgKCFfLnNvbWUodGhpcy5yYXdBdHRyaWJ1dGVzLCAncHJpbWFyeUtleScpKSB7XG4gICAgICBpZiAoJ2lkJyBpbiB0aGlzLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIGlzIGZpc2h5IGhlcmUhXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBjb2x1bW4gY2FsbGVkICdpZCcgd2FzIGFkZGVkIHRvIHRoZSBhdHRyaWJ1dGVzIG9mICcke3RoaXMudGFibGVOYW1lfScgYnV0IG5vdCBtYXJrZWQgd2l0aCAncHJpbWFyeUtleTogdHJ1ZSdgKTtcbiAgICAgIH1cblxuICAgICAgaGVhZCA9IHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICB0eXBlOiBuZXcgRGF0YVR5cGVzLklOVEVHRVIoKSxcbiAgICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICAgIHByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKSB7XG4gICAgICB0YWlsW3RoaXMuX3ZlcnNpb25BdHRyaWJ1dGVdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuSU5URUdFUixcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAwLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdSYXdBdHRyaWJ1dGVzID0ge1xuICAgICAgLi4uaGVhZCxcbiAgICAgIC4uLnRoaXMucmF3QXR0cmlidXRlc1xuICAgIH07XG4gICAgXy5lYWNoKHRhaWwsICh2YWx1ZSwgYXR0cikgPT4ge1xuICAgICAgaWYgKG5ld1Jhd0F0dHJpYnV0ZXNbYXR0cl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdSYXdBdHRyaWJ1dGVzW2F0dHJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJhd0F0dHJpYnV0ZXMgPSBuZXdSYXdBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLnByaW1hcnlLZXlzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHJpbWFyeUtleXMuaWQgPSB0aGlzLnJhd0F0dHJpYnV0ZXMuaWQ7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9maW5kQXV0b0luY3JlbWVudEF0dHJpYnV0ZSgpIHtcbiAgICB0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMucmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJhd0F0dHJpYnV0ZXMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmIChkZWZpbml0aW9uICYmIGRlZmluaXRpb24uYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0YW5jZSBkZWZpbml0aW9uLiBPbmx5IG9uZSBhdXRvaW5jcmVtZW50IGZpZWxkIGFsbG93ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCBzZWxmKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUpIHJldHVybjtcblxuICAgIC8vIGlmIGluY2x1ZGUgaXMgbm90IGFuIGFycmF5LCB3cmFwIGluIGFuIGFycmF5XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZSkpIHtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZSA9IFtvcHRpb25zLmluY2x1ZGVdO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmluY2x1ZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbGwgaW5jbHVkZWQgZWxlbWVudHMgdG8geyBtb2RlbDogTW9kZWwgfSBmb3JtXG4gICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlLm1hcChpbmNsdWRlID0+IHRoaXMuX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUsIHNlbGYpKTtcbiAgfVxuXG4gIHN0YXRpYyBfdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZSwgc2VsZikge1xuICAgIGlmIChzZWxmICYmIHR5cGVvZiBpbmNsdWRlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi5hc3NvY2lhdGlvbnMsIGluY2x1ZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzb2NpYXRpb24gd2l0aCBhbGlhcyBcIiR7aW5jbHVkZX1cIiBkb2VzIG5vdCBleGlzdCBvbiAke3NlbGYubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmFzc29jaWF0aW9uc1tpbmNsdWRlXTtcbiAgICB9XG4gICAgcmV0dXJuIGluY2x1ZGU7XG4gIH1cblxuICBzdGF0aWMgX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUsIHNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgbGV0IG1vZGVsO1xuXG4gICAgICBpZiAoaW5jbHVkZS5fcHNldWRvKSByZXR1cm4gaW5jbHVkZTtcblxuICAgICAgaW5jbHVkZSA9IHRoaXMuX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUsIHNlbGYpO1xuXG4gICAgICBpZiAoaW5jbHVkZSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgIGlmIChzZWxmICYmIGluY2x1ZGUudGFyZ2V0Lm5hbWUgPT09IHNlbGYubmFtZSkge1xuICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLnRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG1vZGVsLCBhc3NvY2lhdGlvbjogaW5jbHVkZSwgYXM6IGluY2x1ZGUuYXMgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGUucHJvdG90eXBlICYmIGluY2x1ZGUucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kZWw6IGluY2x1ZGUgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpbmNsdWRlKSkge1xuICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbikge1xuICAgICAgICAgIGluY2x1ZGUuYXNzb2NpYXRpb24gPSB0aGlzLl90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLmFzc29jaWF0aW9uLCBzZWxmKTtcblxuICAgICAgICAgIGlmIChzZWxmICYmIGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IHNlbGYubmFtZSkge1xuICAgICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGUubW9kZWwpIGluY2x1ZGUubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgICBpZiAoIWluY2x1ZGUuYXMpIGluY2x1ZGUuYXMgPSBpbmNsdWRlLmFzc29jaWF0aW9uLmFzO1xuXG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUsIG1vZGVsKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNsdWRlLm1vZGVsKSB7XG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY2x1ZGUuYWxsKSB7XG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmNsdWRlIHVuZXhwZWN0ZWQuIEVsZW1lbnQgaGFzIHRvIGJlIGVpdGhlciBhIE1vZGVsLCBhbiBBc3NvY2lhdGlvbiBvciBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBzdGF0aWMgX2V4cGFuZEluY2x1ZGVBbGxFbGVtZW50KGluY2x1ZGVzLCBpbmNsdWRlKSB7XG4gICAgLy8gY2hlY2sgJ2FsbCcgYXR0cmlidXRlIHByb3ZpZGVkIGlzIHZhbGlkXG4gICAgbGV0IGFsbCA9IGluY2x1ZGUuYWxsO1xuICAgIGRlbGV0ZSBpbmNsdWRlLmFsbDtcblxuICAgIGlmIChhbGwgIT09IHRydWUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhbGwpKSB7XG4gICAgICAgIGFsbCA9IFthbGxdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZFR5cGVzID0ge1xuICAgICAgICBCZWxvbmdzVG86IHRydWUsXG4gICAgICAgIEhhc09uZTogdHJ1ZSxcbiAgICAgICAgSGFzTWFueTogdHJ1ZSxcbiAgICAgICAgT25lOiBbJ0JlbG9uZ3NUbycsICdIYXNPbmUnXSxcbiAgICAgICAgSGFzOiBbJ0hhc09uZScsICdIYXNNYW55J10sXG4gICAgICAgIE1hbnk6IFsnSGFzTWFueSddXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gYWxsW2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0FsbCcpIHtcbiAgICAgICAgICBhbGwgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSB2YWxpZFR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgaW5jbHVkZSBhbGwgJyR7dHlwZX0nIGlzIG5vdCB2YWxpZCAtIG11c3QgYmUgQmVsb25nc1RvLCBIYXNPbmUsIEhhc01hbnksIE9uZSwgSGFzLCBNYW55IG9yIEFsbGApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgLy8gcmVwbGFjZSB0eXBlIHBsYWNlaG9sZGVyIGUuZy4gJ09uZScgd2l0aCBpdHMgY29uc3RpdHVlbnQgdHlwZXMgZS5nLiAnSGFzT25lJywgJ0JlbG9uZ3NUbydcbiAgICAgICAgICBhbGwuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoIWFsbC5pbmNsdWRlcyh0eXBlc1tqXSkpIHtcbiAgICAgICAgICAgICAgYWxsLnVuc2hpZnQodHlwZXNbal0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBhc3NvY2lhdGlvbnMgb2YgdHlwZXMgc3BlY2lmaWVkIHRvIGluY2x1ZGVzXG4gICAgY29uc3QgbmVzdGVkID0gaW5jbHVkZS5uZXN0ZWQ7XG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgZGVsZXRlIGluY2x1ZGUubmVzdGVkO1xuXG4gICAgICBpZiAoIWluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgICBpbmNsdWRlLmluY2x1ZGUgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaW5jbHVkZS5pbmNsdWRlKSkge1xuICAgICAgICBpbmNsdWRlLmluY2x1ZGUgPSBbaW5jbHVkZS5pbmNsdWRlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1c2VkID0gW107XG4gICAgKGZ1bmN0aW9uIGFkZEFsbEluY2x1ZGVzKHBhcmVudCwgaW5jbHVkZXMpIHtcbiAgICAgIF8uZm9yRWFjaChwYXJlbnQuYXNzb2NpYXRpb25zLCBhc3NvY2lhdGlvbiA9PiB7XG4gICAgICAgIGlmIChhbGwgIT09IHRydWUgJiYgIWFsbC5pbmNsdWRlcyhhc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbW9kZWwgYWxyZWFkeSBpbmNsdWRlZCwgYW5kIHNraXAgaWYgc29cbiAgICAgICAgY29uc3QgbW9kZWwgPSBhc3NvY2lhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGFzID0gYXNzb2NpYXRpb24ub3B0aW9ucy5hcztcblxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB7IG1vZGVsIH07XG4gICAgICAgIGlmIChhcykge1xuICAgICAgICAgIC8vIFdlIG9ubHkgYWRkICdhcycgdG8gdGhlIHByZWRpY2F0ZSBpZiBpdCBhY3R1YWxseSBleGlzdHNcbiAgICAgICAgICBwcmVkaWNhdGUuYXMgPSBhcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNvbWUoaW5jbHVkZXMsIHByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lwIGlmIHJlY3Vyc2luZyBvdmVyIGEgbW9kZWwgYWxyZWFkeSBuZXN0ZWRcbiAgICAgICAgaWYgKG5lc3RlZCAmJiB1c2VkLmluY2x1ZGVzKG1vZGVsKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1c2VkLnB1c2gocGFyZW50KTtcblxuICAgICAgICAvLyBpbmNsdWRlIHRoaXMgbW9kZWxcbiAgICAgICAgY29uc3QgdGhpc0luY2x1ZGUgPSBVdGlscy5jbG9uZURlZXAoaW5jbHVkZSk7XG4gICAgICAgIHRoaXNJbmNsdWRlLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIGlmIChhcykge1xuICAgICAgICAgIHRoaXNJbmNsdWRlLmFzID0gYXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVkZXMucHVzaCh0aGlzSW5jbHVkZSk7XG5cbiAgICAgICAgLy8gcnVuIHJlY3Vyc2l2ZWx5IGlmIG5lc3RlZFxuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgYWRkQWxsSW5jbHVkZXMobW9kZWwsIHRoaXNJbmNsdWRlLmluY2x1ZGUpO1xuICAgICAgICAgIGlmICh0aGlzSW5jbHVkZS5pbmNsdWRlLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHRoaXNJbmNsdWRlLmluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdXNlZC5wb3AoKTtcbiAgICB9KSh0aGlzLCBpbmNsdWRlcyk7XG4gIH1cblxuICBzdGF0aWMgX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zLCB0YWJsZU5hbWVzKSB7XG4gICAgaWYgKCFvcHRpb25zLm1vZGVsKSBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuICAgIHRhYmxlTmFtZXMgPSB0YWJsZU5hbWVzIHx8IHt9O1xuICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzID0gW107XG4gICAgb3B0aW9ucy5pbmNsdWRlTWFwID0ge307XG5cbiAgICAvKiBMZWdhY3kgKi9cbiAgICBvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uID0gZmFsc2U7XG4gICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdGlvbnMucGFyZW50KSB7XG4gICAgICBvcHRpb25zLnRvcE1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICAgIG9wdGlvbnMudG9wTGltaXQgPSBvcHRpb25zLmxpbWl0O1xuICAgIH1cblxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZS5tYXAoaW5jbHVkZSA9PiB7XG4gICAgICBpbmNsdWRlID0gdGhpcy5fY29uZm9ybUluY2x1ZGUoaW5jbHVkZSk7XG4gICAgICBpbmNsdWRlLnBhcmVudCA9IG9wdGlvbnM7XG4gICAgICBpbmNsdWRlLnRvcExpbWl0ID0gb3B0aW9ucy50b3BMaW1pdDtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnQuY2FsbChvcHRpb25zLm1vZGVsLCBpbmNsdWRlLCB0YWJsZU5hbWVzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmNsdWRlLmR1cGxpY2F0aW5nID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5pc011bHRpQXNzb2NpYXRpb247XG4gICAgICB9XG5cbiAgICAgIGluY2x1ZGUuaGFzRHVwbGljYXRpbmcgPSBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nIHx8IGluY2x1ZGUuZHVwbGljYXRpbmc7XG4gICAgICBpbmNsdWRlLmhhc1JlcXVpcmVkID0gaW5jbHVkZS5oYXNSZXF1aXJlZCB8fCBpbmNsdWRlLnJlcXVpcmVkO1xuXG4gICAgICBvcHRpb25zLmhhc0R1cGxpY2F0aW5nID0gb3B0aW9ucy5oYXNEdXBsaWNhdGluZyB8fCBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nO1xuICAgICAgb3B0aW9ucy5oYXNSZXF1aXJlZCA9IG9wdGlvbnMuaGFzUmVxdWlyZWQgfHwgaW5jbHVkZS5yZXF1aXJlZDtcblxuICAgICAgb3B0aW9ucy5oYXNXaGVyZSA9IG9wdGlvbnMuaGFzV2hlcmUgfHwgaW5jbHVkZS5oYXNXaGVyZSB8fCAhIWluY2x1ZGUud2hlcmU7XG4gICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGluY2x1ZGUuaGFzUGFyZW50V2hlcmUgPSBvcHRpb25zLmhhc1BhcmVudFdoZXJlIHx8ICEhb3B0aW9ucy53aGVyZTtcbiAgICAgIGluY2x1ZGUuaGFzUGFyZW50UmVxdWlyZWQgPSBvcHRpb25zLmhhc1BhcmVudFJlcXVpcmVkIHx8ICEhb3B0aW9ucy5yZXF1aXJlZDtcblxuICAgICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkgIT09IGZhbHNlICYmIG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgJiYgb3B0aW9ucy50b3BMaW1pdCkge1xuICAgICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZykge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBmYWxzZTtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gaW5jbHVkZS5oYXNSZXF1aXJlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5oYXNSZXF1aXJlZDtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5IHx8IGZhbHNlO1xuICAgICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZykge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBpbmNsdWRlLnN1YlF1ZXJ5O1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gZmFsc2U7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnkgfHwgaW5jbHVkZS5oYXNQYXJlbnRSZXF1aXJlZCAmJiBpbmNsdWRlLmhhc1JlcXVpcmVkICYmICFpbmNsdWRlLnNlcGFyYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuaW5jbHVkZU1hcFtpbmNsdWRlLmFzXSA9IGluY2x1ZGU7XG4gICAgICBvcHRpb25zLmluY2x1ZGVOYW1lcy5wdXNoKGluY2x1ZGUuYXMpO1xuXG4gICAgICAvLyBTZXQgdG9wIGxldmVsIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLnRvcE1vZGVsID09PSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMuc3ViUXVlcnkgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRvcExpbWl0KSB7XG4gICAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZS5oYXNEdXBsaWNhdGluZykge1xuICAgICAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIExlZ2FjeSAqL1xuICAgICAgb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgPSBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBpbmNsdWRlLmhhc0luY2x1ZGVXaGVyZSB8fCAhIWluY2x1ZGUud2hlcmU7XG4gICAgICBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCA9IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IGluY2x1ZGUuaGFzSW5jbHVkZVJlcXVpcmVkIHx8ICEhaW5jbHVkZS5yZXF1aXJlZDtcblxuICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uaXNNdWx0aUFzc29jaWF0aW9uIHx8IGluY2x1ZGUuaGFzTXVsdGlBc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbiB8fCBpbmNsdWRlLmhhc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRvcE1vZGVsID09PSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMuc3ViUXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBfdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnQoaW5jbHVkZSwgdGFibGVOYW1lcywgb3B0aW9ucykge1xuICAgIHRhYmxlTmFtZXNbaW5jbHVkZS5tb2RlbC5nZXRUYWJsZU5hbWUoKV0gPSB0cnVlO1xuXG4gICAgaWYgKGluY2x1ZGUuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5yYXcpIHtcbiAgICAgIGluY2x1ZGUubW9kZWwuX2V4cGFuZEF0dHJpYnV0ZXMoaW5jbHVkZSk7XG5cbiAgICAgIGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzID0gaW5jbHVkZS5tb2RlbC5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMoaW5jbHVkZS5hdHRyaWJ1dGVzKTtcblxuICAgICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChpbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlzLCAoYXR0ciwga2V5KSA9PiB7XG4gICAgICAgICAgLy8gSW5jbHVkZSB0aGUgcHJpbWFyeSBrZXkgaWYgaXQncyBub3QgYWxyZWFkeSBpbmNsdWRlZCAtIHRha2UgaW50byBhY2NvdW50IHRoYXQgdGhlIHBrIG1pZ2h0IGJlIGFsaWFzZWQgKGR1ZSB0byBhIC5maWVsZCBwcm9wKVxuICAgICAgICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzLnNvbWUoaW5jbHVkZUF0dHIgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIuZmllbGQgIT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbmNsdWRlQXR0cikgJiYgaW5jbHVkZUF0dHJbMF0gPT09IGF0dHIuZmllbGQgJiYgaW5jbHVkZUF0dHJbMV0gPT09IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlQXR0ciA9PT0ga2V5O1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMudW5zaGlmdChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIH1cblxuICAgIC8vIHBzZXVkbyBpbmNsdWRlIGp1c3QgbmVlZGVkIHRoZSBhdHRyaWJ1dGUgbG9naWMsIHJldHVyblxuICAgIGlmIChpbmNsdWRlLl9wc2V1ZG8pIHtcbiAgICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluY2x1ZGUubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoZSBjdXJyZW50IE1vZGVsIGlzIGFjdHVhbGx5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFzc2VkIE1vZGVsIC0gb3IgaXQncyBhIHBzZXVkbyBpbmNsdWRlXG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uIHx8IHRoaXMuX2dldEluY2x1ZGVkQXNzb2NpYXRpb24oaW5jbHVkZS5tb2RlbCwgaW5jbHVkZS5hcyk7XG5cbiAgICBpbmNsdWRlLmFzc29jaWF0aW9uID0gYXNzb2NpYXRpb247XG4gICAgaW5jbHVkZS5hcyA9IGFzc29jaWF0aW9uLmFzO1xuXG4gICAgLy8gSWYgdGhyb3VnaCwgd2UgY3JlYXRlIGEgcHNldWRvIGNoaWxkIGluY2x1ZGUsIHRvIGVhc2Ugb3VyIHBhcnNpbmcgbGF0ZXIgb25cbiAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoICYmIE9iamVjdChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIGlmICghaW5jbHVkZS5pbmNsdWRlKSBpbmNsdWRlLmluY2x1ZGUgPSBbXTtcbiAgICAgIGNvbnN0IHRocm91Z2ggPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2g7XG5cbiAgICAgIGluY2x1ZGUudGhyb3VnaCA9IF8uZGVmYXVsdHMoaW5jbHVkZS50aHJvdWdoIHx8IHt9LCB7XG4gICAgICAgIG1vZGVsOiB0aHJvdWdoLm1vZGVsLFxuICAgICAgICBhczogdGhyb3VnaC5tb2RlbC5uYW1lLFxuICAgICAgICBhc3NvY2lhdGlvbjoge1xuICAgICAgICAgIGlzU2luZ2xlQXNzb2NpYXRpb246IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3BzZXVkbzogdHJ1ZSxcbiAgICAgICAgcGFyZW50OiBpbmNsdWRlXG4gICAgICB9KTtcblxuXG4gICAgICBpZiAodGhyb3VnaC5zY29wZSkge1xuICAgICAgICBpbmNsdWRlLnRocm91Z2gud2hlcmUgPSBpbmNsdWRlLnRocm91Z2gud2hlcmUgPyB7IFtPcC5hbmRdOiBbaW5jbHVkZS50aHJvdWdoLndoZXJlLCB0aHJvdWdoLnNjb3BlXSB9IDogdGhyb3VnaC5zY29wZTtcbiAgICAgIH1cblxuICAgICAgaW5jbHVkZS5pbmNsdWRlLnB1c2goaW5jbHVkZS50aHJvdWdoKTtcbiAgICAgIHRhYmxlTmFtZXNbdGhyb3VnaC50YWJsZU5hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlLm1vZGVsIG1heSBiZSB0aGUgbWFpbiBtb2RlbCwgd2hpbGUgdGhlIGFzc29jaWF0aW9uIHRhcmdldCBtYXkgYmUgc2NvcGVkIC0gdGh1cyB3ZSBuZWVkIHRvIGxvb2sgYXQgYXNzb2NpYXRpb24udGFyZ2V0L3NvdXJjZVxuICAgIGxldCBtb2RlbDtcbiAgICBpZiAoaW5jbHVkZS5tb2RlbC5zY29wZWQgPT09IHRydWUpIHtcbiAgICAgIC8vIElmIHRoZSBwYXNzZWQgbW9kZWwgaXMgYWxyZWFkeSBzY29wZWQsIGtlZXAgdGhhdFxuICAgICAgbW9kZWwgPSBpbmNsdWRlLm1vZGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBtb2RlbCB0aGF0IHdhcyBvcmlnaW5hbGx5IHBhc3NlZCB0byB0aGUgYXNzb2NpYXRpb25cbiAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gaW5jbHVkZS5tb2RlbC5uYW1lID8gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQgOiBpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICB9XG5cbiAgICBtb2RlbC5faW5qZWN0U2NvcGUoaW5jbHVkZSk7XG5cbiAgICAvLyBUaGlzIGNoZWNrIHNob3VsZCBoYXBwZW4gYWZ0ZXIgaW5qZWN0aW5nIHRoZSBzY29wZSwgc2luY2UgdGhlIHNjb3BlIG1heSBjb250YWluIGEgLmF0dHJpYnV0ZXNcbiAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcykge1xuICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5jbHVkZS5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuXG4gICAgaWYgKGluY2x1ZGUucmVxdWlyZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZS5yZXF1aXJlZCA9ICEhaW5jbHVkZS53aGVyZTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSkge1xuICAgICAgaW5jbHVkZS53aGVyZSA9IGluY2x1ZGUud2hlcmUgPyB7IFtPcC5hbmRdOiBbaW5jbHVkZS53aGVyZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZV0gfSA6IGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGU7XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUubGltaXQgJiYgaW5jbHVkZS5zZXBhcmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmNsdWRlLnNlcGFyYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS5zZXBhcmF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKCEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEhhc01hbnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBIYXNNYW55IGFzc29jaWF0aW9ucyBzdXBwb3J0IGluY2x1ZGUuc2VwYXJhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaW5jbHVkZS5kdXBsaWNhdGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgICAmJiBvcHRpb25zLmF0dHJpYnV0ZXMubGVuZ3RoXG4gICAgICAgICYmICFfLmZsYXR0ZW5EZXB0aChvcHRpb25zLmF0dHJpYnV0ZXMsIDIpLmluY2x1ZGVzKGFzc29jaWF0aW9uLnNvdXJjZUtleSlcbiAgICAgICkge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMucHVzaChhc3NvY2lhdGlvbi5zb3VyY2VLZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGluY2x1ZGUuYXR0cmlidXRlc1xuICAgICAgICAmJiBpbmNsdWRlLmF0dHJpYnV0ZXMubGVuZ3RoXG4gICAgICAgICYmICFfLmZsYXR0ZW5EZXB0aChpbmNsdWRlLmF0dHJpYnV0ZXMsIDIpLmluY2x1ZGVzKGFzc29jaWF0aW9uLmZvcmVpZ25LZXkpXG4gICAgICApIHtcbiAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzLnB1c2goYXNzb2NpYXRpb24uZm9yZWlnbktleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgY2hpbGQgaW5jbHVkZXNcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY2x1ZGUsICdpbmNsdWRlJykpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cy5jYWxsKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUsIHRhYmxlTmFtZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmNsdWRlO1xuICB9XG5cbiAgc3RhdGljIF9nZXRJbmNsdWRlZEFzc29jaWF0aW9uKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldE1vZGVsKTtcbiAgICBsZXQgYXNzb2NpYXRpb24gPSBudWxsO1xuICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIG5vdCBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSFgKTtcbiAgICB9XG4gICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGFzc29jaWF0aW9uID0gdGhpcy5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcyk7XG4gICAgICBpZiAoYXNzb2NpYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEFsaWFzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQWxpYXNlcyA9IHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldE1vZGVsKS5tYXAoYXNzb2NpYXRpb24gPT4gYXNzb2NpYXRpb24uYXMpO1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IHVzaW5nIGFuIGFsaWFzLiBgICtcbiAgICAgICAgICBgWW91J3ZlIGluY2x1ZGVkIGFuIGFsaWFzICgke3RhcmdldEFsaWFzfSksIGJ1dCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgYWxpYXMoZXMpIGRlZmluZWQgaW4geW91ciBhc3NvY2lhdGlvbiAoJHtleGlzdGluZ0FsaWFzZXMuam9pbignLCAnKX0pLmApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSB1c2luZyBhbiBhbGlhcy4gYCArXG4gICAgICAgICdZb3UgbXVzdCB1c2UgdGhlIFxcJ2FzXFwnIGtleXdvcmQgdG8gc3BlY2lmeSB0aGUgYWxpYXMgd2l0aGluIHlvdXIgaW5jbHVkZSBzdGF0ZW1lbnQuJyk7XG4gICAgfVxuICAgIGFzc29jaWF0aW9uID0gdGhpcy5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcyk7XG4gICAgaWYgKCFhc3NvY2lhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSBtdWx0aXBsZSB0aW1lcy4gYCArXG4gICAgICAgICdUbyBpZGVudGlmeSB0aGUgY29ycmVjdCBhc3NvY2lhdGlvbiwgeW91IG11c3QgdXNlIHRoZSBcXCdhc1xcJyBrZXl3b3JkIHRvIHNwZWNpZnkgdGhlIGFsaWFzIG9mIHRoZSBhc3NvY2lhdGlvbiB5b3Ugd2FudCB0byBpbmNsdWRlLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH1cblxuXG4gIHN0YXRpYyBfZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKSB7XG4gICAgY29uc3QgaW5jbHVkZXMgPSBvcHRpb25zLmluY2x1ZGU7XG4gICAgaWYgKCFpbmNsdWRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbmNsdWRlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBpbmNsdWRlc1tpbmRleF07XG5cbiAgICAgIGlmIChpbmNsdWRlLmFsbCkge1xuICAgICAgICBpbmNsdWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGxFbGVtZW50KGluY2x1ZGVzLCBpbmNsdWRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmNsdWRlcy5mb3JFYWNoKGluY2x1ZGUgPT4ge1xuICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbC5jYWxsKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIF9jb25mb3JtSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoIWluZGV4LmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwiZmllbGRzXCIgcHJvcGVydHkgZm9yIGluZGV4IGRlZmluaXRpb24nKTtcbiAgICB9XG5cbiAgICBpbmRleCA9IF8uZGVmYXVsdHMoaW5kZXgsIHtcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgcGFyc2VyOiBudWxsXG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZXgudHlwZSAmJiBpbmRleC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICd1bmlxdWUnKSB7XG4gICAgICBpbmRleC51bmlxdWUgPSB0cnVlO1xuICAgICAgZGVsZXRlIGluZGV4LnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cblxuICBzdGF0aWMgX3VuaXFJbmNsdWRlcyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUpIHJldHVybjtcblxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IF8ob3B0aW9ucy5pbmNsdWRlKVxuICAgICAgLmdyb3VwQnkoaW5jbHVkZSA9PiBgJHtpbmNsdWRlLm1vZGVsICYmIGluY2x1ZGUubW9kZWwubmFtZX0tJHtpbmNsdWRlLmFzfWApXG4gICAgICAubWFwKGluY2x1ZGVzID0+IHRoaXMuX2Fzc2lnbk9wdGlvbnMoLi4uaW5jbHVkZXMpKVxuICAgICAgLnZhbHVlKCk7XG4gIH1cblxuICBzdGF0aWMgX2Jhc2VNZXJnZSguLi5hcmdzKSB7XG4gICAgXy5hc3NpZ25XaXRoKC4uLmFyZ3MpO1xuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhhcmdzWzBdLCB0aGlzKTtcbiAgICB0aGlzLl91bmlxSW5jbHVkZXMoYXJnc1swXSk7XG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH1cblxuICBzdGF0aWMgX21lcmdlRnVuY3Rpb24ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShzcmNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBfLnVuaW9uKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICd3aGVyZScgfHwga2V5ID09PSAnaGF2aW5nJykge1xuICAgICAgaWYgKHNyY1ZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHNyY1ZhbHVlID0geyBbT3AuYW5kXTogc3JjVmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob2JqVmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2F0dHJpYnV0ZXMnICYmIF8uaXNQbGFpbk9iamVjdChvYmpWYWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIF8uYXNzaWduV2l0aChvYmpWYWx1ZSwgc3JjVmFsdWUsIChvYmpWYWx1ZSwgc3JjVmFsdWUpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpICYmIEFycmF5LmlzQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIF8udW5pb24ob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgYSBwb3NzaWJsZSBvYmplY3QvYXJyYXkgdG8gY2xvbmUsIHdlIHRyeSBpdC5cbiAgICAvLyBPdGhlcndpc2UsIHdlIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUgd2hlbiBpdCdzIG5vdCB1bmRlZmluZWQsXG4gICAgLy8gb3IgdGhlIHJlc3VsdGluZyBvYmplY3QgaW4gdGhhdCBjYXNlLlxuICAgIGlmIChzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmNsb25lRGVlcChzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcmNWYWx1ZSA9PT0gdW5kZWZpbmVkID8gb2JqVmFsdWUgOiBzcmNWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyBfYXNzaWduT3B0aW9ucyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VNZXJnZSguLi5hcmdzLCB0aGlzLl9tZXJnZUZ1bmN0aW9uKTtcbiAgfVxuXG4gIHN0YXRpYyBfZGVmYXVsdHNPcHRpb25zKHRhcmdldCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLl9iYXNlTWVyZ2UodGFyZ2V0LCBvcHRzLCAoc3JjVmFsdWUsIG9ialZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXJnZUZ1bmN0aW9uKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbW9kZWwsIHJlcHJlc2VudGluZyBhIHRhYmxlIGluIHRoZSBEQiwgd2l0aCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBUaGUgdGFibGUgY29sdW1ucyBhcmUgZGVmaW5lZCBieSB0aGUgaGFzaCB0aGF0IGlzIGdpdmVuIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICogRWFjaCBhdHRyaWJ1dGUgb2YgdGhlIGhhc2ggcmVwcmVzZW50cyBhIGNvbHVtbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogUHJvamVjdC5pbml0KHtcbiAgICogICBjb2x1bW5BOiB7XG4gICAqICAgICB0eXBlOiBTZXF1ZWxpemUuQk9PTEVBTixcbiAgICogICAgIHZhbGlkYXRlOiB7XG4gICAqICAgICAgIGlzOiBbJ1thLXpdJywnaSddLCAgICAgICAgLy8gd2lsbCBvbmx5IGFsbG93IGxldHRlcnNcbiAgICogICAgICAgbWF4OiAyMywgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFsbG93IHZhbHVlcyA8PSAyM1xuICAgKiAgICAgICBpc0luOiB7XG4gICAqICAgICAgICAgYXJnczogW1snZW4nLCAnemgnXV0sXG4gICAqICAgICAgICAgbXNnOiBcIk11c3QgYmUgRW5nbGlzaCBvciBDaGluZXNlXCJcbiAgICogICAgICAgfVxuICAgKiAgICAgfSxcbiAgICogICAgIGZpZWxkOiAnY29sdW1uX2EnXG4gICAqICAgICAvLyBPdGhlciBhdHRyaWJ1dGVzIGhlcmVcbiAgICogICB9LFxuICAgKiAgIGNvbHVtbkI6IFNlcXVlbGl6ZS5TVFJJTkcsXG4gICAqICAgY29sdW1uQzogJ01ZIFZFUlkgT1dOIENPTFVNTiBUWVBFJ1xuICAgKiB9LCB7c2VxdWVsaXplfSlcbiAgICpcbiAgICogc2VxdWVsaXplLm1vZGVscy5tb2RlbE5hbWUgLy8gVGhlIG1vZGVsIHdpbGwgbm93IGJlIGF2YWlsYWJsZSBpbiBtb2RlbHMgdW5kZXIgdGhlIGNsYXNzIG5hbWVcbiAgICpcbiAgICogQHNlZVxuICAgKiA8YSBocmVmPVwiL21hc3Rlci9tYW51YWwvbW9kZWwtYmFzaWNzLmh0bWxcIj5Nb2RlbCBCYXNpY3M8L2E+IGd1aWRlXG4gICAqXG4gICAqIEBzZWVcbiAgICogPGEgaHJlZj1cIi9tYXN0ZXIvbWFudWFsL21vZGVsLWJhc2ljcy5odG1sXCI+SG9va3M8L2E+IGd1aWRlXG4gICAqXG4gICAqIEBzZWVcbiAgICogPGEgaHJlZj1cIi9tYXN0ZXIvbWFudWFsL3ZhbGlkYXRpb25zLWFuZC1jb25zdHJhaW50cy5odG1sXCIvPlZhbGlkYXRpb25zICYgQ29uc3RyYWludHM8L2E+IGd1aWRlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgQW4gb2JqZWN0LCB3aGVyZSBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNvbHVtbiBvZiB0aGUgdGFibGUuIEVhY2ggY29sdW1uIGNhbiBiZSBlaXRoZXIgYSBEYXRhVHlwZSwgYSBzdHJpbmcgb3IgYSB0eXBlLWRlc2NyaXB0aW9uIG9iamVjdCwgd2l0aCB0aGUgcHJvcGVydGllcyBkZXNjcmliZWQgYmVsb3c6XG4gICAqIEBwYXJhbSB7c3RyaW5nfERhdGFUeXBlc3xvYmplY3R9IGF0dHJpYnV0ZXMuY29sdW1uIFRoZSBkZXNjcmlwdGlvbiBvZiBhIGRhdGFiYXNlIGNvbHVtblxuICAgKiBAcGFyYW0ge3N0cmluZ3xEYXRhVHlwZXN9ICAgICAgICBhdHRyaWJ1dGVzLmNvbHVtbi50eXBlIEEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5hbGxvd051bGw9dHJ1ZV0gSWYgZmFsc2UsIHRoZSBjb2x1bW4gd2lsbCBoYXZlIGEgTk9UIE5VTEwgY29uc3RyYWludCwgYW5kIGEgbm90IG51bGwgdmFsaWRhdGlvbiB3aWxsIGJlIHJ1biBiZWZvcmUgYW4gaW5zdGFuY2UgaXMgc2F2ZWQuXG4gICAqIEBwYXJhbSB7YW55fSAgICAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5kZWZhdWx0VmFsdWU9bnVsbF0gQSBsaXRlcmFsIGRlZmF1bHQgdmFsdWUsIGEgSmF2YVNjcmlwdCBmdW5jdGlvbiwgb3IgYW4gU1FMIGZ1bmN0aW9uIChzZWUgYHNlcXVlbGl6ZS5mbmApXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59ICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi51bmlxdWU9ZmFsc2VdIElmIHRydWUsIHRoZSBjb2x1bW4gd2lsbCBnZXQgYSB1bmlxdWUgY29uc3RyYWludC4gSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBjb2x1bW4gd2lsbCBiZSBwYXJ0IG9mIGEgY29tcG9zaXRlIHVuaXF1ZSBpbmRleC4gSWYgbXVsdGlwbGUgY29sdW1ucyBoYXZlIHRoZSBzYW1lIHN0cmluZywgdGhleSB3aWxsIGJlIHBhcnQgb2YgdGhlIHNhbWUgdW5pcXVlIGluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5wcmltYXJ5S2V5PWZhbHNlXSBJZiB0cnVlLCB0aGlzIGF0dHJpYnV0ZSB3aWxsIGJlIG1hcmtlZCBhcyBwcmltYXJ5IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uZmllbGQ9bnVsbF0gSWYgc2V0LCBzZXF1ZWxpemUgd2lsbCBtYXAgdGhlIGF0dHJpYnV0ZSBuYW1lIHRvIGEgZGlmZmVyZW50IG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5hdXRvSW5jcmVtZW50PWZhbHNlXSBJZiB0cnVlLCB0aGlzIGNvbHVtbiB3aWxsIGJlIHNldCB0byBhdXRvIGluY3JlbWVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uYXV0b0luY3JlbWVudElkZW50aXR5PWZhbHNlXSBJZiB0cnVlLCBjb21iaW5lZCB3aXRoIGF1dG9JbmNyZW1lbnQ9dHJ1ZSwgd2lsbCB1c2UgUG9zdGdyZXMgYEdFTkVSQVRFRCBCWSBERUZBVUxUIEFTIElERU5USVRZYCBpbnN0ZWFkIG9mIGBTRVJJQUxgLiBQb3N0Z3JlcyAxMCsgb25seS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmNvbW1lbnQ9bnVsbF0gQ29tbWVudCBmb3IgdGhpcyBjb2x1bW5cbiAgICogQHBhcmFtIHtzdHJpbmd8TW9kZWx9ICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnJlZmVyZW5jZXM9bnVsbF0gQW4gb2JqZWN0IHdpdGggcmVmZXJlbmNlIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfE1vZGVsfSAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5yZWZlcmVuY2VzLm1vZGVsXSBJZiB0aGlzIGNvbHVtbiByZWZlcmVuY2VzIGFub3RoZXIgdGFibGUsIHByb3ZpZGUgaXQgaGVyZSBhcyBhIE1vZGVsLCBvciBhIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ucmVmZXJlbmNlcy5rZXk9J2lkJ10gVGhlIGNvbHVtbiBvZiB0aGUgZm9yZWlnbiB0YWJsZSB0aGF0IHRoaXMgY29sdW1uIHJlZmVyZW5jZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLm9uVXBkYXRlXSBXaGF0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgcmVmZXJlbmNlZCBrZXkgaXMgdXBkYXRlZC4gT25lIG9mIENBU0NBREUsIFJFU1RSSUNULCBTRVQgREVGQVVMVCwgU0VUIE5VTEwgb3IgTk8gQUNUSU9OXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5vbkRlbGV0ZV0gV2hhdCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIHJlZmVyZW5jZWQga2V5IGlzIGRlbGV0ZWQuIE9uZSBvZiBDQVNDQURFLCBSRVNUUklDVCwgU0VUIERFRkFVTFQsIFNFVCBOVUxMIG9yIE5PIEFDVElPTlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uZ2V0XSBQcm92aWRlIGEgY3VzdG9tIGdldHRlciBmb3IgdGhpcyBjb2x1bW4uIFVzZSBgdGhpcy5nZXREYXRhVmFsdWUoU3RyaW5nKWAgdG8gbWFuaXB1bGF0ZSB0aGUgdW5kZXJseWluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5zZXRdIFByb3ZpZGUgYSBjdXN0b20gc2V0dGVyIGZvciB0aGlzIGNvbHVtbi4gVXNlIGB0aGlzLnNldERhdGFWYWx1ZShTdHJpbmcsIFZhbHVlKWAgdG8gbWFuaXB1bGF0ZSB0aGUgdW5kZXJseWluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi52YWxpZGF0ZV0gQW4gb2JqZWN0IG9mIHZhbGlkYXRpb25zIHRvIGV4ZWN1dGUgZm9yIHRoaXMgY29sdW1uIGV2ZXJ5IHRpbWUgdGhlIG1vZGVsIGlzIHNhdmVkLiBDYW4gYmUgZWl0aGVyIHRoZSBuYW1lIG9mIGEgdmFsaWRhdGlvbiBwcm92aWRlZCBieSB2YWxpZGF0b3IuanMsIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBwcm92aWRlZCBieSBleHRlbmRpbmcgdmFsaWRhdG9yLmpzIChzZWUgdGhlIGBEQU9WYWxpZGF0b3JgIHByb3BlcnR5IGZvciBtb3JlIGRldGFpbHMpLCBvciBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBDdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQgYW5kIHRoZSBpbnN0YW5jZSBpdHNlbGYgYXMgdGhlIGB0aGlzYCBiaW5kaW5nLCBhbmQgY2FuIHBvc3NpYmx5IHRha2UgYSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQsIHRvIHNpZ25hbCB0aGF0IHRoZXkgYXJlIGFzeW5jaHJvbm91cy4gSWYgdGhlIHZhbGlkYXRvciBpcyBzeW5jLCBpdCBzaG91bGQgdGhyb3cgaW4gdGhlIGNhc2Ugb2YgYSBmYWlsZWQgdmFsaWRhdGlvbjsgaWYgaXQgaXMgYXN5bmMsIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGVycm9yIHRleHQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIG9wdGlvbnMgVGhlc2Ugb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIFNlcXVlbGl6ZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcXVlbGl6ZSBEZWZpbmUgdGhlIHNlcXVlbGl6ZSBpbnN0YW5jZSB0byBhdHRhY2ggdG8gdGhlIG5ldyBNb2RlbC4gVGhyb3cgZXJyb3IgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMubW9kZWxOYW1lXSBTZXQgbmFtZSBvZiB0aGUgbW9kZWwuIEJ5IGRlZmF1bHQgaXRzIHNhbWUgYXMgQ2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuZGVmYXVsdFNjb3BlPXt9XSBEZWZpbmUgdGhlIGRlZmF1bHQgc2VhcmNoIHNjb3BlIHRvIHVzZSBmb3IgdGhpcyBtb2RlbC4gU2NvcGVzIGhhdmUgdGhlIHNhbWUgZm9ybSBhcyB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gZmluZCAvIGZpbmRBbGxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuc2NvcGVzXSBNb3JlIHNjb3BlcywgZGVmaW5lZCBpbiB0aGUgc2FtZSB3YXkgYXMgZGVmYXVsdFNjb3BlIGFib3ZlLiBTZWUgYE1vZGVsLnNjb3BlYCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgc2NvcGVzIGFyZSBkZWZpbmVkLCBhbmQgd2hhdCB5b3UgY2FuIGRvIHdpdGggdGhlbVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5vbWl0TnVsbF0gRG9uJ3QgcGVyc2lzdCBudWxsIHZhbHVlcy4gVGhpcyBtZWFucyB0aGF0IGFsbCBjb2x1bW5zIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBub3QgYmUgc2F2ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMudGltZXN0YW1wcz10cnVlXSBBZGRzIGNyZWF0ZWRBdCBhbmQgdXBkYXRlZEF0IHRpbWVzdGFtcHMgdG8gdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5wYXJhbm9pZD1mYWxzZV0gQ2FsbGluZyBgZGVzdHJveWAgd2lsbCBub3QgZGVsZXRlIHRoZSBtb2RlbCwgYnV0IGluc3RlYWQgc2V0IGEgYGRlbGV0ZWRBdGAgdGltZXN0YW1wIGlmIHRoaXMgaXMgdHJ1ZS4gTmVlZHMgYHRpbWVzdGFtcHM9dHJ1ZWAgdG8gd29ya1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy51bmRlcnNjb3JlZD1mYWxzZV0gQWRkIHVuZGVyc2NvcmVkIGZpZWxkIHRvIGFsbCBhdHRyaWJ1dGVzLCB0aGlzIGNvdmVycyB1c2VyIGRlZmluZWQgYXR0cmlidXRlcywgdGltZXN0YW1wcyBhbmQgZm9yZWlnbiBrZXlzLiBXaWxsIG5vdCBhZmZlY3QgYXR0cmlidXRlcyB3aXRoIGV4cGxpY2l0bHkgc2V0IGBmaWVsZGAgb3B0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLmZyZWV6ZVRhYmxlTmFtZT1mYWxzZV0gSWYgZnJlZXplVGFibGVOYW1lIGlzIHRydWUsIHNlcXVlbGl6ZSB3aWxsIG5vdCB0cnkgdG8gYWx0ZXIgdGhlIG1vZGVsIG5hbWUgdG8gZ2V0IHRoZSB0YWJsZSBuYW1lLiBPdGhlcndpc2UsIHRoZSBtb2RlbCBuYW1lIHdpbGwgYmUgcGx1cmFsaXplZFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5uYW1lXSBBbiBvYmplY3Qgd2l0aCB0d28gYXR0cmlidXRlcywgYHNpbmd1bGFyYCBhbmQgYHBsdXJhbGAsIHdoaWNoIGFyZSB1c2VkIHdoZW4gdGhpcyBtb2RlbCBpcyBhc3NvY2lhdGVkIHRvIG90aGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMubmFtZS5zaW5ndWxhcj1VdGlscy5zaW5ndWxhcml6ZShtb2RlbE5hbWUpXSBTaW5ndWxhciBuYW1lIGZvciBtb2RlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5uYW1lLnBsdXJhbD1VdGlscy5wbHVyYWxpemUobW9kZWxOYW1lKV0gUGx1cmFsIG5hbWUgZm9yIG1vZGVsXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNdIGluZGV4ZXMgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSBpbmRleC4gRGVmYXVsdHMgdG8gbW9kZWwgbmFtZSArIF8gKyBmaWVsZHMgY29uY2F0ZW5hdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS50eXBlXSBJbmRleCB0eXBlLiBPbmx5IHVzZWQgYnkgbXlzcWwuIE9uZSBvZiBgVU5JUVVFYCwgYEZVTExURVhUYCBhbmQgYFNQQVRJQUxgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS51c2luZ10gVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIGluZGV4IGJ5IChgVVNJTkdgIHN0YXRlbWVudCBpbiBTUUwpLiBCVFJFRSBhbmQgSEFTSCBhcmUgc3VwcG9ydGVkIGJ5IG15c3FsIGFuZCBwb3N0Z3JlcywgYW5kIHBvc3RncmVzIGFkZGl0aW9uYWxseSBzdXBwb3J0cyBHSVNUIGFuZCBHSU4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS5vcGVyYXRvcl0gU3BlY2lmeSBpbmRleCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLnVuaXF1ZT1mYWxzZV0gU2hvdWxkIHRoZSBpbmRleCBieSB1bmlxdWU/IENhbiBhbHNvIGJlIHRyaWdnZXJlZCBieSBzZXR0aW5nIHR5cGUgdG8gYFVOSVFVRWBcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLmNvbmN1cnJlbnRseT1mYWxzZV0gUG9zdGdyZXNTUUwgd2lsbCBidWlsZCB0aGUgaW5kZXggd2l0aG91dCB0YWtpbmcgYW55IHdyaXRlIGxvY2tzLiBQb3N0Z3JlcyBvbmx5XG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfG9iamVjdD59ICAgIFtvcHRpb25zLmluZGV4ZXNbXS5maWVsZHNdIEFuIGFycmF5IG9mIHRoZSBmaWVsZHMgdG8gaW5kZXguIEVhY2ggZmllbGQgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCwgYSBzZXF1ZWxpemUgb2JqZWN0IChlLmcgYHNlcXVlbGl6ZS5mbmApLCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6IGBhdHRyaWJ1dGVgIChmaWVsZCBuYW1lKSwgYGxlbmd0aGAgKGNyZWF0ZSBhIHByZWZpeCBpbmRleCBvZiBsZW5ndGggY2hhcnMpLCBgb3JkZXJgICh0aGUgZGlyZWN0aW9uIHRoZSBjb2x1bW4gc2hvdWxkIGJlIHNvcnRlZCBpbiksIGBjb2xsYXRlYCAodGhlIGNvbGxhdGlvbiAoc29ydCBvcmRlcikgZm9yIHRoZSBjb2x1bW4pXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59ICAgICAgICAgIFtvcHRpb25zLmNyZWF0ZWRBdF0gT3ZlcnJpZGUgdGhlIG5hbWUgb2YgdGhlIGNyZWF0ZWRBdCBhdHRyaWJ1dGUgaWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIG9yIGRpc2FibGUgaXQgaWYgZmFsc2UuIFRpbWVzdGFtcHMgbXVzdCBiZSB0cnVlLiBVbmRlcnNjb3JlZCBmaWVsZCB3aWxsIGJlIHNldCB3aXRoIHVuZGVyc2NvcmVkIHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59ICAgICAgICAgIFtvcHRpb25zLnVwZGF0ZWRBdF0gT3ZlcnJpZGUgdGhlIG5hbWUgb2YgdGhlIHVwZGF0ZWRBdCBhdHRyaWJ1dGUgaWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIG9yIGRpc2FibGUgaXQgaWYgZmFsc2UuIFRpbWVzdGFtcHMgbXVzdCBiZSB0cnVlLiBVbmRlcnNjb3JlZCBmaWVsZCB3aWxsIGJlIHNldCB3aXRoIHVuZGVyc2NvcmVkIHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59ICAgICAgICAgIFtvcHRpb25zLmRlbGV0ZWRBdF0gT3ZlcnJpZGUgdGhlIG5hbWUgb2YgdGhlIGRlbGV0ZWRBdCBhdHRyaWJ1dGUgaWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIG9yIGRpc2FibGUgaXQgaWYgZmFsc2UuIFRpbWVzdGFtcHMgbXVzdCBiZSB0cnVlLiBVbmRlcnNjb3JlZCBmaWVsZCB3aWxsIGJlIHNldCB3aXRoIHVuZGVyc2NvcmVkIHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnRhYmxlTmFtZV0gRGVmYXVsdHMgdG8gcGx1cmFsaXplZCBtb2RlbCBuYW1lLCB1bmxlc3MgZnJlZXplVGFibGVOYW1lIGlzIHRydWUsIGluIHdoaWNoIGNhc2UgaXQgdXNlcyBtb2RlbCBuYW1lIHZlcmJhdGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnNjaGVtYT0ncHVibGljJ10gc2NoZW1hXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmVuZ2luZV0gU3BlY2lmeSBlbmdpbmUgZm9yIG1vZGVsJ3MgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuY2hhcnNldF0gU3BlY2lmeSBjaGFyc2V0IGZvciBtb2RlbCdzIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmNvbW1lbnRdIFNwZWNpZnkgY29tbWVudCBmb3IgbW9kZWwncyB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5jb2xsYXRlXSBTcGVjaWZ5IGNvbGxhdGlvbiBmb3IgbW9kZWwncyB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbml0aWFsQXV0b0luY3JlbWVudF0gU2V0IHRoZSBpbml0aWFsIEFVVE9fSU5DUkVNRU5UIHZhbHVlIGZvciB0aGUgdGFibGUgaW4gTXlTUUwuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmhvb2tzXSBBbiBvYmplY3Qgb2YgaG9vayBmdW5jdGlvbiB0aGF0IGFyZSBjYWxsZWQgYmVmb3JlIGFuZCBhZnRlciBjZXJ0YWluIGxpZmVjeWNsZSBldmVudHMuIFRoZSBwb3NzaWJsZSBob29rcyBhcmU6IGJlZm9yZVZhbGlkYXRlLCBhZnRlclZhbGlkYXRlLCB2YWxpZGF0aW9uRmFpbGVkLCBiZWZvcmVCdWxrQ3JlYXRlLCBiZWZvcmVCdWxrRGVzdHJveSwgYmVmb3JlQnVsa1VwZGF0ZSwgYmVmb3JlQ3JlYXRlLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVcGRhdGUsIGFmdGVyQ3JlYXRlLCBiZWZvcmVTYXZlLCBhZnRlckRlc3Ryb3ksIGFmdGVyVXBkYXRlLCBhZnRlckJ1bGtDcmVhdGUsIGFmdGVyU2F2ZSwgYWZ0ZXJCdWxrRGVzdHJveSBhbmQgYWZ0ZXJCdWxrVXBkYXRlLiBTZWUgSG9va3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG9vayBmdW5jdGlvbnMgYW5kIHRoZWlyIHNpZ25hdHVyZXMuIEVhY2ggcHJvcGVydHkgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheSBvZiBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnZhbGlkYXRlXSBBbiBvYmplY3Qgb2YgbW9kZWwgd2lkZSB2YWxpZGF0aW9ucy4gVmFsaWRhdGlvbnMgaGF2ZSBhY2Nlc3MgdG8gYWxsIG1vZGVsIHZhbHVlcyB2aWEgYHRoaXNgLiBJZiB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uIHRha2VzIGFuIGFyZ3VtZW50LCBpdCBpcyBhc3N1bWVkIHRvIGJlIGFzeW5jLCBhbmQgaXMgY2FsbGVkIHdpdGggYSBjYWxsYmFjayB0aGF0IGFjY2VwdHMgYW4gb3B0aW9uYWwgZXJyb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH1cbiAgICovXG4gIHN0YXRpYyBpbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5zZXF1ZWxpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2VxdWVsaXplIGluc3RhbmNlIHBhc3NlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2VxdWVsaXplID0gb3B0aW9ucy5zZXF1ZWxpemU7XG5cbiAgICBjb25zdCBnbG9iYWxPcHRpb25zID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucztcblxuICAgIG9wdGlvbnMgPSBVdGlscy5tZXJnZShfLmNsb25lRGVlcChnbG9iYWxPcHRpb25zLmRlZmluZSksIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFvcHRpb25zLm1vZGVsTmFtZSkge1xuICAgICAgb3B0aW9ucy5tb2RlbE5hbWUgPSB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFV0aWxzLm1lcmdlKHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgcGx1cmFsOiBVdGlscy5wbHVyYWxpemUob3B0aW9ucy5tb2RlbE5hbWUpLFxuICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUob3B0aW9ucy5tb2RlbE5hbWUpXG4gICAgICB9LFxuICAgICAgaW5kZXhlczogW10sXG4gICAgICBvbWl0TnVsbDogZ2xvYmFsT3B0aW9ucy5vbWl0TnVsbCxcbiAgICAgIHNjaGVtYTogZ2xvYmFsT3B0aW9ucy5zY2hlbWFcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdiZWZvcmVEZWZpbmUnLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLm1vZGVsTmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7IHZhbHVlOiBvcHRpb25zLm1vZGVsTmFtZSB9KTtcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMubW9kZWxOYW1lO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB7fSxcbiAgICAgIGZyZWV6ZVRhYmxlTmFtZTogZmFsc2UsXG4gICAgICB1bmRlcnNjb3JlZDogZmFsc2UsXG4gICAgICBwYXJhbm9pZDogZmFsc2UsXG4gICAgICByZWplY3RPbkVtcHR5OiBmYWxzZSxcbiAgICAgIHdoZXJlQ29sbGVjdGlvbjogbnVsbCxcbiAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgIHNjaGVtYURlbGltaXRlcjogJycsXG4gICAgICBkZWZhdWx0U2NvcGU6IHt9LFxuICAgICAgc2NvcGVzOiB7fSxcbiAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICAvLyBpZiB5b3UgY2FsbCBcImRlZmluZVwiIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZSBtb2RlbE5hbWUsIGRvIG5vdCBjbHV0dGVyIHRoZSBmYWN0b3J5XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmlzRGVmaW5lZCh0aGlzLm5hbWUpKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIucmVtb3ZlTW9kZWwodGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmdldE1vZGVsKHRoaXMubmFtZSkpO1xuICAgIH1cblxuICAgIHRoaXMuYXNzb2NpYXRpb25zID0ge307XG4gICAgdGhpcy5fc2V0dXBIb29rcyhvcHRpb25zLmhvb2tzKTtcblxuICAgIHRoaXMudW5kZXJzY29yZWQgPSB0aGlzLm9wdGlvbnMudW5kZXJzY29yZWQ7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy50YWJsZU5hbWUpIHtcbiAgICAgIHRoaXMudGFibGVOYW1lID0gdGhpcy5vcHRpb25zLmZyZWV6ZVRhYmxlTmFtZSA/IHRoaXMubmFtZSA6IFV0aWxzLnVuZGVyc2NvcmVkSWYoVXRpbHMucGx1cmFsaXplKHRoaXMubmFtZSksIHRoaXMudW5kZXJzY29yZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZSA9IHRoaXMub3B0aW9ucy50YWJsZU5hbWU7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZW1hID0gdGhpcy5vcHRpb25zLnNjaGVtYTtcbiAgICB0aGlzLl9zY2hlbWFEZWxpbWl0ZXIgPSB0aGlzLm9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyO1xuXG4gICAgLy8gZXJyb3IgY2hlY2sgb3B0aW9uc1xuICAgIF8uZWFjaChvcHRpb25zLnZhbGlkYXRlLCAodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIHZhbGlkYXRvclR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBtb2RlbCB2YWxpZGF0b3IgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSB0aGUgc2FtZSBuYW1lIGFzIGEgZmllbGQuIE1vZGVsOiAke3RoaXMubmFtZX0sIGZpZWxkL3ZhbGlkYXRpb24gbmFtZTogJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lbWJlcnMgb2YgdGhlIHZhbGlkYXRlIG9wdGlvbiBtdXN0IGJlIGZ1bmN0aW9ucy4gTW9kZWw6ICR7dGhpcy5uYW1lfSwgZXJyb3Igd2l0aCB2YWxpZGF0ZSBtZW1iZXIgJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yYXdBdHRyaWJ1dGVzID0gXy5tYXBWYWx1ZXMoYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwgbmFtZSkgPT4ge1xuICAgICAgYXR0cmlidXRlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGRhdGF0eXBlIGZvciBhdHRyaWJ1dGUgXCIke3RoaXMubmFtZX0uJHtuYW1lfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsICE9PSBmYWxzZSAmJiBfLmdldChhdHRyaWJ1dGUsICd2YWxpZGF0ZS5ub3ROdWxsJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlZmluaXRpb24gZm9yIFwiJHt0aGlzLm5hbWV9LiR7bmFtZX1cIiwgXCJub3ROdWxsXCIgdmFsaWRhdG9yIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFwiYWxsb3dOdWxsOmZhbHNlXCJgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uZ2V0KGF0dHJpYnV0ZSwgJ3JlZmVyZW5jZXMubW9kZWwucHJvdG90eXBlJykgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUoKTtcbiAgICB0aGlzLl9pbmRleGVzID0gdGhpcy5vcHRpb25zLmluZGV4ZXNcbiAgICAgIC5tYXAoaW5kZXggPT4gVXRpbHMubmFtZUluZGV4KHRoaXMuX2NvbmZvcm1JbmRleChpbmRleCksIHRhYmxlTmFtZSkpO1xuXG4gICAgdGhpcy5wcmltYXJ5S2V5cyA9IHt9O1xuICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzID0ge307XG5cbiAgICAvLyBzZXR1cCBuYW1lcyBvZiB0aW1lc3RhbXAgYXR0cmlidXRlc1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZXN0YW1wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydjcmVhdGVkQXQnLCAndXBkYXRlZEF0JywgJ2RlbGV0ZWRBdCddKSB7XG4gICAgICAgIGlmICghWyd1bmRlZmluZWQnLCAnc3RyaW5nJywgJ2Jvb2xlYW4nXS5pbmNsdWRlcyh0eXBlb2YgdGhpcy5vcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgXCIke2tleX1cIiBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGJvb2xlYW4sIGdvdCAke3R5cGVvZiB0aGlzLm9wdGlvbnNba2V5XX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2tleV0gPT09ICcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgXCIke2tleX1cIiBvcHRpb24gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCA9XG4gICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLmNyZWF0ZWRBdCA6ICdjcmVhdGVkQXQnO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCA9XG4gICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGVkQXQgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLnVwZGF0ZWRBdCA6ICd1cGRhdGVkQXQnO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYW5vaWQgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgPVxuICAgICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0ID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy5kZWxldGVkQXQgOiAnZGVsZXRlZEF0JztcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbmFtZSBmb3IgdmVyc2lvbiBhdHRyaWJ1dGVcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcnNpb24pIHtcbiAgICAgIHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnZlcnNpb24gPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLnZlcnNpb24gOiAndmVyc2lvbic7XG4gICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc1JlYWRPbmx5QXR0cmlidXRlcyA9IHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5zaXplID4gMDtcblxuICAgIC8vIEFkZCBoZWFkIGFuZCB0YWlsIGRlZmF1bHQgYXR0cmlidXRlcyAoaWQsIHRpbWVzdGFtcHMpXG4gICAgdGhpcy5fYWRkRGVmYXVsdEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5fZmluZEF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUoKTtcblxuICAgIHRoaXMuX3Njb3BlID0gdGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZTtcbiAgICB0aGlzLl9zY29wZU5hbWVzID0gWydkZWZhdWx0U2NvcGUnXTtcblxuICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5hZGRNb2RlbCh0aGlzKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYWZ0ZXJEZWZpbmUnLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIHJlZnJlc2hBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmlwdWxhdGlvbiA9IHt9O1xuXG4gICAgdGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMgPSB7fTtcbiAgICB0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycyA9IHt9O1xuXG4gICAgWydnZXQnLCAnc2V0J10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IG9wdCA9IGAke3R5cGV9dGVyTWV0aG9kc2A7XG4gICAgICBjb25zdCBmdW5jcyA9IHsgLi4udGhpcy5vcHRpb25zW29wdF0gfTtcbiAgICAgIGNvbnN0IF9jdXN0b20gPSB0eXBlID09PSAnZ2V0JyA/IHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzIDogdGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnM7XG5cbiAgICAgIF8uZWFjaChmdW5jcywgKG1ldGhvZCwgYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIF9jdXN0b21bYXR0cmlidXRlXSA9IG1ldGhvZDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2dldCcpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnc2V0Jykge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfLmVhY2godGhpcy5yYXdBdHRyaWJ1dGVzLCAob3B0aW9ucywgYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgdHlwZSkpIHtcbiAgICAgICAgICBfY3VzdG9tW2F0dHJpYnV0ZV0gPSBvcHRpb25zW3R5cGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdnZXQnKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgXy5lYWNoKGZ1bmNzLCAoZmN0LCBuYW1lKSA9PiB7XG4gICAgICAgIGlmICghYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdKSB7XG4gICAgICAgICAgYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV1bdHlwZV0gPSBmY3Q7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2RhdGFUeXBlQ2hhbmdlcyA9IHt9O1xuICAgIHRoaXMuX2RhdGFUeXBlU2FuaXRpemVycyA9IHt9O1xuXG4gICAgdGhpcy5faGFzQm9vbGVhbkF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXNEYXRlQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuX2pzb25BdHRyaWJ1dGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLnByb3RvdHlwZS52YWxpZGF0b3JzID0ge307XG5cbiAgICB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcCA9IHt9O1xuXG4gICAgdGhpcy5wcmltYXJ5S2V5cyA9IHt9O1xuICAgIHRoaXMudW5pcXVlS2V5cyA9IHt9O1xuXG4gICAgXy5lYWNoKHRoaXMucmF3QXR0cmlidXRlcywgKGRlZmluaXRpb24sIG5hbWUpID0+IHtcbiAgICAgIGRlZmluaXRpb24udHlwZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZURhdGFUeXBlKGRlZmluaXRpb24udHlwZSk7XG5cbiAgICAgIGRlZmluaXRpb24uTW9kZWwgPSB0aGlzO1xuICAgICAgZGVmaW5pdGlvbi5maWVsZE5hbWUgPSBuYW1lO1xuICAgICAgZGVmaW5pdGlvbi5fbW9kZWxBdHRyaWJ1dGUgPSB0cnVlO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5maWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb24uZmllbGQgPSBVdGlscy51bmRlcnNjb3JlZElmKG5hbWUsIHRoaXMudW5kZXJzY29yZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5wcmltYXJ5S2V5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeUtleXNbbmFtZV0gPSBkZWZpbml0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcFtkZWZpbml0aW9uLmZpZWxkXSA9IGRlZmluaXRpb247XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUuX3Nhbml0aXplKSB7XG4gICAgICAgIHRoaXMuX2RhdGFUeXBlU2FuaXRpemVyc1tuYW1lXSA9IGRlZmluaXRpb24udHlwZS5fc2FuaXRpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUuX2lzQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9kYXRhVHlwZUNoYW5nZXNbbmFtZV0gPSBkZWZpbml0aW9uLnR5cGUuX2lzQ2hhbmdlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CT09MRUFOKSB7XG4gICAgICAgIHRoaXMuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEUgfHwgZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEVPTkxZKSB7XG4gICAgICAgIHRoaXMuX2hhc0RhdGVBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgdGhpcy5fanNvbkF0dHJpYnV0ZXMuYWRkKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVklSVFVBTCkge1xuICAgICAgICB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZXNbbmFtZV0gPSAoKSA9PiBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZpbml0aW9uLmRlZmF1bHRWYWx1ZSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCAndW5pcXVlJykgJiYgZGVmaW5pdGlvbi51bmlxdWUpIHtcbiAgICAgICAgbGV0IGlkeE5hbWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgZGVmaW5pdGlvbi51bmlxdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24udW5pcXVlLCAnbmFtZScpXG4gICAgICAgICkge1xuICAgICAgICAgIGlkeE5hbWUgPSBkZWZpbml0aW9uLnVuaXF1ZS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uLnVuaXF1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZHhOYW1lID0gZGVmaW5pdGlvbi51bmlxdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGAke3RoaXMudGFibGVOYW1lfV8ke25hbWV9X3VuaXF1ZWA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnVuaXF1ZUtleXNbaWR4TmFtZV0gfHwgeyBmaWVsZHM6IFtdIH07XG5cbiAgICAgICAgaWR4LmZpZWxkcy5wdXNoKGRlZmluaXRpb24uZmllbGQpO1xuICAgICAgICBpZHgubXNnID0gaWR4Lm1zZyB8fCBkZWZpbml0aW9uLnVuaXF1ZS5tc2cgfHwgbnVsbDtcbiAgICAgICAgaWR4Lm5hbWUgPSBpZHhOYW1lIHx8IGZhbHNlO1xuICAgICAgICBpZHguY29sdW1uID0gbmFtZTtcbiAgICAgICAgaWR4LmN1c3RvbUluZGV4ID0gZGVmaW5pdGlvbi51bmlxdWUgIT09IHRydWU7XG5cbiAgICAgICAgdGhpcy51bmlxdWVLZXlzW2lkeE5hbWVdID0gaWR4O1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sICd2YWxpZGF0ZScpKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnZhbGlkYXRvcnNbbmFtZV0gPSBkZWZpbml0aW9uLnZhbGlkYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmRleCA9PT0gdHJ1ZSAmJiBkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTkIpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5wdXNoKFxuICAgICAgICAgIFV0aWxzLm5hbWVJbmRleChcbiAgICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmRleCh7XG4gICAgICAgICAgICAgIGZpZWxkczogW2RlZmluaXRpb24uZmllbGQgfHwgbmFtZV0sXG4gICAgICAgICAgICAgIHVzaW5nOiAnZ2luJ1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLmdldFRhYmxlTmFtZSgpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLmluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGZpZWxkIHRvIGF0dHJpYnV0ZSBuYW1lc1xuICAgIHRoaXMuZmllbGRBdHRyaWJ1dGVNYXAgPSBfLnJlZHVjZSh0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcCwgKG1hcCwgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSAhPT0gdmFsdWUuZmllbGROYW1lKSB7XG4gICAgICAgIG1hcFtrZXldID0gdmFsdWUuZmllbGROYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSk7XG5cbiAgICB0aGlzLl9oYXNKc29uQXR0cmlidXRlcyA9ICEhdGhpcy5fanNvbkF0dHJpYnV0ZXMuc2l6ZTtcblxuICAgIHRoaXMuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzID0gISF0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5zaXplO1xuXG4gICAgdGhpcy5faGFzRGVmYXVsdFZhbHVlcyA9ICFfLmlzRW1wdHkodGhpcy5fZGVmYXVsdFZhbHVlcyk7XG5cbiAgICB0aGlzLnRhYmxlQXR0cmlidXRlcyA9IF8ub21pdEJ5KHRoaXMucmF3QXR0cmlidXRlcywgKF9hLCBrZXkpID0+IHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhrZXkpKTtcblxuICAgIHRoaXMucHJvdG90eXBlLl9oYXNDdXN0b21HZXR0ZXJzID0gT2JqZWN0LmtleXModGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMpLmxlbmd0aDtcbiAgICB0aGlzLnByb3RvdHlwZS5faGFzQ3VzdG9tU2V0dGVycyA9IE9iamVjdC5rZXlzKHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzKS5sZW5ndGg7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVNYW5pcHVsYXRpb24pKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1vZGVsLnByb3RvdHlwZSwga2V5KSkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYE5vdCBvdmVycmlkaW5nIGJ1aWx0LWluIG1ldGhvZCBmcm9tIG1vZGVsIGF0dHJpYnV0ZTogJHtrZXl9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBrZXksIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltrZXldKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3RvdHlwZS5yYXdBdHRyaWJ1dGVzID0gdGhpcy5yYXdBdHRyaWJ1dGVzO1xuICAgIHRoaXMucHJvdG90eXBlLl9pc0F0dHJpYnV0ZSA9IGtleSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm90b3R5cGUucmF3QXR0cmlidXRlcywga2V5KTtcblxuICAgIC8vIFByaW1hcnkga2V5IGNvbnZlbmllbmNlIGNvbnN0aWFibGVzXG4gICAgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucHJpbWFyeUtleXMpO1xuICAgIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSA9IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXNbMF07XG4gICAgaWYgKHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSkge1xuICAgICAgdGhpcy5wcmltYXJ5S2V5RmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCB8fCB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgfVxuXG4gICAgdGhpcy5faGFzUHJpbWFyeUtleXMgPSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5faXNQcmltYXJ5S2V5ID0ga2V5ID0+IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYXR0cmlidXRlIGZyb20gbW9kZWwgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIG5hbWUgb2YgYXR0cmlidXRlIHRvIHJlbW92ZVxuICAgKi9cbiAgc3RhdGljIHJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBkZWxldGUgdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmMgdGhpcyBNb2RlbCB0byB0aGUgREIsIHRoYXQgaXMgY3JlYXRlIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBzeW5jIG9wdGlvbnNcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplI3N5bmN9IGZvciBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzeW5jKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0aW9ucy5ob29rcztcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnRhYmxlQXR0cmlidXRlcztcbiAgICBjb25zdCByYXdBdHRyaWJ1dGVzID0gdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXA7XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlU3luYycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgYXdhaXQgdGhpcy5kcm9wKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpO1xuXG4gICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5jcmVhdGVUYWJsZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuYWx0ZXIpIHtcbiAgICAgIGNvbnN0IHRhYmxlSW5mb3MgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucXVlcnlJbnRlcmZhY2UuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpLFxuICAgICAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKVxuICAgICAgXSk7XG4gICAgICBjb25zdCBjb2x1bW5zID0gdGFibGVJbmZvc1swXTtcbiAgICAgIC8vIFVzZSBmb3IgYWx0ZXIgZm9yZWlnbiBrZXlzXG4gICAgICBjb25zdCBmb3JlaWduS2V5UmVmZXJlbmNlcyA9IHRhYmxlSW5mb3NbMV07XG4gICAgICBjb25zdCByZW1vdmVkQ29uc3RyYWludHMgPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBjb2x1bW5OYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgY29sdW1uTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWNvbHVtbnNbY29sdW1uTmFtZV0gJiYgIWNvbHVtbnNbYXR0cmlidXRlc1tjb2x1bW5OYW1lXS5maWVsZF0pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmFkZENvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZXNbY29sdW1uTmFtZV0uZmllbGQgfHwgY29sdW1uTmFtZSwgYXR0cmlidXRlc1tjb2x1bW5OYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWx0ZXIgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMuYWx0ZXIgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuYWx0ZXIuZHJvcCAhPT0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2x1bW5OYW1lIGluIGNvbHVtbnMpIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb2x1bW5zLCBjb2x1bW5OYW1lKSkgY29udGludWU7XG4gICAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZSA9IHJhd0F0dHJpYnV0ZXNbY29sdW1uTmFtZV07XG4gICAgICAgICAgaWYgKCFjdXJyZW50QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlLnByaW1hcnlLZXkpIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIENoZWNrIGZvcmVpZ24ga2V5cy4gSWYgaXQncyBhIGZvcmVpZ24ga2V5LCBpdCBzaG91bGQgcmVtb3ZlIGNvbnN0cmFpbnQgZmlyc3QuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IGN1cnJlbnRBdHRyaWJ1dGUucmVmZXJlbmNlcztcbiAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5zY2hlbWE7XG4gICAgICAgICAgICAvLyBGaW5kIGV4aXN0ZWQgZm9yZWlnbiBrZXlzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXlSZWZlcmVuY2Ugb2YgZm9yZWlnbktleVJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludE5hbWUgPSBmb3JlaWduS2V5UmVmZXJlbmNlLmNvbnN0cmFpbnROYW1lO1xuICAgICAgICAgICAgICBpZiAoISFjb25zdHJhaW50TmFtZVxuICAgICAgICAgICAgICAgICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UudGFibGVDYXRhbG9nID09PSBkYXRhYmFzZVxuICAgICAgICAgICAgICAgICYmIChzY2hlbWEgPyBmb3JlaWduS2V5UmVmZXJlbmNlLnRhYmxlU2NoZW1hID09PSBzY2hlbWEgOiB0cnVlKVxuICAgICAgICAgICAgICAgICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZFRhYmxlTmFtZSA9PT0gcmVmZXJlbmNlcy5tb2RlbFxuICAgICAgICAgICAgICAgICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZENvbHVtbk5hbWUgPT09IHJlZmVyZW5jZXMua2V5XG4gICAgICAgICAgICAgICAgJiYgKHNjaGVtYSA/IGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZFRhYmxlU2NoZW1hID09PSBzY2hlbWEgOiB0cnVlKVxuICAgICAgICAgICAgICAgICYmICFyZW1vdmVkQ29uc3RyYWludHNbY29uc3RyYWludE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbnN0cmFpbnQgb24gZm9yZWlnbiBrZXlzLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZW1vdmVkQ29uc3RyYWludHNbY29uc3RyYWludE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIGN1cnJlbnRBdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpbmRleGVzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5zaG93SW5kZXgodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBpbmRleGVzID0gdGhpcy5faW5kZXhlcy5maWx0ZXIoaXRlbTEgPT5cbiAgICAgICFpbmRleGVzLnNvbWUoaXRlbTIgPT4gaXRlbTEubmFtZSA9PT0gaXRlbTIubmFtZSlcbiAgICApLnNvcnQoKGluZGV4MSwgaW5kZXgyKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSAncG9zdGdyZXMnKSB7XG4gICAgICAvLyBtb3ZlIGNvbmN1cnJlbnQgaW5kZXhlcyB0byB0aGUgYm90dG9tIHRvIGF2b2lkIHdlaXJkIGRlYWRsb2Nrc1xuICAgICAgICBpZiAoaW5kZXgxLmNvbmN1cnJlbnRseSA9PT0gdHJ1ZSkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChpbmRleDIuY29uY3VycmVudGx5ID09PSB0cnVlKSByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmFkZEluZGV4KHRhYmxlTmFtZSwgeyAuLi5vcHRpb25zLCAuLi5pbmRleCB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJTeW5jJywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCB0aGUgdGFibGUgcmVwcmVzZW50ZWQgYnkgdGhpcyBNb2RlbFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9uc10gZHJvcCBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLmNhc2NhZGU9ZmFsc2VdICAgQWxzbyBkcm9wIGFsbCBvYmplY3RzIGRlcGVuZGluZyBvbiB0aGlzIHRhYmxlLCBzdWNoIGFzIHZpZXdzLiBPbmx5IHdvcmtzIGluIHBvc3RncmVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRyb3Aob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRyb3BUYWJsZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kcm9wU2NoZW1hKHNjaGVtYSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSBzY2hlbWEgdG8gdGhpcyBtb2RlbC4gRm9yIHBvc3RncmVzLCB0aGlzIHdpbGwgYWN0dWFsbHkgcGxhY2UgdGhlIHNjaGVtYSBpbiBmcm9udCBvZiB0aGUgdGFibGUgbmFtZSAtIGBcInNjaGVtYVwiLlwidGFibGVOYW1lXCJgLFxuICAgKiB3aGlsZSB0aGUgc2NoZW1hIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSB0YWJsZSBuYW1lIGZvciBteXNxbCBhbmQgc3FsaXRlIC0gYCdzY2hlbWEudGFibGVuYW1lJ2AuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciB1c2UgY2FzZXMgd2hlcmUgdGhlIHNhbWUgbW9kZWwgaXMgbmVlZGVkIGluIG11bHRpcGxlIHNjaGVtYXMuIEluIHN1Y2ggYSB1c2UgY2FzZSBpdCBpcyBpbXBvcnRhbnRcbiAgICogdG8gY2FsbCBgbW9kZWwuc2NoZW1hKHNjaGVtYSwgW29wdGlvbnNdKS5zeW5jKClgIGZvciBlYWNoIG1vZGVsIHRvIGVuc3VyZSB0aGUgbW9kZWxzIGFyZSBjcmVhdGVkIGluIHRoZSBjb3JyZWN0IHNjaGVtYS5cbiAgICpcbiAgICogSWYgYSBzaW5nbGUgZGVmYXVsdCBzY2hlbWEgcGVyIG1vZGVsIGlzIG5lZWRlZCwgc2V0IHRoZSBgb3B0aW9ucy5zY2hlbWE9J3NjaGVtYSdgIHBhcmFtZXRlciBkdXJpbmcgdGhlIGBkZWZpbmUoKWAgY2FsbFxuICAgKiBmb3IgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBzY2hlbWEgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYVxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9uc10gc2NoZW1hIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuc2NoZW1hRGVsaW1pdGVyPScuJ10gVGhlIGNoYXJhY3RlcihzKSB0aGF0IHNlcGFyYXRlcyB0aGUgc2NoZW1hIG5hbWUgZnJvbSB0aGUgdGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplI2RlZmluZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc2V0dGluZyBhIGRlZmF1bHQgc2NoZW1hLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9XG4gICAqL1xuICBzdGF0aWMgc2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgY2xvbmUgPSBjbGFzcyBleHRlbmRzIHRoaXMge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbmFtZScsIHsgdmFsdWU6IHRoaXMubmFtZSB9KTtcblxuICAgIGNsb25lLl9zY2hlbWEgPSBzY2hlbWE7XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBjbG9uZS5fc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICAgICAgY2xvbmUuX3NjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhYmxlIG5hbWUgb2YgdGhlIG1vZGVsLCB0YWtpbmcgc2NoZW1hIGludG8gYWNjb3VudC4gVGhlIG1ldGhvZCB3aWxsIHJldHVybiBUaGUgbmFtZSBhcyBhIHN0cmluZyBpZiB0aGUgbW9kZWwgaGFzIG5vIHNjaGVtYSxcbiAgICogb3IgYW4gb2JqZWN0IHdpdGggYHRhYmxlTmFtZWAsIGBzY2hlbWFgIGFuZCBgZGVsaW1pdGVyYCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG9iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXRUYWJsZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkU2NoZW1hKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1bi1zY29wZWQgbW9kZWxcbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfVxuICAgKi9cbiAgc3RhdGljIHVuc2NvcGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHNjb3BlIHRvIHRoZSBtb2RlbC4gVGhpcyBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYWRkaW5nIHNjb3BlcyB3aXRoIGluY2x1ZGVzLCB3aGVuIHRoZSBtb2RlbCB5b3Ugd2FudCB0byBpbmNsdWRlIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhlIHRpbWUgdGhpcyBtb2RlbCBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhIHNjb3BlIHdpdGggdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RzLiBQYXNzIGBvdmVycmlkZTogdHJ1ZWAgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIHNpbGVuY2UgdGhpcyBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjb3BlLiBVc2UgYGRlZmF1bHRTY29wZWAgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2NvcGVcbiAgICogQHBhcmFtIHtvYmplY3R8RnVuY3Rpb259IHNjb3BlIHNjb3BlIG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zXSBzY29wZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5vdmVycmlkZT1mYWxzZV0gb3ZlcnJpZGUgb2xkIHNjb3BlIGlmIGFscmVhZHkgZGVmaW5lZFxuICAgKi9cbiAgc3RhdGljIGFkZFNjb3BlKG5hbWUsIHNjb3BlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgb3ZlcnJpZGU6IGZhbHNlLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoKG5hbWUgPT09ICdkZWZhdWx0U2NvcGUnICYmIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUpLmxlbmd0aCA+IDAgfHwgbmFtZSBpbiB0aGlzLm9wdGlvbnMuc2NvcGVzKSAmJiBvcHRpb25zLm92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2NvcGUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0cy4gUGFzcyB7IG92ZXJyaWRlOiB0cnVlIH0gYXMgb3B0aW9ucyB0byBzaWxlbmNlIHRoaXMgZXJyb3JgKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2RlZmF1bHRTY29wZScpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGUgPSB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2NvcGVzW25hbWVdID0gc2NvcGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgc2NvcGUgY3JlYXRlZCBpbiBgZGVmaW5lYCB0byB0aGUgbW9kZWwuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmhvdyB0byBjcmVhdGUgc2NvcGVzPC9jYXB0aW9uPlxuICAgKiBjb25zdCBNb2RlbCA9IHNlcXVlbGl6ZS5kZWZpbmUoJ21vZGVsJywgYXR0cmlidXRlcywge1xuICAgKiAgIGRlZmF1bHRTY29wZToge1xuICAgKiAgICAgd2hlcmU6IHtcbiAgICogICAgICAgdXNlcm5hbWU6ICdkYW4nXG4gICAqICAgICB9LFxuICAgKiAgICAgbGltaXQ6IDEyXG4gICAqICAgfSxcbiAgICogICBzY29wZXM6IHtcbiAgICogICAgIGlzQUxpZToge1xuICAgKiAgICAgICB3aGVyZToge1xuICAgKiAgICAgICAgIHN0dWZmOiAnY2FrZSdcbiAgICogICAgICAgfVxuICAgKiAgICAgfSxcbiAgICogICAgIGNvbXBsZXhGdW5jdGlvbjogZnVuY3Rpb24oZW1haWwsIGFjY2Vzc0xldmVsKSB7XG4gICAqICAgICAgIHJldHVybiB7XG4gICAqICAgICAgICAgd2hlcmU6IHtcbiAgICogICAgICAgICAgIGVtYWlsOiB7XG4gICAqICAgICAgICAgICAgIFtPcC5saWtlXTogZW1haWxcbiAgICogICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICBhY2Nlc3NfbGV2ZWwge1xuICAgKiAgICAgICAgICAgICBbT3AuZ3RlXTogYWNjZXNzTGV2ZWxcbiAgICogICAgICAgICAgIH1cbiAgICogICAgICAgICB9XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqICMgQXMgeW91IGhhdmUgZGVmaW5lZCBhIGRlZmF1bHQgc2NvcGUsIGV2ZXJ5IHRpbWUgeW91IGRvIE1vZGVsLmZpbmQsIHRoZSBkZWZhdWx0IHNjb3BlIGlzIGFwcGVuZGVkIHRvIHlvdXIgcXVlcnkuIEhlcmUncyBhIGNvdXBsZSBvZiBleGFtcGxlczpcbiAgICpcbiAgICogTW9kZWwuZmluZEFsbCgpIC8vIFdIRVJFIHVzZXJuYW1lID0gJ2RhbidcbiAgICogTW9kZWwuZmluZEFsbCh7IHdoZXJlOiB7IGFnZTogeyBbT3AuZ3RdOiAxMiB9IH0gfSkgLy8gV0hFUkUgYWdlID4gMTIgQU5EIHVzZXJuYW1lID0gJ2RhbidcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VG8gaW52b2tlIHNjb3BlIGZ1bmN0aW9ucyB5b3UgY2FuIGRvPC9jYXB0aW9uPlxuICAgKiBNb2RlbC5zY29wZSh7IG1ldGhvZDogWydjb21wbGV4RnVuY3Rpb24nLCAnZGFuQHNlcXVlbGl6ZS5jb20nLCA0Ml19KS5maW5kQWxsKClcbiAgICogLy8gV0hFUkUgZW1haWwgbGlrZSAnZGFuQHNlcXVlbGl6ZS5jb20lJyBBTkQgYWNjZXNzX2xldmVsID49IDQyXG4gICAqXG4gICAqIEBwYXJhbSB7P0FycmF5fG9iamVjdHxzdHJpbmd9IFtvcHRpb25dIFRoZSBzY29wZShzKSB0byBhcHBseS4gU2NvcGVzIGNhbiBlaXRoZXIgYmUgcGFzc2VkIGFzIGNvbnNlY3V0aXZlIGFyZ3VtZW50cywgb3IgYXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzLiBUbyBhcHBseSBzaW1wbGUgc2NvcGVzIGFuZCBzY29wZSBmdW5jdGlvbnMgd2l0aCBubyBhcmd1bWVudHMsIHBhc3MgdGhlbSBhcyBzdHJpbmdzLiBGb3Igc2NvcGUgZnVuY3Rpb24sIHBhc3MgYW4gb2JqZWN0LCB3aXRoIGEgYG1ldGhvZGAgcHJvcGVydHkuIFRoZSB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nLCBpZiB0aGUgbWV0aG9kIGRvZXMgbm90IHRha2UgYW55IGFyZ3VtZW50cywgb3IgYW4gYXJyYXksIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QsIGFuZCBjb25zZWN1dGl2ZSBlbGVtZW50cyBhcmUgYXJndW1lbnRzIHRvIHRoYXQgbWV0aG9kLiBQYXNzIG51bGwgdG8gcmVtb3ZlIGFsbCBzY29wZXMsIGluY2x1ZGluZyB0aGUgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfSBBIHJlZmVyZW5jZSB0byB0aGUgbW9kZWwsIHdpdGggdGhlIHNjb3BlKHMpIGFwcGxpZWQuIENhbGxpbmcgc2NvcGUgYWdhaW4gb24gdGhlIHJldHVybmVkIG1vZGVsIHdpbGwgY2xlYXIgdGhlIHByZXZpb3VzIHNjb3BlLlxuICAgKi9cbiAgc3RhdGljIHNjb3BlKG9wdGlvbikge1xuICAgIGNvbnN0IHNlbGYgPSBjbGFzcyBleHRlbmRzIHRoaXMge307XG4gICAgbGV0IHNjb3BlO1xuICAgIGxldCBzY29wZU5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ25hbWUnLCB7IHZhbHVlOiB0aGlzLm5hbWUgfSk7XG5cbiAgICBzZWxmLl9zY29wZSA9IHt9O1xuICAgIHNlbGYuX3Njb3BlTmFtZXMgPSBbXTtcbiAgICBzZWxmLnNjb3BlZCA9IHRydWU7XG5cbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uZmxhdHRlbihhcmd1bWVudHMpO1xuXG4gICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgc2NvcGUgPSBudWxsO1xuICAgICAgc2NvcGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG4gICAgICAgIGlmIChvcHRpb24ubWV0aG9kKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uLm1ldGhvZCkgJiYgISFzZWxmLm9wdGlvbnMuc2NvcGVzW29wdGlvbi5tZXRob2RbMF1dKSB7XG4gICAgICAgICAgICBzY29wZU5hbWUgPSBvcHRpb24ubWV0aG9kWzBdO1xuICAgICAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV0uYXBwbHkoc2VsZiwgb3B0aW9uLm1ldGhvZC5zbGljZSgxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNlbGYub3B0aW9ucy5zY29wZXNbb3B0aW9uLm1ldGhvZF0pIHtcbiAgICAgICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbi5tZXRob2Q7XG4gICAgICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXS5hcHBseShzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcGUgPSBvcHRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uID09PSAnZGVmYXVsdFNjb3BlJyAmJiBfLmlzUGxhaW5PYmplY3Qoc2VsZi5vcHRpb25zLmRlZmF1bHRTY29wZSkpIHtcbiAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuZGVmYXVsdFNjb3BlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uO1xuICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNjb3BlID0gc2NvcGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKHNjb3BlLCB0aGlzKTtcbiAgICAgICAgLy8gY2xvbmUgc2NvcGUgc28gaXQgZG9lc24ndCBnZXQgbW9kaWZpZWRcbiAgICAgICAgdGhpcy5fYXNzaWduT3B0aW9ucyhzZWxmLl9zY29wZSwgVXRpbHMuY2xvbmVEZWVwKHNjb3BlKSk7XG4gICAgICAgIHNlbGYuX3Njb3BlTmFtZXMucHVzaChzY29wZU5hbWUgPyBzY29wZU5hbWUgOiAnZGVmYXVsdFNjb3BlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlNlcXVlbGl6ZVNjb3BlRXJyb3IoYEludmFsaWQgc2NvcGUgJHtzY29wZU5hbWV9IGNhbGxlZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIG11bHRpcGxlIGluc3RhbmNlcy5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2ltcGxlIHNlYXJjaCB1c2luZyBBTkQgYW5kID08L2NhcHRpb24+XG4gICAqIE1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiB7XG4gICAqICAgICBhdHRyMTogNDIsXG4gICAqICAgICBhdHRyMjogJ2Nha2UnXG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiAjIFdIRVJFIGF0dHIxID0gNDIgQU5EIGF0dHIyID0gJ2Nha2UnXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzaW5nIGdyZWF0ZXIgdGhhbiwgbGVzcyB0aGFuIGV0Yy48L2NhcHRpb24+XG4gICAqIGNvbnN0IHtndCwgbHRlLCBuZSwgaW46IG9wSW59ID0gU2VxdWVsaXplLk9wO1xuICAgKlxuICAgKiBNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZToge1xuICAgKiAgICAgYXR0cjE6IHtcbiAgICogICAgICAgW2d0XTogNTBcbiAgICogICAgIH0sXG4gICAqICAgICBhdHRyMjoge1xuICAgKiAgICAgICBbbHRlXTogNDVcbiAgICogICAgIH0sXG4gICAqICAgICBhdHRyMzoge1xuICAgKiAgICAgICBbb3BJbl06IFsxLDIsM11cbiAgICogICAgIH0sXG4gICAqICAgICBhdHRyNDoge1xuICAgKiAgICAgICBbbmVdOiA1XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiAjIFdIRVJFIGF0dHIxID4gNTAgQU5EIGF0dHIyIDw9IDQ1IEFORCBhdHRyMyBJTiAoMSwyLDMpIEFORCBhdHRyNCAhPSA1XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlF1ZXJpZXMgdXNpbmcgT1I8L2NhcHRpb24+XG4gICAqIGNvbnN0IHtvciwgYW5kLCBndCwgbHR9ID0gU2VxdWVsaXplLk9wO1xuICAgKlxuICAgKiBNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZToge1xuICAgKiAgICAgbmFtZTogJ2EgcHJvamVjdCcsXG4gICAqICAgICBbb3JdOiBbXG4gICAqICAgICAgIHtpZDogWzEsIDIsIDNdfSxcbiAgICogICAgICAge1xuICAgKiAgICAgICAgIFthbmRdOiBbXG4gICAqICAgICAgICAgICB7aWQ6IHtbZ3RdOiAxMH19LFxuICAgKiAgICAgICAgICAge2lkOiB7W2x0XTogMTAwfX1cbiAgICogICAgICAgICBdXG4gICAqICAgICAgIH1cbiAgICogICAgIF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAjIFdIRVJFIGBNb2RlbGAuYG5hbWVgID0gJ2EgcHJvamVjdCcgQU5EIChgTW9kZWxgLmBpZGAgSU4gKDEsIDIsIDMpIE9SIChgTW9kZWxgLmBpZGAgPiAxMCBBTkQgYE1vZGVsYC5gaWRgIDwgMTAwKSk7XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE9wZXJhdG9yc30gZm9yIHBvc3NpYmxlIG9wZXJhdG9yc1xuICAgKiBfX0FsaWFzX186IF9hbGxfXG4gICAqXG4gICAqIFRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2YgTW9kZWwgaW5zdGFuY2VzIGlmIHRoZSBxdWVyeSBzdWNjZWVkcy5fXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnNdIEEgaGFzaCBvZiBvcHRpb25zIHRvIGRlc2NyaWJlIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMud2hlcmVdIEEgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGRlc2NyaWJlIHlvdXIgc2VhcmNoLiBTZWUgYWJvdmUgZm9yIGV4YW1wbGVzLlxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fG9iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmF0dHJpYnV0ZXNdIEEgbGlzdCBvZiB0aGUgYXR0cmlidXRlcyB0aGF0IHlvdSB3YW50IHRvIHNlbGVjdCwgb3IgYW4gb2JqZWN0IHdpdGggYGluY2x1ZGVgIGFuZCBgZXhjbHVkZWAga2V5cy4gVG8gcmVuYW1lIGFuIGF0dHJpYnV0ZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5LCB3aXRoIHR3byBlbGVtZW50cyAtIHRoZSBmaXJzdCBpcyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIHRoZSBEQiAob3Igc29tZSBraW5kIG9mIGV4cHJlc3Npb24gc3VjaCBhcyBgU2VxdWVsaXplLmxpdGVyYWxgLCBgU2VxdWVsaXplLmZuYCBhbmQgc28gb24pLCBhbmQgdGhlIHNlY29uZCBpcyB0aGUgbmFtZSB5b3Ugd2FudCB0aGUgYXR0cmlidXRlIHRvIGhhdmUgaW4gdGhlIHJldHVybmVkIGluc3RhbmNlXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlXSBTZWxlY3QgYWxsIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCwgcGx1cyBzb21lIGFkZGl0aW9uYWwgb25lcy4gVXNlZnVsIGZvciBhZ2dyZWdhdGlvbnMsIGUuZy4gYHsgYXR0cmlidXRlczogeyBpbmNsdWRlOiBbW3NlcXVlbGl6ZS5mbignQ09VTlQnLCBzZXF1ZWxpemUuY29sKCdpZCcpKSwgJ3RvdGFsJ11dIH1gXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuYXR0cmlidXRlcy5leGNsdWRlXSBTZWxlY3QgYWxsIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCwgZXhjZXB0IHNvbWUgZmV3LiBVc2VmdWwgZm9yIHNlY3VyaXR5IHB1cnBvc2VzIGUuZy4gYHsgYXR0cmlidXRlczogeyBleGNsdWRlOiBbJ3Bhc3N3b3JkJ10gfSB9YFxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnBhcmFub2lkPXRydWVdIElmIHRydWUsIG9ubHkgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHJldHVybmVkLiBJZiBmYWxzZSwgYm90aCBkZWxldGVkIGFuZCBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgcmV0dXJuZWQuIE9ubHkgYXBwbGllcyBpZiBgb3B0aW9ucy5wYXJhbm9pZGAgaXMgdHJ1ZSBmb3IgdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gIHtBcnJheTxvYmplY3R8TW9kZWx8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVdIEEgbGlzdCBvZiBhc3NvY2lhdGlvbnMgdG8gZWFnZXJseSBsb2FkIHVzaW5nIGEgbGVmdCBqb2luLiBTdXBwb3J0ZWQgaXMgZWl0aGVyIGB7IGluY2x1ZGU6IFsgTW9kZWwxLCBNb2RlbDIsIC4uLl19YCBvciBgeyBpbmNsdWRlOiBbeyBtb2RlbDogTW9kZWwxLCBhczogJ0FsaWFzJyB9XX1gIG9yIGB7IGluY2x1ZGU6IFsnQWxpYXMnXX1gLiBJZiB5b3VyIGFzc29jaWF0aW9uIGFyZSBzZXQgdXAgd2l0aCBhbiBgYXNgIChlZy4gYFguaGFzTWFueShZLCB7IGFzOiAnWiB9YCwgeW91IG5lZWQgdG8gc3BlY2lmeSBaIGluIHRoZSBhcyBhdHRyaWJ1dGUgd2hlbiBlYWdlciBsb2FkaW5nIFkpLlxuICAgKiBAcGFyYW0gIHtNb2RlbH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5tb2RlbF0gVGhlIG1vZGVsIHlvdSB3YW50IHRvIGVhZ2VybHkgbG9hZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5hc10gVGhlIGFsaWFzIG9mIHRoZSByZWxhdGlvbiwgaW4gY2FzZSB0aGUgbW9kZWwgeW91IHdhbnQgdG8gZWFnZXJseSBsb2FkIGlzIGFsaWFzZWQuIEZvciBgaGFzT25lYCAvIGBiZWxvbmdzVG9gLCB0aGlzIHNob3VsZCBiZSB0aGUgc2luZ3VsYXIgbmFtZSwgYW5kIGZvciBgaGFzTWFueWAsIGl0IHNob3VsZCBiZSB0aGUgcGx1cmFsXG4gICAqIEBwYXJhbSAge0Fzc29jaWF0aW9ufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmFzc29jaWF0aW9uXSBUaGUgYXNzb2NpYXRpb24geW91IHdhbnQgdG8gZWFnZXJseSBsb2FkLiAoVGhpcyBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHByb3ZpZGluZyBhIG1vZGVsL2FzIHBhaXIpXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLndoZXJlXSBXaGVyZSBjbGF1c2VzIHRvIGFwcGx5IHRvIHRoZSBjaGlsZCBtb2RlbHMuIE5vdGUgdGhhdCB0aGlzIGNvbnZlcnRzIHRoZSBlYWdlciBsb2FkIHRvIGFuIGlubmVyIGpvaW4sIHVubGVzcyB5b3UgZXhwbGljaXRseSBzZXQgYHJlcXVpcmVkOiBmYWxzZWBcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ub3I9ZmFsc2VdIFdoZXRoZXIgdG8gYmluZCB0aGUgT04gYW5kIFdIRVJFIGNsYXVzZSB0b2dldGhlciBieSBPUiBpbnN0ZWFkIG9mIEFORC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ub25dIFN1cHBseSB5b3VyIG93biBPTiBjb25kaXRpb24gZm9yIHRoZSBqb2luLlxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5hdHRyaWJ1dGVzXSBBIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzZWxlY3QgZnJvbSB0aGUgY2hpbGQgbW9kZWxcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ucmVxdWlyZWRdIElmIHRydWUsIGNvbnZlcnRzIHRvIGFuIGlubmVyIGpvaW4sIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBtb2RlbCB3aWxsIG9ubHkgYmUgbG9hZGVkIGlmIGl0IGhhcyBhbnkgbWF0Y2hpbmcgY2hpbGRyZW4uIFRydWUgaWYgYGluY2x1ZGUud2hlcmVgIGlzIHNldCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5yaWdodF0gSWYgdHJ1ZSwgY29udmVydHMgdG8gYSByaWdodCBqb2luIGlmIGRpYWxlY3Qgc3VwcG9ydCBpdC4gSWdub3JlZCBpZiBgaW5jbHVkZS5yZXF1aXJlZGAgaXMgdHJ1ZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uc2VwYXJhdGVdIElmIHRydWUsIHJ1bnMgYSBzZXBhcmF0ZSBxdWVyeSB0byBmZXRjaCB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZXMsIG9ubHkgc3VwcG9ydGVkIGZvciBoYXNNYW55IGFzc29jaWF0aW9uc1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5saW1pdF0gTGltaXQgdGhlIGpvaW5lZCByb3dzLCBvbmx5IHN1cHBvcnRlZCB3aXRoIGluY2x1ZGUuc2VwYXJhdGU9dHJ1ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS50aHJvdWdoLmFzXSBUaGUgYWxpYXMgZm9yIHRoZSBqb2luIG1vZGVsLCBpbiBjYXNlIHlvdSB3YW50IHRvIGdpdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSB0aGFuIHRoZSBkZWZhdWx0IG9uZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10udGhyb3VnaC53aGVyZV0gRmlsdGVyIG9uIHRoZSBqb2luIG1vZGVsIGZvciBiZWxvbmdzVG9NYW55IHJlbGF0aW9uc1xuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS50aHJvdWdoLmF0dHJpYnV0ZXNdIEEgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNlbGVjdCBmcm9tIHRoZSBqb2luIG1vZGVsIGZvciBiZWxvbmdzVG9NYW55IHJlbGF0aW9uc1xuICAgKiBAcGFyYW0gIHtBcnJheTxvYmplY3R8TW9kZWx8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5pbmNsdWRlXSBMb2FkIGZ1cnRoZXIgbmVzdGVkIHJlbGF0ZWQgbW9kZWxzXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmR1cGxpY2F0aW5nXSBNYXJrIHRoZSBpbmNsdWRlIGFzIGR1cGxpY2F0aW5nLCB3aWxsIHByZXZlbnQgYSBzdWJxdWVyeSBmcm9tIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSAge0FycmF5fFNlcXVlbGl6ZS5mbnxTZXF1ZWxpemUuY29sfFNlcXVlbGl6ZS5saXRlcmFsfSAgICAgICAgW29wdGlvbnMub3JkZXJdIFNwZWNpZmllcyBhbiBvcmRlcmluZy4gVXNpbmcgYW4gYXJyYXksIHlvdSBjYW4gcHJvdmlkZSBzZXZlcmFsIGNvbHVtbnMgLyBmdW5jdGlvbnMgdG8gb3JkZXIgYnkuIEVhY2ggZWxlbWVudCBjYW4gYmUgZnVydGhlciB3cmFwcGVkIGluIGEgdHdvLWVsZW1lbnQgYXJyYXkuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBjb2x1bW4gLyBmdW5jdGlvbiB0byBvcmRlciBieSwgdGhlIHNlY29uZCBpcyB0aGUgZGlyZWN0aW9uLiBGb3IgZXhhbXBsZTogYG9yZGVyOiBbWyduYW1lJywgJ0RFU0MnXV1gLiBJbiB0aGlzIHdheSB0aGUgY29sdW1uIHdpbGwgYmUgZXNjYXBlZCwgYnV0IHRoZSBkaXJlY3Rpb24gd2lsbCBub3QuXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMubGltaXRdIExpbWl0IGZvciByZXN1bHRcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5vZmZzZXRdIE9mZnNldCBmb3IgcmVzdWx0XG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmxvY2tdIExvY2sgdGhlIHNlbGVjdGVkIHJvd3MuIFBvc3NpYmxlIG9wdGlvbnMgYXJlIHRyYW5zYWN0aW9uLkxPQ0suVVBEQVRFIGFuZCB0cmFuc2FjdGlvbi5MT0NLLlNIQVJFLiBQb3N0Z3JlcyBhbHNvIHN1cHBvcnRzIHRyYW5zYWN0aW9uLkxPQ0suS0VZX1NIQVJFLCB0cmFuc2FjdGlvbi5MT0NLLk5PX0tFWV9VUERBVEUgYW5kIHNwZWNpZmljIG1vZGVsIGxvY2tzIHdpdGggam9pbnMuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuc2tpcExvY2tlZF0gU2tpcCBsb2NrZWQgcm93cy4gT25seSBzdXBwb3J0ZWQgaW4gUG9zdGdyZXMuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMucmF3XSBSZXR1cm4gcmF3IHJlc3VsdC4gU2VlIHNlcXVlbGl6ZS5xdWVyeSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmhhdmluZ10gSGF2aW5nIG9wdGlvbnNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58RXJyb3J9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMucmVqZWN0T25FbXB0eT1mYWxzZV0gVGhyb3dzIGFuIGVycm9yIHdoZW4gbm8gcmVjb3JkcyBmb3VuZFxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUjcXVlcnl9XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1vZGVsPj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZEFsbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlF1ZXJ5RXJyb3IoJ1RoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZEFsbCBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5RdWVyeUVycm9yKCdUaGUgYXR0cmlidXRlcyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBjb2x1bW4gbmFtZXMgb3IgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53YXJuT25JbnZhbGlkT3B0aW9ucyhvcHRpb25zLCBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpKTtcblxuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSB7fTtcblxuICAgIHRhYmxlTmFtZXNbdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyldID0gdHJ1ZTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB7IGhvb2tzOiB0cnVlIH0pO1xuXG4gICAgLy8gc2V0IHJlamVjdE9uRW1wdHkgb3B0aW9uLCBkZWZhdWx0cyB0byBtb2RlbCBvcHRpb25zXG4gICAgb3B0aW9ucy5yZWplY3RPbkVtcHR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdyZWplY3RPbkVtcHR5JylcbiAgICAgID8gb3B0aW9ucy5yZWplY3RPbkVtcHR5XG4gICAgICA6IHRoaXMub3B0aW9ucy5yZWplY3RPbkVtcHR5O1xuXG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlRmluZCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5fZXhwYW5kQXR0cmlidXRlcyhvcHRpb25zKTtcbiAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGwnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgPSB0aGlzLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgb3B0aW9ucy5oYXNKb2luID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMsIHRhYmxlTmFtZXMpO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3QgcmF3LCB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB3ZSBpbmNsdWRlIHRoZSBwcmltYXJ5IGtleSBmb3IgZGUtZHVwbGljYXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICAgICYmICFvcHRpb25zLnJhd1xuICAgICAgICAmJiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgJiYgIW9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlcyh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUpXG4gICAgICAgICYmICghb3B0aW9ucy5ncm91cCB8fCAhb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24pXG4gICAgICApIHtcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uY29uY2F0KG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgICBvcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyA9IHRoaXMuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgLy8gd2hlcmVDb2xsZWN0aW9uIGlzIHVzZWQgZm9yIG5vbi1wcmltYXJ5IGtleSB1cGRhdGVzXG4gICAgdGhpcy5vcHRpb25zLndoZXJlQ29sbGVjdGlvbiA9IG9wdGlvbnMud2hlcmUgfHwgbnVsbDtcblxuICAgIFV0aWxzLm1hcEZpbmRlck9wdGlvbnMob3B0aW9ucywgdGhpcyk7XG5cbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlRmluZEFmdGVyT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RPcHRpb25zID0geyAuLi5vcHRpb25zLCB0YWJsZU5hbWVzOiBPYmplY3Qua2V5cyh0YWJsZU5hbWVzKSB9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnNlbGVjdCh0aGlzLCB0aGlzLmdldFRhYmxlTmFtZShzZWxlY3RPcHRpb25zKSwgc2VsZWN0T3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyRmluZCcsIHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vcmVqZWN0T25FbXB0eSBtb2RlXG4gICAgaWYgKF8uaXNFbXB0eShyZXN1bHRzKSAmJiBvcHRpb25zLnJlamVjdE9uRW1wdHkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RPbkVtcHR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBvcHRpb25zLnJlamVjdE9uRW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RPbkVtcHR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBvcHRpb25zLnJlamVjdE9uRW1wdHk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVtcHR5UmVzdWx0RXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgTW9kZWwuX2ZpbmRTZXBhcmF0ZShyZXN1bHRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyB3YXJuT25JbnZhbGlkT3B0aW9ucyhvcHRpb25zLCB2YWxpZENvbHVtbk5hbWVzKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1bnJlY29nbml6ZWRPcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKGsgPT4gIXZhbGlkUXVlcnlLZXl3b3Jkcy5oYXMoaykpO1xuICAgIGNvbnN0IHVuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMgPSBfLmludGVyc2VjdGlvbih1bnJlY29nbml6ZWRPcHRpb25zLCB2YWxpZENvbHVtbk5hbWVzKTtcbiAgICBpZiAoIW9wdGlvbnMud2hlcmUgJiYgdW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2dnZXIud2FybihgTW9kZWwgYXR0cmlidXRlcyAoJHt1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzLmpvaW4oJywgJyl9KSBwYXNzZWQgaW50byBmaW5kZXIgbWV0aG9kIG9wdGlvbnMgb2YgbW9kZWwgJHt0aGlzLm5hbWV9LCBidXQgdGhlIG9wdGlvbnMud2hlcmUgb2JqZWN0IGlzIGVtcHR5LiBEaWQgeW91IGZvcmdldCB0byB1c2Ugb3B0aW9ucy53aGVyZT9gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzKSByZXR1cm4gYXR0cmlidXRlcztcbiAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHJldHVybiBhdHRyaWJ1dGVzO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlKVxuICAgICAgICAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXS50eXBlLmZpZWxkc1xuICAgICAgKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdCh0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXS50eXBlLmZpZWxkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IF8udW5pcShhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIF9maW5kU2VwYXJhdGUocmVzdWx0cywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlIHx8IG9wdGlvbnMucmF3IHx8ICFyZXN1bHRzKSByZXR1cm4gcmVzdWx0cztcblxuICAgIGNvbnN0IG9yaWdpbmFsID0gcmVzdWx0cztcbiAgICBpZiAob3B0aW9ucy5wbGFpbikgcmVzdWx0cyA9IFtyZXN1bHRzXTtcblxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHJldHVybiBvcmlnaW5hbDtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMuaW5jbHVkZS5tYXAoYXN5bmMgaW5jbHVkZSA9PiB7XG4gICAgICBpZiAoIWluY2x1ZGUuc2VwYXJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IE1vZGVsLl9maW5kU2VwYXJhdGUoXG4gICAgICAgICAgcmVzdWx0cy5yZWR1Y2UoKG1lbW8sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFzc29jaWF0aW9ucyA9IHJlc3VsdC5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5hcyk7XG5cbiAgICAgICAgICAgIC8vIE1pZ2h0IGJlIGFuIGVtcHR5IGJlbG9uZ3NUbyByZWxhdGlvblxuICAgICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbnMpIHJldHVybiBtZW1vO1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBhcnJheSBzbyB3ZSBjYW4gY29uY2F0IG5vIG1hdHRlciBpZiBpdCdzIDE6MSBvciA6TVxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc29jaWF0aW9ucykpIGFzc29jaWF0aW9ucyA9IFthc3NvY2lhdGlvbnNdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXNzb2NpYXRpb25zLmxlbmd0aDsgaSAhPT0gbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgbWVtby5wdXNoKGFzc29jaWF0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICAuLi5fLm9taXQob3B0aW9ucywgJ2luY2x1ZGUnLCAnYXR0cmlidXRlcycsICdvcmRlcicsICd3aGVyZScsICdsaW1pdCcsICdvZmZzZXQnLCAncGxhaW4nLCAnc2NvcGUnKSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGUuaW5jbHVkZSB8fCBbXVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWFwID0gYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi5nZXQocmVzdWx0cywge1xuXG4gICAgICAgIC4uLl8ub21pdChvcHRpb25zLCBub25DYXNjYWRpbmdPcHRpb25zKSxcbiAgICAgICAgLi4uXy5vbWl0KGluY2x1ZGUsIFsncGFyZW50JywgJ2Fzc29jaWF0aW9uJywgJ2FzJywgJ29yaWdpbmFsQXR0cmlidXRlcyddKVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICBpbmNsdWRlLmFzc29jaWF0aW9uLmFzLFxuICAgICAgICAgIG1hcFtyZXN1bHQuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5KV0sXG4gICAgICAgICAgeyByYXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGEgc2luZ2xlIGluc3RhbmNlIGJ5IGl0cyBwcmltYXJ5IGtleS5fXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd8QnVmZmVyfSAgICAgIHBhcmFtIFRoZSB2YWx1ZSBvZiB0aGUgZGVzaXJlZCBpbnN0YW5jZSdzIHByaW1hcnkga2V5LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICAgICAgICAgICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSAgICAgICAgICAgZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zLCBOb3RlIHRoYXQgb3B0aW9ucy53aGVyZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZEJ5UGsocGFyYW0sIG9wdGlvbnMpIHtcbiAgICAvLyByZXR1cm4gUHJvbWlzZSByZXNvbHZlZCB3aXRoIG51bGwgaWYgbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICBpZiAoW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMocGFyYW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIocGFyYW0pKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgICBbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXTogcGFyYW1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgcGFzc2VkIHRvIGZpbmRCeVBrIGlzIGludmFsaWQ6ICR7cGFyYW19YCk7XG4gICAgfVxuXG4gICAgLy8gQnlwYXNzIGEgcG9zc2libGUgb3ZlcmxvYWRlZCBmaW5kT25lXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGEgc2luZ2xlIGluc3RhbmNlLiBSZXR1cm5zIHRoZSBmaXJzdCBpbnN0YW5jZSBmb3VuZCwgb3IgbnVsbCBpZiBub25lIGNhbiBiZSBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBbb3B0aW9uc10gQSBoYXNoIG9mIG9wdGlvbnMgdG8gZGVzY3JpYmUgdGhlIHNjb3BlIG9mIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHxudWxsPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kT25lKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kT25lIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB1bmlxdWVTaW5nbGVDb2x1bW5zID0gXy5jaGFpbih0aGlzLnVuaXF1ZUtleXMpLnZhbHVlcygpLmZpbHRlcihjID0+IGMuZmllbGRzLmxlbmd0aCA9PT0gMSkubWFwKCdjb2x1bW4nKS52YWx1ZSgpO1xuXG4gICAgICAvLyBEb24ndCBhZGQgbGltaXQgaWYgcXVlcnlpbmcgZGlyZWN0bHkgb24gdGhlIHBrIG9yIGEgdW5pcXVlIGNvbHVtblxuICAgICAgaWYgKCFvcHRpb25zLndoZXJlIHx8ICFfLnNvbWUob3B0aW9ucy53aGVyZSwgKHZhbHVlLCBrZXkpID0+XG4gICAgICAgIChrZXkgPT09IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSB8fCB1bmlxdWVTaW5nbGVDb2x1bW5zLmluY2x1ZGVzKGtleSkpICYmXG4gICAgICAgICAgKFV0aWxzLmlzUHJpbWl0aXZlKHZhbHVlKSB8fCBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKVxuICAgICAgKSkge1xuICAgICAgICBvcHRpb25zLmxpbWl0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCeXBhc3MgYSBwb3NzaWJsZSBvdmVybG9hZGVkIGZpbmRBbGwuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEFsbChfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHBsYWluOiB0cnVlXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhbiBhZ2dyZWdhdGlvbiBtZXRob2Qgb24gdGhlIHNwZWNpZmllZCBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgYXR0cmlidXRlIFRoZSBhdHRyaWJ1dGUgdG8gYWdncmVnYXRlIG92ZXIuIENhbiBiZSBhIGZpZWxkIG5hbWUgb3IgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgYWdncmVnYXRlRnVuY3Rpb24gVGhlIGZ1bmN0aW9uIHRvIHVzZSBmb3IgYWdncmVnYXRpb24sIGUuZy4gc3VtLCBtYXggZXRjLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnMuIFNlZSBzZXF1ZWxpemUucXVlcnkgZm9yIGZ1bGwgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnMud2hlcmVdIEEgaGFzaCBvZiBzZWFyY2ggYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtIHtEYXRhVHlwZXN8c3RyaW5nfSBbb3B0aW9ucy5kYXRhVHlwZV0gVGhlIHR5cGUgb2YgdGhlIHJlc3VsdC4gSWYgYGZpZWxkYCBpcyBhIGZpZWxkIGluIHRoaXMgTW9kZWwsIHRoZSBkZWZhdWx0IHdpbGwgYmUgdGhlIHR5cGUgb2YgdGhhdCBmaWVsZCwgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIGZsb2F0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuZGlzdGluY3RdIEFwcGxpZXMgRElTVElOQ1QgdG8gdGhlIGZpZWxkIGJlaW5nIGFnZ3JlZ2F0ZWQgb3ZlclxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSAgICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMucGxhaW5dIFdoZW4gYHRydWVgLCB0aGUgZmlyc3QgcmV0dXJuZWQgdmFsdWUgb2YgYGFnZ3JlZ2F0ZUZ1bmN0aW9uYCBpcyBjYXN0IHRvIGBkYXRhVHlwZWAgYW5kIHJldHVybmVkLiBJZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgYXJlIHNwZWNpZmllZCwgYWxvbmcgd2l0aCBgZ3JvdXBgIGNsYXVzZXMsIHNldCBgcGxhaW5gIHRvIGBmYWxzZWAgdG8gcmV0dXJuIGFsbCB2YWx1ZXMgb2YgYWxsIHJldHVybmVkIHJvd3MuICBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8RGF0YVR5cGVzfG9iamVjdD59IFJldHVybnMgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQgY2FzdCB0byBgb3B0aW9ucy5kYXRhVHlwZWAsIHVubGVzcyBgb3B0aW9ucy5wbGFpbmAgaXMgZmFsc2UsIGluIHdoaWNoIGNhc2UgdGhlIGNvbXBsZXRlIGRhdGEgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGFnZ3JlZ2F0ZShhdHRyaWJ1dGUsIGFnZ3JlZ2F0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgYXR0cmlidXRlcyBoZXJlIGFzIHRoZSBgaW5qZWN0U2NvcGVgIGNhbGwgd291bGQgaW5qZWN0IG5vbiBhZ2dyZWdhdGUgY29sdW1ucy5cbiAgICBjb25zdCBwcmV2QXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBwcmV2QXR0cmlidXRlcztcbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJPcHRpb25zID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgY29uc3QgZmllbGQgPSBhdHRyT3B0aW9ucyAmJiBhdHRyT3B0aW9ucy5maWVsZCB8fCBhdHRyaWJ1dGU7XG4gICAgbGV0IGFnZ3JlZ2F0ZUNvbHVtbiA9IHRoaXMuc2VxdWVsaXplLmNvbChmaWVsZCk7XG5cbiAgICBpZiAob3B0aW9ucy5kaXN0aW5jdCkge1xuICAgICAgYWdncmVnYXRlQ29sdW1uID0gdGhpcy5zZXF1ZWxpemUuZm4oJ0RJU1RJTkNUJywgYWdncmVnYXRlQ29sdW1uKTtcbiAgICB9XG5cbiAgICBsZXQgeyBncm91cCB9ID0gb3B0aW9ucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShncm91cCkgJiYgQXJyYXkuaXNBcnJheShncm91cFswXSkpIHtcbiAgICAgIG5vRG91YmxlTmVzdGVkR3JvdXAoKTtcbiAgICAgIGdyb3VwID0gXy5mbGF0dGVuKGdyb3VwKTtcbiAgICB9XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gXy51bmlvbkJ5KFxuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgZ3JvdXAsXG4gICAgICBbW3RoaXMuc2VxdWVsaXplLmZuKGFnZ3JlZ2F0ZUZ1bmN0aW9uLCBhZ2dyZWdhdGVDb2x1bW4pLCBhZ2dyZWdhdGVGdW5jdGlvbl1dLFxuICAgICAgYSA9PiBBcnJheS5pc0FycmF5KGEpID8gYVsxXSA6IGFcbiAgICApO1xuXG4gICAgaWYgKCFvcHRpb25zLmRhdGFUeXBlKSB7XG4gICAgICBpZiAoYXR0ck9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IGF0dHJPcHRpb25zLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgRkxPQVQgYXMgZmFsbGJhY2tcbiAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IG5ldyBEYXRhVHlwZXMuRkxPQVQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZURhdGFUeXBlKG9wdGlvbnMuZGF0YVR5cGUpO1xuICAgIH1cblxuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJhd1NlbGVjdCh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucywgYWdncmVnYXRlRnVuY3Rpb24sIHRoaXMpO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIHdoZXJlIGNsYXVzZS5cbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgYW4gYGluY2x1ZGVgIG9wdGlvbiwgdGhlIG51bWJlciBvZiBtYXRjaGluZyBhc3NvY2lhdGlvbnMgd2lsbCBiZSBjb3VudGVkIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgW29wdGlvbnNdIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICBbb3B0aW9ucy53aGVyZV0gQSBoYXNoIG9mIHNlYXJjaCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgIFtvcHRpb25zLmluY2x1ZGVdIEluY2x1ZGUgb3B0aW9ucy4gU2VlIGBmaW5kYCBmb3IgZGV0YWlsc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIFtvcHRpb25zLnBhcmFub2lkPXRydWVdIFNldCBgdHJ1ZWAgdG8gY291bnQgb25seSBub24tZGVsZXRlZCByZWNvcmRzLiBDYW4gYmUgdXNlZCBvbiBtb2RlbHMgd2l0aCBgcGFyYW5vaWRgIGVuYWJsZWRcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBbb3B0aW9ucy5kaXN0aW5jdF0gQXBwbHkgQ09VTlQoRElTVElOQ1QoY29sKSkgb24gcHJpbWFyeSBrZXkgb3Igb24gb3B0aW9ucy5jb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgW29wdGlvbnMuY29sXSBDb2x1bW4gb24gd2hpY2ggQ09VTlQoKSBzaG91bGQgYmUgYXBwbGllZFxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIFtvcHRpb25zLmF0dHJpYnV0ZXNdIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgZ3JvdXBgXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgW29wdGlvbnMuZ3JvdXBdIEZvciBjcmVhdGluZyBjb21wbGV4IGNvdW50cy4gV2lsbCByZXR1cm4gbXVsdGlwbGUgcm93cyBhcyBuZWVkZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259ICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNvdW50KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgaG9va3M6IHRydWUgfSk7XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDb3VudCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgY29sID0gb3B0aW9ucy5jb2wgfHwgJyonO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGNvbCA9IGAke3RoaXMubmFtZX0uJHtvcHRpb25zLmNvbCB8fCB0aGlzLnByaW1hcnlLZXlGaWVsZH1gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kaXN0aW5jdCAmJiBjb2wgPT09ICcqJykge1xuICAgICAgY29sID0gdGhpcy5wcmltYXJ5S2V5RmllbGQ7XG4gICAgfVxuICAgIG9wdGlvbnMucGxhaW4gPSAhb3B0aW9ucy5ncm91cDtcbiAgICBvcHRpb25zLmRhdGFUeXBlID0gbmV3IERhdGFUeXBlcy5JTlRFR0VSKCk7XG4gICAgb3B0aW9ucy5pbmNsdWRlSWdub3JlQXR0cmlidXRlcyA9IGZhbHNlO1xuXG4gICAgLy8gTm8gbGltaXQsIG9mZnNldCBvciBvcmRlciBmb3IgdGhlIG9wdGlvbnMgbWF4IGJlIGdpdmVuIHRvIGNvdW50KClcbiAgICAvLyBTZXQgdGhlbSB0byBudWxsIHRvIHByZXZlbnQgc2NvcGVzIHNldHRpbmcgdGhvc2UgdmFsdWVzXG4gICAgb3B0aW9ucy5saW1pdCA9IG51bGw7XG4gICAgb3B0aW9ucy5vZmZzZXQgPSBudWxsO1xuICAgIG9wdGlvbnMub3JkZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGNvbCwgJ2NvdW50Jywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbGwgdGhlIHJvd3MgbWF0Y2hpbmcgeW91ciBxdWVyeSwgd2l0aGluIGEgc3BlY2lmaWVkIG9mZnNldCAvIGxpbWl0LCBhbmQgZ2V0IHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBtYXRjaGluZyB5b3VyIHF1ZXJ5LiBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciBwYWdpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgTW9kZWwuZmluZEFuZENvdW50QWxsKHtcbiAgICogICB3aGVyZTogLi4uLFxuICAgKiAgIGxpbWl0OiAxMixcbiAgICogICBvZmZzZXQ6IDEyXG4gICAqIH0pO1xuICAgKlxuICAgKiAjIEluIHRoZSBhYm92ZSBleGFtcGxlLCBgcmVzdWx0LnJvd3NgIHdpbGwgY29udGFpbiByb3dzIDEzIHRocm91Z2ggMjQsIHdoaWxlIGByZXN1bHQuY291bnRgIHdpbGwgcmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyB0aGF0IG1hdGNoZWQgeW91ciBxdWVyeS5cbiAgICpcbiAgICogIyBXaGVuIHlvdSBhZGQgaW5jbHVkZXMsIG9ubHkgdGhvc2Ugd2hpY2ggYXJlIHJlcXVpcmVkIChlaXRoZXIgYmVjYXVzZSB0aGV5IGhhdmUgYSB3aGVyZSBjbGF1c2UsIG9yIGJlY2F1c2UgYHJlcXVpcmVkYCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlIG9uIHRoZSBpbmNsdWRlKSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb3VudCBwYXJ0LlxuICAgKlxuICAgKiAjIFN1cHBvc2UgeW91IHdhbnQgdG8gZmluZCBhbGwgdXNlcnMgd2hvIGhhdmUgYSBwcm9maWxlIGF0dGFjaGVkOlxuICAgKlxuICAgKiBVc2VyLmZpbmRBbmRDb3VudEFsbCh7XG4gICAqICAgaW5jbHVkZTogW1xuICAgKiAgICAgIHsgbW9kZWw6IFByb2ZpbGUsIHJlcXVpcmVkOiB0cnVlfVxuICAgKiAgIF0sXG4gICAqICAgbGltaXQ6IDNcbiAgICogfSk7XG4gICAqXG4gICAqICMgQmVjYXVzZSB0aGUgaW5jbHVkZSBmb3IgYFByb2ZpbGVgIGhhcyBgcmVxdWlyZWRgIHNldCBpdCB3aWxsIHJlc3VsdCBpbiBhbiBpbm5lciBqb2luLCBhbmQgb25seSB0aGUgdXNlcnMgd2hvIGhhdmUgYSBwcm9maWxlIHdpbGwgYmUgY291bnRlZC4gSWYgd2UgcmVtb3ZlIGByZXF1aXJlZGAgZnJvbSB0aGUgaW5jbHVkZSwgYm90aCB1c2VycyB3aXRoIGFuZCB3aXRob3V0IHByb2ZpbGVzIHdpbGwgYmUgY291bnRlZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSBmaW5kQWxsIG9wdGlvbnNcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gZm9yIGEgc3BlY2lmaWNhdGlvbiBvZiBmaW5kIGFuZCBxdWVyeSBvcHRpb25zXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmNvdW50fSBmb3IgYSBzcGVjaWZpY2F0aW9uIG9mIGNvdW50IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8e2NvdW50OiBudW1iZXIsIHJvd3M6IE1vZGVsW119Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kQW5kQ291bnRBbGwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRBbmRDb3VudEFsbCBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvdW50T3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGlmIChjb3VudE9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgY291bnRPcHRpb25zLmF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgW2NvdW50LCByb3dzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuY291bnQoY291bnRPcHRpb25zKSxcbiAgICAgIHRoaXMuZmluZEFsbChvcHRpb25zKVxuICAgIF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50LFxuICAgICAgcm93czogY291bnQgPT09IDAgPyBbXSA6IHJvd3NcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgb2YgZmllbGRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIGF0dHJpYnV0ZSAvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUgYWdncmVnYXRlXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmFnZ3JlZ2F0ZX0gZm9yIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbWF4KGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCAnbWF4Jywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgbWluaW11bSB2YWx1ZSBvZiBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgYXR0cmlidXRlIC8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSBhZ2dyZWdhdGVcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuYWdncmVnYXRlfSBmb3Igb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBtaW4oZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsICdtaW4nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBzdW0gb2YgZmllbGRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIGF0dHJpYnV0ZSAvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUgYWdncmVnYXRlXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmFnZ3JlZ2F0ZX0gZm9yIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdW0oZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsICdzdW0nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBuZXcgbW9kZWwgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSB2YWx1ZXMgQW4gb2JqZWN0IG9mIGtleSB2YWx1ZSBwYWlycyBvciBhbiBhcnJheSBvZiBzdWNoLiBJZiBhbiBhcnJheSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGluc3RhbmNlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc10gSW5zdGFuY2UgYnVpbGQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHZhbHVlcyB3aWxsIGlnbm9yZSBmaWVsZCBhbmQgdmlydHVhbCBzZXR0ZXJzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzTmV3UmVjb3JkPXRydWVdIElzIHRoaXMgbmV3IHJlY29yZFxuICAgKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmluY2x1ZGVdIGFuIGFycmF5IG9mIGluY2x1ZGUgb3B0aW9ucyAtIFVzZWQgdG8gYnVpbGQgcHJlZmV0Y2hlZC9pbmNsdWRlZCBtb2RlbCBpbnN0YW5jZXMuIFNlZSBgc2V0YFxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx8QXJyYXk8TW9kZWw+fVxuICAgKi9cbiAgc3RhdGljIGJ1aWxkKHZhbHVlcywgb3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1bGtCdWlsZCh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGhpcyh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGJ1bGtCdWlsZCh2YWx1ZVNldHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyBpc05ld1JlY29yZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoYXR0cmlidXRlID0+IEFycmF5LmlzQXJyYXkoYXR0cmlidXRlKSA/IGF0dHJpYnV0ZVsxXSA6IGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlU2V0cy5tYXAodmFsdWVzID0+IHRoaXMuYnVpbGQodmFsdWVzLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgbmV3IG1vZGVsIGluc3RhbmNlIGFuZCBjYWxscyBzYXZlIG9uIGl0LlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5idWlsZH1cbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuc2F2ZX1cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIHZhbHVlcyAgICAgICAgICAgICAgICAgICAgICAgSGFzaCBvZiBkYXRhIHZhbHVlcyB0byBjcmVhdGUgbmV3IHJlY29yZCB3aXRoXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgIEJ1aWxkIGFuZCBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5yYXc9ZmFsc2VdICAgICAgICAgIElmIHNldCB0byB0cnVlLCB2YWx1ZXMgd2lsbCBpZ25vcmUgZmllbGQgYW5kIHZpcnR1YWwgc2V0dGVycy5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmlzTmV3UmVjb3JkPXRydWVdICAgSXMgdGhpcyBuZXcgcmVjb3JkXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlXSAgICAgICAgICAgIEFuIGFycmF5IG9mIGluY2x1ZGUgb3B0aW9ucyAtIFVzZWQgdG8gYnVpbGQgcHJlZmV0Y2hlZC9pbmNsdWRlZCBtb2RlbCBpbnN0YW5jZXMuIFNlZSBgc2V0YFxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gICAgICAgW29wdGlvbnMuZmllbGRzXSAgICAgICAgICAgICBBbiBvcHRpb25hbCBhcnJheSBvZiBzdHJpbmdzLCByZXByZXNlbnRpbmcgZGF0YWJhc2UgY29sdW1ucy4gSWYgZmllbGRzIGlzIHByb3ZpZGVkLCBvbmx5IHRob3NlIGNvbHVtbnMgd2lsbCBiZSB2YWxpZGF0ZWQgYW5kIHNhdmVkLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuc2lsZW50PWZhbHNlXSAgICAgICBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMudmFsaWRhdGU9dHJ1ZV0gICAgICBJZiBmYWxzZSwgdmFsaWRhdGlvbnMgd29uJ3QgYmUgcnVuLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICBSdW4gYmVmb3JlIGFuZCBhZnRlciBjcmVhdGUgLyB1cGRhdGUgKyB2YWxpZGF0ZSBob29rc1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0gIHtib29sZWFufEFycmF5fSAgW29wdGlvbnMucmV0dXJuaW5nPXRydWVdICAgICBBcHBlbmRzIFJFVFVSTklORyA8bW9kZWwgY29sdW1ucz4gdG8gZ2V0IGJhY2sgYWxsIGRlZmluZWQgdmFsdWVzOyBpZiBhbiBhcnJheSBvZiBjb2x1bW4gbmFtZXMsIGFwcGVuZCBSRVRVUk5JTkcgPGNvbHVtbnM+IHRvIGdldCBiYWNrIHNwZWNpZmljIGNvbHVtbnMgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICpcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zIHx8IHt9KTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJ1aWxkKHZhbHVlcywge1xuICAgICAgaXNOZXdSZWNvcmQ6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zLmZpZWxkcyxcbiAgICAgIGluY2x1ZGU6IG9wdGlvbnMuaW5jbHVkZSxcbiAgICAgIHJhdzogb3B0aW9ucy5yYXcsXG4gICAgICBzaWxlbnQ6IG9wdGlvbnMuc2lsZW50XG4gICAgfSkuc2F2ZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgcm93IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnksIG9yIGJ1aWxkIChidXQgZG9uJ3Qgc2F2ZSkgdGhlIHJvdyBpZiBub25lIGlzIGZvdW5kLlxuICAgKiBUaGUgc3VjY2Vzc2Z1bCByZXN1bHQgb2YgdGhlIHByb21pc2Ugd2lsbCBiZSAoaW5zdGFuY2UsIGJ1aWx0KVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBvcHRpb25zIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICBvcHRpb25zLndoZXJlIEEgaGFzaCBvZiBzZWFyY2ggYXR0cmlidXRlcy4gSWYgYHdoZXJlYCBpcyBhIHBsYWluIG9iamVjdCBpdCB3aWxsIGJlIGFwcGVuZGVkIHdpdGggZGVmYXVsdHMgdG8gYnVpbGQgYSBuZXcgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLmRlZmF1bHRzXSBEZWZhdWx0IHZhbHVlcyB0byB1c2UgaWYgYnVpbGRpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbCxib29sZWFuPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kT3JCdWlsZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRPckJ1aWxkLiAnICtcbiAgICAgICAgJ1BsZWFzZSBub3RlIHRoYXQgdGhlIEFQSSBoYXMgY2hhbmdlZCwgYW5kIGlzIG5vdyBvcHRpb25zIG9ubHkgKGFuIG9iamVjdCB3aXRoIHdoZXJlLCBkZWZhdWx0cyBrZXlzLCB0cmFuc2FjdGlvbiBldGMuKSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcztcblxuICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IHsgLi4ub3B0aW9ucy5kZWZhdWx0cyB9O1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZSA9IHRoaXMuYnVpbGQodmFsdWVzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIFtpbnN0YW5jZSwgdHJ1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpbnN0YW5jZSwgZmFsc2VdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSByb3cgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSwgb3IgYnVpbGQgYW5kIHNhdmUgdGhlIHJvdyBpZiBub25lIGlzIGZvdW5kXG4gICAqIFRoZSBzdWNjZXNzZnVsIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSB3aWxsIGJlIChpbnN0YW5jZSwgY3JlYXRlZClcbiAgICpcbiAgICogSWYgbm8gdHJhbnNhY3Rpb24gaXMgcGFzc2VkIGluIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhIG5ldyB0cmFuc2FjdGlvbiB3aWxsIGJlIGNyZWF0ZWQgaW50ZXJuYWxseSwgdG8gcHJldmVudCB0aGUgcmFjZSBjb25kaXRpb24gd2hlcmUgYSBtYXRjaGluZyByb3cgaXMgY3JlYXRlZCBieSBhbm90aGVyIGNvbm5lY3Rpb24gYWZ0ZXIgdGhlIGZpbmQgYnV0IGJlZm9yZSB0aGUgaW5zZXJ0IGNhbGwuXG4gICAqIEhvd2V2ZXIsIGl0IGlzIG5vdCBhbHdheXMgcG9zc2libGUgdG8gaGFuZGxlIHRoaXMgY2FzZSBpbiBTUUxpdGUsIHNwZWNpZmljYWxseSBpZiBvbmUgdHJhbnNhY3Rpb24gaW5zZXJ0cyBhbmQgYW5vdGhlciB0cmllcyB0byBzZWxlY3QgYmVmb3JlIHRoZSBmaXJzdCBvbmUgaGFzIGNvbW1pdHRlZC4gSW4gdGhpcyBjYXNlLCBhbiBpbnN0YW5jZSBvZiBzZXF1ZWxpemUuIFRpbWVvdXRFcnJvciB3aWxsIGJlIHRocm93biBpbnN0ZWFkLlxuICAgKiBJZiBhIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQsIGEgc2F2ZXBvaW50IHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLCBhbmQgYW55IHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbiB3aWxsIGJlIGhhbmRsZWQgaW50ZXJuYWxseS5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gZm9yIGEgZnVsbCBzcGVjaWZpY2F0aW9uIG9mIGZpbmQgYW5kIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgb3B0aW9ucyBmaW5kIGFuZCBjcmVhdGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBvcHRpb25zLndoZXJlIHdoZXJlIEEgaGFzaCBvZiBzZWFyY2ggYXR0cmlidXRlcy4gSWYgYHdoZXJlYCBpcyBhIHBsYWluIG9iamVjdCBpdCB3aWxsIGJlIGFwcGVuZGVkIHdpdGggZGVmYXVsdHMgdG8gYnVpbGQgYSBuZXcgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtvcHRpb25zLmRlZmF1bHRzXSBEZWZhdWx0IHZhbHVlcyB0byB1c2UgaWYgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbCxib29sZWFuPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kT3JDcmVhdGUob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kT3JDcmVhdGUuICcgK1xuICAgICAgICAnUGxlYXNlIG5vdGUgdGhhdCB0aGUgQVBJIGhhcyBjaGFuZ2VkLCBhbmQgaXMgbm93IG9wdGlvbnMgb25seSAoYW4gb2JqZWN0IHdpdGggd2hlcmUsIGRlZmF1bHRzIGtleXMsIHRyYW5zYWN0aW9uIGV0Yy4pJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHRzKTtcbiAgICAgIGNvbnN0IHVua25vd25EZWZhdWx0cyA9IGRlZmF1bHRzLmZpbHRlcihuYW1lID0+ICF0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0pO1xuXG4gICAgICBpZiAodW5rbm93bkRlZmF1bHRzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIud2FybihgVW5rbm93biBhdHRyaWJ1dGVzICgke3Vua25vd25EZWZhdWx0c30pIHBhc3NlZCB0byBkZWZhdWx0cyBvcHRpb24gb2YgZmluZE9yQ3JlYXRlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoJ3RyYW5zYWN0aW9uJyk7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcm5hbFRyYW5zYWN0aW9uID0gIW9wdGlvbnMudHJhbnNhY3Rpb247XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgdHJhbnNhY3Rpb247XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnRyYW5zYWN0aW9uKG9wdGlvbnMpO1xuICAgICAgdHJhbnNhY3Rpb24gPSB0O1xuICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG5cbiAgICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kT25lKFV0aWxzLmRlZmF1bHRzKHsgdHJhbnNhY3Rpb24gfSwgb3B0aW9ucykpO1xuICAgICAgaWYgKGZvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbZm91bmQsIGZhbHNlXTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzID0geyAuLi5vcHRpb25zLmRlZmF1bHRzIH07XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVhdGVkLmdldCh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHF1ZXJ5IHJldHVybmVkIGFuIGVtcHR5IHJlc3VsdCBmb3IgdGhlIHByaW1hcnkga2V5LCB3ZSBrbm93IHRoYXQgdGhpcyB3YXMgYWN0dWFsbHkgYSB1bmlxdWUgY29uc3RyYWludCB2aW9sYXRpb25cbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtjcmVhdGVkLCB0cnVlXTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKSkgdGhyb3cgZXJyO1xuICAgICAgICBjb25zdCBmbGF0dGVuZWRXaGVyZSA9IFV0aWxzLmZsYXR0ZW5PYmplY3REZWVwKG9wdGlvbnMud2hlcmUpO1xuICAgICAgICBjb25zdCBmbGF0dGVuZWRXaGVyZUtleXMgPSBPYmplY3Qua2V5cyhmbGF0dGVuZWRXaGVyZSkubWFwKG5hbWUgPT4gXy5sYXN0KG5hbWUuc3BsaXQoJy4nKSkpO1xuICAgICAgICBjb25zdCB3aGVyZUZpZWxkcyA9IGZsYXR0ZW5lZFdoZXJlS2V5cy5tYXAobmFtZSA9PiBfLmdldCh0aGlzLnJhd0F0dHJpYnV0ZXMsIGAke25hbWV9LmZpZWxkYCwgbmFtZSkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0RmllbGRzID0gb3B0aW9ucy5kZWZhdWx0cyAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0pXG4gICAgICAgICAgLm1hcChuYW1lID0+IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXS5maWVsZCB8fCBuYW1lKTtcblxuICAgICAgICBjb25zdCBlcnJGaWVsZEtleXMgPSBPYmplY3Qua2V5cyhlcnIuZmllbGRzKTtcbiAgICAgICAgY29uc3QgZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzID0gVXRpbHMuaW50ZXJzZWN0cyhlcnJGaWVsZEtleXMsIHdoZXJlRmllbGRzKTtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWVsZHMgJiYgIWVyckZpZWxkc1doZXJlSW50ZXJzZWN0cyAmJiBVdGlscy5pbnRlcnNlY3RzKGVyckZpZWxkS2V5cywgZGVmYXVsdEZpZWxkcykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzKSB7XG4gICAgICAgICAgXy5lYWNoKGVyci5maWVsZHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXBba2V5XS5maWVsZE5hbWU7XG4gICAgICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKSAhPT0gb3B0aW9ucy53aGVyZVtuYW1lXS50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9I2ZpbmRPckNyZWF0ZTogdmFsdWUgdXNlZCBmb3IgJHtuYW1lfSB3YXMgbm90IGVxdWFsIGZvciBib3RoIHRoZSBmaW5kIGFuZCB0aGUgY3JlYXRlIGNhbGxzLCAnJHtvcHRpb25zLndoZXJlW25hbWVdfScgdnMgJyR7dmFsdWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZW9uZSBtdXN0IGhhdmUgY3JlYXRlZCBhIG1hdGNoaW5nIGluc3RhbmNlIGluc2lkZSB0aGUgc2FtZSB0cmFuc2FjdGlvbiBzaW5jZSB3ZSBsYXN0IGRpZCBhIGZpbmQuIExldCdzIGZpbmQgaXQhXG4gICAgICAgIGNvbnN0IG90aGVyQ3JlYXRlZCA9IGF3YWl0IHRoaXMuZmluZE9uZShVdGlscy5kZWZhdWx0cyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IGludGVybmFsVHJhbnNhY3Rpb24gPyBudWxsIDogdHJhbnNhY3Rpb25cbiAgICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgIC8vIFNhbml0eSBjaGVjaywgaWRlYWxseSB3ZSBjYXVnaHQgdGhpcyBhdCB0aGUgZGVmYXVsdEZlaWxkcy9lcnIuZmllbGRzIGNoZWNrXG4gICAgICAgIC8vIEJ1dCBpZiB3ZSBkaWRuJ3QgYW5kIGluc3RhbmNlIGlzIG51bGwsIHdlIHdpbGwgdGhyb3dcbiAgICAgICAgaWYgKG90aGVyQ3JlYXRlZCA9PT0gbnVsbCkgdGhyb3cgZXJyO1xuXG4gICAgICAgIHJldHVybiBbb3RoZXJDcmVhdGVkLCBmYWxzZV07XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChpbnRlcm5hbFRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1vcmUgcGVyZm9ybWFudCBmaW5kT3JDcmVhdGUgdGhhdCB3aWxsIG5vdCB3b3JrIHVuZGVyIGEgdHJhbnNhY3Rpb24gKGF0IGxlYXN0IG5vdCBpbiBwb3N0Z3JlcylcbiAgICogV2lsbCBleGVjdXRlIGEgZmluZCBjYWxsLCBpZiBlbXB0eSB0aGVuIGF0dGVtcHQgdG8gY3JlYXRlLCBpZiB1bmlxdWUgY29uc3RyYWludCB0aGVuIGF0dGVtcHQgdG8gZmluZCBhZ2FpblxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSBmb3IgYSBmdWxsIHNwZWNpZmljYXRpb24gb2YgZmluZCBhbmQgb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMud2hlcmUgQSBoYXNoIG9mIHNlYXJjaCBhdHRyaWJ1dGVzLiBJZiBgd2hlcmVgIGlzIGEgcGxhaW4gb2JqZWN0IGl0IHdpbGwgYmUgYXBwZW5kZWQgd2l0aCBkZWZhdWx0cyB0byBidWlsZCBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmRlZmF1bHRzXSBEZWZhdWx0IHZhbHVlcyB0byB1c2UgaWYgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWwsYm9vbGVhbj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZENyZWF0ZUZpbmQob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kQ3JlYXRlRmluZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB2YWx1ZXMgPSB7IC4uLm9wdGlvbnMuZGVmYXVsdHMgfTtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgIH1cblxuXG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKGZvdW5kKSByZXR1cm4gW2ZvdW5kLCBmYWxzZV07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gW2NyZWF0ZWQsIHRydWVdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcikpIHRocm93IGVycjtcbiAgICAgIGNvbnN0IGZvdW5kQWdhaW4gPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gW2ZvdW5kQWdhaW4sIGZhbHNlXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IG9yIHVwZGF0ZSBhIHNpbmdsZSByb3cuIEFuIHVwZGF0ZSB3aWxsIGJlIGV4ZWN1dGVkIGlmIGEgcm93IHdoaWNoIG1hdGNoZXMgdGhlIHN1cHBsaWVkIHZhbHVlcyBvbiBlaXRoZXIgdGhlIHByaW1hcnkga2V5IG9yIGEgdW5pcXVlIGtleSBpcyBmb3VuZC4gTm90ZSB0aGF0IHRoZSB1bmlxdWUgaW5kZXggbXVzdCBiZSBkZWZpbmVkIGluIHlvdXIgc2VxdWVsaXplIG1vZGVsIGFuZCBub3QganVzdCBpbiB0aGUgdGFibGUuIE90aGVyd2lzZSB5b3UgbWF5IGV4cGVyaWVuY2UgYSB1bmlxdWUgY29uc3RyYWludCB2aW9sYXRpb24sIGJlY2F1c2Ugc2VxdWVsaXplIGZhaWxzIHRvIGlkZW50aWZ5IHRoZSByb3cgdGhhdCBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogKipJbXBsZW1lbnRhdGlvbiBkZXRhaWxzOioqXG4gICAqXG4gICAqICogTXlTUUwgLSBJbXBsZW1lbnRlZCB3aXRoIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFYFxuICAgKiAqIFBvc3RncmVTUUwgLSBJbXBsZW1lbnRlZCB3aXRoIE9OIENPTkZMSUNUIERPIFVQREFURS4gSWYgdXBkYXRlIGRhdGEgY29udGFpbnMgUEsgZmllbGQsIHRoZW4gUEsgaXMgc2VsZWN0ZWQgYXMgdGhlIGRlZmF1bHQgY29uZmxpY3Qga2V5LiBPdGhlcndpc2UgZmlyc3QgdW5pcXVlIGNvbnN0cmFpbnQvaW5kZXggd2lsbCBiZSBzZWxlY3RlZCwgd2hpY2ggY2FuIHNhdGlzZnkgY29uZmxpY3Qga2V5IHJlcXVpcmVtZW50cy5cbiAgICogKiBTUUxpdGUgLSBJbXBsZW1lbnRlZCB3aXRoIE9OIENPTkZMSUNUIERPIFVQREFURVxuICAgKiAqIE1TU1FMIC0gSW1wbGVtZW50ZWQgYXMgYSBzaW5nbGUgcXVlcnkgdXNpbmcgYE1FUkdFYCBhbmQgYFdIRU4gKE5PVCkgTUFUQ0hFRCBUSEVOYFxuICAgKlxuICAgKiAqKk5vdGUqKiB0aGF0IFBvc3RncmVzL1NRTGl0ZSByZXR1cm5zIG51bGwgZm9yIGNyZWF0ZWQsIG5vIG1hdHRlciBpZiB0aGUgcm93IHdhcyBjcmVhdGVkIG9yIHVwZGF0ZWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICB2YWx1ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCBvZiB2YWx1ZXMgdG8gdXBzZXJ0XG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydCBvcHRpb25zXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMudmFsaWRhdGU9dHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgIFJ1biB2YWxpZGF0aW9ucyBiZWZvcmUgdGhlIHJvdyBpcyBpbnNlcnRlZFxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgIFtvcHRpb25zLmZpZWxkcz1PYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpXSBUaGUgZmllbGRzIHRvIGluc2VydCAvIHVwZGF0ZS4gRGVmYXVsdHMgdG8gYWxsIGNoYW5nZWQgZmllbGRzXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgICAgIFJ1biBiZWZvcmUgLyBhZnRlciB1cHNlcnQgaG9va3M/XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMucmV0dXJuaW5nPXRydWVdICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIGZldGNoZXMgYmFjayBhdXRvIGdlbmVyYXRlZCB2YWx1ZXNcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICAgICAgICAgICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgICAgICAgICAgICAgICAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdICAgICAgICAgICAgICAgICAgQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8W01vZGVsLCBib29sZWFuIHwgbnVsbF0+fSByZXR1cm5zIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCB0aGUgZmlyc3QgYmVpbmcgdGhlIG5ldyByZWNvcmQgYW5kIHRoZSBzZWNvbmQgYmVpbmcgYHRydWVgIGlmIGl0IHdhcyBqdXN0IGNyZWF0ZWQgb3IgYGZhbHNlYCBpZiBpdCBhbHJlYWR5IGV4aXN0ZWQgKGV4Y2VwdCBvbiBQb3N0Z3JlcyBhbmQgU1FMaXRlLCB3aGljaCBjYW4ndCBkZXRlY3QgdGhpcyBhbmQgd2lsbCBhbHdheXMgcmV0dXJuIGBudWxsYCBpbnN0ZWFkIG9mIGEgYm9vbGVhbikuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBzZXJ0KHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIHJldHVybmluZzogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgLi4uVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpXG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgY29uc3QgaGFzUHJpbWFyeSA9IHRoaXMucHJpbWFyeUtleUZpZWxkIGluIHZhbHVlcyB8fCB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgaW4gdmFsdWVzO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5idWlsZCh2YWx1ZXMpO1xuXG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXG4gICAgY29uc3QgY2hhbmdlZCA9IEFycmF5LmZyb20oaW5zdGFuY2UuX2NoYW5nZWQpO1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gY2hhbmdlZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgYXdhaXQgaW5zdGFuY2UudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIE1hcCBmaWVsZCBuYW1lc1xuICAgIGNvbnN0IHVwZGF0ZWREYXRhVmFsdWVzID0gXy5waWNrKGluc3RhbmNlLmRhdGFWYWx1ZXMsIGNoYW5nZWQpO1xuICAgIGNvbnN0IGluc2VydFZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyhpbnN0YW5jZS5kYXRhVmFsdWVzLCBPYmplY3Qua2V5cyhpbnN0YW5jZS5yYXdBdHRyaWJ1dGVzKSwgdGhpcyk7XG4gICAgY29uc3QgdXBkYXRlVmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHVwZGF0ZWREYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcywgdGhpcyk7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG5cbiAgICAvLyBBdHRhY2ggY3JlYXRlZEF0XG4gICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIXVwZGF0ZVZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbY3JlYXRlZEF0QXR0cl0uZmllbGQgfHwgY3JlYXRlZEF0QXR0cjtcbiAgICAgIGluc2VydFZhbHVlc1tmaWVsZF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKGNyZWF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIWluc2VydFZhbHVlc1t1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdXBkYXRlZEF0QXR0cl0uZmllbGQgfHwgdXBkYXRlZEF0QXR0cjtcbiAgICAgIGluc2VydFZhbHVlc1tmaWVsZF0gPSB1cGRhdGVWYWx1ZXNbZmllbGRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYWRkcyBhIG51bGwgdmFsdWUgZm9yIHRoZSBwcmltYXJ5IGtleSwgaWYgbm9uZSB3YXMgZ2l2ZW4gYnkgdGhlIHVzZXIuXG4gICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhhdCBiZWNhdXNlIG9mIHNvbWUgUG9zdGdyZXMgdGVjaG5pY2FsaXRpZXMuXG4gICAgaWYgKCFoYXNQcmltYXJ5ICYmIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiAhdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uZGVmYXVsdFZhbHVlKSB7XG4gICAgICBkZWxldGUgaW5zZXJ0VmFsdWVzW3RoaXMucHJpbWFyeUtleUZpZWxkXTtcbiAgICAgIGRlbGV0ZSB1cGRhdGVWYWx1ZXNbdGhpcy5wcmltYXJ5S2V5RmllbGRdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVVcHNlcnQnLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnVwc2VydCh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIGluc3RhbmNlLndoZXJlKCksIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgW3JlY29yZF0gPSByZXN1bHQ7XG4gICAgcmVjb3JkLmlzTmV3UmVjb3JkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJVcHNlcnQnLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGluc2VydCBtdWx0aXBsZSBpbnN0YW5jZXMgaW4gYnVsay5cbiAgICpcbiAgICogVGhlIHN1Y2Nlc3MgaGFuZGxlciBpcyBwYXNzZWQgYW4gYXJyYXkgb2YgaW5zdGFuY2VzLCBidXQgcGxlYXNlIG5vdGljZSB0aGF0IHRoZXNlIG1heSBub3QgY29tcGxldGVseSByZXByZXNlbnQgdGhlIHN0YXRlIG9mIHRoZSByb3dzIGluIHRoZSBEQi4gVGhpcyBpcyBiZWNhdXNlIE15U1FMXG4gICAqIGFuZCBTUUxpdGUgZG8gbm90IG1ha2UgaXQgZWFzeSB0byBvYnRhaW4gYmFjayBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBJRHMgYW5kIG90aGVyIGRlZmF1bHQgdmFsdWVzIGluIGEgd2F5IHRoYXQgY2FuIGJlIG1hcHBlZCB0byBtdWx0aXBsZSByZWNvcmRzLlxuICAgKiBUbyBvYnRhaW4gSW5zdGFuY2VzIGZvciB0aGUgbmV3bHkgY3JlYXRlZCB2YWx1ZXMsIHlvdSB3aWxsIG5lZWQgdG8gcXVlcnkgZm9yIHRoZW0gYWdhaW4uXG4gICAqXG4gICAqIElmIHZhbGlkYXRpb24gZmFpbHMsIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggYW4gYXJyYXktbGlrZSBBZ2dyZWdhdGVFcnJvclxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgcmVjb3JkcyAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdCBvZiBvYmplY3RzIChrZXkvdmFsdWUgcGFpcnMpIHRvIGNyZWF0ZSBpbnN0YW5jZXMgZnJvbVxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgICAgQnVsayBjcmVhdGUgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgW29wdGlvbnMuZmllbGRzXSAgICAgICAgICAgICAgICAgRmllbGRzIHRvIGluc2VydCAoZGVmYXVsdHMgdG8gYWxsIGZpZWxkcylcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnZhbGlkYXRlPWZhbHNlXSAgICAgICAgIFNob3VsZCBlYWNoIHJvdyBiZSBzdWJqZWN0IHRvIHZhbGlkYXRpb24gYmVmb3JlIGl0IGlzIGluc2VydGVkLiBUaGUgd2hvbGUgaW5zZXJ0IHdpbGwgZmFpbCBpZiBvbmUgcm93IGZhaWxzIHZhbGlkYXRpb25cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgICAgIFJ1biBiZWZvcmUgLyBhZnRlciBidWxrIGNyZWF0ZSBob29rcz9cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmluZGl2aWR1YWxIb29rcz1mYWxzZV0gIFJ1biBiZWZvcmUgLyBhZnRlciBjcmVhdGUgaG9va3MgZm9yIGVhY2ggaW5kaXZpZHVhbCBJbnN0YW5jZT8gQnVsa0NyZWF0ZSBob29rcyB3aWxsIHN0aWxsIGJlIHJ1biBpZiBvcHRpb25zLmhvb2tzIGlzIHRydWUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzPWZhbHNlXSBJZ25vcmUgZHVwbGljYXRlIHZhbHVlcyBmb3IgcHJpbWFyeSBrZXlzPyAobm90IHN1cHBvcnRlZCBieSBNU1NRTCBvciBQb3N0Z3JlcyA8IDkuNSlcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIFtvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlXSAgICAgIEZpZWxkcyB0byB1cGRhdGUgaWYgcm93IGtleSBhbHJlYWR5IGV4aXN0cyAob24gZHVwbGljYXRlIGtleSB1cGRhdGUpPyAob25seSBzdXBwb3J0ZWQgYnkgTXlTUUwsIE1hcmlhREIsIFNRTGl0ZSA+PSAzLjI0LjAgJiBQb3N0Z3JlcyA+PSA5LjUpLiBCeSBkZWZhdWx0LCBhbGwgZmllbGRzIGFyZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtib29sZWFufEFycmF5fSAgW29wdGlvbnMucmV0dXJuaW5nPWZhbHNlXSAgICAgICAgSWYgdHJ1ZSwgYXBwZW5kIFJFVFVSTklORyA8bW9kZWwgY29sdW1ucz4gdG8gZ2V0IGJhY2sgYWxsIGRlZmluZWQgdmFsdWVzOyBpZiBhbiBhcnJheSBvZiBjb2x1bW4gbmFtZXMsIGFwcGVuZCBSRVRVUk5JTkcgPGNvbHVtbnM+IHRvIGdldCBiYWNrIHNwZWNpZmljIGNvbHVtbnMgKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdICAgICBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNb2RlbD4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGJ1bGtDcmVhdGUocmVjb3Jkcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGRpYWxlY3QgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3Q7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG5cbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZXMgPSByZWNvcmRzLm1hcCh2YWx1ZXMgPT4gdGhpcy5idWlsZCh2YWx1ZXMsIHsgaXNOZXdSZWNvcmQ6IHRydWUsIGluY2x1ZGU6IG9wdGlvbnMuaW5jbHVkZSB9KSk7XG5cbiAgICBjb25zdCByZWN1cnNpdmVCdWxrQ3JlYXRlID0gYXN5bmMgKGluc3RhbmNlcywgb3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICBob29rczogdHJ1ZSxcbiAgICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVybmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAmJiBbJ21zc3FsJ10uaW5jbHVkZXMoZGlhbGVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RpYWxlY3R9IGRvZXMgbm90IHN1cHBvcnQgdGhlIGlnbm9yZUR1cGxpY2F0ZXMgb3B0aW9uLmApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgJiYgKGRpYWxlY3QgIT09ICdteXNxbCcgJiYgZGlhbGVjdCAhPT0gJ21hcmlhZGInICYmIGRpYWxlY3QgIT09ICdzcWxpdGUnICYmIGRpYWxlY3QgIT09ICdwb3N0Z3JlcycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkaWFsZWN0fSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB1cGRhdGVPbkR1cGxpY2F0ZSBvcHRpb24uYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcblxuICAgICAgb3B0aW9ucy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcyB8fCBPYmplY3Qua2V5cyhtb2RlbC5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuXG4gICAgICBpZiAob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpICYmIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IF8uaW50ZXJzZWN0aW9uKFxuICAgICAgICAgICAgXy53aXRob3V0KE9iamVjdC5rZXlzKG1vZGVsLnRhYmxlQXR0cmlidXRlcyksIGNyZWF0ZWRBdEF0dHIpLFxuICAgICAgICAgICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVPbkR1cGxpY2F0ZSBvcHRpb24gb25seSBzdXBwb3J0cyBub24tZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgICBhd2FpdCBtb2RlbC5ydW5Ib29rcygnYmVmb3JlQnVsa0NyZWF0ZScsIGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvLyBWYWxpZGF0ZVxuICAgICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmluZGl2aWR1YWxIb29rcztcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIGluc3RhbmNlID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2UudmFsaWRhdGUodmFsaWRhdGVPcHRpb25zKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuQnVsa1JlY29yZEVycm9yKGVyciwgaW5zdGFuY2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcblxuICAgICAgICBkZWxldGUgb3B0aW9ucy5za2lwO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgaW5zdGFuY2UgPT4ge1xuICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWxPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGhvb2tzOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuZmllbGRzO1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pbmRpdmlkdWFsSG9va3M7XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXM7XG5cbiAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluZGl2aWR1YWxPcHRpb25zKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSAmJiBvcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5pbmNsdWRlLmZpbHRlcihpbmNsdWRlID0+IGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8pLm1hcChhc3luYyBpbmNsdWRlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZXMucHVzaChhc3NvY2lhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYXNzb2NpYXRpb25JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSlcbiAgICAgICAgICAgICAgLm9taXQoWydhc3NvY2lhdGlvbiddKVxuICAgICAgICAgICAgICAuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZ1xuICAgICAgICAgICAgICB9KS52YWx1ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMgPSBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGFzc29jaWF0aW9uSW5zdGFuY2VzLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlc1tpZHhdO1xuICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXBbaWR4XTtcblxuICAgICAgICAgICAgICBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLnNldChpbnN0YW5jZSwgYXNzb2NpYXRpb25JbnN0YW5jZSwgeyBzYXZlOiBmYWxzZSwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgaW4gb25lIHF1ZXJ5XG4gICAgICAgIC8vIFJlY3JlYXRlIHJlY29yZHMgZnJvbSBpbnN0YW5jZXMgdG8gcmVwcmVzZW50IGFueSBjaGFuZ2VzIG1hZGUgaW4gaG9va3Mgb3IgdmFsaWRhdGlvblxuICAgICAgICByZWNvcmRzID0gaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gaW5zdGFuY2UuZGF0YVZhbHVlcztcblxuICAgICAgICAgIC8vIHNldCBjcmVhdGVkQXQvdXBkYXRlZEF0IGF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhdmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbY3JlYXRlZEF0QXR0cl0gPSBub3c7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKGNyZWF0ZWRBdEF0dHIpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goY3JlYXRlZEF0QXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICF2YWx1ZXNbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgICAgICAgIHZhbHVlc1t1cGRhdGVkQXRBdHRyXSA9IG5vdztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvdXQgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModmFsdWVzLCBvcHRpb25zLmZpZWxkcywgbW9kZWwpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgZGVsZXRlIG91dFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXAgYXR0cmlidXRlcyB0byBmaWVsZHMgZm9yIHNlcmlhbCBpZGVudGlmaWNhdGlvblxuICAgICAgICBjb25zdCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIG1vZGVsLnRhYmxlQXR0cmlidXRlcykge1xuICAgICAgICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkIHx8IGF0dHJdID0gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcCB1cGRhdGVPbkR1cGxpY2F0ZSBhdHRyaWJ1dGVzIHRvIGZpZWxkc1xuICAgICAgICBpZiAob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcChhdHRyID0+IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgfHwgYXR0cik7XG4gICAgICAgICAgLy8gR2V0IHByaW1hcnkga2V5cyBmb3IgcG9zdGdyZXMgdG8gZW5hYmxlIHVwZGF0ZU9uRHVwbGljYXRlXG4gICAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gXy5jaGFpbihtb2RlbC5wcmltYXJ5S2V5cykudmFsdWVzKCkubWFwKCdmaWVsZCcpLnZhbHVlKCk7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1vZGVsLnVuaXF1ZUtleXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IF8uY2hhaW4obW9kZWwudW5pcXVlS2V5cykudmFsdWVzKCkuZmlsdGVyKGMgPT4gYy5maWVsZHMubGVuZ3RoID49IDEpLm1hcChjID0+IGMuZmllbGRzKS5yZWR1Y2UoYyA9PiBjWzBdKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcCByZXR1cm5pbmcgYXR0cmlidXRlcyB0byBmaWVsZHNcbiAgICAgICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZXR1cm5pbmcpKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSBvcHRpb25zLnJldHVybmluZy5tYXAoYXR0ciA9PiBfLmdldChtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLCAnZmllbGQnLCBhdHRyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbW9kZWwucXVlcnlJbnRlcmZhY2UuYnVsa0luc2VydChtb2RlbC5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHJlY29yZHMsIG9wdGlvbnMsIGZpZWxkTWFwcGVkQXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCBrZXkgPT09IG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiZcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5nZXQobW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSkgJiZcbiAgICAgICAgICAgICAgICBbJ215c3FsJywgJ21hcmlhZGInLCAnc3FsaXRlJ10uaW5jbHVkZXMoZGlhbGVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcXVlcnkuanMgZm9yIHRoZXNlIERCcyBpcyBibGluZCwgaXQgYXV0b2luY3JlbWVudHMgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeWtleSB2YWx1ZSwgZXZlbiBpZiBpdCB3YXMgc2V0IG1hbnVhbGx5LiBBbHNvLCBpdCBjYW5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbW9yZSByZXN1bHRzIHRoYW4gaW5zdGFuY2VzLCBidWc/LlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVzdWx0W2tleV07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlICYmIG9wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5pbmNsdWRlLmZpbHRlcihpbmNsdWRlID0+ICEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyB8fFxuICAgICAgICAgIGluY2x1ZGUucGFyZW50ICYmIGluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpLm1hcChhc3luYyBpbmNsdWRlID0+IHtcbiAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAgPSBbXTtcblxuICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgYXNzb2NpYXRlZCA9IGluc3RhbmNlLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NvY2lhdGVkKSkgYXNzb2NpYXRlZCA9IFthc3NvY2lhdGVkXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlIG9mIGFzc29jaWF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpIHtcbiAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2Uuc2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSwgaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5IHx8IGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXNzb2NpYXRpb25JbnN0YW5jZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VzLnB1c2goYXNzb2NpYXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcC5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXNzb2NpYXRpb25JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSlcbiAgICAgICAgICAgIC5vbWl0KFsnYXNzb2NpYXRpb24nXSlcbiAgICAgICAgICAgIC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmdcbiAgICAgICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMgPSBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGFzc29jaWF0aW9uSW5zdGFuY2VzLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVNldHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXNbaWR4XTtcbiAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwW2lkeF07XG5cbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXldOiBpbnN0YW5jZS5nZXQoaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXldOiBhc3NvY2lhdGlvbkluc3RhbmNlLmdldChhc3NvY2lhdGlvbkluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdmFsdWVzIGRlZmluZWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgLi4uaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyhpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5fYXV0b0dlbmVyYXRlZCB8fFxuICAgICAgICAgICAgICAgICAgICBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlc1thdHRyXSA9IGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhbHVlU2V0cy5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRocm91Z2hPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpXG4gICAgICAgICAgICAgIC5vbWl0KFsnYXNzb2NpYXRpb24nLCAnYXR0cmlidXRlcyddKVxuICAgICAgICAgICAgICAuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZ1xuICAgICAgICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICAgICAgdGhyb3VnaE9wdGlvbnMubW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbDtcbiAgICAgICAgICAgIGNvbnN0IHRocm91Z2hJbnN0YW5jZXMgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbC5idWxrQnVpbGQodmFsdWVTZXRzLCB0aHJvdWdoT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUodGhyb3VnaEluc3RhbmNlcywgdGhyb3VnaE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYXAgZmllbGRzIGJhY2sgdG8gYXR0cmlidXRlc1xuICAgICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHJdID0gaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdID0gaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgICAgICBpbnN0YW5jZS5jaGFuZ2VkKGF0dHIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc05ld1JlY29yZCA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgICBhd2FpdCBtb2RlbC5ydW5Ib29rcygnYWZ0ZXJCdWxrQ3JlYXRlJywgaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBtb2RlbC4gVGhpcyBpcyBhIGNvbnZlbmllbnQgbWV0aG9kIGZvciBNb2RlbC5kZXN0cm95KHsgdHJ1bmNhdGU6IHRydWUgfSkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgW29wdGlvbnNdIFRoZSBvcHRpb25zIHBhc3NlZCB0byBNb2RlbC5kZXN0cm95IGluIGFkZGl0aW9uIHRvIHRydW5jYXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMuY2FzY2FkZSA9IGZhbHNlXSBUcnVuY2F0ZXMgYWxsIHRhYmxlcyB0aGF0IGhhdmUgZm9yZWlnbi1rZXkgcmVmZXJlbmNlcyB0byB0aGUgbmFtZWQgdGFibGUsIG9yIHRvIGFueSB0YWJsZXMgYWRkZWQgdG8gdGhlIGdyb3VwIGR1ZSB0byBDQVNDQURFLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgIFtvcHRpb25zLnJlc3RhcnRJZGVudGl0eT1mYWxzZV0gQXV0b21hdGljYWxseSByZXN0YXJ0IHNlcXVlbmNlcyBvd25lZCBieSBjb2x1bW5zIG9mIHRoZSB0cnVuY2F0ZWQgdGFibGUuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259ICAgICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZGVzdHJveX0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICovXG4gIHN0YXRpYyBhc3luYyB0cnVuY2F0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcbiAgICBvcHRpb25zLnRydW5jYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXN0cm95KG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBtdWx0aXBsZSBpbnN0YW5jZXMsIG9yIHNldCB0aGVpciBkZWxldGVkQXQgdGltZXN0YW1wIHRvIHRoZSBjdXJyZW50IHRpbWUgaWYgYHBhcmFub2lkYCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveSBvcHRpb25zXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgW29wdGlvbnMud2hlcmVdICAgICAgICAgICAgICAgICBGaWx0ZXIgdGhlIGRlc3Ryb3lcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgICAgIFJ1biBiZWZvcmUgLyBhZnRlciBidWxrIGRlc3Ryb3kgaG9va3M/XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuaW5kaXZpZHVhbEhvb2tzPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgZGVzdHJveSB3aWxsIFNFTEVDVCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgd2hlcmUgcGFyYW1ldGVyIGFuZCB3aWxsIGV4ZWN1dGUgYmVmb3JlIC8gYWZ0ZXIgZGVzdHJveSBob29rcyBvbiBlYWNoIHJvd1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgIFtvcHRpb25zLmxpbWl0XSAgICAgICAgICAgICAgICAgSG93IG1hbnkgcm93cyB0byBkZWxldGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5mb3JjZT1mYWxzZV0gICAgICAgICAgIERlbGV0ZSBpbnN0ZWFkIG9mIHNldHRpbmcgZGVsZXRlZEF0IHRvIGN1cnJlbnQgdGltZXN0YW1wIChvbmx5IGFwcGxpY2FibGUgaWYgYHBhcmFub2lkYCBpcyBlbmFibGVkKVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLnRydW5jYXRlPWZhbHNlXSAgICAgICAgSWYgc2V0IHRvIHRydWUsIGRpYWxlY3RzIHRoYXQgc3VwcG9ydCBpdCB3aWxsIHVzZSBUUlVOQ0FURSBpbnN0ZWFkIG9mIERFTEVURSBGUk9NLiBJZiBhIHRhYmxlIGlzIHRydW5jYXRlZCB0aGUgd2hlcmUgYW5kIGxpbWl0IG9wdGlvbnMgYXJlIGlnbm9yZWRcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5jYXNjYWRlPWZhbHNlXSAgICAgICAgIE9ubHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFRSVU5DQVRFLiBUcnVuY2F0ZXMgIGFsbCB0YWJsZXMgdGhhdCBoYXZlIGZvcmVpZ24ta2V5IHJlZmVyZW5jZXMgdG8gdGhlIG5hbWVkIHRhYmxlLCBvciB0byBhbnkgdGFibGVzIGFkZGVkIHRvIHRoZSBncm91cCBkdWUgdG8gQ0FTQ0FERS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHk9ZmFsc2VdIE9ubHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFRSVU5DQVRFLiBBdXRvbWF0aWNhbGx5IHJlc3RhcnQgc2VxdWVuY2VzIG93bmVkIGJ5IGNvbHVtbnMgb2YgdGhlIHRydW5jYXRlZCB0YWJsZS5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgbnVtYmVyIG9mIGRlc3Ryb3llZCByb3dzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVzdHJveShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8ICEob3B0aW9ucy53aGVyZSB8fCBvcHRpb25zLnRydW5jYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHdoZXJlIG9yIHRydW5jYXRlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgbW9kZWwuZGVzdHJveS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudHJ1bmNhdGUgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLndoZXJlKSAmJiAhKG9wdGlvbnMud2hlcmUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBsYWluIG9iamVjdCwgYXJyYXkgb3Igc2VxdWVsaXplIG1ldGhvZCBpbiB0aGUgb3B0aW9ucy53aGVyZSBwYXJhbWV0ZXIgb2YgbW9kZWwuZGVzdHJveS4nKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICBjYXNjYWRlOiBmYWxzZSxcbiAgICAgIHJlc3RhcnRJZGVudGl0eTogZmFsc2VcbiAgICB9KTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURTtcblxuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cblxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVCdWxrRGVzdHJveScsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIC8vIEdldCBkYW9zIGFuZCBydW4gYmVmb3JlRGVzdHJveSBob29rIG9uIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHsgd2hlcmU6IG9wdGlvbnMud2hlcmUsIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmsgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5ydW5Ib29rcygnYmVmb3JlRGVzdHJveScsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIC8vIFJ1biBkZWxldGUgcXVlcnkgKG9yIHVwZGF0ZSBpZiBwYXJhbm9pZClcbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIC8vIFNldCBxdWVyeSB0eXBlIGFwcHJvcHJpYXRlbHkgd2hlbiBydW5uaW5nIHNvZnQgZGVsZXRlXG4gICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG5cbiAgICAgIGNvbnN0IGF0dHJWYWx1ZUhhc2ggPSB7fTtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0uZmllbGQ7XG4gICAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgICAgW2ZpZWxkXTogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGxcbiAgICAgIH07XG5cblxuICAgICAgYXR0clZhbHVlSGFzaFtmaWVsZF0gPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgYXR0clZhbHVlSGFzaCwgT2JqZWN0LmFzc2lnbih3aGVyZSwgb3B0aW9ucy53aGVyZSksIG9wdGlvbnMsIHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa0RlbGV0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlckRlc3Ryb3kgaG9vayBvbiBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHlcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHRoaXMucnVuSG9va3MoJ2FmdGVyRGVzdHJveScsIGluc3RhbmNlLCBvcHRpb25zKSlcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyQnVsa0Rlc3Ryb3knLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIG11bHRpcGxlIGluc3RhbmNlcyBpZiBgcGFyYW5vaWRgIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlIG9wdGlvbnNcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBbb3B0aW9ucy53aGVyZV0gICAgICAgICAgICAgICAgIEZpbHRlciB0aGUgcmVzdG9yZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgICAgUnVuIGJlZm9yZSAvIGFmdGVyIGJ1bGsgcmVzdG9yZSBob29rcz9cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5pbmRpdmlkdWFsSG9va3M9ZmFsc2VdIElmIHNldCB0byB0cnVlLCByZXN0b3JlIHdpbGwgZmluZCBhbGwgcmVjb3JkcyB3aXRoaW4gdGhlIHdoZXJlIHBhcmFtZXRlciBhbmQgd2lsbCBleGVjdXRlIGJlZm9yZSAvIGFmdGVyIGJ1bGtSZXN0b3JlIGhvb2tzIG9uIGVhY2ggcm93XG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgW29wdGlvbnMubGltaXRdICAgICAgICAgICAgICAgICBIb3cgbWFueSByb3dzIHRvIHVuZGVsZXRlIChvbmx5IGZvciBteXNxbClcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgcmVzdG9yZShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkgdGhyb3cgbmV3IEVycm9yKCdNb2RlbCBpcyBub3QgcGFyYW5vaWQnKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuUkFXO1xuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVCdWxrUmVzdG9yZScsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgLy8gR2V0IGRhb3MgYW5kIHJ1biBiZWZvcmVSZXN0b3JlIGhvb2sgb24gZWFjaCByZWNvcmQgaW5kaXZpZHVhbGx5XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoeyB3aGVyZTogb3B0aW9ucy53aGVyZSwgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZywgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyaywgcGFyYW5vaWQ6IGZhbHNlIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHRoaXMucnVuSG9va3MoJ2JlZm9yZVJlc3RvcmUnLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgLy8gUnVuIHVuZGVsZXRlIHF1ZXJ5XG4gICAgY29uc3QgYXR0clZhbHVlSGFzaCA9IHt9O1xuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuXG4gICAgYXR0clZhbHVlSGFzaFtkZWxldGVkQXRBdHRyaWJ1dGUuZmllbGQgfHwgZGVsZXRlZEF0Q29sXSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZTtcbiAgICBvcHRpb25zLm9taXROdWxsID0gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBhdHRyVmFsdWVIYXNoLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIC8vIFJ1biBhZnRlckRlc3Ryb3kgaG9vayBvbiBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHlcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHRoaXMucnVuSG9va3MoJ2FmdGVyUmVzdG9yZScsIGluc3RhbmNlLCBvcHRpb25zKSlcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyQnVsa1Jlc3RvcmUnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIHRoYXQgbWF0Y2ggdGhlIHdoZXJlIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICB2YWx1ZXMgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggb2YgdmFsdWVzIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgb3B0aW9ucy53aGVyZSAgICAgICAgICAgICAgICAgICBPcHRpb25zIHRvIGRlc2NyaWJlIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMucGFyYW5vaWQ9dHJ1ZV0gICAgICAgICBJZiB0cnVlLCBvbmx5IG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSB1cGRhdGVkLiBJZiBmYWxzZSwgYm90aCBkZWxldGVkIGFuZCBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgdXBkYXRlZC4gT25seSBhcHBsaWVzIGlmIGBvcHRpb25zLnBhcmFub2lkYCBpcyB0cnVlIGZvciB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICBbb3B0aW9ucy5maWVsZHNdICAgICAgICAgICAgICAgIEZpZWxkcyB0byB1cGRhdGUgKGRlZmF1bHRzIHRvIGFsbCBmaWVsZHMpXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy52YWxpZGF0ZT10cnVlXSAgICAgICAgIFNob3VsZCBlYWNoIHJvdyBiZSBzdWJqZWN0IHRvIHZhbGlkYXRpb24gYmVmb3JlIGl0IGlzIGluc2VydGVkLiBUaGUgd2hvbGUgaW5zZXJ0IHdpbGwgZmFpbCBpZiBvbmUgcm93IGZhaWxzIHZhbGlkYXRpb25cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgICAgUnVuIGJlZm9yZSAvIGFmdGVyIGJ1bGsgdXBkYXRlIGhvb2tzP1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuc2lkZUVmZmVjdHM9dHJ1ZV0gICAgICBXaGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgdGhlIHNpZGUgZWZmZWN0cyBvZiBhbnkgdmlydHVhbCBzZXR0ZXJzLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaW5kaXZpZHVhbEhvb2tzPWZhbHNlXSBSdW4gYmVmb3JlIC8gYWZ0ZXIgdXBkYXRlIGhvb2tzPy4gSWYgdHJ1ZSwgdGhpcyB3aWxsIGV4ZWN1dGUgYSBTRUxFQ1QgZm9sbG93ZWQgYnkgaW5kaXZpZHVhbCBVUERBVEVzLiBBIHNlbGVjdCBpcyBuZWVkZWQsIGJlY2F1c2UgdGhlIHJvdyBkYXRhIG5lZWRzIHRvIGJlIHBhc3NlZCB0byB0aGUgaG9va3NcbiAgICogQHBhcmFtICB7Ym9vbGVhbnxBcnJheX0gIFtvcHRpb25zLnJldHVybmluZz1mYWxzZV0gICAgICAgSWYgdHJ1ZSwgYXBwZW5kIFJFVFVSTklORyA8bW9kZWwgY29sdW1ucz4gdG8gZ2V0IGJhY2sgYWxsIGRlZmluZWQgdmFsdWVzOyBpZiBhbiBhcnJheSBvZiBjb2x1bW4gbmFtZXMsIGFwcGVuZCBSRVRVUk5JTkcgPGNvbHVtbnM+IHRvIGdldCBiYWNrIHNwZWNpZmljIGNvbHVtbnMgKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICBbb3B0aW9ucy5saW1pdF0gICAgICAgICAgICAgICAgIEhvdyBtYW55IHJvd3MgdG8gdXBkYXRlIChvbmx5IGZvciBteXNxbCBhbmQgbWFyaWFkYiwgaW1wbGVtZW50ZWQgYXMgVE9QKG4pIGZvciBNU1NRTDsgZm9yIHNxbGl0ZSBpdCBpcyBzdXBwb3J0ZWQgb25seSB3aGVuIHJvd2lkIGlzIHByZXNlbnQpXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdICAgICAgICAgIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PG51bWJlcixudW1iZXI+Pn0gIFRoZSBwcm9taXNlIHJldHVybnMgYW4gYXJyYXkgd2l0aCBvbmUgb3IgdHdvIGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyBhbHdheXMgdGhlIG51bWJlclxuICAgKiBvZiBhZmZlY3RlZCByb3dzLCB3aGlsZSB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGFjdHVhbCBhZmZlY3RlZCByb3dzIChvbmx5IHN1cHBvcnRlZCBpbiBwb3N0Z3JlcyB3aXRoIGBvcHRpb25zLnJldHVybmluZ2AgdHJ1ZSkuXG4gICAqXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBkYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICB0aGlzLl9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgcmV0dXJuaW5nOiBmYWxzZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIHNpZGVFZmZlY3RzOiB0cnVlXG4gICAgfSkpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuXG4gICAgLy8gQ2xvbmUgdmFsdWVzIHNvIGl0IGRvZXNuJ3QgZ2V0IG1vZGlmaWVkIGZvciBjYWxsZXIgc2NvcGUgYW5kIGlnbm9yZSB1bmRlZmluZWQgdmFsdWVzXG4gICAgdmFsdWVzID0gXy5vbWl0QnkodmFsdWVzLCB2YWx1ZSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgIC8vIFJlbW92ZSB2YWx1ZXMgdGhhdCBhcmUgbm90IGluIHRoZSBvcHRpb25zLmZpZWxkc1xuICAgIGlmIChvcHRpb25zLmZpZWxkcyAmJiBvcHRpb25zLmZpZWxkcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKE9iamVjdC5rZXlzKHZhbHVlcyksIE9iamVjdC5rZXlzKHRoaXMudGFibGVBdHRyaWJ1dGVzKSk7XG4gICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB2YWx1ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCkgfHwgVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgICBsZXQgdmFsdWVzVXNlO1xuICAgIC8vIFZhbGlkYXRlXG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGNvbnN0IGJ1aWxkID0gdGhpcy5idWlsZCh2YWx1ZXMpO1xuICAgICAgYnVpbGQuc2V0KHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0LCB2YWx1ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdLCB7IHJhdzogdHJ1ZSB9KTtcblxuICAgICAgaWYgKG9wdGlvbnMuc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIF8ucGljayhidWlsZC5nZXQoKSwgYnVpbGQuY2hhbmdlZCgpKSk7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlvbihvcHRpb25zLmZpZWxkcywgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHdhbnQgdG8gc2tpcCB2YWxpZGF0aW9ucyBmb3IgYWxsIG90aGVyIGZpZWxkc1xuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyksIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGF3YWl0IGJ1aWxkLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5za2lwID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5kYXRhVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IF8ucGljayhhdHRyaWJ1dGVzLmRhdGFWYWx1ZXMsIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdmFsdWVzO1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlQnVsa1VwZGF0ZScsIG9wdGlvbnMpO1xuICAgICAgdmFsdWVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICB2YWx1ZXNVc2UgPSB2YWx1ZXM7XG5cbiAgICAvLyBHZXQgaW5zdGFuY2VzIGFuZCBydW4gYmVmb3JlVXBkYXRlIGhvb2sgb24gZWFjaCByZWNvcmQgaW5kaXZpZHVhbGx5XG4gICAgbGV0IGluc3RhbmNlcztcbiAgICBsZXQgdXBkYXRlRG9uZVJvd0J5Um93ID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoe1xuICAgICAgICB3aGVyZTogb3B0aW9ucy53aGVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyayxcbiAgICAgICAgcGFyYW5vaWQ6IG9wdGlvbnMucGFyYW5vaWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAvLyBSdW4gYmVmb3JlVXBkYXRlIGhvb2tzIG9uIGVhY2ggcmVjb3JkIGFuZCBjaGVjayB3aGV0aGVyIGJlZm9yZVVwZGF0ZSBob29rIGNoYW5nZXMgdmFsdWVzIHVuaWZvcm1seVxuICAgICAgICAvLyBpLmUuIHdoZXRoZXIgdGhleSBjaGFuZ2UgdmFsdWVzIGZvciBlYWNoIHJlY29yZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgbGV0IGNoYW5nZWRWYWx1ZXM7XG4gICAgICAgIGxldCBkaWZmZXJlbnQgPSBmYWxzZTtcblxuICAgICAgICBpbnN0YW5jZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIGluc3RhbmNlID0+IHtcbiAgICAgICAgICAvLyBSZWNvcmQgdXBkYXRlcyBpbiBpbnN0YW5jZXMgZGF0YVZhbHVlc1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICAgICAgICAvLyBTZXQgdGhlIGNoYW5nZWQgZmllbGRzIG9uIHRoZSBpbnN0YW5jZVxuICAgICAgICAgIF8uZm9ySW4odmFsdWVzVXNlLCAobmV3VmFsdWUsIGF0dHIpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZXREYXRhVmFsdWUoYXR0ciwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUnVuIGJlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlVXBkYXRlJywgaW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzQ2hhbmdlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXy5mb3JJbihpbnN0YW5jZS5kYXRhVmFsdWVzLCAobmV3VmFsdWUsIGF0dHIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NoYW5nZWRWYWx1ZXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghY2hhbmdlZFZhbHVlcykge1xuICAgICAgICAgICAgICBjaGFuZ2VkVmFsdWVzID0gdGhpc0NoYW5nZWRWYWx1ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaWZmZXJlbnQgPSAhXy5pc0VxdWFsKGNoYW5nZWRWYWx1ZXMsIHRoaXNDaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICAvLyBIb29rcyBkbyBub3QgY2hhbmdlIHZhbHVlcyBvciBjaGFuZ2UgdGhlbSB1bmlmb3JtbHlcbiAgICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEhvb2tzIGNoYW5nZSB2YWx1ZXMgLSByZWNvcmQgY2hhbmdlcyBpbiB2YWx1ZXNVc2Ugc28gdGhleSBhcmUgZXhlY3V0ZWRcbiAgICAgICAgICAgIHZhbHVlc1VzZSA9IGNoYW5nZWRWYWx1ZXM7XG4gICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pb24ob3B0aW9ucy5maWVsZHMsIGtleXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWxPcHRpb25zID0ge1xuICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICBob29rczogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pbmRpdmlkdWFsSG9va3M7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5zYXZlKGluZGl2aWR1YWxPcHRpb25zKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdXBkYXRlRG9uZVJvd0J5Um93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh1cGRhdGVEb25lUm93QnlSb3cpIHtcbiAgICAgIHJlc3VsdCA9IFtpbnN0YW5jZXMubGVuZ3RoLCBpbnN0YW5jZXNdO1xuICAgIH0gZWxzZSBpZiAoXy5pc0VtcHR5KHZhbHVlc1VzZSlcbiAgICAgICB8fCBPYmplY3Qua2V5cyh2YWx1ZXNVc2UpLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNVc2VbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZWRBdCBpcyBiZWluZyBwYXNzZWQsIHRoZW4gc2tpcCB1cGRhdGVcbiAgICAgIHJlc3VsdCA9IFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzVXNlID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHZhbHVlc1VzZSwgb3B0aW9ucy5maWVsZHMsIHRoaXMpO1xuICAgICAgb3B0aW9ucyA9IFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuaGFzVHJpZ2dlciA6IGZhbHNlO1xuXG4gICAgICBjb25zdCBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlc1VzZSwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcy50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJlc3VsdCA9IFthZmZlY3RlZFJvd3MubGVuZ3RoLCBhZmZlY3RlZFJvd3NdO1xuICAgICAgICBpbnN0YW5jZXMgPSBhZmZlY3RlZFJvd3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbYWZmZWN0ZWRSb3dzXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5ydW5Ib29rcygnYWZ0ZXJVcGRhdGUnLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICAgIHJlc3VsdFsxXSA9IGluc3RhbmNlcztcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdmFsdWVzO1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJCdWxrVXBkYXRlJywgb3B0aW9ucyk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhIGRlc2NyaWJlIHF1ZXJ5IG9uIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzY2hlbWFdIHNjaGVtYSBuYW1lIHRvIHNlYXJjaCB0YWJsZSBpblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIHF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IGhhc2ggb2YgYXR0cmlidXRlcyBhbmQgdGhlaXIgdHlwZXNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZXNjcmliZShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kZXNjcmliZVRhYmxlKHRoaXMudGFibGVOYW1lLCB7IHNjaGVtYTogc2NoZW1hIHx8IHRoaXMuX3NjaGVtYSB8fCB1bmRlZmluZWQsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICBzdGF0aWMgX2dldERlZmF1bHRUaW1lc3RhbXAoYXR0cikge1xuICAgIGlmICghIXRoaXMucmF3QXR0cmlidXRlc1thdHRyXSAmJiAhIXRoaXMucmF3QXR0cmlidXRlc1thdHRyXS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGlscy50b0RlZmF1bHRWYWx1ZSh0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZGVmYXVsdFZhbHVlLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhdGljIF9leHBhbmRBdHRyaWJ1dGVzKG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKTtcblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMuZXhjbHVkZSkge1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuZmlsdGVyKGVsZW0gPT4gIW9wdGlvbnMuYXR0cmlidXRlcy5leGNsdWRlLmluY2x1ZGVzKGVsZW0pKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGUpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuXG4gIC8vIEluamVjdCBfc2NvcGUgaW50byBvcHRpb25zLlxuICBzdGF0aWMgX2luamVjdFNjb3BlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY29wZSA9IFV0aWxzLmNsb25lRGVlcCh0aGlzLl9zY29wZSk7XG4gICAgdGhpcy5fZGVmYXVsdHNPcHRpb25zKG9wdGlvbnMsIHNjb3BlKTtcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBoYXNBbGlhcyhhbGlhcykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hc3NvY2lhdGlvbnMsIGFsaWFzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHZhbHVlIG9mIG9uZSBvciBtb3JlIGNvbHVtbnMuIFRoaXMgaXMgZG9uZSBpbiB0aGUgZGF0YWJhc2UsIHdoaWNoIG1lYW5zIGl0IGRvZXMgbm90IHVzZSB0aGUgdmFsdWVzIGN1cnJlbnRseSBzdG9yZWQgb24gdGhlIEluc3RhbmNlLiBUaGUgaW5jcmVtZW50IGlzIGRvbmUgdXNpbmcgYVxuICAgKiBgYGAgU0VUIGNvbHVtbiA9IGNvbHVtbiArIFggV0hFUkUgZm9vID0gJ2JhcicgYGBgIHF1ZXJ5LiBUbyBnZXQgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgYW4gaW5jcmVtZW50IGludG8gdGhlIEluc3RhbmNlIHlvdSBzaG91bGQgZG8gYSByZWxvYWQuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmluY3JlbWVudCBudW1iZXIgYnkgMTwvY2FwdGlvbj5cbiAgICogTW9kZWwuaW5jcmVtZW50KCdudW1iZXInLCB7IHdoZXJlOiB7IGZvbzogJ2JhcicgfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmluY3JlbWVudCBudW1iZXIgYW5kIGNvdW50IGJ5IDI8L2NhcHRpb24+XG4gICAqIE1vZGVsLmluY3JlbWVudChbJ251bWJlcicsICdjb3VudCddLCB7IGJ5OiAyLCB3aGVyZTogeyBmb286ICdiYXInIH0gfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmluY3JlbWVudCBhbnN3ZXIgYnkgNDIsIGFuZCBkZWNyZW1lbnQgdHJpZXMgYnkgMTwvY2FwdGlvbj5cbiAgICogLy8gYGJ5YCBpcyBpZ25vcmVkLCBhcyBlYWNoIGNvbHVtbiBoYXMgaXRzIG93biB2YWx1ZVxuICAgKiBNb2RlbC5pbmNyZW1lbnQoeyBhbnN3ZXI6IDQyLCB0cmllczogLTF9LCB7IGJ5OiAyLCB3aGVyZTogeyBmb286ICdiYXInIH0gfSk7XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3JlbG9hZH1cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fG9iamVjdH0gIGZpZWxkcyAgICAgICAgICAgICAgICAgICAgICAgSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoYXQgY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBvZiBgYnlgIGdpdmVuIGluIG9wdGlvbnMuIElmIGFuIGFycmF5IGlzIHByb3ZpZGVkLCB0aGUgc2FtZSBpcyB0cnVlIGZvciBlYWNoIGNvbHVtbi4gSWYgYW5kIG9iamVjdCBpcyBwcm92aWRlZCwgZWFjaCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIGdpdmVuLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgb3B0aW9ucy53aGVyZSAgICAgICAgICAgICAgICBjb25kaXRpb25zIGhhc2hcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgIFtvcHRpb25zLmJ5PTFdICAgICAgICAgICAgICAgVGhlIG51bWJlciB0byBpbmNyZW1lbnQgYnlcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgIFtvcHRpb25zLnNpbGVudD1mYWxzZV0gICAgICAgSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICAgICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbFtdLD9udW1iZXI+fSByZXR1cm5zIGFuIGFycmF5IG9mIGFmZmVjdGVkIHJvd3MgYW5kIGFmZmVjdGVkIGNvdW50IHdpdGggYG9wdGlvbnMucmV0dXJuaW5nYCB0cnVlLCB3aGVuZXZlciBzdXBwb3J0ZWQgYnkgZGlhbGVjdFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpIGZpZWxkcyA9IFtmaWVsZHNdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGZpZWxkcyA9IGZpZWxkcy5tYXAoZiA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJhd0F0dHJpYnV0ZXNbZl0gJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAhPT0gZikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICB0aGlzLl9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyh7fSwgb3B0aW9ucywge1xuICAgICAgYnk6IDEsXG4gICAgICB3aGVyZToge30sXG4gICAgICBpbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpc1N1YnRyYWN0aW9uID0gIW9wdGlvbnMuaW5jcmVtZW50O1xuXG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcblxuICAgIGNvbnN0IHdoZXJlID0geyAuLi5vcHRpb25zLndoZXJlIH07XG5cbiAgICAvLyBBIHBsYWluIG9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgZmllbGRzIHRvIGJlIGluY3JlbWVudGVkIGFuZCB3aG9zZSB2YWx1ZXMgYXJlXG4gICAgLy8gdGhlIGFtb3VudHMgdG8gYmUgaW5jcmVtZW50ZWQgYnkuXG4gICAgbGV0IGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkW2ZpZWxkXSA9IG9wdGlvbnMuYnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBgZmllbGRzYCBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXksIHRoZW4gd2UgYXNzdW1lIGl0IGFscmVhZHkgaGFzIHRoZVxuICAgICAgLy8gZm9ybSBuZWNlc3NhcnkgdG8gYmUgcGxhY2VkIGRpcmVjdGx5IGluIHRoZSBgaW5jcmVtZW50QW1vdW50c0J5RmllbGRgIHZhcmlhYmxlLlxuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSBmaWVsZHM7XG4gICAgfVxuXG4gICAgLy8gSWYgb3B0aW1pc3RpYyBsb2NraW5nIGlzIGVuYWJsZWQsIHdlIGNhbiB0YWtlIGFkdmFudGFnZSB0aGF0IHRoaXMgaXMgYW5cbiAgICAvLyBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhdGlvbiBhbmQgc2VuZCBpdCBoZXJlIGFzIHdlbGwuIFdlIHB1dCBgLTFgIGZvclxuICAgIC8vIGRlY3JlbWVudGluZyBiZWNhdXNlIGl0IHdpbGwgYmUgc3VidHJhY3RlZCwgZ2V0dGluZyBgLSgtMSlgIHdoaWNoIGlzIGArMWBcbiAgICBpZiAodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGRbdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZV0gPSBpc1N1YnRyYWN0aW9uID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkID0ge307XG5cbiAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiB1cGRhdGVkQXRBdHRyICYmICFpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFt1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdXBkYXRlZEF0QXR0cl0uZmllbGQgfHwgdXBkYXRlZEF0QXR0cjtcbiAgICAgIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkW2F0dHJOYW1lXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyk7XG4gICAgbGV0IGFmZmVjdGVkUm93cztcbiAgICBpZiAoaXNTdWJ0cmFjdGlvbikge1xuICAgICAgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kZWNyZW1lbnQoXG4gICAgICAgIHRoaXMsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5pbmNyZW1lbnQoXG4gICAgICAgIHRoaXMsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIHJldHVybiBbYWZmZWN0ZWRSb3dzLCBhZmZlY3RlZFJvd3MubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FmZmVjdGVkUm93c107XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVtZW50IHRoZSB2YWx1ZSBvZiBvbmUgb3IgbW9yZSBjb2x1bW5zLiBUaGlzIGlzIGRvbmUgaW4gdGhlIGRhdGFiYXNlLCB3aGljaCBtZWFucyBpdCBkb2VzIG5vdCB1c2UgdGhlIHZhbHVlcyBjdXJyZW50bHkgc3RvcmVkIG9uIHRoZSBJbnN0YW5jZS4gVGhlIGRlY3JlbWVudCBpcyBkb25lIHVzaW5nIGFcbiAgICogYGBgc3FsIFNFVCBjb2x1bW4gPSBjb2x1bW4gLSBYIFdIRVJFIGZvbyA9ICdiYXInYGBgIHF1ZXJ5LiBUbyBnZXQgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgYSBkZWNyZW1lbnQgaW50byB0aGUgSW5zdGFuY2UgeW91IHNob3VsZCBkbyBhIHJlbG9hZC5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+ZGVjcmVtZW50IG51bWJlciBieSAxPC9jYXB0aW9uPlxuICAgKiBNb2RlbC5kZWNyZW1lbnQoJ251bWJlcicsIHsgd2hlcmU6IHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+ZGVjcmVtZW50IG51bWJlciBhbmQgY291bnQgYnkgMjwvY2FwdGlvbj5cbiAgICogTW9kZWwuZGVjcmVtZW50KFsnbnVtYmVyJywgJ2NvdW50J10sIHsgYnk6IDIsIHdoZXJlOiB7IGZvbzogJ2JhcicgfSB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+ZGVjcmVtZW50IGFuc3dlciBieSA0MiwgYW5kIGRlY3JlbWVudCB0cmllcyBieSAtMTwvY2FwdGlvbj5cbiAgICogLy8gYGJ5YCBpcyBpZ25vcmVkLCBzaW5jZSBlYWNoIGNvbHVtbiBoYXMgaXRzIG93biB2YWx1ZVxuICAgKiBNb2RlbC5kZWNyZW1lbnQoeyBhbnN3ZXI6IDQyLCB0cmllczogLTF9LCB7IGJ5OiAyLCB3aGVyZTogeyBmb286ICdiYXInIH0gfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fG9iamVjdH0gZmllbGRzIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGF0IGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgb2YgYGJ5YCBnaXZlbiBpbiBvcHRpb25zLiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgZWFjaCBjb2x1bW4uIElmIGFuZCBvYmplY3QgaXMgcHJvdmlkZWQsIGVhY2ggY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBnaXZlbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgZGVjcmVtZW50IG9wdGlvbnMsIHNpbWlsYXIgdG8gaW5jcmVtZW50XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmluY3JlbWVudH1cbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjcmVsb2FkfVxuICAgKiBAc2luY2UgNC4zNi4wXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsW10sP251bWJlcj59IHJldHVybnMgYW4gYXJyYXkgb2YgYWZmZWN0ZWQgcm93cyBhbmQgYWZmZWN0ZWQgY291bnQgd2l0aCBgb3B0aW9ucy5yZXR1cm5pbmdgIHRydWUsIHdoZW5ldmVyIHN1cHBvcnRlZCBieSBkaWFsZWN0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVjcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudChmaWVsZHMsIHtcbiAgICAgIGJ5OiAxLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGluY3JlbWVudDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBfb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucykge1xuICAgIGFzc2VydChvcHRpb25zICYmIG9wdGlvbnMud2hlcmUsICdNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXInKTtcbiAgICBhc3NlcnQoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy53aGVyZSkgfHwgb3B0aW9ucy53aGVyZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCxcbiAgICAgICdFeHBlY3RlZCBwbGFpbiBvYmplY3QsIGFycmF5IG9yIHNlcXVlbGl6ZSBtZXRob2QgaW4gdGhlIG9wdGlvbnMud2hlcmUgcGFyYW1ldGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHF1ZXJ5IGZvciB0aGlzIGluc3RhbmNlLCB1c2Ugd2l0aCBgb3B0aW9ucy53aGVyZWBcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tWZXJzaW9uPWZhbHNlXSBpbmNsdWRlIHZlcnNpb24gYXR0cmlidXRlIGluIHdoZXJlIGhhc2hcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHdoZXJlKGNoZWNrVmVyc2lvbikge1xuICAgIGNvbnN0IHdoZXJlID0gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5yZWR1Y2UoKHJlc3VsdCwgYXR0cmlidXRlKSA9PiB7XG4gICAgICByZXN1bHRbYXR0cmlidXRlXSA9IHRoaXMuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcblxuICAgIGlmIChfLnNpemUod2hlcmUpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLndoZXJlQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbkF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl92ZXJzaW9uQXR0cmlidXRlO1xuICAgIGlmIChjaGVja1ZlcnNpb24gJiYgdmVyc2lvbkF0dHIpIHtcbiAgICAgIHdoZXJlW3ZlcnNpb25BdHRyXSA9IHRoaXMuZ2V0KHZlcnNpb25BdHRyLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLm1hcFdoZXJlRmllbGROYW1lcyh3aGVyZSwgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtvYmplY3QgU2VxdWVsaXplSW5zdGFuY2U6JHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XWA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgdW5kZXJseWluZyBkYXRhIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkga2V5IHRvIGxvb2sgaW4gaW5zdGFuY2UgZGF0YSBzdG9yZVxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fVxuICAgKi9cbiAgZ2V0RGF0YVZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHVuZGVybHlpbmcgZGF0YSB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IGtleSB0byBzZXQgaW4gaW5zdGFuY2UgZGF0YSBzdG9yZVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgbmV3IHZhbHVlIGZvciBnaXZlbiBrZXlcbiAgICpcbiAgICovXG4gIHNldERhdGFWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldO1xuXG4gICAgaWYgKCFfLmlzRXF1YWwodmFsdWUsIG9yaWdpbmFsVmFsdWUpKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIG5vIGtleSBpcyBnaXZlbiwgcmV0dXJucyBhbGwgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZSwgYWxzbyBpbnZva2luZyB2aXJ0dWFsIGdldHRlcnMuXG4gICAqXG4gICAqIElmIGtleSBpcyBnaXZlbiBhbmQgYSBmaWVsZCBvciB2aXJ0dWFsIGdldHRlciBpcyBwcmVzZW50IGZvciB0aGUga2V5IGl0IHdpbGwgY2FsbCB0aGF0IGdldHRlciAtIGVsc2UgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIGZvciBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW2tleV0ga2V5IHRvIGdldCB2YWx1ZSBvZlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXSBnZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBsYWluPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgaW5jbHVkZWQgaW5zdGFuY2VzIHdpbGwgYmUgcmV0dXJuZWQgYXMgcGxhaW4gb2JqZWN0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIGZpZWxkIGFuZCB2aXJ0dWFsIHNldHRlcnMgd2lsbCBiZSBpZ25vcmVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R8YW55fVxuICAgKi9cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBrZXk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2N1c3RvbUdldHRlcnMsIGtleSkgJiYgIW9wdGlvbnMucmF3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21HZXR0ZXJzW2tleV0uY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wbGFpbiAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGFWYWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV0ubWFwKGluc3RhbmNlID0+IGluc3RhbmNlLmdldChvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YVZhbHVlc1trZXldIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV0uZ2V0KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuX2hhc0N1c3RvbUdldHRlcnNcbiAgICAgIHx8IG9wdGlvbnMucGxhaW4gJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlXG4gICAgICB8fCBvcHRpb25zLmNsb25lXG4gICAgKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICAgIGxldCBfa2V5O1xuXG4gICAgICBpZiAodGhpcy5faGFzQ3VzdG9tR2V0dGVycykge1xuICAgICAgICBmb3IgKF9rZXkgaW4gdGhpcy5fY3VzdG9tR2V0dGVycykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgICAgICAgJiYgIXRoaXMuX29wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlcyhfa2V5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9jdXN0b21HZXR0ZXJzLCBfa2V5KSkge1xuICAgICAgICAgICAgdmFsdWVzW19rZXldID0gdGhpcy5nZXQoX2tleSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoX2tleSBpbiB0aGlzLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVzLCBfa2V5KVxuICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmRhdGFWYWx1ZXMsIF9rZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIHZhbHVlc1tfa2V5XSA9IHRoaXMuZ2V0KF9rZXksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaXMgdXNlZCB0byB1cGRhdGUgdmFsdWVzIG9uIHRoZSBpbnN0YW5jZSAodGhlIHNlcXVlbGl6ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UgdGhhdCBpcywgcmVtZW1iZXIgdGhhdCBub3RoaW5nIHdpbGwgYmUgcGVyc2lzdGVkIGJlZm9yZSB5b3UgYWN0dWFsbHkgY2FsbCBgc2F2ZWApLlxuICAgKiBJbiBpdHMgbW9zdCBiYXNpYyBmb3JtIGBzZXRgIHdpbGwgdXBkYXRlIGEgdmFsdWUgc3RvcmVkIGluIHRoZSB1bmRlcmx5aW5nIGBkYXRhVmFsdWVzYCBvYmplY3QuIEhvd2V2ZXIsIGlmIGEgY3VzdG9tIHNldHRlciBmdW5jdGlvbiBpcyBkZWZpbmVkIGZvciB0aGUga2V5LCB0aGF0IGZ1bmN0aW9uXG4gICAqIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQuIFRvIGJ5cGFzcyB0aGUgc2V0dGVyLCB5b3UgY2FuIHBhc3MgYHJhdzogdHJ1ZWAgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKlxuICAgKiBJZiBzZXQgaXMgY2FsbGVkIHdpdGggYW4gb2JqZWN0LCBpdCB3aWxsIGxvb3Agb3ZlciB0aGUgb2JqZWN0LCBhbmQgY2FsbCBzZXQgcmVjdXJzaXZlbHkgZm9yIGVhY2gga2V5LCB2YWx1ZSBwYWlyLiBJZiB5b3Ugc2V0IHJhdyB0byB0cnVlLCB0aGUgdW5kZXJseWluZyBkYXRhVmFsdWVzIHdpbGwgZWl0aGVyIGJlXG4gICAqIHNldCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHBhc3NlZCwgb3IgdXNlZCB0byBleHRlbmQgZGF0YVZhbHVlcywgaWYgZGF0YVZhbHVlcyBhbHJlYWR5IGNvbnRhaW4gdmFsdWVzLlxuICAgKlxuICAgKiBXaGVuIHNldCBpcyBjYWxsZWQsIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgZmllbGQgaXMgc3RvcmVkIGFuZCBzZXRzIGEgY2hhbmdlZCBmbGFnKHNlZSBgY2hhbmdlZGApLlxuICAgKlxuICAgKiBTZXQgY2FuIGFsc28gYmUgdXNlZCB0byBidWlsZCBpbnN0YW5jZXMgZm9yIGFzc29jaWF0aW9ucywgaWYgeW91IGhhdmUgdmFsdWVzIGZvciB0aG9zZS5cbiAgICogV2hlbiB1c2luZyBzZXQgd2l0aCBhc3NvY2lhdGlvbnMgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBrZXkgbWF0Y2hlcyB0aGUgYWxpYXMgb2YgdGhlIGFzc29jaWF0aW9uXG4gICAqIHdoaWxlIGFsc28gbWFraW5nIHN1cmUgdGhhdCB0aGUgcHJvcGVyIGluY2x1ZGUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IChmcm9tIC5idWlsZCgpIG9yIC5maW5kT25lKCkpXG4gICAqXG4gICAqIElmIGNhbGxlZCB3aXRoIGEgZG90LnNlcGFyYXRlZCBrZXkgb24gYSBKU09OL0pTT05CIGF0dHJpYnV0ZSBpdCB3aWxsIHNldCB0aGUgdmFsdWUgbmVzdGVkIGFuZCBmbGFnIHRoZSBlbnRpcmUgb2JqZWN0IGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGluY2x1ZGVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0ga2V5IGtleSB0byBzZXQsIGl0IGNhbiBiZSBzdHJpbmcgb3Igb2JqZWN0LiBXaGVuIHN0cmluZyBpdCB3aWxsIHNldCB0aGF0IGtleSwgZm9yIG9iamVjdCBpdCB3aWxsIGxvb3Agb3ZlciBhbGwgb2JqZWN0IHByb3BlcnRpZXMgbmQgc2V0IHRoZW0uXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSB2YWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIGZpZWxkIGFuZCB2aXJ0dWFsIHNldHRlcnMgd2lsbCBiZSBpZ25vcmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzZXQ9ZmFsc2VdIENsZWFyIGFsbCBwcmV2aW91c2x5IHNldCBkYXRhIHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9XG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IG9yaWdpbmFsVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSBrZXk7XG4gICAgICBvcHRpb25zID0gdmFsdWUgfHwge307XG5cbiAgICAgIGlmIChvcHRpb25zLnJlc2V0KSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgcmF3LCBhbmQgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBpbmNsdWRlcyBvciBzcGVjaWFsIGF0dHJpYnV0ZXMsIGp1c3Qgc2V0IGl0IHN0cmFpZ2h0IG9uIHRoZSBkYXRhVmFsdWVzIG9iamVjdFxuICAgICAgaWYgKG9wdGlvbnMucmF3ICYmICEodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUpICYmICEob3B0aW9ucyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMpICYmICF0aGlzLmNvbnN0cnVjdG9yLl9oYXNEYXRlQXR0cmlidXRlcyAmJiAhdGhpcy5jb25zdHJ1Y3Rvci5faGFzQm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGF0YVZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhVmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJhdywgLmNoYW5nZWQoKSBzaG91bGRuJ3QgYmUgdHJ1ZVxuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSB7IC4uLnRoaXMuZGF0YVZhbHVlcyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9vcCBhbmQgY2FsbCBzZXRcbiAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICAgIGNvbnN0IHNldEtleXMgPSBkYXRhID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZXNba10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGssIHZhbHVlc1trXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRLZXlzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBzZXRLZXlzKHRoaXMuY29uc3RydWN0b3IuX3ZpcnR1YWxBdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzKSB7XG4gICAgICAgICAgICBzZXRLZXlzKHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlc1trZXldLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5yYXcpIHtcbiAgICAgICAgICAvLyBJZiByYXcsIC5jaGFuZ2VkKCkgc2hvdWxkbid0IGJlIHRydWVcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSB7IC4uLnRoaXMuZGF0YVZhbHVlcyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGlmICghb3B0aW9ucy5yYXcpIHtcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgcmF3LCBhbmQgdGhlcmUncyBhIGN1c3RvbSBzZXR0ZXJcbiAgICBpZiAoIW9wdGlvbnMucmF3ICYmIHRoaXMuX2N1c3RvbVNldHRlcnNba2V5XSkge1xuICAgICAgdGhpcy5fY3VzdG9tU2V0dGVyc1trZXldLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAvLyBjdXN0b20gc2V0dGVyIHNob3VsZCBoYXZlIGNoYW5nZWQgdmFsdWUsIGdldCB0aGF0IGNoYW5nZWQgdmFsdWVcbiAgICAgIC8vIFRPRE86IHY1IG1ha2Ugc2V0dGVycyByZXR1cm4gbmV3IHZhbHVlIGluc3RlYWQgb2YgY2hhbmdpbmcgaW50ZXJuYWwgc3RvcmVcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgICBpZiAoIV8uaXNFcXVhbChuZXdWYWx1ZSwgb3JpZ2luYWxWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV0gPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBpbmNsdWRlZCBtb2RlbHMsIGFuZCBpZiB0aGlzIGtleSBtYXRjaGVzIHRoZSBpbmNsdWRlIG1vZGVsIG5hbWVzL2FsaWFzZXNcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIC8vIFBhc3MgaXQgb24gdG8gdGhlIGluY2x1ZGUgaGFuZGxlclxuICAgICAgICB0aGlzLl9zZXRJbmNsdWRlKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIEJ1bmNoIG9mIHN0dWZmIHdlIHdvbid0IGRvIHdoZW4gaXQncyByYXdcbiAgICAgIGlmICghb3B0aW9ucy5yYXcpIHtcbiAgICAgICAgLy8gSWYgYXR0cmlidXRlIGlzIG5vdCBpbiBtb2RlbCBkZWZpbml0aW9uLCByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnLicpICYmIHRoaXMuY29uc3RydWN0b3IuX2pzb25BdHRyaWJ1dGVzLmhhcyhrZXkuc3BsaXQoJy4nKVswXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzTmVzdGVkVmFsdWUgPSBEb3R0aWUuZ2V0KHRoaXMuZGF0YVZhbHVlcywga2V5KTtcbiAgICAgICAgICAgIGlmICghXy5pc0VxdWFsKHByZXZpb3VzTmVzdGVkVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBEb3R0aWUuc2V0KHRoaXMuZGF0YVZhbHVlcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZChrZXkuc3BsaXQoJy4nKVswXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBzZXQgcHJpbWFyeSBrZXkgYW5kIHByaW1hcnkga2V5IGlzIGFscmVhZHkgZGVmaW5lZCwgcmV0dXJuXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNQcmltYXJ5S2V5cyAmJiBvcmlnaW5hbFZhbHVlICYmIHRoaXMuY29uc3RydWN0b3IuX2lzUHJpbWFyeUtleShrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhdHRlbXB0aW5nIHRvIHNldCByZWFkIG9ubHkgYXR0cmlidXRlcywgcmV0dXJuXG4gICAgICAgIGlmICghdGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLmNvbnN0cnVjdG9yLl9oYXNSZWFkT25seUF0dHJpYnV0ZXMgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fcmVhZE9ubHlBdHRyaWJ1dGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUncyBhIGRhdGEgdHlwZSBzYW5pdGl6ZXJcbiAgICAgIGlmIChcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZClcbiAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlU2FuaXRpemVycywga2V5KVxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVTYW5pdGl6ZXJzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB3aGVuIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCBhbmQgbm90IHJhd1xuICAgICAgaWYgKFxuICAgICAgICAhb3B0aW9ucy5yYXcgJiZcbiAgICAgICAgKFxuICAgICAgICAgIC8vIFRydWUgd2hlbiBzZXF1ZWxpemUgbWV0aG9kXG4gICAgICAgICAgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGRhdGEgdHlwZSB0eXBlIGNvbXBhcmF0b3JzXG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0gJiYgdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgb3B0aW9ucykgfHwgLy8gQ2hlY2sgZGVmYXVsdFxuICAgICAgICAgICF0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XSAmJiAhXy5pc0VxdWFsKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSlcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBkYXRhIHZhbHVlXG4gICAgICB0aGlzLmRhdGFWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZXModXBkYXRlcykge1xuICAgIHJldHVybiB0aGlzLnNldCh1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBjaGFuZ2VkIGlzIGNhbGxlZCB3aXRoIGEgc3RyaW5nIGl0IHdpbGwgcmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZhbHVlIG9mIHRoYXQga2V5IGluIGBkYXRhVmFsdWVzYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgdmFsdWUgaW4gYF9wcmV2aW91c0RhdGFWYWx1ZXNgLlxuICAgKlxuICAgKiBJZiBjaGFuZ2VkIGlzIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCBpdCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBrZXlzIHRoYXQgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBJZiBjaGFuZ2VkIGlzIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50IGFuZCBubyBrZXlzIGhhdmUgY2hhbmdlZCwgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBmYWxzZWAgd2hlbiBhIHByb3BlcnR5IGZyb20gYSBuZXN0ZWQgKGZvciBleGFtcGxlIEpTT04pIHByb3BlcnR5XG4gICAqIHdhcyBlZGl0ZWQgbWFudWFsbHksIHlvdSBtdXN0IGNhbGwgYGNoYW5nZWQoJ2tleScsIHRydWUpYCBtYW51YWxseSBpbiB0aGVzZSBjYXNlcy5cbiAgICogV3JpdGluZyBhbiBlbnRpcmVseSBuZXcgb2JqZWN0IChlZy4gZGVlcCBjbG9uZWQpIHdpbGwgYmUgZGV0ZWN0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCBtZGwgPSBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoKTtcbiAgICogbWRsLm15SnNvbkZpZWxkLmEgPSAxO1xuICAgKiBjb25zb2xlLmxvZyhtZGwuY2hhbmdlZCgpKSA9PiBmYWxzZVxuICAgKiBtZGwuc2F2ZSgpOyAvLyB0aGlzIHdpbGwgbm90IHNhdmUgYW55dGhpbmdcbiAgICogbWRsLmNoYW5nZWQoJ215SnNvbkZpZWxkJywgdHJ1ZSk7XG4gICAqIGNvbnNvbGUubG9nKG1kbC5jaGFuZ2VkKCkpID0+IFsnbXlKc29uRmllbGQnXVxuICAgKiBtZGwuc2F2ZSgpOyAvLyB3aWxsIHNhdmVcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBrZXkgdG8gY2hlY2sgb3IgY2hhbmdlIHN0YXR1cyBvZlxuICAgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXSB2YWx1ZSB0byBzZXRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW58QXJyYXl9XG4gICAqL1xuICBjaGFuZ2VkKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VkLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NoYW5nZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWQuYWRkKGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fY2hhbmdlZC5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZC5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB2YWx1ZSBmb3Iga2V5IGZyb20gYF9wcmV2aW91c0RhdGFWYWx1ZXNgLlxuICAgKlxuICAgKiBJZiBjYWxsZWQgd2l0aG91dCBhIGtleSwgcmV0dXJucyB0aGUgcHJldmlvdXMgdmFsdWVzIGZvciBhbGwgdmFsdWVzIHdoaWNoIGhhdmUgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0ga2V5IHRvIGdldCBwcmV2aW91cyB2YWx1ZSBvZlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fEFycmF5PGFueT59XG4gICAqL1xuICBwcmV2aW91cyhrZXkpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF8ucGlja0J5KHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcywgKHZhbHVlLCBrZXkpID0+IHRoaXMuY2hhbmdlZChrZXkpKTtcbiAgfVxuXG4gIF9zZXRJbmNsdWRlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGluc3RhbmNlID0+IGluc3RhbmNlLmRhdGFWYWx1ZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGluY2x1ZGUgPSB0aGlzLl9vcHRpb25zLmluY2x1ZGVNYXBba2V5XTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgYWNjZXNzb3IgPSBrZXk7XG4gICAgY29uc3QgcHJpbWFyeUtleUF0dHJpYnV0ZSA9IGluY2x1ZGUubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBjb25zdCBjaGlsZE9wdGlvbnMgPSB7XG4gICAgICBpc05ld1JlY29yZDogdGhpcy5pc05ld1JlY29yZCxcbiAgICAgIGluY2x1ZGU6IGluY2x1ZGUuaW5jbHVkZSxcbiAgICAgIGluY2x1ZGVOYW1lczogaW5jbHVkZS5pbmNsdWRlTmFtZXMsXG4gICAgICBpbmNsdWRlTWFwOiBpbmNsdWRlLmluY2x1ZGVNYXAsXG4gICAgICBpbmNsdWRlVmFsaWRhdGVkOiB0cnVlLFxuICAgICAgcmF3OiBvcHRpb25zLnJhdyxcbiAgICAgIGF0dHJpYnV0ZXM6IGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBsZXQgaXNFbXB0eTtcblxuICAgIGlmIChpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkIHx8IGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgaWYgKGFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpc0VtcHR5ID0gdmFsdWUgJiYgdmFsdWVbcHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGw7XG4gICAgICAgIHRoaXNbYWNjZXNzb3JdID0gdGhpcy5kYXRhVmFsdWVzW2FjY2Vzc29yXSA9IGlzRW1wdHkgPyBudWxsIDogaW5jbHVkZS5tb2RlbC5idWlsZCh2YWx1ZSwgY2hpbGRPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzRW1wdHkgPSB2YWx1ZVswXSAmJiB2YWx1ZVswXVtwcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gbnVsbDtcbiAgICAgICAgdGhpc1thY2Nlc3Nvcl0gPSB0aGlzLmRhdGFWYWx1ZXNbYWNjZXNzb3JdID0gaXNFbXB0eSA/IFtdIDogaW5jbHVkZS5tb2RlbC5idWxrQnVpbGQodmFsdWUsIGNoaWxkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGlzIGluc3RhbmNlLCBhbmQgaWYgdGhlIHZhbGlkYXRpb24gcGFzc2VzLCBwZXJzaXN0cyBpdCB0byB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNhdmVkIGluc3RhbmNlIChvciByZWplY3RzIHdpdGggYSBgU2VxdWVsaXplLlZhbGlkYXRpb25FcnJvcmAsIHdoaWNoIHdpbGwgaGF2ZSBhIHByb3BlcnR5IGZvciBlYWNoIG9mIHRoZSBmaWVsZHMgZm9yIHdoaWNoIHRoZSB2YWxpZGF0aW9uIGZhaWxlZCwgd2l0aCB0aGUgZXJyb3IgbWVzc2FnZSBmb3IgdGhhdCBmaWVsZCkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG9wdGltaXplZCB0byBwZXJmb3JtIGFuIFVQREFURSBvbmx5IGludG8gdGhlIGZpZWxkcyB0aGF0IGNoYW5nZWQuIElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIG5vIFNRTCBxdWVyeSB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF3YXJlIG9mIGVhZ2VyIGxvYWRlZCBhc3NvY2lhdGlvbnMuIEluIG90aGVyIHdvcmRzLCBpZiBzb21lIG90aGVyIG1vZGVsIGluc3RhbmNlIChjaGlsZCkgd2FzIGVhZ2VyIGxvYWRlZCB3aXRoIHRoaXMgaW5zdGFuY2UgKHBhcmVudCksIGFuZCB5b3UgY2hhbmdlIHNvbWV0aGluZyBpbiB0aGUgY2hpbGQsIGNhbGxpbmcgYHNhdmUoKWAgd2lsbCBzaW1wbHkgaWdub3JlIHRoZSBjaGFuZ2UgdGhhdCBoYXBwZW5lZCBvbiB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtvcHRpb25zXSBzYXZlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gICAgW29wdGlvbnMuZmllbGRzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBzdHJpbmdzLCByZXByZXNlbnRpbmcgZGF0YWJhc2UgY29sdW1ucy4gSWYgZmllbGRzIGlzIHByb3ZpZGVkLCBvbmx5IHRob3NlIGNvbHVtbnMgd2lsbCBiZSB2YWxpZGF0ZWQgYW5kIHNhdmVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLnZhbGlkYXRlPXRydWVdIElmIGZhbHNlLCB2YWxpZGF0aW9ucyB3b24ndCBiZSBydW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLmhvb2tzPXRydWVdIFJ1biBiZWZvcmUgYW5kIGFmdGVyIGNyZWF0ZSAvIHVwZGF0ZSArIHZhbGlkYXRlIGhvb2tzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMucmV0dXJuaW5nXSBBcHBlbmQgUkVUVVJOSU5HICogdG8gZ2V0IGJhY2sgYXV0byBnZW5lcmF0ZWQgdmFsdWVzIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBhc3luYyBzYXZlKG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBhcmd1bWVudCB3YXMgcmVtb3ZlZCBpbiBmYXZvciBvZiB0aGUgb3B0aW9ucyBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKHRoaXMuY2hhbmdlZCgpLCBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5kZWZhdWx0RmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByaW1hcnlLZXlOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IHByaW1hcnlLZXlBdHRyaWJ1dGUgPSBwcmltYXJ5S2V5TmFtZSAmJiB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbcHJpbWFyeUtleU5hbWVdO1xuICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICBjb25zdCB2ZXJzaW9uQXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3ZlcnNpb25BdHRyaWJ1dGU7XG4gICAgY29uc3QgaG9vayA9IHRoaXMuaXNOZXdSZWNvcmQgPyAnQ3JlYXRlJyA6ICdVcGRhdGUnO1xuICAgIGNvbnN0IHdhc05ld1JlY29yZCA9IHRoaXMuaXNOZXdSZWNvcmQ7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgbGV0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcblxuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmIG9wdGlvbnMuZmllbGRzLmxlbmd0aCA+PSAxICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb25BdHRyICYmIG9wdGlvbnMuZmllbGRzLmxlbmd0aCA+PSAxICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh2ZXJzaW9uQXR0cikpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godmVyc2lvbkF0dHIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNpbGVudCA9PT0gdHJ1ZSAmJiAhKHRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5nZXQodXBkYXRlZEF0QXR0ciwgeyByYXc6IHRydWUgfSkpKSB7XG4gICAgICAvLyBVcGRhdGVBdEF0dHIgbWlnaHQgaGF2ZSBiZWVuIGFkZGVkIGFzIGEgcmVzdWx0IG9mIE9iamVjdC5rZXlzKE1vZGVsLnJhd0F0dHJpYnV0ZXMpLiBJbiB0aGF0IGNhc2Ugd2UgaGF2ZSB0byByZW1vdmUgaXQgYWdhaW5cbiAgICAgIF8ucmVtb3ZlKG9wdGlvbnMuZmllbGRzLCB2YWwgPT4gdmFsID09PSB1cGRhdGVkQXRBdHRyKTtcbiAgICAgIHVwZGF0ZWRBdEF0dHIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKGNyZWF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goY3JlYXRlZEF0QXR0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmltYXJ5S2V5QXR0cmlidXRlICYmIHByaW1hcnlLZXlBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhwcmltYXJ5S2V5TmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMudW5zaGlmdChwcmltYXJ5S2V5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAocHJpbWFyeUtleU5hbWUgJiYgdGhpcy5nZXQocHJpbWFyeUtleU5hbWUsIHsgcmF3OiB0cnVlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXR0ZW1wdGVkIHRvIHNhdmUgYW4gaW5zdGFuY2Ugd2l0aCBubyBwcmltYXJ5IGtleSwgdGhpcyBpcyBub3QgYWxsb3dlZCBzaW5jZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBnbG9iYWwgdXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuc2lsZW50ICYmIG9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICB0aGlzLmRhdGFWYWx1ZXNbdXBkYXRlZEF0QXR0cl0gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCAmJiBjcmVhdGVkQXRBdHRyICYmICF0aGlzLmRhdGFWYWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgIHRoaXMuZGF0YVZhbHVlc1tjcmVhdGVkQXRBdHRyXSA9IHRoaXMuY29uc3RydWN0b3IuX2dldERlZmF1bHRUaW1lc3RhbXAoY3JlYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlXG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBjb25zdCBiZWZvcmVIb29rVmFsdWVzID0gXy5waWNrKHRoaXMuZGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMpO1xuICAgICAgbGV0IGlnbm9yZUNoYW5nZWQgPSBfLmRpZmZlcmVuY2UodGhpcy5jaGFuZ2VkKCksIG9wdGlvbnMuZmllbGRzKTsgLy8gSW4gY2FzZSBvZiB1cGRhdGUgd2hlcmUgaXQncyBvbmx5IHN1cHBvc2VkIHRvIHVwZGF0ZSB0aGUgcGFzc2VkIHZhbHVlcyBhbmQgdGhlIGhvb2sgdmFsdWVzXG4gICAgICBsZXQgaG9va0NoYW5nZWQ7XG4gICAgICBsZXQgYWZ0ZXJIb29rVmFsdWVzO1xuXG4gICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiBvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICBpZ25vcmVDaGFuZ2VkID0gXy53aXRob3V0KGlnbm9yZUNoYW5nZWQsIHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKGBiZWZvcmUke2hvb2t9YCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0RmllbGRzICYmICF0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIGFmdGVySG9va1ZhbHVlcyA9IF8ucGljayh0aGlzLmRhdGFWYWx1ZXMsIF8uZGlmZmVyZW5jZSh0aGlzLmNoYW5nZWQoKSwgaWdub3JlQ2hhbmdlZCkpO1xuXG4gICAgICAgIGhvb2tDaGFuZ2VkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFmdGVySG9va1ZhbHVlcykpIHtcbiAgICAgICAgICBpZiAoYWZ0ZXJIb29rVmFsdWVzW2tleV0gIT09IGJlZm9yZUhvb2tWYWx1ZXNba2V5XSkge1xuICAgICAgICAgICAgaG9va0NoYW5nZWQucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlxKG9wdGlvbnMuZmllbGRzLmNvbmNhdChob29rQ2hhbmdlZCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9va0NoYW5nZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgICAgICAvLyBWYWxpZGF0ZSBhZ2FpblxuXG4gICAgICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIGhvb2tDaGFuZ2VkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnNraXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzLmxlbmd0aCAmJiB0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9vcHRpb25zLmluY2x1ZGUuZmlsdGVyKGluY2x1ZGUgPT4gaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbykubWFwKGFzeW5jIGluY2x1ZGUgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSlcbiAgICAgICAgICAub21pdChbJ2Fzc29jaWF0aW9uJ10pXG4gICAgICAgICAgLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICAgICAgcGFyZW50UmVjb3JkOiB0aGlzXG4gICAgICAgICAgfSkudmFsdWUoKTtcblxuICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcblxuICAgICAgICBhd2FpdCB0aGlzW2luY2x1ZGUuYXNzb2NpYXRpb24uYWNjZXNzb3JzLnNldF0oaW5zdGFuY2UsIHsgc2F2ZTogZmFsc2UsIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmVhbEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzLmZpbHRlcihmaWVsZCA9PiAhdGhpcy5jb25zdHJ1Y3Rvci5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGZpZWxkKSk7XG4gICAgaWYgKCFyZWFsRmllbGRzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCF0aGlzLmNoYW5nZWQoKSAmJiAhdGhpcy5pc05ld1JlY29yZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCB2ZXJzaW9uRmllbGROYW1lID0gXy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3ZlcnNpb25BdHRyXSwgJ2ZpZWxkJykgfHwgdmVyc2lvbkF0dHI7XG4gICAgY29uc3QgdmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHRoaXMuZGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIGxldCBxdWVyeSA9IG51bGw7XG4gICAgbGV0IGFyZ3MgPSBbXTtcbiAgICBsZXQgd2hlcmU7XG5cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgcXVlcnkgPSAnaW5zZXJ0JztcbiAgICAgIGFyZ3MgPSBbdGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlcywgb3B0aW9uc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlID0gdGhpcy53aGVyZSh0cnVlKTtcbiAgICAgIGlmICh2ZXJzaW9uQXR0cikge1xuICAgICAgICB2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV0gPSBwYXJzZUludCh2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV0sIDEwKSArIDE7XG4gICAgICB9XG4gICAgICBxdWVyeSA9ICd1cGRhdGUnO1xuICAgICAgYXJncyA9IFt0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzLCB3aGVyZSwgb3B0aW9uc107XG4gICAgfVxuXG4gICAgY29uc3QgW3Jlc3VsdCwgcm93c1VwZGF0ZWRdID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5xdWVyeUludGVyZmFjZVtxdWVyeV0oLi4uYXJncyk7XG4gICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgdGhhdCBhIHJvdyB3YXMgdXBkYXRlZCwgb3RoZXJ3aXNlIGl0J3MgYW4gb3B0aW1pc3RpYyBsb2NraW5nIGVycm9yLlxuICAgICAgaWYgKHJvd3NVcGRhdGVkIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLk9wdGltaXN0aWNMb2NrRXJyb3Ioe1xuICAgICAgICAgIG1vZGVsTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICB3aGVyZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5kYXRhVmFsdWVzW3ZlcnNpb25BdHRyXSA9IHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFuc2ZlciBkYXRhYmFzZSBnZW5lcmF0ZWQgdmFsdWVzIChkZWZhdWx0cywgYXV0b2luY3JlbWVudCwgZXRjKVxuICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmXG4gICAgICAgICAgdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0clxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlc1thdHRyXSA9IHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICBkZWxldGUgdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCByZXN1bHQuZGF0YVZhbHVlcyk7XG5cbiAgICBPYmplY3QuYXNzaWduKHJlc3VsdC5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgIGlmICh3YXNOZXdSZWNvcmQgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0aGlzLl9vcHRpb25zLmluY2x1ZGUuZmlsdGVyKGluY2x1ZGUgPT4gIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvIHx8XG4gICAgICAgICAgaW5jbHVkZS5wYXJlbnQgJiYgaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkubWFwKGFzeW5jIGluY2x1ZGUgPT4ge1xuICAgICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmdldChpbmNsdWRlLmFzKTtcblxuICAgICAgICAgIGlmICghaW5zdGFuY2VzKSByZXR1cm47XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuXG4gICAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSlcbiAgICAgICAgICAgIC5vbWl0KFsnYXNzb2NpYXRpb24nXSlcbiAgICAgICAgICAgIC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgICAgICAgIHBhcmVudFJlY29yZDogdGhpc1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcblxuICAgICAgICAgIC8vIEluc3RhbmNlcyB3aWxsIGJlIHVwZGF0ZWQgaW4gcGxhY2Ugc28gd2UgY2FuIHNhZmVseSB0cmVhdCBIYXNPbmUgbGlrZSBhIEhhc01hbnlcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVzMCA9IHtcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5XTogdGhpcy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleV06IGluc3RhbmNlLmdldChpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHZhbHVlcyBkZWZpbmVkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgICAgICAgICAgIC4uLmluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXMoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uX2F1dG9HZW5lcmF0ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWVzMFthdHRyXSA9IGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbC5jcmVhdGUodmFsdWVzMCwgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSwgdGhpcy5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKGBhZnRlciR7aG9va31gLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICByZXN1bHQuX3ByZXZpb3VzRGF0YVZhbHVlc1tmaWVsZF0gPSByZXN1bHQuZGF0YVZhbHVlc1tmaWVsZF07XG4gICAgICB0aGlzLmNoYW5nZWQoZmllbGQsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5pc05ld1JlY29yZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBjdXJyZW50IGluc3RhbmNlIGluLXBsYWNlLCBpLmUuIHVwZGF0ZSB0aGUgb2JqZWN0IHdpdGggY3VycmVudCBkYXRhIGZyb20gdGhlIERCIGFuZCByZXR1cm4gdGhlIHNhbWUgb2JqZWN0LlxuICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIGRvaW5nIGEgYGZpbmQoSW5zdGFuY2UuaWQpYCwgYmVjYXVzZSB0aGF0IHdvdWxkIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlLiBXaXRoIHRoaXMgbWV0aG9kLFxuICAgKiBhbGwgcmVmZXJlbmNlcyB0byB0aGUgSW5zdGFuY2UgYXJlIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IGRhdGEgYW5kIG5vIG5ldyBvYmplY3RzIGFyZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIG9uIHRvIGBNb2RlbC5maW5kYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgYXN5bmMgcmVsb2FkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMoe1xuICAgICAgd2hlcmU6IHRoaXMud2hlcmUoKVxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgIGluY2x1ZGU6IHRoaXMuX29wdGlvbnMuaW5jbHVkZSB8fCB1bmRlZmluZWRcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlbG9hZGVkID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmICghcmVsb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSW5zdGFuY2VFcnJvcihcbiAgICAgICAgJ0luc3RhbmNlIGNvdWxkIG5vdCBiZSByZWxvYWRlZCBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0IGFueW1vcmUgKGZpbmQgY2FsbCByZXR1cm5lZCBudWxsKSdcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgb3B0aW9ucyBvZiB0aGUgaW5zdGFuY2VcbiAgICB0aGlzLl9vcHRpb25zID0gcmVsb2FkZWQuX29wdGlvbnM7XG4gICAgLy8gcmUtc2V0IGluc3RhbmNlIHZhbHVlc1xuICAgIHRoaXMuc2V0KHJlbG9hZGVkLmRhdGFWYWx1ZXMsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHJlc2V0OiB0cnVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICogVmFsaWRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBpbnN0YW5jZSBhY2NvcmRpbmcgdG8gdmFsaWRhdGlvbiBydWxlcyBzZXQgaW4gdGhlIG1vZGVsIGRlZmluaXRpb24uXG4gICpcbiAgKiBUaGUgcHJvbWlzZSBmdWxmaWxscyBpZiBhbmQgb25seSBpZiB2YWxpZGF0aW9uIHN1Y2Nlc3NmdWw7IG90aGVyd2lzZSBpdCByZWplY3RzIGFuIEVycm9yIGluc3RhbmNlIGNvbnRhaW5pbmcgeyBmaWVsZCBuYW1lIDogW2Vycm9yIG1zZ3NdIH0gZW50cmllcy5cbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIHZhbGlkYXRvclxuICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnNraXBdIEFuIGFycmF5IG9mIHN0cmluZ3MuIEFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluIHRoaXMgYXJyYXkgd2lsbCBub3QgYmUgdmFsaWRhdGVkXG4gICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZmllbGRzXSBBbiBhcnJheSBvZiBzdHJpbmdzLiBPbmx5IHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluIHRoaXMgYXJyYXkgd2lsbCBiZSB2YWxpZGF0ZWRcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhvb2tzPXRydWVdIFJ1biBiZWZvcmUgYW5kIGFmdGVyIHZhbGlkYXRlIGhvb2tzXG4gICpcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgKi9cbiAgYXN5bmMgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSW5zdGFuY2VWYWxpZGF0b3IodGhpcywgb3B0aW9ucykudmFsaWRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNhbGxpbmcgYHNldGAgYW5kIHRoZW4gY2FsbGluZyBgc2F2ZWAgYnV0IGl0IG9ubHkgc2F2ZXMgdGhlXG4gICAqIGV4YWN0IHZhbHVlcyBwYXNzZWQgdG8gaXQsIG1ha2luZyBpdCBtb3JlIGF0b21pYyBhbmQgc2FmZXIuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3NldH1cbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjc2F2ZX1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBTZWUgYHNldGBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU2VlIGBzYXZlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBhc3luYyB1cGRhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgLy8gQ2xvbmUgdmFsdWVzIHNvIGl0IGRvZXNuJ3QgZ2V0IG1vZGlmaWVkIGZvciBjYWxsZXIgc2NvcGUgYW5kIGlnbm9yZSB1bmRlZmluZWQgdmFsdWVzXG4gICAgdmFsdWVzID0gXy5vbWl0QnkodmFsdWVzLCB2YWx1ZSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IGNoYW5nZWRCZWZvcmUgPSB0aGlzLmNoYW5nZWQoKSB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSBvcHRpb25zID0geyBmaWVsZHM6IG9wdGlvbnMgfTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3Qgc2V0T3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBzZXRPcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnNldCh2YWx1ZXMsIHNldE9wdGlvbnMpO1xuXG4gICAgLy8gTm93IHdlIG5lZWQgdG8gZmlndXJlIG91dCB3aGljaCBmaWVsZHMgd2VyZSBhY3R1YWxseSBhZmZlY3RlZCBieSB0aGUgc2V0dGVyLlxuICAgIGNvbnN0IHNpZGVFZmZlY3RzID0gXy53aXRob3V0KHRoaXMuY2hhbmdlZCgpLCAuLi5jaGFuZ2VkQmVmb3JlKTtcbiAgICBjb25zdCBmaWVsZHMgPSBfLnVuaW9uKE9iamVjdC5rZXlzKHZhbHVlcyksIHNpZGVFZmZlY3RzKTtcblxuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24oZmllbGRzLCB0aGlzLmNoYW5nZWQoKSk7XG4gICAgICBvcHRpb25zLmRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zYXZlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHJvdyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaW5zdGFuY2UuIERlcGVuZGluZyBvbiB5b3VyIHNldHRpbmcgZm9yIHBhcmFub2lkLCB0aGUgcm93IHdpbGwgZWl0aGVyIGJlIGNvbXBsZXRlbHkgZGVsZXRlZCwgb3IgaGF2ZSBpdHMgZGVsZXRlZEF0IHRpbWVzdGFtcCBzZXQgdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW29wdGlvbnM9e31dIGRlc3Ryb3kgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5mb3JjZT1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHBhcmFub2lkIG1vZGVscyB3aWxsIGFjdHVhbGx5IGJlIGRlbGV0ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoJ2JlZm9yZURlc3Ryb3knLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLndoZXJlKHRydWUpO1xuXG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgb3B0aW9ucy5mb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKVxuICAgICAgICA/IGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWVcbiAgICAgICAgOiBudWxsO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5nZXREYXRhVmFsdWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBjb25zdCB1bmRlZmluZWRPck51bGwgPSBjdXJyZW50VmFsdWUgPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgPT0gbnVsbDtcbiAgICAgIGlmICh1bmRlZmluZWRPck51bGwgfHwgXy5pc0VxdWFsKGN1cnJlbnRWYWx1ZSwgZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0aW1lc3RhbXAgaWYgaXQgd2Fzbid0IGFscmVhZHkgc2V0XG4gICAgICAgIHRoaXMuc2V0RGF0YVZhbHVlKGF0dHJpYnV0ZU5hbWUsIG5ldyBEYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNhdmUoeyAuLi5vcHRpb25zLCBob29rczogZmFsc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IucXVlcnlJbnRlcmZhY2UuZGVsZXRlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB3aGVyZSwgeyB0eXBlOiBRdWVyeVR5cGVzLkRFTEVURSwgbGltaXQ6IG51bGwsIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoJ2FmdGVyRGVzdHJveScsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEgaW5zdGFuY2UgaXMgXCJzb2Z0IGRlbGV0ZWRcIi4gIFRoaXMgaXNcbiAgICogcGFydGljdWxhcmx5IHVzZWZ1bCBpZiB0aGUgaW1wbGVtZW50ZXIgcmVuYW1lZCB0aGUgYGRlbGV0ZWRBdGAgYXR0cmlidXRlXG4gICAqIHRvIHNvbWV0aGluZyBkaWZmZXJlbnQuICBUaGlzIG1ldGhvZCByZXF1aXJlcyBgcGFyYW5vaWRgIHRvIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNTb2Z0RGVsZXRlZCgpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIGlzIG5vdCBwYXJhbm9pZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gdGhpcy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHx8IG51bGw7XG4gICAgY29uc3QgaXNTZXQgPSBkZWxldGVkQXQgIT09IGRlZmF1bHRWYWx1ZTtcblxuICAgIHJldHVybiBpc1NldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRoZSByb3cgY29ycmVzcG9uZGluZyB0byB0aGlzIGluc3RhbmNlLiBPbmx5IGF2YWlsYWJsZSBmb3IgcGFyYW5vaWQgbW9kZWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9ucz17fV0gcmVzdG9yZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVzdG9yZShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkgdGhyb3cgbmV3IEVycm9yKCdNb2RlbCBpcyBub3QgcGFyYW5vaWQnKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoJ2JlZm9yZVJlc3RvcmUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG5cbiAgICB0aGlzLnNldERhdGFWYWx1ZShkZWxldGVkQXRDb2wsIGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYXZlKHsgLi4ub3B0aW9ucywgaG9va3M6IGZhbHNlLCBvbWl0TnVsbDogZmFsc2UgfSk7XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcygnYWZ0ZXJSZXN0b3JlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdmFsdWUgb2Ygb25lIG9yIG1vcmUgY29sdW1ucy4gVGhpcyBpcyBkb25lIGluIHRoZSBkYXRhYmFzZSwgd2hpY2ggbWVhbnMgaXQgZG9lcyBub3QgdXNlIHRoZSB2YWx1ZXMgY3VycmVudGx5IHN0b3JlZCBvbiB0aGUgSW5zdGFuY2UuIFRoZSBpbmNyZW1lbnQgaXMgZG9uZSB1c2luZyBhXG4gICAqIGBgYHNxbFxuICAgKiBTRVQgY29sdW1uID0gY29sdW1uICsgWFxuICAgKiBgYGBcbiAgICogcXVlcnkuIFRoZSB1cGRhdGVkIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgYnkgZGVmYXVsdCBpbiBQb3N0Z3Jlcy4gSG93ZXZlciwgaW4gb3RoZXIgZGlhbGVjdHMsIHlvdSB3aWxsIG5lZWQgdG8gZG8gYSByZWxvYWQgdG8gZ2V0IHRoZSBuZXcgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnN0YW5jZS5pbmNyZW1lbnQoJ251bWJlcicpIC8vIGluY3JlbWVudCBudW1iZXIgYnkgMVxuICAgKlxuICAgKiBpbnN0YW5jZS5pbmNyZW1lbnQoWydudW1iZXInLCAnY291bnQnXSwgeyBieTogMiB9KSAvLyBpbmNyZW1lbnQgbnVtYmVyIGFuZCBjb3VudCBieSAyXG4gICAqXG4gICAqIC8vIGluY3JlbWVudCBhbnN3ZXIgYnkgNDIsIGFuZCB0cmllcyBieSAxLlxuICAgKiAvLyBgYnlgIGlzIGlnbm9yZWQsIHNpbmNlIGVhY2ggY29sdW1uIGhhcyBpdHMgb3duIHZhbHVlXG4gICAqIGluc3RhbmNlLmluY3JlbWVudCh7IGFuc3dlcjogNDIsIHRyaWVzOiAxfSwgeyBieTogMiB9KVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNyZWxvYWR9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fG9iamVjdH0gZmllbGRzIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGF0IGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgb2YgYGJ5YCBnaXZlbiBpbiBvcHRpb25zLiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgZWFjaCBjb2x1bW4uIElmIGFuZCBvYmplY3QgaXMgcHJvdmlkZWQsIGVhY2ggY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBnaXZlbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ieT0xXSBUaGUgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNpbGVudD1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5pbmc9dHJ1ZV0gQXBwZW5kIFJFVFVSTklORyAqIHRvIGdldCBiYWNrIGF1dG8gZ2VuZXJhdGVkIHZhbHVlcyAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGFzeW5jIGluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy53aGVyZSgpO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLndoZXJlID0geyAuLi5vcHRpb25zLndoZXJlLCAuLi5pZGVudGlmaWVyIH07XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IHRoaXM7XG5cbiAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLmluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVtZW50IHRoZSB2YWx1ZSBvZiBvbmUgb3IgbW9yZSBjb2x1bW5zLiBUaGlzIGlzIGRvbmUgaW4gdGhlIGRhdGFiYXNlLCB3aGljaCBtZWFucyBpdCBkb2VzIG5vdCB1c2UgdGhlIHZhbHVlcyBjdXJyZW50bHkgc3RvcmVkIG9uIHRoZSBJbnN0YW5jZS4gVGhlIGRlY3JlbWVudCBpcyBkb25lIHVzaW5nIGFcbiAgICogYGBgc3FsXG4gICAqIFNFVCBjb2x1bW4gPSBjb2x1bW4gLSBYXG4gICAqIGBgYFxuICAgKiBxdWVyeS4gVGhlIHVwZGF0ZWQgaW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZCBieSBkZWZhdWx0IGluIFBvc3RncmVzLiBIb3dldmVyLCBpbiBvdGhlciBkaWFsZWN0cywgeW91IHdpbGwgbmVlZCB0byBkbyBhIHJlbG9hZCB0byBnZXQgdGhlIG5ldyB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGluc3RhbmNlLmRlY3JlbWVudCgnbnVtYmVyJykgLy8gZGVjcmVtZW50IG51bWJlciBieSAxXG4gICAqXG4gICAqIGluc3RhbmNlLmRlY3JlbWVudChbJ251bWJlcicsICdjb3VudCddLCB7IGJ5OiAyIH0pIC8vIGRlY3JlbWVudCBudW1iZXIgYW5kIGNvdW50IGJ5IDJcbiAgICpcbiAgICogLy8gZGVjcmVtZW50IGFuc3dlciBieSA0MiwgYW5kIHRyaWVzIGJ5IDEuXG4gICAqIC8vIGBieWAgaXMgaWdub3JlZCwgc2luY2UgZWFjaCBjb2x1bW4gaGFzIGl0cyBvd24gdmFsdWVcbiAgICogaW5zdGFuY2UuZGVjcmVtZW50KHsgYW5zd2VyOiA0MiwgdHJpZXM6IDF9LCB7IGJ5OiAyIH0pXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3JlbG9hZH1cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl8b2JqZWN0fSBmaWVsZHMgSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoYXQgY29sdW1uIGlzIGRlY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBvZiBgYnlgIGdpdmVuIGluIG9wdGlvbnMuIElmIGFuIGFycmF5IGlzIHByb3ZpZGVkLCB0aGUgc2FtZSBpcyB0cnVlIGZvciBlYWNoIGNvbHVtbi4gSWYgYW5kIG9iamVjdCBpcyBwcm92aWRlZCwgZWFjaCBjb2x1bW4gaXMgZGVjcmVtZW50ZWQgYnkgdGhlIHZhbHVlIGdpdmVuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtvcHRpb25zXSBkZWNyZW1lbnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICBbb3B0aW9ucy5ieT0xXSBUaGUgbnVtYmVyIHRvIGRlY3JlbWVudCBieVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMucmV0dXJuaW5nPXRydWVdIEFwcGVuZCBSRVRVUk5JTkcgKiB0byBnZXQgYmFjayBhdXRvIGdlbmVyYXRlZCB2YWx1ZXMgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZGVjcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudChmaWVsZHMsIHtcbiAgICAgIGJ5OiAxLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGluY3JlbWVudDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgYW5kIGBvdGhlcmAgSW5zdGFuY2UgcmVmZXIgdG8gdGhlIHNhbWUgcm93XG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IG90aGVyIE90aGVyIGluc3RhbmNlIHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghb3RoZXIgfHwgIW90aGVyLmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmV2ZXJ5KGF0dHJpYnV0ZSA9PiB0aGlzLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSBvdGhlci5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyBpcyBlcXVhbCB0byBvbmUgb2YgYG90aGVyc2AgYnkgY2FsbGluZyBlcXVhbHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxNb2RlbD59IG90aGVycyBBbiBhcnJheSBvZiBpbnN0YW5jZXMgdG8gY2hlY2sgYWdhaW5zdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFsc09uZU9mKG90aGVycykge1xuICAgIHJldHVybiBvdGhlcnMuc29tZShvdGhlciA9PiB0aGlzLmVxdWFscyhvdGhlcikpO1xuICB9XG5cbiAgc2V0VmFsaWRhdG9ycyhhdHRyaWJ1dGUsIHZhbGlkYXRvcnMpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnNbYXR0cmlidXRlXSA9IHZhbGlkYXRvcnM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaW5zdGFuY2UgdG8gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgKiBQcm94aWVzIHRvIGNhbGxpbmcgYGdldGAgd2l0aCBubyBrZXlzLlxuICAgKiBUaGlzIG1lYW5zIGdldCBhbGwgdmFsdWVzIGdvdHRlbiBmcm9tIHRoZSBEQiwgYW5kIGFwcGx5IGFsbCBjdXN0b20gZ2V0dGVycy5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjZ2V0fVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBfLmNsb25lRGVlcChcbiAgICAgIHRoaXMuZ2V0KHtcbiAgICAgICAgcGxhaW46IHRydWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgMTptIGFzc29jaWF0aW9uIGJldHdlZW4gdGhpcyAodGhlIHNvdXJjZSkgYW5kIHRoZSBwcm92aWRlZCB0YXJnZXQuXG4gICAqIFRoZSBmb3JlaWduIGtleSBpcyBhZGRlZCBvbiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgICAgIHRhcmdldCBUYXJnZXQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9uc10gaGFzTWFueSBhc3NvY2lhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMuaG9va3M9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHJ1biBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyB3aGVuIGFuIGFzc29jaWF0ZWQgbW9kZWwgaXMgZGVsZXRlZCBiZWNhdXNlIG9mIGEgY2FzY2FkZS4gRm9yIGV4YW1wbGUgaWYgYFVzZXIuaGFzT25lKFByb2ZpbGUsIHtvbkRlbGV0ZTogJ2Nhc2NhZGUnLCBob29rczp0cnVlfSlgLCB0aGUgYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3MgZm9yIHByb2ZpbGUgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgaXMgZGVsZXRlZC4gT3RoZXJ3aXNlIHRoZSBwcm9maWxlIHdpbGwgYmUgZGVsZXRlZCB3aXRob3V0IGludm9raW5nIGFueSBob29rc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgIFtvcHRpb25zLmFzXSBUaGUgYWxpYXMgb2YgdGhpcyBtb2RlbC4gSWYgeW91IHByb3ZpZGUgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBwbHVyYWwsIGFuZCB3aWxsIGJlIHNpbmd1bGFyaXplZCB1c2luZyBub2RlLmluZmxlY3Rpb24uIElmIHlvdSB3YW50IHRvIGNvbnRyb2wgdGhlIHNpbmd1bGFyIHZlcnNpb24geW91cnNlbGYsIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYHBsdXJhbGAgYW5kIGBzaW5ndWxhcmAga2V5cy4gU2VlIGFsc28gdGhlIGBuYW1lYCBvcHRpb24gcGFzc2VkIHRvIGBzZXF1ZWxpemUuZGVmaW5lYC4gSWYgeW91IGNyZWF0ZSBtdWx0aXBsZSBhc3NvY2lhdGlvbnMgYmV0d2VlbiB0aGUgc2FtZSB0YWJsZXMsIHlvdSBzaG91bGQgcHJvdmlkZSBhbiBhbGlhcyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlbS4gSWYgeW91IHByb3ZpZGUgYW4gYWxpYXMgd2hlbiBjcmVhdGluZyB0aGUgYXNzb2NpYXRpb24sIHlvdSBzaG91bGQgcHJvdmlkZSB0aGUgc2FtZSBhbGlhcyB3aGVuIGVhZ2VyIGxvYWRpbmcgYW5kIHdoZW4gZ2V0dGluZyBhc3NvY2lhdGVkIG1vZGVscy4gRGVmYXVsdHMgdG8gdGhlIHBsdXJhbGl6ZWQgbmFtZSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICBbb3B0aW9ucy5mb3JlaWduS2V5XSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgaW4gdGhlIHRhcmdldCB0YWJsZSBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBmb3JlaWduIGNvbHVtbiAoc2VlIGBTZXF1ZWxpemUuZGVmaW5lYCBmb3Igc3ludGF4KS4gV2hlbiB1c2luZyBhbiBvYmplY3QsIHlvdSBjYW4gYWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uLiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiBzb3VyY2UgKyBwcmltYXJ5IGtleSBvZiBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBbb3B0aW9ucy5zb3VyY2VLZXldIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byB1c2UgYXMgdGhlIGtleSBmb3IgdGhlIGFzc29jaWF0aW9uIGluIHRoZSBzb3VyY2UgdGFibGUuIERlZmF1bHRzIHRvIHRoZSBwcmltYXJ5IGtleSBvZiB0aGUgc291cmNlIHRhYmxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgW29wdGlvbnMuc2NvcGVdIEEga2V5L3ZhbHVlIHNldCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXNzb2NpYXRpb24gY3JlYXRlIGFuZCBmaW5kIGRlZmF1bHRzIG9uIHRoZSB0YXJnZXQuIChzcWxpdGUgbm90IHN1cHBvcnRlZCBmb3IgTjpNKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgIFtvcHRpb25zLm9uRGVsZXRlPSdTRVQmbmJzcDtOVUxMfENBU0NBREUnXSBTRVQgTlVMTCBpZiBmb3JlaWduS2V5IGFsbG93cyBudWxscywgQ0FTQ0FERSBpZiBvdGhlcndpc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBbb3B0aW9ucy5vblVwZGF0ZT0nQ0FTQ0FERSddIFNldCBgT04gVVBEQVRFYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLmNvbnN0cmFpbnRzPXRydWVdIFNob3VsZCBvbiB1cGRhdGUgYW5kIG9uIGRlbGV0ZSBjb25zdHJhaW50cyBiZSBlbmFibGVkIG9uIHRoZSBmb3JlaWduIGtleS5cbiAgICpcbiAgICogQHJldHVybnMge0hhc01hbnl9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFVzZXIuaGFzTWFueShQcm9maWxlKSAvLyBUaGlzIHdpbGwgYWRkIHVzZXJJZCB0byB0aGUgcHJvZmlsZSB0YWJsZVxuICAgKi9cbiAgc3RhdGljIGhhc01hbnkodGFyZ2V0LCBvcHRpb25zKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBOOk0gYXNzb2NpYXRpb24gd2l0aCBhIGpvaW4gdGFibGUuIERlZmluaW5nIGB0aHJvdWdoYCBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgICAgICB0YXJnZXQgVGFyZ2V0IG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgb3B0aW9ucyBiZWxvbmdzVG9NYW55IGFzc29jaWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy5ob29rcz1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcnVuIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIHdoZW4gYW4gYXNzb2NpYXRlZCBtb2RlbCBpcyBkZWxldGVkIGJlY2F1c2Ugb2YgYSBjYXNjYWRlLiBGb3IgZXhhbXBsZSBpZiBgVXNlci5oYXNPbmUoUHJvZmlsZSwge29uRGVsZXRlOiAnY2FzY2FkZScsIGhvb2tzOnRydWV9KWAsIHRoZSBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyBmb3IgcHJvZmlsZSB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBpcyBkZWxldGVkLiBPdGhlcndpc2UgdGhlIHByb2ZpbGUgd2lsbCBiZSBkZWxldGVkIHdpdGhvdXQgaW52b2tpbmcgYW55IGhvb2tzXG4gICAqIEBwYXJhbSB7TW9kZWx8c3RyaW5nfG9iamVjdH0gb3B0aW9ucy50aHJvdWdoIFRoZSBuYW1lIG9mIHRoZSB0YWJsZSB0aGF0IGlzIHVzZWQgdG8gam9pbiBzb3VyY2UgYW5kIHRhcmdldCBpbiBuOm0gYXNzb2NpYXRpb25zLiBDYW4gYWxzbyBiZSBhIHNlcXVlbGl6ZSBtb2RlbCBpZiB5b3Ugd2FudCB0byBkZWZpbmUgdGhlIGp1bmN0aW9uIHRhYmxlIHlvdXJzZWxmIGFuZCBhZGQgZXh0cmEgYXR0cmlidXRlcyB0byBpdC5cbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgICAgICBbb3B0aW9ucy50aHJvdWdoLm1vZGVsXSBUaGUgbW9kZWwgdXNlZCB0byBqb2luIGJvdGggc2lkZXMgb2YgdGhlIE46TSBhc3NvY2lhdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9ucy50aHJvdWdoLnNjb3BlXSBBIGtleS92YWx1ZSBzZXQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGFzc29jaWF0aW9uIGNyZWF0ZSBhbmQgZmluZCBkZWZhdWx0cyBvbiB0aGUgdGhyb3VnaCBtb2RlbC4gKFJlbWVtYmVyIHRvIGFkZCB0aGUgYXR0cmlidXRlcyB0byB0aGUgdGhyb3VnaCBtb2RlbClcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy50aHJvdWdoLnVuaXF1ZT10cnVlXSBJZiB0cnVlIGEgdW5pcXVlIGtleSB3aWxsIGJlIGdlbmVyYXRlZCBmcm9tIHRoZSBmb3JlaWduIGtleXMgdXNlZCAobWlnaHQgd2FudCB0byB0dXJuIHRoaXMgb2ZmIGFuZCBjcmVhdGUgc3BlY2lmaWMgdW5pcXVlIGtleXMgd2hlbiB1c2luZyBzY29wZXMpXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgW29wdGlvbnMuYXNdIFRoZSBhbGlhcyBvZiB0aGlzIGFzc29jaWF0aW9uLiBJZiB5b3UgcHJvdmlkZSBhIHN0cmluZywgaXQgc2hvdWxkIGJlIHBsdXJhbCwgYW5kIHdpbGwgYmUgc2luZ3VsYXJpemVkIHVzaW5nIG5vZGUuaW5mbGVjdGlvbi4gSWYgeW91IHdhbnQgdG8gY29udHJvbCB0aGUgc2luZ3VsYXIgdmVyc2lvbiB5b3Vyc2VsZiwgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBgcGx1cmFsYCBhbmQgYHNpbmd1bGFyYCBrZXlzLiBTZWUgYWxzbyB0aGUgYG5hbWVgIG9wdGlvbiBwYXNzZWQgdG8gYHNlcXVlbGl6ZS5kZWZpbmVgLiBJZiB5b3UgY3JlYXRlIG11bHRpcGxlIGFzc29jaWF0aW9ucyBiZXR3ZWVuIHRoZSBzYW1lIHRhYmxlcywgeW91IHNob3VsZCBwcm92aWRlIGFuIGFsaWFzIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtLiBJZiB5b3UgcHJvdmlkZSBhbiBhbGlhcyB3aGVuIGNyZWF0aW5nIHRoZSBhc3NvY2lhdGlvbiwgeW91IHNob3VsZCBwcm92aWRlIHRoZSBzYW1lIGFsaWFzIHdoZW4gZWFnZXIgbG9hZGluZyBhbmQgd2hlbiBnZXR0aW5nIGFzc29jaWF0ZWQgbW9kZWxzLiBEZWZhdWx0cyB0byB0aGUgcGx1cmFsaXplZCBuYW1lIG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgIFtvcHRpb25zLmZvcmVpZ25LZXldIFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBpbiB0aGUgam9pbiB0YWJsZSAocmVwcmVzZW50aW5nIHRoZSBzb3VyY2UgbW9kZWwpIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIGZvcmVpZ24gY29sdW1uIChzZWUgYFNlcXVlbGl6ZS5kZWZpbmVgIGZvciBzeW50YXgpLiBXaGVuIHVzaW5nIGFuIG9iamVjdCwgeW91IGNhbiBhZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gc2V0IHRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHNvdXJjZSArIHByaW1hcnkga2V5IG9mIHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgIFtvcHRpb25zLm90aGVyS2V5XSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgaW4gdGhlIGpvaW4gdGFibGUgKHJlcHJlc2VudGluZyB0aGUgdGFyZ2V0IG1vZGVsKSBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBvdGhlciBjb2x1bW4gKHNlZSBgU2VxdWVsaXplLmRlZmluZWAgZm9yIHN5bnRheCkuIFdoZW4gdXNpbmcgYW4gb2JqZWN0LCB5b3UgY2FuIGFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbi4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgdGFyZ2V0ICsgcHJpbWFyeSBrZXkgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgW29wdGlvbnMuc2NvcGVdIEEga2V5L3ZhbHVlIHNldCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXNzb2NpYXRpb24gY3JlYXRlIGFuZCBmaW5kIGRlZmF1bHRzIG9uIHRoZSB0YXJnZXQuIChzcWxpdGUgbm90IHN1cHBvcnRlZCBmb3IgTjpNKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLnRpbWVzdGFtcHM9c2VxdWVsaXplLm9wdGlvbnMudGltZXN0YW1wc10gU2hvdWxkIHRoZSBqb2luIG1vZGVsIGhhdmUgdGltZXN0YW1wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgIFtvcHRpb25zLm9uRGVsZXRlPSdTRVQmbmJzcDtOVUxMfENBU0NBREUnXSBDYXNjYWRlIGlmIHRoaXMgaXMgYSBuOm0sIGFuZCBzZXQgbnVsbCBpZiBpdCBpcyBhIDE6bVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgIFtvcHRpb25zLm9uVXBkYXRlPSdDQVNDQURFJ10gU2V0cyBgT04gVVBEQVRFYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLmNvbnN0cmFpbnRzPXRydWVdIFNob3VsZCBvbiB1cGRhdGUgYW5kIG9uIGRlbGV0ZSBjb25zdHJhaW50cyBiZSBlbmFibGVkIG9uIHRoZSBmb3JlaWduIGtleS5cbiAgICpcbiAgICogQHJldHVybnMge0JlbG9uZ3NUb01hbnl9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEF1dG9tYWdpY2FsbHkgZ2VuZXJhdGVkIGpvaW4gbW9kZWxcbiAgICogVXNlci5iZWxvbmdzVG9NYW55KFByb2plY3QsIHsgdGhyb3VnaDogJ1VzZXJQcm9qZWN0cycgfSlcbiAgICogUHJvamVjdC5iZWxvbmdzVG9NYW55KFVzZXIsIHsgdGhyb3VnaDogJ1VzZXJQcm9qZWN0cycgfSlcbiAgICpcbiAgICogLy8gSm9pbiBtb2RlbCB3aXRoIGFkZGl0aW9uYWwgYXR0cmlidXRlc1xuICAgKiBjb25zdCBVc2VyUHJvamVjdHMgPSBzZXF1ZWxpemUuZGVmaW5lKCdVc2VyUHJvamVjdHMnLCB7XG4gICAqICAgc3RhcnRlZDogU2VxdWVsaXplLkJPT0xFQU5cbiAgICogfSlcbiAgICogVXNlci5iZWxvbmdzVG9NYW55KFByb2plY3QsIHsgdGhyb3VnaDogVXNlclByb2plY3RzIH0pXG4gICAqIFByb2plY3QuYmVsb25nc1RvTWFueShVc2VyLCB7IHRocm91Z2g6IFVzZXJQcm9qZWN0cyB9KVxuICAgKi9cbiAgc3RhdGljIGJlbG9uZ3NUb01hbnkodGFyZ2V0LCBvcHRpb25zKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gYmV0d2VlbiB0aGlzICh0aGUgc291cmNlKSBhbmQgdGhlIHByb3ZpZGVkIHRhcmdldC4gVGhlIGZvcmVpZ24ga2V5IGlzIGFkZGVkIG9uIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICB0YXJnZXQgVGFyZ2V0IG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9uc10gaGFzT25lIGFzc29jaWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmhvb2tzPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBydW4gYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3Mgd2hlbiBhbiBhc3NvY2lhdGVkIG1vZGVsIGlzIGRlbGV0ZWQgYmVjYXVzZSBvZiBhIGNhc2NhZGUuIEZvciBleGFtcGxlIGlmIGBVc2VyLmhhc09uZShQcm9maWxlLCB7b25EZWxldGU6ICdjYXNjYWRlJywgaG9va3M6dHJ1ZX0pYCwgdGhlIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIGZvciBwcm9maWxlIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGlzIGRlbGV0ZWQuIE90aGVyd2lzZSB0aGUgcHJvZmlsZSB3aWxsIGJlIGRlbGV0ZWQgd2l0aG91dCBpbnZva2luZyBhbnkgaG9va3NcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLmFzXSBUaGUgYWxpYXMgb2YgdGhpcyBtb2RlbCwgaW4gc2luZ3VsYXIgZm9ybS4gU2VlIGFsc28gdGhlIGBuYW1lYCBvcHRpb24gcGFzc2VkIHRvIGBzZXF1ZWxpemUuZGVmaW5lYC4gSWYgeW91IGNyZWF0ZSBtdWx0aXBsZSBhc3NvY2lhdGlvbnMgYmV0d2VlbiB0aGUgc2FtZSB0YWJsZXMsIHlvdSBzaG91bGQgcHJvdmlkZSBhbiBhbGlhcyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlbS4gSWYgeW91IHByb3ZpZGUgYW4gYWxpYXMgd2hlbiBjcmVhdGluZyB0aGUgYXNzb2NpYXRpb24sIHlvdSBzaG91bGQgcHJvdmlkZSB0aGUgc2FtZSBhbGlhcyB3aGVuIGVhZ2VyIGxvYWRpbmcgYW5kIHdoZW4gZ2V0dGluZyBhc3NvY2lhdGVkIG1vZGVscy4gRGVmYXVsdHMgdG8gdGhlIHNpbmd1bGFyaXplZCBuYW1lIG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgW29wdGlvbnMuZm9yZWlnbktleV0gVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGF0dHJpYnV0ZSBpbiB0aGUgdGFyZ2V0IG1vZGVsIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIGZvcmVpZ24gY29sdW1uIChzZWUgYFNlcXVlbGl6ZS5kZWZpbmVgIGZvciBzeW50YXgpLiBXaGVuIHVzaW5nIGFuIG9iamVjdCwgeW91IGNhbiBhZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gc2V0IHRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHNvdXJjZSArIHByaW1hcnkga2V5IG9mIHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMuc291cmNlS2V5XSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHVzZSBhcyB0aGUga2V5IGZvciB0aGUgYXNzb2NpYXRpb24gaW4gdGhlIHNvdXJjZSB0YWJsZS4gRGVmYXVsdHMgdG8gdGhlIHByaW1hcnkga2V5IG9mIHRoZSBzb3VyY2UgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLm9uRGVsZXRlPSdTRVQmbmJzcDtOVUxMfENBU0NBREUnXSBTRVQgTlVMTCBpZiBmb3JlaWduS2V5IGFsbG93cyBudWxscywgQ0FTQ0FERSBpZiBvdGhlcndpc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLm9uVXBkYXRlPSdDQVNDQURFJ10gU2V0cyAnT04gVVBEQVRFJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuY29uc3RyYWludHM9dHJ1ZV0gU2hvdWxkIG9uIHVwZGF0ZSBhbmQgb24gZGVsZXRlIGNvbnN0cmFpbnRzIGJlIGVuYWJsZWQgb24gdGhlIGZvcmVpZ24ga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMudW5pcXVlS2V5XSBUaGUgY3VzdG9tIG5hbWUgZm9yIHVuaXF1ZSBjb25zdHJhaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7SGFzT25lfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBVc2VyLmhhc09uZShQcm9maWxlKSAvLyBUaGlzIHdpbGwgYWRkIHVzZXJJZCB0byB0aGUgcHJvZmlsZSB0YWJsZVxuICAgKi9cbiAgc3RhdGljIGhhc09uZSh0YXJnZXQsIG9wdGlvbnMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3NvY2lhdGlvbiBiZXR3ZWVuIHRoaXMgKHRoZSBzb3VyY2UpIGFuZCB0aGUgcHJvdmlkZWQgdGFyZ2V0LiBUaGUgZm9yZWlnbiBrZXkgaXMgYWRkZWQgb24gdGhlIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgIHRhcmdldCBUaGUgdGFyZ2V0IG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9uc10gYmVsb25nc1RvIGFzc29jaWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmhvb2tzPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBydW4gYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3Mgd2hlbiBhbiBhc3NvY2lhdGVkIG1vZGVsIGlzIGRlbGV0ZWQgYmVjYXVzZSBvZiBhIGNhc2NhZGUuIEZvciBleGFtcGxlIGlmIGBVc2VyLmhhc09uZShQcm9maWxlLCB7b25EZWxldGU6ICdjYXNjYWRlJywgaG9va3M6dHJ1ZX0pYCwgdGhlIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIGZvciBwcm9maWxlIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGlzIGRlbGV0ZWQuIE90aGVyd2lzZSB0aGUgcHJvZmlsZSB3aWxsIGJlIGRlbGV0ZWQgd2l0aG91dCBpbnZva2luZyBhbnkgaG9va3NcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLmFzXSBUaGUgYWxpYXMgb2YgdGhpcyBtb2RlbCwgaW4gc2luZ3VsYXIgZm9ybS4gU2VlIGFsc28gdGhlIGBuYW1lYCBvcHRpb24gcGFzc2VkIHRvIGBzZXF1ZWxpemUuZGVmaW5lYC4gSWYgeW91IGNyZWF0ZSBtdWx0aXBsZSBhc3NvY2lhdGlvbnMgYmV0d2VlbiB0aGUgc2FtZSB0YWJsZXMsIHlvdSBzaG91bGQgcHJvdmlkZSBhbiBhbGlhcyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlbS4gSWYgeW91IHByb3ZpZGUgYW4gYWxpYXMgd2hlbiBjcmVhdGluZyB0aGUgYXNzb2NpYXRpb24sIHlvdSBzaG91bGQgcHJvdmlkZSB0aGUgc2FtZSBhbGlhcyB3aGVuIGVhZ2VyIGxvYWRpbmcgYW5kIHdoZW4gZ2V0dGluZyBhc3NvY2lhdGVkIG1vZGVscy4gRGVmYXVsdHMgdG8gdGhlIHNpbmd1bGFyaXplZCBuYW1lIG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgW29wdGlvbnMuZm9yZWlnbktleV0gVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGF0dHJpYnV0ZSBpbiB0aGUgc291cmNlIHRhYmxlIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIGZvcmVpZ24gY29sdW1uIChzZWUgYFNlcXVlbGl6ZS5kZWZpbmVgIGZvciBzeW50YXgpLiBXaGVuIHVzaW5nIGFuIG9iamVjdCwgeW91IGNhbiBhZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gc2V0IHRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRhcmdldCArIHByaW1hcnkga2V5IG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMudGFyZ2V0S2V5XSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHVzZSBhcyB0aGUga2V5IGZvciB0aGUgYXNzb2NpYXRpb24gaW4gdGhlIHRhcmdldCB0YWJsZS4gRGVmYXVsdHMgdG8gdGhlIHByaW1hcnkga2V5IG9mIHRoZSB0YXJnZXQgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLm9uRGVsZXRlPSdTRVQmbmJzcDtOVUxMfE5PJm5ic3A7QUNUSU9OJ10gU0VUIE5VTEwgaWYgZm9yZWlnbktleSBhbGxvd3MgbnVsbHMsIE5PIEFDVElPTiBpZiBvdGhlcndpc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLm9uVXBkYXRlPSdDQVNDQURFJ10gU2V0cyAnT04gVVBEQVRFJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuY29uc3RyYWludHM9dHJ1ZV0gU2hvdWxkIG9uIHVwZGF0ZSBhbmQgb24gZGVsZXRlIGNvbnN0cmFpbnRzIGJlIGVuYWJsZWQgb24gdGhlIGZvcmVpZ24ga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QmVsb25nc1RvfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBQcm9maWxlLmJlbG9uZ3NUbyhVc2VyKSAvLyBUaGlzIHdpbGwgYWRkIHVzZXJJZCB0byB0aGUgcHJvZmlsZSB0YWJsZVxuICAgKi9cbiAgc3RhdGljIGJlbG9uZ3NUbyh0YXJnZXQsIG9wdGlvbnMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cblxuT2JqZWN0LmFzc2lnbihNb2RlbCwgYXNzb2NpYXRpb25zTWl4aW4pO1xuSG9va3MuYXBwbHlUbyhNb2RlbCwgdHJ1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG4iLCJcbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogT3BlcmF0b3Igc3ltYm9scyB0byBiZSB1c2VkIHdoZW4gcXVlcnlpbmcgZGF0YVxuICpcbiAqIEBzZWUge0BsaW5rIE1vZGVsI3doZXJlfVxuICpcbiAqIEBwcm9wZXJ0eSBlcVxuICogQHByb3BlcnR5IG5lXG4gKiBAcHJvcGVydHkgZ3RlXG4gKiBAcHJvcGVydHkgZ3RcbiAqIEBwcm9wZXJ0eSBsdGVcbiAqIEBwcm9wZXJ0eSBsdFxuICogQHByb3BlcnR5IG5vdFxuICogQHByb3BlcnR5IGlzXG4gKiBAcHJvcGVydHkgaW5cbiAqIEBwcm9wZXJ0eSBub3RJblxuICogQHByb3BlcnR5IGxpa2VcbiAqIEBwcm9wZXJ0eSBub3RMaWtlXG4gKiBAcHJvcGVydHkgaUxpa2VcbiAqIEBwcm9wZXJ0eSBub3RJTGlrZVxuICogQHByb3BlcnR5IHN0YXJ0c1dpdGhcbiAqIEBwcm9wZXJ0eSBlbmRzV2l0aFxuICogQHByb3BlcnR5IHN1YnN0cmluZ1xuICogQHByb3BlcnR5IHJlZ2V4cFxuICogQHByb3BlcnR5IG5vdFJlZ2V4cFxuICogQHByb3BlcnR5IGlSZWdleHBcbiAqIEBwcm9wZXJ0eSBub3RJUmVnZXhwXG4gKiBAcHJvcGVydHkgYmV0d2VlblxuICogQHByb3BlcnR5IG5vdEJldHdlZW5cbiAqIEBwcm9wZXJ0eSBvdmVybGFwXG4gKiBAcHJvcGVydHkgY29udGFpbnNcbiAqIEBwcm9wZXJ0eSBjb250YWluZWRcbiAqIEBwcm9wZXJ0eSBhZGphY2VudFxuICogQHByb3BlcnR5IHN0cmljdExlZnRcbiAqIEBwcm9wZXJ0eSBzdHJpY3RSaWdodFxuICogQHByb3BlcnR5IG5vRXh0ZW5kUmlnaHRcbiAqIEBwcm9wZXJ0eSBub0V4dGVuZExlZnRcbiAqIEBwcm9wZXJ0eSBhbmRcbiAqIEBwcm9wZXJ0eSBvclxuICogQHByb3BlcnR5IGFueVxuICogQHByb3BlcnR5IGFsbFxuICogQHByb3BlcnR5IHZhbHVlc1xuICogQHByb3BlcnR5IGNvbFxuICogQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gKiBAcHJvcGVydHkgam9pblxuICovXG5jb25zdCBPcCA9IHtcbiAgZXE6IFN5bWJvbC5mb3IoJ2VxJyksXG4gIG5lOiBTeW1ib2wuZm9yKCduZScpLFxuICBndGU6IFN5bWJvbC5mb3IoJ2d0ZScpLFxuICBndDogU3ltYm9sLmZvcignZ3QnKSxcbiAgbHRlOiBTeW1ib2wuZm9yKCdsdGUnKSxcbiAgbHQ6IFN5bWJvbC5mb3IoJ2x0JyksXG4gIG5vdDogU3ltYm9sLmZvcignbm90JyksXG4gIGlzOiBTeW1ib2wuZm9yKCdpcycpLFxuICBpbjogU3ltYm9sLmZvcignaW4nKSxcbiAgbm90SW46IFN5bWJvbC5mb3IoJ25vdEluJyksXG4gIGxpa2U6IFN5bWJvbC5mb3IoJ2xpa2UnKSxcbiAgbm90TGlrZTogU3ltYm9sLmZvcignbm90TGlrZScpLFxuICBpTGlrZTogU3ltYm9sLmZvcignaUxpa2UnKSxcbiAgbm90SUxpa2U6IFN5bWJvbC5mb3IoJ25vdElMaWtlJyksXG4gIHN0YXJ0c1dpdGg6IFN5bWJvbC5mb3IoJ3N0YXJ0c1dpdGgnKSxcbiAgZW5kc1dpdGg6IFN5bWJvbC5mb3IoJ2VuZHNXaXRoJyksXG4gIHN1YnN0cmluZzogU3ltYm9sLmZvcignc3Vic3RyaW5nJyksXG4gIHJlZ2V4cDogU3ltYm9sLmZvcigncmVnZXhwJyksXG4gIG5vdFJlZ2V4cDogU3ltYm9sLmZvcignbm90UmVnZXhwJyksXG4gIGlSZWdleHA6IFN5bWJvbC5mb3IoJ2lSZWdleHAnKSxcbiAgbm90SVJlZ2V4cDogU3ltYm9sLmZvcignbm90SVJlZ2V4cCcpLFxuICBiZXR3ZWVuOiBTeW1ib2wuZm9yKCdiZXR3ZWVuJyksXG4gIG5vdEJldHdlZW46IFN5bWJvbC5mb3IoJ25vdEJldHdlZW4nKSxcbiAgb3ZlcmxhcDogU3ltYm9sLmZvcignb3ZlcmxhcCcpLFxuICBjb250YWluczogU3ltYm9sLmZvcignY29udGFpbnMnKSxcbiAgY29udGFpbmVkOiBTeW1ib2wuZm9yKCdjb250YWluZWQnKSxcbiAgYWRqYWNlbnQ6IFN5bWJvbC5mb3IoJ2FkamFjZW50JyksXG4gIHN0cmljdExlZnQ6IFN5bWJvbC5mb3IoJ3N0cmljdExlZnQnKSxcbiAgc3RyaWN0UmlnaHQ6IFN5bWJvbC5mb3IoJ3N0cmljdFJpZ2h0JyksXG4gIG5vRXh0ZW5kUmlnaHQ6IFN5bWJvbC5mb3IoJ25vRXh0ZW5kUmlnaHQnKSxcbiAgbm9FeHRlbmRMZWZ0OiBTeW1ib2wuZm9yKCdub0V4dGVuZExlZnQnKSxcbiAgYW5kOiBTeW1ib2wuZm9yKCdhbmQnKSxcbiAgb3I6IFN5bWJvbC5mb3IoJ29yJyksXG4gIGFueTogU3ltYm9sLmZvcignYW55JyksXG4gIGFsbDogU3ltYm9sLmZvcignYWxsJyksXG4gIHZhbHVlczogU3ltYm9sLmZvcigndmFsdWVzJyksXG4gIGNvbDogU3ltYm9sLmZvcignY29sJyksXG4gIHBsYWNlaG9sZGVyOiBTeW1ib2wuZm9yKCdwbGFjZWhvbGRlcicpLFxuICBqb2luOiBTeW1ib2wuZm9yKCdqb2luJyksXG4gIG1hdGNoOiBTeW1ib2wuZm9yKCdtYXRjaCcpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVudW0gb2YgcXVlcnkgdHlwZXMgdXNlZCBieSBgc2VxdWVsaXplLnF1ZXJ5YFxuICpcbiAqIEBzZWUge0BsaW5rIFNlcXVlbGl6ZSNxdWVyeX1cbiAqXG4gKiBAcHJvcGVydHkgU0VMRUNUXG4gKiBAcHJvcGVydHkgSU5TRVJUXG4gKiBAcHJvcGVydHkgVVBEQVRFXG4gKiBAcHJvcGVydHkgQlVMS1VQREFURVxuICogQHByb3BlcnR5IEJVTEtERUxFVEVcbiAqIEBwcm9wZXJ0eSBERUxFVEVcbiAqIEBwcm9wZXJ0eSBVUFNFUlRcbiAqIEBwcm9wZXJ0eSBWRVJTSU9OXG4gKiBAcHJvcGVydHkgU0hPV1RBQkxFU1xuICogQHByb3BlcnR5IFNIT1dJTkRFWEVTXG4gKiBAcHJvcGVydHkgREVTQ1JJQkVcbiAqIEBwcm9wZXJ0eSBSQVdcbiAqIEBwcm9wZXJ0eSBGT1JFSUdOS0VZU1xuICogQHByb3BlcnR5IFNIT1dDT05TVFJBSU5UU1xuICovXG5jb25zdCBRdWVyeVR5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgU0VMRUNUOiAnU0VMRUNUJyxcbiAgSU5TRVJUOiAnSU5TRVJUJyxcbiAgVVBEQVRFOiAnVVBEQVRFJyxcbiAgQlVMS1VQREFURTogJ0JVTEtVUERBVEUnLFxuICBCVUxLREVMRVRFOiAnQlVMS0RFTEVURScsXG4gIERFTEVURTogJ0RFTEVURScsXG4gIFVQU0VSVDogJ1VQU0VSVCcsXG4gIFZFUlNJT046ICdWRVJTSU9OJyxcbiAgU0hPV1RBQkxFUzogJ1NIT1dUQUJMRVMnLFxuICBTSE9XSU5ERVhFUzogJ1NIT1dJTkRFWEVTJyxcbiAgREVTQ1JJQkU6ICdERVNDUklCRScsXG4gIFJBVzogJ1JBVycsXG4gIEZPUkVJR05LRVlTOiAnRk9SRUlHTktFWVMnLFxuICBTSE9XQ09OU1RSQUlOVFM6ICdTSE9XQ09OU1RSQUlOVFMnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCByZXRyeSA9IHJlcXVpcmUoJ3JldHJ5LWFzLXByb21pc2VkJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGEtdHlwZXMnKTtcbmNvbnN0IERlZmVycmFibGUgPSByZXF1aXJlKCcuL2RlZmVycmFibGUnKTtcbmNvbnN0IE1vZGVsTWFuYWdlciA9IHJlcXVpcmUoJy4vbW9kZWwtbWFuYWdlcicpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi9xdWVyeS10eXBlcycpO1xuY29uc3QgVGFibGVIaW50cyA9IHJlcXVpcmUoJy4vdGFibGUtaGludHMnKTtcbmNvbnN0IEluZGV4SGludHMgPSByZXF1aXJlKCcuL2luZGV4LWhpbnRzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgSG9va3MgPSByZXF1aXJlKCcuL2hvb2tzJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2luZGV4Jyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMnKS52YWxpZGF0b3I7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzJyk7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKCcuL3V0aWxzL2RlcHJlY2F0aW9ucycpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gY2xhc3MsIHRoZSBlbnRyeSBwb2ludCB0byBzZXF1ZWxpemUuXG4gKi9cbmNsYXNzIFNlcXVlbGl6ZSB7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBzZXF1ZWxpemUgd2l0aCBuYW1lIG9mIGRhdGFiYXNlLCB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHdpdGhvdXQgcGFzc3dvcmQgLyB3aXRoIGJsYW5rIHBhc3N3b3JkXG4gICAqIGNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoJ2RhdGFiYXNlJywgJ3VzZXJuYW1lJywgbnVsbCwge1xuICAgKiAgIGRpYWxlY3Q6ICdteXNxbCdcbiAgICogfSlcbiAgICpcbiAgICogLy8gd2l0aCBwYXNzd29yZCBhbmQgb3B0aW9uc1xuICAgKiBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKCdteV9kYXRhYmFzZScsICdqb2huJywgJ2RvZScsIHtcbiAgICogICBkaWFsZWN0OiAncG9zdGdyZXMnXG4gICAqIH0pXG4gICAqXG4gICAqIC8vIHdpdGggZGF0YWJhc2UsIHVzZXJuYW1lLCBhbmQgcGFzc3dvcmQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAqIGNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoeyBkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkLCBkaWFsZWN0OiAnbXNzcWwnIH0pO1xuICAgKlxuICAgKiAvLyB3aXRoIHVyaVxuICAgKiBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKCdteXNxbDovL2xvY2FsaG9zdDozMzA2L2RhdGFiYXNlJywge30pXG4gICAqXG4gICAqIC8vIG9wdGlvbiBleGFtcGxlc1xuICAgKiBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKCdkYXRhYmFzZScsICd1c2VybmFtZScsICdwYXNzd29yZCcsIHtcbiAgICogICAvLyB0aGUgc3FsIGRpYWxlY3Qgb2YgdGhlIGRhdGFiYXNlXG4gICAqICAgLy8gY3VycmVudGx5IHN1cHBvcnRlZDogJ215c3FsJywgJ3NxbGl0ZScsICdwb3N0Z3JlcycsICdtc3NxbCdcbiAgICogICBkaWFsZWN0OiAnbXlzcWwnLFxuICAgKlxuICAgKiAgIC8vIGN1c3RvbSBob3N0OyBkZWZhdWx0OiBsb2NhbGhvc3RcbiAgICogICBob3N0OiAnbXkuc2VydmVyLnRsZCcsXG4gICAqICAgLy8gZm9yIHBvc3RncmVzLCB5b3UgY2FuIGFsc28gc3BlY2lmeSBhbiBhYnNvbHV0ZSBwYXRoIHRvIGEgZGlyZWN0b3J5XG4gICAqICAgLy8gY29udGFpbmluZyBhIFVOSVggc29ja2V0IHRvIGNvbm5lY3Qgb3ZlclxuICAgKiAgIC8vIGhvc3Q6ICcvc29ja2V0cy9wc3FsX3NvY2tldHMnLlxuICAgKlxuICAgKiAgIC8vIGN1c3RvbSBwb3J0OyBkZWZhdWx0OiBkaWFsZWN0IGRlZmF1bHRcbiAgICogICBwb3J0OiAxMjM0NSxcbiAgICpcbiAgICogICAvLyBjdXN0b20gcHJvdG9jb2w7IGRlZmF1bHQ6ICd0Y3AnXG4gICAqICAgLy8gcG9zdGdyZXMgb25seSwgdXNlZnVsIGZvciBIZXJva3VcbiAgICogICBwcm90b2NvbDogbnVsbCxcbiAgICpcbiAgICogICAvLyBkaXNhYmxlIGxvZ2dpbmcgb3IgcHJvdmlkZSBhIGN1c3RvbSBsb2dnaW5nIGZ1bmN0aW9uOyBkZWZhdWx0OiBjb25zb2xlLmxvZ1xuICAgKiAgIGxvZ2dpbmc6IGZhbHNlLFxuICAgKlxuICAgKiAgIC8vIHlvdSBjYW4gYWxzbyBwYXNzIGFueSBkaWFsZWN0IG9wdGlvbnMgdG8gdGhlIHVuZGVybHlpbmcgZGlhbGVjdCBsaWJyYXJ5XG4gICAqICAgLy8gLSBkZWZhdWx0IGlzIGVtcHR5XG4gICAqICAgLy8gLSBjdXJyZW50bHkgc3VwcG9ydGVkOiAnbXlzcWwnLCAncG9zdGdyZXMnLCAnbXNzcWwnXG4gICAqICAgZGlhbGVjdE9wdGlvbnM6IHtcbiAgICogICAgIHNvY2tldFBhdGg6ICcvQXBwbGljYXRpb25zL01BTVAvdG1wL215c3FsL215c3FsLnNvY2snLFxuICAgKiAgICAgc3VwcG9ydEJpZ051bWJlcnM6IHRydWUsXG4gICAqICAgICBiaWdOdW1iZXJTdHJpbmdzOiB0cnVlXG4gICAqICAgfSxcbiAgICpcbiAgICogICAvLyB0aGUgc3RvcmFnZSBlbmdpbmUgZm9yIHNxbGl0ZVxuICAgKiAgIC8vIC0gZGVmYXVsdCAnOm1lbW9yeTonXG4gICAqICAgc3RvcmFnZTogJ3BhdGgvdG8vZGF0YWJhc2Uuc3FsaXRlJyxcbiAgICpcbiAgICogICAvLyBkaXNhYmxlIGluc2VydGluZyB1bmRlZmluZWQgdmFsdWVzIGFzIE5VTExcbiAgICogICAvLyAtIGRlZmF1bHQ6IGZhbHNlXG4gICAqICAgb21pdE51bGw6IHRydWUsXG4gICAqXG4gICAqICAgLy8gYSBmbGFnIGZvciB1c2luZyBhIG5hdGl2ZSBsaWJyYXJ5IG9yIG5vdC5cbiAgICogICAvLyBpbiB0aGUgY2FzZSBvZiAncGcnIC0tIHNldCB0aGlzIHRvIHRydWUgd2lsbCBhbGxvdyBTU0wgc3VwcG9ydFxuICAgKiAgIC8vIC0gZGVmYXVsdDogZmFsc2VcbiAgICogICBuYXRpdmU6IHRydWUsXG4gICAqXG4gICAqICAgLy8gU3BlY2lmeSBvcHRpb25zLCB3aGljaCBhcmUgdXNlZCB3aGVuIHNlcXVlbGl6ZS5kZWZpbmUgaXMgY2FsbGVkLlxuICAgKiAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZTpcbiAgICogICAvLyAgIGRlZmluZTogeyB0aW1lc3RhbXBzOiBmYWxzZSB9XG4gICAqICAgLy8gaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzOlxuICAgKiAgIC8vICAgTW9kZWwuaW5pdChhdHRyaWJ1dGVzLCB7IHRpbWVzdGFtcHM6IGZhbHNlIH0pO1xuICAgKiAgIC8vICAgc2VxdWVsaXplLmRlZmluZShuYW1lLCBhdHRyaWJ1dGVzLCB7IHRpbWVzdGFtcHM6IGZhbHNlIH0pO1xuICAgKiAgIC8vIHNvIGRlZmluaW5nIHRoZSB0aW1lc3RhbXBzIGZvciBlYWNoIG1vZGVsIHdpbGwgYmUgbm90IG5lY2Vzc2FyeVxuICAgKiAgIGRlZmluZToge1xuICAgKiAgICAgdW5kZXJzY29yZWQ6IGZhbHNlLFxuICAgKiAgICAgZnJlZXplVGFibGVOYW1lOiBmYWxzZSxcbiAgICogICAgIGNoYXJzZXQ6ICd1dGY4JyxcbiAgICogICAgIGRpYWxlY3RPcHRpb25zOiB7XG4gICAqICAgICAgIGNvbGxhdGU6ICd1dGY4X2dlbmVyYWxfY2knXG4gICAqICAgICB9LFxuICAgKiAgICAgdGltZXN0YW1wczogdHJ1ZVxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgLy8gc2ltaWxhciBmb3Igc3luYzogeW91IGNhbiBkZWZpbmUgdGhpcyB0byBhbHdheXMgZm9yY2Ugc3luYyBmb3IgbW9kZWxzXG4gICAqICAgc3luYzogeyBmb3JjZTogdHJ1ZSB9LFxuICAgKlxuICAgKiAgIC8vIHBvb2wgY29uZmlndXJhdGlvbiB1c2VkIHRvIHBvb2wgZGF0YWJhc2UgY29ubmVjdGlvbnNcbiAgICogICBwb29sOiB7XG4gICAqICAgICBtYXg6IDUsXG4gICAqICAgICBpZGxlOiAzMDAwMCxcbiAgICogICAgIGFjcXVpcmU6IDYwMDAwLFxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgLy8gaXNvbGF0aW9uIGxldmVsIG9mIGVhY2ggdHJhbnNhY3Rpb25cbiAgICogICAvLyBkZWZhdWx0cyB0byBkaWFsZWN0IGRlZmF1bHRcbiAgICogICBpc29sYXRpb25MZXZlbDogVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRVBFQVRBQkxFX1JFQURcbiAgICogfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2RhdGFiYXNlXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW3VzZXJuYW1lPW51bGxdIFRoZSB1c2VybmFtZSB3aGljaCBpcyB1c2VkIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbnN0IHRoZSBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW3Bhc3N3b3JkPW51bGxdIFRoZSBwYXNzd29yZCB3aGljaCBpcyB1c2VkIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbnN0IHRoZSBkYXRhYmFzZS4gU3VwcG9ydHMgU1FMQ2lwaGVyIGVuY3J5cHRpb24gZm9yIFNRTGl0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnM9e31dIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmhvc3Q9J2xvY2FsaG9zdCddIFRoZSBob3N0IG9mIHRoZSByZWxhdGlvbmFsIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb3J0PV0gVGhlIHBvcnQgb2YgdGhlIHJlbGF0aW9uYWwgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnVzZXJuYW1lPW51bGxdIFRoZSB1c2VybmFtZSB3aGljaCBpcyB1c2VkIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbnN0IHRoZSBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMucGFzc3dvcmQ9bnVsbF0gVGhlIHBhc3N3b3JkIHdoaWNoIGlzIHVzZWQgdG8gYXV0aGVudGljYXRlIGFnYWluc3QgdGhlIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5kYXRhYmFzZT1udWxsXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuZGlhbGVjdF0gVGhlIGRpYWxlY3Qgb2YgdGhlIGRhdGFiYXNlIHlvdSBhcmUgY29ubmVjdGluZyB0by4gT25lIG9mIG15c3FsLCBwb3N0Z3Jlcywgc3FsaXRlIGFuZCBtc3NxbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuZGlhbGVjdE1vZHVsZT1udWxsXSBJZiBzcGVjaWZpZWQsIHVzZSB0aGlzIGRpYWxlY3QgbGlicmFyeS4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHVzZSBwZy5qcyBpbnN0ZWFkIG9mIHBnIHdoZW4gY29ubmVjdGluZyB0byBhIHBnIGRhdGFiYXNlLCB5b3Ugc2hvdWxkIHNwZWNpZnkgJ3JlcXVpcmUoXCJwZy5qc1wiKScgaGVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5kaWFsZWN0TW9kdWxlUGF0aD1udWxsXSBJZiBzcGVjaWZpZWQsIGxvYWQgdGhlIGRpYWxlY3QgbGlicmFyeSBmcm9tIHRoaXMgcGF0aC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHVzZSBwZy5qcyBpbnN0ZWFkIG9mIHBnIHdoZW4gY29ubmVjdGluZyB0byBhIHBnIGRhdGFiYXNlLCB5b3Ugc2hvdWxkIHNwZWNpZnkgJy9wYXRoL3RvL3BnLmpzJyBoZXJlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLmRpYWxlY3RPcHRpb25zXSBBbiBvYmplY3Qgb2YgYWRkaXRpb25hbCBvcHRpb25zLCB3aGljaCBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBjb25uZWN0aW9uIGxpYnJhcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuc3RvcmFnZV0gT25seSB1c2VkIGJ5IHNxbGl0ZS4gRGVmYXVsdHMgdG8gJzptZW1vcnk6J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5wcm90b2NvbD0ndGNwJ10gVGhlIHByb3RvY29sIG9mIHRoZSByZWxhdGlvbmFsIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5kZWZpbmU9e31dIERlZmF1bHQgb3B0aW9ucyBmb3IgbW9kZWwgZGVmaW5pdGlvbnMuIFNlZSB7QGxpbmsgTW9kZWwuaW5pdH0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnF1ZXJ5PXt9XSBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcXVlbGl6ZS5xdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5zY2hlbWE9bnVsbF0gQSBzY2hlbWEgdG8gdXNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnNldD17fV0gRGVmYXVsdCBvcHRpb25zIGZvciBzZXF1ZWxpemUuc2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnN5bmM9e31dIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VxdWVsaXplLnN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMudGltZXpvbmU9JyswMDowMCddIFRoZSB0aW1lem9uZSB1c2VkIHdoZW4gY29udmVydGluZyBhIGRhdGUgZnJvbSB0aGUgZGF0YWJhc2UgaW50byBhIEphdmFTY3JpcHQgZGF0ZS4gVGhlIHRpbWV6b25lIGlzIGFsc28gdXNlZCB0byBTRVQgVElNRVpPTkUgd2hlbiBjb25uZWN0aW5nIHRvIHRoZSBzZXJ2ZXIsIHRvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgTk9XLCBDVVJSRU5UX1RJTUVTVEFNUCBhbmQgb3RoZXIgdGltZSByZWxhdGVkIGZ1bmN0aW9ucyBoYXZlIGluIHRoZSByaWdodCB0aW1lem9uZS4gRm9yIGJlc3QgY3Jvc3MgcGxhdGZvcm0gcGVyZm9ybWFuY2UgdXNlIHRoZSBmb3JtYXQgKy8tSEg6TU0uIFdpbGwgYWxzbyBhY2NlcHQgc3RyaW5nIHZlcnNpb25zIG9mIHRpbWV6b25lcyB1c2VkIGJ5IG1vbWVudC5qcyAoZS5nLiAnQW1lcmljYS9Mb3NfQW5nZWxlcycpOyB0aGlzIGlzIHVzZWZ1bCB0byBjYXB0dXJlIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcz0nd2FybmluZyddIFRoZSBQb3N0Z3JlU1FMIGBjbGllbnRfbWluX21lc3NhZ2VzYCBzZXNzaW9uIHBhcmFtZXRlci4gU2V0IHRvIGBmYWxzZWAgdG8gbm90IG92ZXJyaWRlIHRoZSBkYXRhYmFzZSdzIGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3M9dHJ1ZV0gVGhlIFBvc3RncmVTUUwgYHN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5nc2Agc2Vzc2lvbiBwYXJhbWV0ZXIuIFNldCB0byBgZmFsc2VgIHRvIG5vdCBzZXQgdGhlIG9wdGlvbi4gV0FSTklORzogU2V0dGluZyB0aGlzIHRvIGZhbHNlIG1heSBleHBvc2UgdnVsbmVyYWJpbGl0aWVzIGFuZCBpcyBub3QgcmVjb21tZW5kZWQhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9Y29uc29sZS5sb2ddIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgU2VxdWVsaXplIHdvdWxkIGxvZyBzb21ldGhpbmcuIEZ1bmN0aW9uIG1heSByZWNlaXZlIG11bHRpcGxlIHBhcmFtZXRlcnMgYnV0IG9ubHkgZmlyc3Qgb25lIGlzIHByaW50ZWQgYnkgYGNvbnNvbGUubG9nYC4gVG8gcHJpbnQgYWxsIHZhbHVlcyB1c2UgYCguLi5tc2cpID0+IGNvbnNvbGUubG9nKG1zZylgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLm9taXROdWxsPWZhbHNlXSBBIGZsYWcgdGhhdCBkZWZpbmVzIGlmIG51bGwgdmFsdWVzIHNob3VsZCBiZSBwYXNzZWQgYXMgdmFsdWVzIHRvIENSRUFURS9VUERBVEUgU1FMIHF1ZXJpZXMgb3Igbm90LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5uYXRpdmU9ZmFsc2VdIEEgZmxhZyB0aGF0IGRlZmluZXMgaWYgbmF0aXZlIGxpYnJhcnkgc2hhbGwgYmUgdXNlZCBvciBub3QuIEN1cnJlbnRseSBvbmx5IGhhcyBhbiBlZmZlY3QgZm9yIHBvc3RncmVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnJlcGxpY2F0aW9uPWZhbHNlXSBVc2UgcmVhZCAvIHdyaXRlIHJlcGxpY2F0aW9uLiBUbyBlbmFibGUgcmVwbGljYXRpb24sIHBhc3MgYW4gb2JqZWN0LCB3aXRoIHR3byBwcm9wZXJ0aWVzLCByZWFkIGFuZCB3cml0ZS4gV3JpdGUgc2hvdWxkIGJlIGFuIG9iamVjdCAoYSBzaW5nbGUgc2VydmVyIGZvciBoYW5kbGluZyB3cml0ZXMpLCBhbmQgcmVhZCBhbiBhcnJheSBvZiBvYmplY3QgKHNldmVyYWwgc2VydmVycyB0byBoYW5kbGUgcmVhZHMpLiBFYWNoIHJlYWQvd3JpdGUgc2VydmVyIGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogYGhvc3RgLCBgcG9ydGAsIGB1c2VybmFtZWAsIGBwYXNzd29yZGAsIGBkYXRhYmFzZWBcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMucG9vbF0gc2VxdWVsaXplIGNvbm5lY3Rpb24gcG9vbCBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wubWF4PTVdIE1heGltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb24gaW4gcG9vbFxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLm1pbj0wXSBNaW5pbXVtIG51bWJlciBvZiBjb25uZWN0aW9uIGluIHBvb2xcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5pZGxlPTEwMDAwXSBUaGUgbWF4aW11bSB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRoYXQgYSBjb25uZWN0aW9uIGNhbiBiZSBpZGxlIGJlZm9yZSBiZWluZyByZWxlYXNlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5hY3F1aXJlPTYwMDAwXSBUaGUgbWF4aW11bSB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRoYXQgcG9vbCB3aWxsIHRyeSB0byBnZXQgY29ubmVjdGlvbiBiZWZvcmUgdGhyb3dpbmcgZXJyb3JcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5ldmljdD0xMDAwXSBUaGUgdGltZSBpbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzLCBhZnRlciB3aGljaCBzZXF1ZWxpemUtcG9vbCB3aWxsIHJlbW92ZSBpZGxlIGNvbm5lY3Rpb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5wb29sLnZhbGlkYXRlXSBBIGZ1bmN0aW9uIHRoYXQgdmFsaWRhdGVzIGEgY29ubmVjdGlvbi4gQ2FsbGVkIHdpdGggY2xpZW50LiBUaGUgZGVmYXVsdCBmdW5jdGlvbiBjaGVja3MgdGhhdCBjbGllbnQgaXMgYW4gb2JqZWN0LCBhbmQgdGhhdCBpdHMgc3RhdGUgaXMgbm90IGRpc2Nvbm5lY3RlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLm1heFVzZXM9SW5maW5pdHldIFRoZSBudW1iZXIgb2YgdGltZXMgYSBjb25uZWN0aW9uIGNhbiBiZSB1c2VkIGJlZm9yZSBkaXNjYXJkaW5nIGl0IGZvciBhIHJlcGxhY2VtZW50LCBbYHVzZWQgZm9yIGV2ZW50dWFsIGNsdXN0ZXIgcmViYWxhbmNpbmdgXShodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS1wb29sKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMucXVvdGVJZGVudGlmaWVycz10cnVlXSBTZXQgdG8gYGZhbHNlYCB0byBtYWtlIHRhYmxlIG5hbWVzIGFuZCBhdHRyaWJ1dGVzIGNhc2UtaW5zZW5zaXRpdmUgb24gUG9zdGdyZXMgYW5kIHNraXAgZG91YmxlIHF1b3Rpbmcgb2YgdGhlbS4gIFdBUk5JTkc6IFNldHRpbmcgdGhpcyB0byBmYWxzZSBtYXkgZXhwb3NlIHZ1bG5lcmFiaWxpdGllcyBhbmQgaXMgbm90IHJlY29tbWVuZGVkIVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy50cmFuc2FjdGlvblR5cGU9J0RFRkVSUkVEJ10gU2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uIHR5cGUuIFNlZSBgU2VxdWVsaXplLlRyYW5zYWN0aW9uLlRZUEVTYCBmb3IgcG9zc2libGUgb3B0aW9ucy4gU3FsaXRlIG9ubHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmlzb2xhdGlvbkxldmVsXSBTZXQgdGhlIGRlZmF1bHQgdHJhbnNhY3Rpb24gaXNvbGF0aW9uIGxldmVsLiBTZWUgYFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTYCBmb3IgcG9zc2libGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMucmV0cnldIFNldCBvZiBmbGFncyB0aGF0IGNvbnRyb2wgd2hlbiBhIHF1ZXJ5IGlzIGF1dG9tYXRpY2FsbHkgcmV0cmllZC4gQWNjZXB0cyBhbGwgb3B0aW9ucyBmb3IgW2ByZXRyeS1hcy1wcm9taXNlZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNraGFuc2VuL3JldHJ5LWFzLXByb21pc2VkKS5cbiAgICogQHBhcmFtIHtBcnJheX0gICAgW29wdGlvbnMucmV0cnkubWF0Y2hdIE9ubHkgcmV0cnkgYSBxdWVyeSBpZiB0aGUgZXJyb3IgbWF0Y2hlcyBvbmUgb2YgdGhlc2Ugc3RyaW5ncy5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucmV0cnkubWF4XSBIb3cgbWFueSB0aW1lcyBhIGZhaWxpbmcgcXVlcnkgaXMgYXV0b21hdGljYWxseSByZXRyaWVkLiAgU2V0IHRvIDAgdG8gZGlzYWJsZSByZXRyeWluZyBvbiBTUUxfQlVTWSBlcnJvci5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMudHlwZVZhbGlkYXRpb249ZmFsc2VdIFJ1biBidWlsdC1pbiB0eXBlIHZhbGlkYXRvcnMgb24gaW5zZXJ0IGFuZCB1cGRhdGUsIGFuZCBzZWxlY3Qgd2l0aCB3aGVyZSBjbGF1c2UsIGUuZy4gdmFsaWRhdGUgdGhhdCBhcmd1bWVudHMgcGFzc2VkIHRvIGludGVnZXIgZmllbGRzIGFyZSBpbnRlZ2VyLWxpa2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLm9wZXJhdG9yc0FsaWFzZXNdIFN0cmluZyBiYXNlZCBvcGVyYXRvciBhbGlhcy4gUGFzcyBvYmplY3QgdG8gbGltaXQgc2V0IG9mIGFsaWFzZWQgb3BlcmF0b3JzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5ob29rc10gQW4gb2JqZWN0IG9mIGdsb2JhbCBob29rIGZ1bmN0aW9ucyB0aGF0IGFyZSBjYWxsZWQgYmVmb3JlIGFuZCBhZnRlciBjZXJ0YWluIGxpZmVjeWNsZSBldmVudHMuIEdsb2JhbCBob29rcyB3aWxsIHJ1biBhZnRlciBhbnkgbW9kZWwtc3BlY2lmaWMgaG9va3MgZGVmaW5lZCBmb3IgdGhlIHNhbWUgZXZlbnQgKFNlZSBgU2VxdWVsaXplLk1vZGVsLmluaXQoKWAgZm9yIGEgbGlzdCkuICBBZGRpdGlvbmFsbHksIGBiZWZvcmVDb25uZWN0KClgLCBgYWZ0ZXJDb25uZWN0KClgLCBgYmVmb3JlRGlzY29ubmVjdCgpYCwgYW5kIGBhZnRlckRpc2Nvbm5lY3QoKWAgaG9va3MgbWF5IGJlIGRlZmluZWQgaGVyZS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMubWluaWZ5QWxpYXNlcz1mYWxzZV0gQSBmbGFnIHRoYXQgZGVmaW5lcyBpZiBhbGlhc2VzIHNob3VsZCBiZSBtaW5pZmllZCAobW9zdGx5IHVzZWZ1bCB0byBhdm9pZCBQb3N0Z3JlcyBhbGlhcyBjaGFyYWN0ZXIgbGltaXQgb2YgNjQpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLmxvZ1F1ZXJ5UGFyYW1ldGVycz1mYWxzZV0gQSBmbGFnIHRoYXQgZGVmaW5lcyBpZiBzaG93IGJpbmQgcGFyYW1ldGVycyBpbiBsb2cuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgbGV0IGNvbmZpZztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkYXRhYmFzZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIG5ldyBTZXF1ZWxpemUoeyAuLi4gb3B0aW9ucyB9KVxuICAgICAgb3B0aW9ucyA9IGRhdGFiYXNlO1xuICAgICAgY29uZmlnID0gXy5waWNrKG9wdGlvbnMsICdob3N0JywgJ3BvcnQnLCAnZGF0YWJhc2UnLCAndXNlcm5hbWUnLCAncGFzc3dvcmQnKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRhdGFiYXNlID09PSAnc3RyaW5nJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiB1c2VybmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIG5ldyBTZXF1ZWxpemUoVVJJLCB7IC4uLiBvcHRpb25zIH0pXG5cbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgb3B0aW9ucyA9IHVzZXJuYW1lIHx8IHt9O1xuXG4gICAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5wYXJzZShhcmd1bWVudHNbMF0sIHRydWUpO1xuXG4gICAgICBvcHRpb25zLmRpYWxlY3QgPSB1cmxQYXJ0cy5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKTtcbiAgICAgIG9wdGlvbnMuaG9zdCA9IHVybFBhcnRzLmhvc3RuYW1lO1xuXG4gICAgICBpZiAob3B0aW9ucy5kaWFsZWN0ID09PSAnc3FsaXRlJyAmJiB1cmxQYXJ0cy5wYXRobmFtZSAmJiAhdXJsUGFydHMucGF0aG5hbWUuc3RhcnRzV2l0aCgnLzptZW1vcnknKSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlUGF0aCA9IHBhdGguam9pbihvcHRpb25zLmhvc3QsIHVybFBhcnRzLnBhdGhuYW1lKTtcbiAgICAgICAgb3B0aW9ucy5zdG9yYWdlID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuc3RvcmFnZSB8fCBzdG9yYWdlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxQYXJ0cy5wYXRobmFtZSkge1xuICAgICAgICBjb25maWcuZGF0YWJhc2UgPSB1cmxQYXJ0cy5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsUGFydHMucG9ydCkge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSB1cmxQYXJ0cy5wb3J0O1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsUGFydHMuYXV0aCkge1xuICAgICAgICBjb25zdCBhdXRoUGFydHMgPSB1cmxQYXJ0cy5hdXRoLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgY29uZmlnLnVzZXJuYW1lID0gYXV0aFBhcnRzWzBdO1xuXG4gICAgICAgIGlmIChhdXRoUGFydHMubGVuZ3RoID4gMSlcbiAgICAgICAgICBjb25maWcucGFzc3dvcmQgPSBhdXRoUGFydHMuc2xpY2UoMSkuam9pbignOicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsUGFydHMucXVlcnkpIHtcbiAgICAgICAgLy8gQWxsb3cgaG9zdCBxdWVyeSBhcmd1bWVudCB0byBvdmVycmlkZSB0aGUgdXJsIGhvc3QuXG4gICAgICAgIC8vIEVuYWJsZXMgc3BlY2lmeWluZyBkb21haW4gc29ja2V0IGhvc3RzIHdoaWNoIGNhbm5vdCBiZSBzcGVjaWZpZWQgdmlhIHRoZSB0eXBpY2FsXG4gICAgICAgIC8vIGhvc3QgcGFydCBvZiBhIHVybC5cbiAgICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5Lmhvc3QpIHtcbiAgICAgICAgICBvcHRpb25zLmhvc3QgPSB1cmxQYXJ0cy5xdWVyeS5ob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMsIHVybFBhcnRzLnF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmRpYWxlY3RPcHRpb25zID0gdXJsUGFydHMucXVlcnk7XG4gICAgICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSBKU09OLnBhcnNlKHVybFBhcnRzLnF1ZXJ5Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICBvcHRpb25zLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMgPSBvO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLCBzdHJpbmcgaXMgbm90IGEgdmFsaWQgSlNPTlxuICAgICAgICAgICAgICAvLyBhbiB0aHVzIGRvZXMgbm90IG5lZWQgYW55IGZ1cnRoZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXcgU2VxdWVsaXplKGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQsIHsgLi4uIG9wdGlvbnMgfSlcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgY29uZmlnID0geyBkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkIH07XG4gICAgfVxuXG4gICAgU2VxdWVsaXplLnJ1bkhvb2tzKCdiZWZvcmVJbml0JywgY29uZmlnLCBvcHRpb25zKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGRpYWxlY3Q6IG51bGwsXG4gICAgICBkaWFsZWN0TW9kdWxlOiBudWxsLFxuICAgICAgZGlhbGVjdE1vZHVsZVBhdGg6IG51bGwsXG4gICAgICBob3N0OiAnbG9jYWxob3N0JyxcbiAgICAgIHByb3RvY29sOiAndGNwJyxcbiAgICAgIGRlZmluZToge30sXG4gICAgICBxdWVyeToge30sXG4gICAgICBzeW5jOiB7fSxcbiAgICAgIHRpbWV6b25lOiAnKzAwOjAwJyxcbiAgICAgIGNsaWVudE1pbk1lc3NhZ2VzOiAnd2FybmluZycsXG4gICAgICBzdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzOiB0cnVlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZ2dpbmc6IGNvbnNvbGUubG9nLFxuICAgICAgb21pdE51bGw6IGZhbHNlLFxuICAgICAgbmF0aXZlOiBmYWxzZSxcbiAgICAgIHJlcGxpY2F0aW9uOiBmYWxzZSxcbiAgICAgIHNzbDogdW5kZWZpbmVkLFxuICAgICAgcG9vbDoge30sXG4gICAgICBxdW90ZUlkZW50aWZpZXJzOiB0cnVlLFxuICAgICAgaG9va3M6IHt9LFxuICAgICAgcmV0cnk6IHtcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgICdTUUxJVEVfQlVTWTogZGF0YWJhc2UgaXMgbG9ja2VkJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvbi5UWVBFUy5ERUZFUlJFRCxcbiAgICAgIGlzb2xhdGlvbkxldmVsOiBudWxsLFxuICAgICAgZGF0YWJhc2VWZXJzaW9uOiAwLFxuICAgICAgdHlwZVZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgYmVuY2htYXJrOiBmYWxzZSxcbiAgICAgIG1pbmlmeUFsaWFzZXM6IGZhbHNlLFxuICAgICAgbG9nUXVlcnlQYXJhbWV0ZXJzOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlhbGVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWFsZWN0IG5lZWRzIHRvIGJlIGV4cGxpY2l0bHkgc3VwcGxpZWQgYXMgb2YgdjQuMC4wJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ID09PSAncG9zdGdyZXNxbCcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kaWFsZWN0ID0gJ3Bvc3RncmVzJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgPT09ICdzcWxpdGUnICYmIHRoaXMub3B0aW9ucy50aW1lem9uZSAhPT0gJyswMDowMCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2V0dGluZyBhIGN1c3RvbSB0aW1lem9uZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IFNRTGl0ZSwgZGF0ZXMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBVVEMuIFBsZWFzZSByZW1vdmUgdGhlIGN1c3RvbSB0aW1lem9uZSBwYXJhbWV0ZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMub3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dXBIb29rcyhvcHRpb25zLmhvb2tzKTtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSB8fCB0aGlzLm9wdGlvbnMuZGF0YWJhc2UsXG4gICAgICB1c2VybmFtZTogY29uZmlnLnVzZXJuYW1lIHx8IHRoaXMub3B0aW9ucy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQgfHwgdGhpcy5vcHRpb25zLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICBob3N0OiBjb25maWcuaG9zdCB8fCB0aGlzLm9wdGlvbnMuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0IHx8IHRoaXMub3B0aW9ucy5wb3J0LFxuICAgICAgcG9vbDogdGhpcy5vcHRpb25zLnBvb2wsXG4gICAgICBwcm90b2NvbDogdGhpcy5vcHRpb25zLnByb3RvY29sLFxuICAgICAgbmF0aXZlOiB0aGlzLm9wdGlvbnMubmF0aXZlLFxuICAgICAgc3NsOiB0aGlzLm9wdGlvbnMuc3NsLFxuICAgICAgcmVwbGljYXRpb246IHRoaXMub3B0aW9ucy5yZXBsaWNhdGlvbixcbiAgICAgIGRpYWxlY3RNb2R1bGU6IHRoaXMub3B0aW9ucy5kaWFsZWN0TW9kdWxlLFxuICAgICAgZGlhbGVjdE1vZHVsZVBhdGg6IHRoaXMub3B0aW9ucy5kaWFsZWN0TW9kdWxlUGF0aCxcbiAgICAgIGtlZXBEZWZhdWx0VGltZXpvbmU6IHRoaXMub3B0aW9ucy5rZWVwRGVmYXVsdFRpbWV6b25lLFxuICAgICAgZGlhbGVjdE9wdGlvbnM6IHRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9uc1xuICAgIH07XG5cbiAgICBsZXQgRGlhbGVjdDtcbiAgICAvLyBSZXF1aXJpbmcgdGhlIGRpYWxlY3QgaW4gYSBzd2l0Y2gtY2FzZSB0byBrZWVwIHRoZVxuICAgIC8vIHJlcXVpcmUgY2FsbHMgc3RhdGljLiAoQnJvd3NlcmlmeSBmaXgpXG4gICAgc3dpdGNoICh0aGlzLmdldERpYWxlY3QoKSkge1xuICAgICAgY2FzZSAnbWFyaWFkYic6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKCcuL2RpYWxlY3RzL21hcmlhZGInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtc3NxbCc6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKCcuL2RpYWxlY3RzL21zc3FsJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbXlzcWwnOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9teXNxbCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc3RncmVzJzpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvcG9zdGdyZXMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzcWxpdGUnOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9zcWxpdGUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkaWFsZWN0ICR7dGhpcy5nZXREaWFsZWN0KCl9IGlzIG5vdCBzdXBwb3J0ZWQuIFN1cHBvcnRlZCBkaWFsZWN0czogbXNzcWwsIG1hcmlhZGIsIG15c3FsLCBwb3N0Z3JlcywgYW5kIHNxbGl0ZS5gKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpYWxlY3QgPSBuZXcgRGlhbGVjdCh0aGlzKTtcbiAgICB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IudHlwZVZhbGlkYXRpb24gPSBvcHRpb25zLnR5cGVWYWxpZGF0aW9uO1xuXG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcykpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1N0cmluZ09wZXJhdG9ycygpO1xuICAgICAgdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLnNldE9wZXJhdG9yc0FsaWFzZXModGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub0Jvb2xPcGVyYXRvckFsaWFzZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gdGhpcy5kaWFsZWN0LnF1ZXJ5SW50ZXJmYWNlO1xuXG4gICAgLyoqXG4gICAgICogTW9kZWxzIGFyZSBzdG9yZWQgaGVyZSB1bmRlciB0aGUgbmFtZSBnaXZlbiB0byBgc2VxdWVsaXplLmRlZmluZWBcbiAgICAgKi9cbiAgICB0aGlzLm1vZGVscyA9IHt9O1xuICAgIHRoaXMubW9kZWxNYW5hZ2VyID0gbmV3IE1vZGVsTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyO1xuXG4gICAgU2VxdWVsaXplLnJ1bkhvb2tzKCdhZnRlckluaXQnLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGRhdGEgdHlwZXMgYW5kIHBhcnNlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWZyZXNoVHlwZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBkaWFsZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3BlY2lmaWVkIGRpYWxlY3QuXG4gICAqL1xuICBnZXREaWFsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlhbGVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhYmFzZSBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YWJhc2UgbmFtZS5cbiAgICovXG4gIGdldERhdGFiYXNlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YWJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBRdWVyeUludGVyZmFjZS5cbiAgICpcbiAgICogQHJldHVybnMge1F1ZXJ5SW50ZXJmYWNlfSBBbiBpbnN0YW5jZSAoc2luZ2xldG9uKSBvZiBRdWVyeUludGVyZmFjZS5cbiAgICovXG4gIGdldFF1ZXJ5SW50ZXJmYWNlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5SW50ZXJmYWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIG5ldyBtb2RlbCwgcmVwcmVzZW50aW5nIGEgdGFibGUgaW4gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBUaGUgdGFibGUgY29sdW1ucyBhcmUgZGVmaW5lZCBieSB0aGUgb2JqZWN0IHRoYXQgaXMgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gRWFjaCBrZXkgb2YgdGhlIG9iamVjdCByZXByZXNlbnRzIGEgY29sdW1uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1vZGVsLiBUaGUgbW9kZWwgd2lsbCBiZSBzdG9yZWQgaW4gYHNlcXVlbGl6ZS5tb2RlbHNgIHVuZGVyIHRoaXMgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyBBbiBvYmplY3QsIHdoZXJlIGVhY2ggYXR0cmlidXRlIGlzIGEgY29sdW1uIG9mIHRoZSB0YWJsZS4gU2VlIHtAbGluayBNb2RlbC5pbml0fVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZXNlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZSBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBTZXF1ZWxpemUgY29uc3RydWN0b3IgYW5kIHBhc3NlZCB0byBNb2RlbC5pbml0KClcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuaW5pdH0gZm9yIGEgbW9yZSBjb21wcmVoZW5zaXZlIHNwZWNpZmljYXRpb24gb2YgdGhlIGBvcHRpb25zYCBhbmQgYGF0dHJpYnV0ZXNgIG9iamVjdHMuXG4gICAqIEBzZWVcbiAgICogPGEgaHJlZj1cIi9tYXN0ZXIvbWFudWFsL21vZGVsLWJhc2ljcy5odG1sXCI+TW9kZWwgQmFzaWNzPC9hPiBndWlkZVxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9IE5ld2x5IGRlZmluZWQgbW9kZWxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogc2VxdWVsaXplLmRlZmluZSgnbW9kZWxOYW1lJywge1xuICAgKiAgIGNvbHVtbkE6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLkJPT0xFQU4sXG4gICAqICAgICAgIHZhbGlkYXRlOiB7XG4gICAqICAgICAgICAgaXM6IFtcIlthLXpdXCIsJ2knXSwgICAgICAgIC8vIHdpbGwgb25seSBhbGxvdyBsZXR0ZXJzXG4gICAqICAgICAgICAgbWF4OiAyMywgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFsbG93IHZhbHVlcyA8PSAyM1xuICAgKiAgICAgICAgIGlzSW46IHtcbiAgICogICAgICAgICAgIGFyZ3M6IFtbJ2VuJywgJ3poJ11dLFxuICAgKiAgICAgICAgICAgbXNnOiBcIk11c3QgYmUgRW5nbGlzaCBvciBDaGluZXNlXCJcbiAgICogICAgICAgICB9XG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIGZpZWxkOiAnY29sdW1uX2EnXG4gICAqICAgfSxcbiAgICogICBjb2x1bW5COiBTZXF1ZWxpemUuU1RSSU5HLFxuICAgKiAgIGNvbHVtbkM6ICdNWSBWRVJZIE9XTiBDT0xVTU4gVFlQRSdcbiAgICogfSk7XG4gICAqXG4gICAqIHNlcXVlbGl6ZS5tb2RlbHMubW9kZWxOYW1lIC8vIFRoZSBtb2RlbCB3aWxsIG5vdyBiZSBhdmFpbGFibGUgaW4gbW9kZWxzIHVuZGVyIHRoZSBuYW1lIGdpdmVuIHRvIGRlZmluZVxuICAgKi9cbiAgZGVmaW5lKG1vZGVsTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5tb2RlbE5hbWUgPSBtb2RlbE5hbWU7XG4gICAgb3B0aW9ucy5zZXF1ZWxpemUgPSB0aGlzO1xuXG4gICAgY29uc3QgbW9kZWwgPSBjbGFzcyBleHRlbmRzIE1vZGVsIHt9O1xuXG4gICAgbW9kZWwuaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIE1vZGVsIHdoaWNoIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxOYW1lIFRoZSBuYW1lIG9mIGEgbW9kZWwgZGVmaW5lZCB3aXRoIFNlcXVlbGl6ZS5kZWZpbmVcbiAgICpcbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBtb2RlbCBpcyBub3QgZGVmaW5lZCAodGhhdCBpcywgaWYgc2VxdWVsaXplI2lzRGVmaW5lZCByZXR1cm5zIGZhbHNlKVxuICAgKiBAcmV0dXJucyB7TW9kZWx9IFNwZWNpZmllZCBtb2RlbFxuICAgKi9cbiAgbW9kZWwobW9kZWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzRGVmaW5lZChtb2RlbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bW9kZWxOYW1lfSBoYXMgbm90IGJlZW4gZGVmaW5lZGApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1vZGVsTWFuYWdlci5nZXRNb2RlbChtb2RlbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBkZWZpbmVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWUgVGhlIG5hbWUgb2YgYSBtb2RlbCBkZWZpbmVkIHdpdGggU2VxdWVsaXplLmRlZmluZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1vZGVsIGlzIGFscmVhZHkgZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqL1xuICBpc0RlZmluZWQobW9kZWxOYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzLmZpbmQobW9kZWwgPT4gbW9kZWwubmFtZSA9PT0gbW9kZWxOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgcXVlcnkgb24gdGhlIERCLCBvcHRpb25hbGx5IGJ5cGFzc2luZyBhbGwgdGhlIFNlcXVlbGl6ZSBnb29kbmVzcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBhcmd1bWVudHM6IGFuIGFycmF5IG9mIHJlc3VsdHMsIGFuZCBhIG1ldGFkYXRhIG9iamVjdCwgY29udGFpbmluZyBudW1iZXIgb2YgYWZmZWN0ZWQgcm93cyBldGMuXG4gICAqXG4gICAqIElmIHlvdSBhcmUgcnVubmluZyBhIHR5cGUgb2YgcXVlcnkgd2hlcmUgeW91IGRvbid0IG5lZWQgdGhlIG1ldGFkYXRhLCBmb3IgZXhhbXBsZSBhIGBTRUxFQ1RgIHF1ZXJ5LCB5b3UgY2FuIHBhc3MgaW4gYSBxdWVyeSB0eXBlIHRvIG1ha2Ugc2VxdWVsaXplIGZvcm1hdCB0aGUgcmVzdWx0czpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgW3Jlc3VsdHMsIG1ldGFkYXRhXSA9IGF3YWl0IHNlcXVlbGl6ZS5xdWVyeSgnU0VMRUNULi4uJyk7IC8vIFJhdyBxdWVyeSAtIHVzZSBhcnJheSBkZXN0cnVjdHVyaW5nXG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzZXF1ZWxpemUucXVlcnkoJ1NFTEVDVC4uLicsIHsgdHlwZTogc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0VMRUNUIH0pOyAvLyBTRUxFQ1QgcXVlcnkgLSBubyBkZXN0cnVjdHVyaW5nXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgc3FsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9ucz17fV0gUXVlcnkgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLnJhd10gSWYgdHJ1ZSwgc2VxdWVsaXplIHdpbGwgbm90IHRyeSB0byBmb3JtYXQgdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LCBvciBidWlsZCBhbiBpbnN0YW5jZSBvZiBhIG1vZGVsIGZyb20gdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSAgICAgW29wdGlvbnMudHJhbnNhY3Rpb249bnVsbF0gVGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBleGVjdXRlZCB1bmRlclxuICAgKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9ICAgICAgW29wdGlvbnMudHlwZT0nUkFXJ10gVGhlIHR5cGUgb2YgcXVlcnkgeW91IGFyZSBleGVjdXRpbmcuIFRoZSBxdWVyeSB0eXBlIGFmZmVjdHMgaG93IHJlc3VsdHMgYXJlIGZvcm1hdHRlZCBiZWZvcmUgdGhleSBhcmUgcGFzc2VkIGJhY2suIFRoZSB0eXBlIGlzIGEgc3RyaW5nLCBidXQgYFNlcXVlbGl6ZS5RdWVyeVR5cGVzYCBpcyBwcm92aWRlZCBhcyBjb252ZW5pZW5jZSBzaG9ydGN1dHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5uZXN0PWZhbHNlXSBJZiB0cnVlLCB0cmFuc2Zvcm1zIG9iamVjdHMgd2l0aCBgLmAgc2VwYXJhdGVkIHByb3BlcnR5IG5hbWVzIGludG8gbmVzdGVkIG9iamVjdHMgdXNpbmcgW2RvdHRpZS5qc10oaHR0cHM6Ly9naXRodWIuY29tL21pY2toYW5zZW4vZG90dGllLmpzKS4gRm9yIGV4YW1wbGUgeyAndXNlci51c2VybmFtZSc6ICdqb2huJyB9IGJlY29tZXMgeyB1c2VyOiB7IHVzZXJuYW1lOiAnam9obicgfX0uIFdoZW4gYG5lc3RgIGlzIHRydWUsIHRoZSBxdWVyeSB0eXBlIGlzIGFzc3VtZWQgdG8gYmUgYCdTRUxFQ1QnYCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWRcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLnBsYWluPWZhbHNlXSBTZXRzIHRoZSBxdWVyeSB0eXBlIHRvIGBTRUxFQ1RgIGFuZCByZXR1cm4gYSBzaW5nbGUgcm93XG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSAgICBbb3B0aW9ucy5yZXBsYWNlbWVudHNdIEVpdGhlciBhbiBvYmplY3Qgb2YgbmFtZWQgcGFyYW1ldGVyIHJlcGxhY2VtZW50cyBpbiB0aGUgZm9ybWF0IGA6cGFyYW1gIG9yIGFuIGFycmF5IG9mIHVubmFtZWQgcmVwbGFjZW1lbnRzIHRvIHJlcGxhY2UgYD9gIGluIHlvdXIgU1FMLlxuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gICAgW29wdGlvbnMuYmluZF0gRWl0aGVyIGFuIG9iamVjdCBvZiBuYW1lZCBiaW5kIHBhcmFtZXRlciBpbiB0aGUgZm9ybWF0IGBfcGFyYW1gIG9yIGFuIGFycmF5IG9mIHVubmFtZWQgYmluZCBwYXJhbWV0ZXIgdG8gcmVwbGFjZSBgJDEsICQyLCAuLi5gIGluIHlvdXIgU1FMLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMudXNlTWFzdGVyPWZhbHNlXSBGb3JjZSB0aGUgcXVlcnkgdG8gdXNlIHRoZSB3cml0ZSBwb29sLCByZWdhcmRsZXNzIG9mIHRoZSBxdWVyeSB0eXBlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICBbb3B0aW9ucy5pbnN0YW5jZV0gQSBzZXF1ZWxpemUgbW9kZWwgaW5zdGFuY2Ugd2hvc2UgTW9kZWwgaXMgdG8gYmUgdXNlZCB0byBidWlsZCB0aGUgcXVlcnkgcmVzdWx0XG4gICAqIEBwYXJhbSB7dHlwZW9mIE1vZGVsfSAgICBbb3B0aW9ucy5tb2RlbF0gQSBzZXF1ZWxpemUgbW9kZWwgdXNlZCB0byBidWlsZCB0aGUgcmV0dXJuZWQgbW9kZWwgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9ucy5yZXRyeV0gU2V0IG9mIGZsYWdzIHRoYXQgY29udHJvbCB3aGVuIGEgcXVlcnkgaXMgYXV0b21hdGljYWxseSByZXRyaWVkLiBBY2NlcHRzIGFsbCBvcHRpb25zIGZvciBbYHJldHJ5LWFzLXByb21pc2VkYF0oaHR0cHM6Ly9naXRodWIuY29tL21pY2toYW5zZW4vcmV0cnktYXMtcHJvbWlzZWQpLlxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgW29wdGlvbnMucmV0cnkubWF0Y2hdIE9ubHkgcmV0cnkgYSBxdWVyeSBpZiB0aGUgZXJyb3IgbWF0Y2hlcyBvbmUgb2YgdGhlc2Ugc3RyaW5ncy5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfSAgICAgICAgIFtvcHRpb25zLnJldHJ5Lm1heF0gSG93IG1hbnkgdGltZXMgYSBmYWlsaW5nIHF1ZXJ5IGlzIGF1dG9tYXRpY2FsbHkgcmV0cmllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLnN1cHBvcnRzU2VhcmNoUGF0aF0gSWYgZmFsc2UgZG8gbm90IHByZXBlbmQgdGhlIHF1ZXJ5IHdpdGggdGhlIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMubWFwVG9Nb2RlbD1mYWxzZV0gTWFwIHJldHVybmVkIGZpZWxkcyB0byBtb2RlbCdzIGZpZWxkcyBpZiBgb3B0aW9ucy5tb2RlbGAgb3IgYG9wdGlvbnMuaW5zdGFuY2VgIGlzIHByZXNlbnQuIE1hcHBpbmcgd2lsbCBvY2N1ciBiZWZvcmUgYnVpbGRpbmcgdGhlIG1vZGVsIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnMuZmllbGRNYXBdIE1hcCByZXR1cm5lZCBmaWVsZHMgdG8gYXJiaXRyYXJ5IG5hbWVzIGZvciBgU0VMRUNUYCBxdWVyeSB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgTW9kZWwuYnVpbGR9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGluc3RhbmNlIG9wdGlvbi5cbiAgICovXG5cbiAgYXN5bmMgcXVlcnkoc3FsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLnF1ZXJ5LCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAob3B0aW9ucy5pbnN0YW5jZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgb3B0aW9ucy5tb2RlbCA9IG9wdGlvbnMuaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmluc3RhbmNlICYmICFvcHRpb25zLm1vZGVsKSB7XG4gICAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gbWFwIHJhdyBmaWVsZHMgdG8gbW9kZWwgYXR0cmlidXRlc1xuICAgIGlmIChvcHRpb25zLm1hcFRvTW9kZWwpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRNYXAgPSBfLmdldChvcHRpb25zLCAnbW9kZWwuZmllbGRBdHRyaWJ1dGVNYXAnLCB7fSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZ2dpbmc6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9wdGlvbnMsICdsb2dnaW5nJykgPyB0aGlzLm9wdGlvbnMubG9nZ2luZyA6IGNvbnNvbGUubG9nLFxuICAgICAgc2VhcmNoUGF0aDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucywgJ3NlYXJjaFBhdGgnKSA/IHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoIDogJ0RFRkFVTFQnXG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwgfHwgb3B0aW9ucy5uZXN0IHx8IG9wdGlvbnMucGxhaW4pIHtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5TRUxFQ1Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlJBVztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2lmIGRpYWxlY3QgZG9lc24ndCBzdXBwb3J0IHNlYXJjaF9wYXRoIG9yIGRpYWxlY3Qgb3B0aW9uXG4gICAgLy90byBwcmVwZW5kIHNlYXJjaFBhdGggaXMgbm90IHRydWUgZGVsZXRlIHRoZSBzZWFyY2hQYXRoIG9wdGlvblxuICAgIGlmIChcbiAgICAgICF0aGlzLmRpYWxlY3Quc3VwcG9ydHMuc2VhcmNoUGF0aCB8fFxuICAgICAgIXRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9ucyB8fFxuICAgICAgIXRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9ucy5wcmVwZW5kU2VhcmNoUGF0aCB8fFxuICAgICAgb3B0aW9ucy5zdXBwb3J0c1NlYXJjaFBhdGggPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zZWFyY2hQYXRoO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgLy9pZiB1c2VyIHdhbnRzIHRvIGFsd2F5cyBwcmVwZW5kIHNlYXJjaFBhdGggKGRpYWxlY3RPcHRpb25zLnByZXByZW5kU2VhcmNoUGF0aCA9IHRydWUpXG4gICAgICAvL3RoZW4gc2V0IHRvIERFRkFVTFQgaWYgbm9uZSBpcyBwcm92aWRlZFxuICAgICAgb3B0aW9ucy5zZWFyY2hQYXRoID0gJ0RFRkFVTFQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3FsID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHNxbC52YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBgc3FsLnZhbHVlc2AgYW5kIGBvcHRpb25zLnJlcGxhY2VtZW50c2AgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5yZXBsYWNlbWVudHMgPSBzcWwudmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3FsLmJpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iaW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggYHNxbC5iaW5kYCBhbmQgYG9wdGlvbnMuYmluZGAgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5iaW5kID0gc3FsLmJpbmQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcWwucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzcWwgPSBzcWwucXVlcnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3FsID0gc3FsLnRyaW0oKTtcblxuICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cyAmJiBvcHRpb25zLmJpbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBgcmVwbGFjZW1lbnRzYCBhbmQgYGJpbmRgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZXBsYWNlbWVudHMpKSB7XG4gICAgICAgIHNxbCA9IFV0aWxzLmZvcm1hdChbc3FsXS5jb25jYXQob3B0aW9ucy5yZXBsYWNlbWVudHMpLCB0aGlzLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgPSBVdGlscy5mb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCBvcHRpb25zLnJlcGxhY2VtZW50cywgdGhpcy5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBiaW5kUGFyYW1ldGVycztcblxuICAgIGlmIChvcHRpb25zLmJpbmQpIHtcbiAgICAgIFtzcWwsIGJpbmRQYXJhbWV0ZXJzXSA9IHRoaXMuZGlhbGVjdC5RdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIG9wdGlvbnMuYmluZCwgdGhpcy5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkICYmICFvcHRpb25zLmNvbXBsZXRlc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke29wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWR9IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIHRyYW5zYWN0aW9uKCR7b3B0aW9ucy50cmFuc2FjdGlvbi5pZH0pLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgaXQuIChUaGUgcmVqZWN0ZWQgcXVlcnkgaXMgYXR0YWNoZWQgYXMgdGhlICdzcWwnIHByb3BlcnR5IG9mIHRoaXMgZXJyb3IpYCk7XG4gICAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLnJldHJ5LCAuLi5vcHRpb25zLnJldHJ5IH07XG5cbiAgICByZXR1cm4gcmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHVuZGVmaW5lZCAmJiBTZXF1ZWxpemUuX2Nscykge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gU2VxdWVsaXplLl9jbHMuZ2V0KCd0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjaGVja1RyYW5zYWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCAob3B0aW9ucy50cmFuc2FjdGlvbiA/IG9wdGlvbnMudHJhbnNhY3Rpb24uY29ubmVjdGlvbiA6IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbihvcHRpb25zKSk7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyB0aGlzLmRpYWxlY3QuUXVlcnkoY29ubmVjdGlvbiwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZVF1ZXJ5Jywgb3B0aW9ucywgcXVlcnkpO1xuICAgICAgICBjaGVja1RyYW5zYWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeS5ydW4oc3FsLCBiaW5kUGFyYW1ldGVycyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlclF1ZXJ5Jywgb3B0aW9ucywgcXVlcnkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgcmV0cnlPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgcXVlcnkgd2hpY2ggd291bGQgc2V0IGFuIGVudmlyb25tZW50IG9yIHVzZXIgdmFyaWFibGUuIFRoZSB2YXJpYWJsZXMgYXJlIHNldCBwZXIgY29ubmVjdGlvbiwgc28gdGhpcyBmdW5jdGlvbiBuZWVkcyBhIHRyYW5zYWN0aW9uLlxuICAgKiBPbmx5IHdvcmtzIGZvciBNeVNRTC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICB2YXJpYWJsZXMgT2JqZWN0IHdpdGggbXVsdGlwbGUgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgIFtvcHRpb25zXSBxdWVyeSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUaGUgdHJhbnNhY3Rpb24gdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIGV4ZWN1dGVkIHVuZGVyXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzZXQodmFyaWFibGVzLCBvcHRpb25zKSB7XG5cbiAgICAvLyBQcmVwYXJlIG9wdGlvbnNcbiAgICBvcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMuc2V0LCAuLi50eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ICE9PSAnbXlzcWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcXVlbGl6ZS5zZXQgaXMgb25seSBzdXBwb3J0ZWQgZm9yIG15c3FsJyk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50cmFuc2FjdGlvbiB8fCAhKG9wdGlvbnMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnRyYW5zYWN0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgc29tZSBvcHRpb25zLCBzaW5jZSB0aGlzIGlzbid0IGEgU0VMRUNUXG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuICAgIG9wdGlvbnMudHlwZSA9ICdTRVQnO1xuXG4gICAgLy8gR2VuZXJhdGUgU1FMIFF1ZXJ5XG4gICAgY29uc3QgcXVlcnkgPVxuICAgICAgYFNFVCAke1xuICAgICAgICBfLm1hcCh2YXJpYWJsZXMsICh2LCBrKSA9PiBgQCR7a30gOj0gJHt0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgXCIke3Z9XCJgIDogdn1gKS5qb2luKCcsICcpfWA7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgc3RyaW5nIHZhbHVlIHRvIGVzY2FwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZXNjYXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5lc2NhcGUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhYmFzZSBzY2hlbWEuXG4gICAqXG4gICAqICoqTm90ZToqKiB0aGlzIGlzIGEgc2NoZW1hIGluIHRoZSBbcG9zdGdyZXMgc2Vuc2Ugb2YgdGhlIHdvcmRdKGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjEvc3RhdGljL2RkbC1zY2hlbWFzLmh0bWwpLFxuICAgKiBub3QgYSBkYXRhYmFzZSB0YWJsZS4gSW4gbXlzcWwgYW5kIHNxbGl0ZSwgdGhpcyBjb21tYW5kIHdpbGwgZG8gbm90aGluZy5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuc2NoZW1hfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hIE5hbWUgb2YgdGhlIHNjaGVtYVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5jcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGFsbCBkZWZpbmVkIHNjaGVtYXNcbiAgICpcbiAgICogKipOb3RlOioqIHRoaXMgaXMgYSBzY2hlbWEgaW4gdGhlIFtwb3N0Z3JlcyBzZW5zZSBvZiB0aGUgd29yZF0oaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMS9zdGF0aWMvZGRsLXNjaGVtYXMuaHRtbCksXG4gICAqIG5vdCBhIGRhdGFiYXNlIHRhYmxlLiBJbiBteXNxbCBhbmQgc3FsaXRlLCB0aGlzIHdpbGwgc2hvdyBhbGwgdGFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzaG93QWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5zaG93QWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGEgc2luZ2xlIHNjaGVtYVxuICAgKlxuICAgKiAqKk5vdGU6KiogdGhpcyBpcyBhIHNjaGVtYSBpbiB0aGUgW3Bvc3RncmVzIHNlbnNlIG9mIHRoZSB3b3JkXShodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4xL3N0YXRpYy9kZGwtc2NoZW1hcy5odG1sKSxcbiAgICogbm90IGEgZGF0YWJhc2UgdGFibGUuIEluIG15c3FsIGFuZCBzcWxpdGUsIHRoaXMgZHJvcCBhIHRhYmxlIG1hdGNoaW5nIHRoZSBzY2hlbWEgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hIE5hbWUgb2YgdGhlIHNjaGVtYVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYWxsIHNjaGVtYXMuXG4gICAqXG4gICAqICoqTm90ZToqKiB0aGlzIGlzIGEgc2NoZW1hIGluIHRoZSBbcG9zdGdyZXMgc2Vuc2Ugb2YgdGhlIHdvcmRdKGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjEvc3RhdGljL2RkbC1zY2hlbWFzLmh0bWwpLFxuICAgKiBub3QgYSBkYXRhYmFzZSB0YWJsZS4gSW4gbXlzcWwgYW5kIHNxbGl0ZSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBkcm9wIGFsbCB0YWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmMgYWxsIGRlZmluZWQgbW9kZWxzIHRvIHRoZSBEQi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBzeW5jIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZT1mYWxzZV0gSWYgZm9yY2UgaXMgdHJ1ZSwgZWFjaCBNb2RlbCB3aWxsIHJ1biBgRFJPUCBUQUJMRSBJRiBFWElTVFNgLCBiZWZvcmUgaXQgdHJpZXMgdG8gY3JlYXRlIGl0cyBvd24gdGFibGVcbiAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLm1hdGNoXSBNYXRjaCBhIHJlZ2V4IGFnYWluc3QgdGhlIGRhdGFiYXNlIG5hbWUgYmVmb3JlIHN5bmNpbmcsIGEgc2FmZXR5IGNoZWNrIGZvciBjYXNlcyB3aGVyZSBmb3JjZTogdHJ1ZSBpcyB1c2VkIGluIHRlc3RzIGJ1dCBub3QgbGl2ZSBjb2RlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1jb25zb2xlLmxvZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWE9J3B1YmxpYyddIFRoZSBzY2hlbWEgdGhhdCB0aGUgdGFibGVzIHNob3VsZCBiZSBjcmVhdGVkIGluLiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGZvciBlYWNoIHRhYmxlIGluIHNlcXVlbGl6ZS5kZWZpbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ob29rcz10cnVlXSBJZiBob29rcyBpcyB0cnVlIHRoZW4gYmVmb3JlU3luYywgYWZ0ZXJTeW5jLCBiZWZvcmVCdWxrU3luYywgYWZ0ZXJCdWxrU3luYyBob29rcyB3aWxsIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW58b2JqZWN0fSBbb3B0aW9ucy5hbHRlcj1mYWxzZV0gQWx0ZXJzIHRhYmxlcyB0byBmaXQgbW9kZWxzLiBQcm92aWRlIGFuIG9iamVjdCBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLiBOb3QgcmVjb21tZW5kZWQgZm9yIHByb2R1Y3Rpb24gdXNlLiBJZiBub3QgZnVydGhlciBjb25maWd1cmVkIGRlbGV0ZXMgZGF0YSBpbiBjb2x1bW5zIHRoYXQgd2VyZSByZW1vdmVkIG9yIGhhZCB0aGVpciB0eXBlIGNoYW5nZWQgaW4gdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsdGVyLmRyb3A9dHJ1ZV0gUHJldmVudHMgYW55IGRyb3Agc3RhdGVtZW50cyB3aGlsZSBhbHRlcmluZyBhIHRhYmxlIHdoZW4gc2V0IHRvIGBmYWxzZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzeW5jKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udGhpcy5vcHRpb25zLnN5bmMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaG9va3M6IG9wdGlvbnMgPyBvcHRpb25zLmhvb2tzICE9PSBmYWxzZSA6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMubWF0Y2gpIHtcbiAgICAgIGlmICghb3B0aW9ucy5tYXRjaC50ZXN0KHRoaXMuY29uZmlnLmRhdGFiYXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIFwiJHt0aGlzLmNvbmZpZy5kYXRhYmFzZX1cIiBkb2VzIG5vdCBtYXRjaCBzeW5jIG1hdGNoIHBhcmFtZXRlciBcIiR7b3B0aW9ucy5tYXRjaH1cImApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVCdWxrU3luYycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgYXdhaXQgdGhpcy5kcm9wKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbHMgPSBbXTtcblxuICAgIC8vIFRvcG9sb2dpY2FsbHkgc29ydCBieSBmb3JlaWduIGtleSBjb25zdHJhaW50cyB0byBnaXZlIHVzIGFuIGFwcHJvcHJpYXRlXG4gICAgLy8gY3JlYXRpb24gb3JkZXJcbiAgICB0aGlzLm1vZGVsTWFuYWdlci5mb3JFYWNoTW9kZWwobW9kZWwgPT4ge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERCIHNob3VsZCB0aHJvdyBhbiBTUUwgZXJyb3IgaWYgcmVmZXJlbmNpbmcgbm9uLWV4aXN0ZW50IHRhYmxlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBubyBtb2RlbHMgZGVmaW5lZCwganVzdCBhdXRoZW50aWNhdGVcbiAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IHRoaXMuYXV0aGVudGljYXRlKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vZGVscykgYXdhaXQgbW9kZWwuc3luYyhvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyQnVsa1N5bmMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJ1bmNhdGUgYWxsIHRhYmxlcyBkZWZpbmVkIHRocm91Z2ggdGhlIHNlcXVlbGl6ZSBtb2RlbHMuXG4gICAqIFRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIGBNb2RlbC50cnVuY2F0ZSgpYCBvbiBlYWNoIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIHBhc3NlZCB0byBNb2RlbC5kZXN0cm95IGluIGFkZGl0aW9uIHRvIHRydW5jYXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC50cnVuY2F0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIHRydW5jYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbHMgPSBbXTtcblxuICAgIHRoaXMubW9kZWxNYW5hZ2VyLmZvckVhY2hNb2RlbChtb2RlbCA9PiB7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWxzLnB1c2gobW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHsgcmV2ZXJzZTogZmFsc2UgfSk7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhc2NhZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzKSBhd2FpdCBtb2RlbC50cnVuY2F0ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobW9kZWxzLm1hcChtb2RlbCA9PiBtb2RlbC50cnVuY2F0ZShvcHRpb25zKSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCB0YWJsZXMgZGVmaW5lZCB0aHJvdWdoIHRoaXMgc2VxdWVsaXplIGluc3RhbmNlLlxuICAgKiBUaGlzIGlzIGRvbmUgYnkgY2FsbGluZyBNb2RlbC5kcm9wIG9uIGVhY2ggbW9kZWwuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmRyb3B9IGZvciBvcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGVhY2ggY2FsbCB0byBNb2RlbC5kcm9wXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcChvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWxzID0gW107XG5cbiAgICB0aGlzLm1vZGVsTWFuYWdlci5mb3JFYWNoTW9kZWwobW9kZWwgPT4ge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB7IHJldmVyc2U6IGZhbHNlIH0pO1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBtb2RlbHMpIGF3YWl0IG1vZGVsLmRyb3Aob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB0aGUgY29ubmVjdGlvbiBieSB0cnlpbmcgdG8gYXV0aGVudGljYXRlLiBJdCBydW5zIGBTRUxFQ1QgMSsxIEFTIHJlc3VsdGAgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gcXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHBsYWluOiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMucXVlcnkoJ1NFTEVDVCAxKzEgQVMgcmVzdWx0Jywgb3B0aW9ucyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBhc3luYyBkYXRhYmFzZVZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm4gZm9yIHJhbmRvbSBiYXNlZCBvbiB0aGUgZGlhbGVjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmZufVxuICAgKi9cbiAgcmFuZG9tKCkge1xuICAgIGNvbnN0IGRpYSA9IHRoaXMuZ2V0RGlhbGVjdCgpO1xuICAgIGlmIChkaWEgPT09ICdwb3N0Z3JlcycgfHwgZGlhID09PSAnc3FsaXRlJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oJ1JBTkRPTScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbignUkFORCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGRhdGFiYXNlIGZ1bmN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIGluIHNlYXJjaCBxdWVyaWVzLCBib3RoIGluIHdoZXJlIGFuZCBvcmRlciBwYXJ0cywgYW5kIGFzIGRlZmF1bHQgdmFsdWVzIGluIGNvbHVtbiBkZWZpbml0aW9ucy5cbiAgICogSWYgeW91IHdhbnQgdG8gcmVmZXIgdG8gY29sdW1ucyBpbiB5b3VyIGZ1bmN0aW9uLCB5b3Ugc2hvdWxkIHVzZSBgc2VxdWVsaXplLmNvbGAsIHNvIHRoYXQgdGhlIGNvbHVtbnMgYXJlIHByb3Blcmx5IGludGVycHJldGVkIGFzIGNvbHVtbnMgYW5kIG5vdCBhIHN0cmluZ3MuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZS5kZWZpbmV9XG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZS5jb2x9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbiBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gY2FsbFxuICAgKiBAcGFyYW0ge2FueX0gYXJncyBBbGwgZnVydGhlciBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvblxuICAgKlxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmZufVxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGEgdXNlcidzIHVzZXJuYW1lIHRvIHVwcGVyIGNhc2U8L2NhcHRpb24+XG4gICAqIGluc3RhbmNlLnVwZGF0ZSh7XG4gICAqICAgdXNlcm5hbWU6IHNlcXVlbGl6ZS5mbigndXBwZXInLCBzZXF1ZWxpemUuY29sKCd1c2VybmFtZScpKVxuICAgKiB9KTtcbiAgICovXG4gIHN0YXRpYyBmbihmbiwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgVXRpbHMuRm4oZm4sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIERCLCB0aGlzIGFsbG93cyByZWZlcmVuY2luZyBhbm90aGVyIGNvbHVtbiBpbiB5b3VyIHF1ZXJ5LiBUaGlzIGlzIG9mdGVuIHVzZWZ1bCBpbiBjb25qdW5jdGlvbiB3aXRoIGBzZXF1ZWxpemUuZm5gLCBzaW5jZSByYXcgc3RyaW5nIGFyZ3VtZW50cyB0byBmbiB3aWxsIGJlIGVzY2FwZWQuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZSNmbn1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbCBUaGUgbmFtZSBvZiB0aGUgY29sdW1uXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuY29sfVxuICAgKi9cbiAgc3RhdGljIGNvbChjb2wpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkNvbChjb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGNhbGwgdG8gdGhlIGNhc3QgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIHZhbHVlIHRvIGNhc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgdG8gY2FzdCBpdCB0b1xuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmNhc3R9XG4gICAqL1xuICBzdGF0aWMgY2FzdCh2YWwsIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkNhc3QodmFsLCB0eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBsaXRlcmFsLCBpLmUuIHNvbWV0aGluZyB0aGF0IHdpbGwgbm90IGJlIGVzY2FwZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWwgbGl0ZXJhbCB2YWx1ZVxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmxpdGVyYWx9XG4gICAqL1xuICBzdGF0aWMgbGl0ZXJhbCh2YWwpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkxpdGVyYWwodmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBBTkQgcXVlcnlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5zdHJpbmd8b2JqZWN0fSBhcmdzIEVhY2ggYXJndW1lbnQgd2lsbCBiZSBqb2luZWQgYnkgQU5EXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuYW5kfVxuICAgKi9cbiAgc3RhdGljIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHsgW09wLmFuZF06IGFyZ3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBPUiBxdWVyeVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKlxuICAgKiBAcGFyYW0gey4uLnN0cmluZ3xvYmplY3R9IGFyZ3MgRWFjaCBhcmd1bWVudCB3aWxsIGJlIGpvaW5lZCBieSBPUlxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLm9yfVxuICAgKi9cbiAgc3RhdGljIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4geyBbT3Aub3JdOiBhcmdzIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIG5lc3RlZCB3aGVyZSBjb25kaXRpb25zIGZvciBwb3N0Z3Jlcy9zcWxpdGUvbXlzcWwganNvbiBkYXRhLXR5cGUuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY29uZGl0aW9uc09yUGF0aCBBIGhhc2ggY29udGFpbmluZyBzdHJpbmdzL251bWJlcnMgb3Igb3RoZXIgbmVzdGVkIGhhc2gsIGEgc3RyaW5nIHVzaW5nIGRvdCBub3RhdGlvbiBvciBhIHN0cmluZyB1c2luZyBwb3N0Z3Jlcy9zcWxpdGUvbXlzcWwganNvbiBzeW50YXguXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufSBbdmFsdWVdIEFuIG9wdGlvbmFsIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC4gUHJvZHVjZXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gXCI8anNvbiBwYXRoPiA9ICc8dmFsdWU+J1wiLlxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuanNvbn1cbiAgICovXG4gIHN0YXRpYyBqc29uKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5Kc29uKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHdheSBvZiBzcGVjaWZ5aW5nIGF0dHIgPSBjb25kaXRpb24uXG4gICAqXG4gICAqIFRoZSBhdHRyIGNhbiBlaXRoZXIgYmUgYW4gb2JqZWN0IHRha2VuIGZyb20gYE1vZGVsLnJhd0F0dHJpYnV0ZXNgIChmb3IgZXhhbXBsZSBgTW9kZWwucmF3QXR0cmlidXRlcy5pZGAgb3IgYE1vZGVsLnJhd0F0dHJpYnV0ZXMubmFtZWApLiBUaGVcbiAgICogYXR0cmlidXRlIHNob3VsZCBiZSBkZWZpbmVkIGluIHlvdXIgbW9kZWwgZGVmaW5pdGlvbi4gVGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBhbiBvYmplY3QgZnJvbSBvbmUgb2YgdGhlIHNlcXVlbGl6ZSB1dGlsaXR5IGZ1bmN0aW9ucyAoYHNlcXVlbGl6ZS5mbmAsIGBzZXF1ZWxpemUuY29sYCBldGMuKVxuICAgKlxuICAgKiBGb3Igc3RyaW5nIGF0dHJpYnV0ZXMsIHVzZSB0aGUgcmVndWxhciBgeyB3aGVyZTogeyBhdHRyOiBzb21ldGhpbmcgfX1gIHN5bnRheC4gSWYgeW91IGRvbid0IHdhbnQgeW91ciBzdHJpbmcgdG8gYmUgZXNjYXBlZCwgdXNlIGBzZXF1ZWxpemUubGl0ZXJhbGAuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyIFRoZSBhdHRyaWJ1dGUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYW4gYXR0cmlidXRlIG9iamVjdCBmcm9tIGBNb2RlbC5yYXdBdHRyaWJ1dGVzYCBvciBhIHNlcXVlbGl6ZSBvYmplY3QsIGZvciBleGFtcGxlIGFuIGluc3RhbmNlIG9mIGBzZXF1ZWxpemUuZm5gLiBGb3Igc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGVzLCB1c2UgdGhlIFBPSk8gc3ludGF4XG4gICAqIEBwYXJhbSB7c3ltYm9sfSBbY29tcGFyYXRvcj0nT3AuZXEnXSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGxvZ2ljIFRoZSBjb25kaXRpb24uIENhbiBiZSBib3RoIGEgc2ltcGx5IHR5cGUsIG9yIGEgZnVydGhlciBjb25kaXRpb24gKGBvcmAsIGBhbmRgLCBgLmxpdGVyYWxgIGV0Yy4pXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKi9cbiAgc3RhdGljIHdoZXJlKGF0dHIsIGNvbXBhcmF0b3IsIGxvZ2ljKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5XaGVyZShhdHRyLCBjb21wYXJhdG9yLCBsb2dpYyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSB0cmFuc2FjdGlvbi4gV2hlbiB1c2luZyB0cmFuc2FjdGlvbnMsIHlvdSBzaG91bGQgcGFzcyB0aGUgdHJhbnNhY3Rpb24gaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQgaW4gb3JkZXIgZm9yIHRoZSBxdWVyeSB0byBoYXBwZW4gdW5kZXIgdGhhdCB0cmFuc2FjdGlvbiBAc2VlIHtAbGluayBUcmFuc2FjdGlvbn1cbiAgICpcbiAgICogSWYgeW91IGhhdmUgW0NMU10oaHR0cHM6Ly9naXRodWIuY29tL0plZmYtTGV3aXMvY2xzLWhvb2tlZCkgZW5hYmxlZCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBwYXNzZWQgdG8gYW55IHF1ZXJ5IHRoYXQgcnVucyB3aXRoaW4gdGhlIGNhbGxiYWNrXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHRyeSB7XG4gICAqICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBzZXF1ZWxpemUudHJhbnNhY3Rpb24oKTtcbiAgICogICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kT25lKC4uLiwgeyB0cmFuc2FjdGlvbiB9KTtcbiAgICogICBhd2FpdCB1c2VyLnVwZGF0ZSguLi4sIHsgdHJhbnNhY3Rpb24gfSk7XG4gICAqICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAqIH0gY2F0Y2gge1xuICAgKiAgIGF3YWl0IHRyYW5zYWN0aW9uLnJvbGxiYWNrKClcbiAgICogfVxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHN5bnRheCBmb3IgYXV0b21hdGljYWxseSBjb21taXR0aW5nIG9yIHJvbGxpbmcgYmFjayBiYXNlZCBvbiB0aGUgcHJvbWlzZSBjaGFpbiByZXNvbHV0aW9uIGlzIGFsc28gc3VwcG9ydGVkPC9jYXB0aW9uPlxuICAgKlxuICAgKiB0cnkge1xuICAgKiAgIGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbih0cmFuc2FjdGlvbiA9PiB7IC8vIE5vdGUgdGhhdCB3ZSBwYXNzIGEgY2FsbGJhY2sgcmF0aGVyIHRoYW4gYXdhaXRpbmcgdGhlIGNhbGwgd2l0aCBubyBhcmd1bWVudHNcbiAgICogICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRPbmUoLi4uLCB7dHJhbnNhY3Rpb259KTtcbiAgICogICAgIGF3YWl0IHVzZXIudXBkYXRlKC4uLiwge3RyYW5zYWN0aW9ufSk7XG4gICAqICAgfSk7XG4gICAqICAgLy8gQ29tbWl0dGVkXG4gICAqIH0gY2F0Y2goZXJyKSB7XG4gICAqICAgLy8gUm9sbGVkIGJhY2tcbiAgICogICBjb25zb2xlLmVycm9yKGVycik7XG4gICAqIH1cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VG8gZW5hYmxlIENMUywgYWRkIGl0IGRvIHlvdXIgcHJvamVjdCwgY3JlYXRlIGEgbmFtZXNwYWNlIGFuZCBzZXQgaXQgb24gdGhlIHNlcXVlbGl6ZSBjb25zdHJ1Y3Rvcjo8L2NhcHRpb24+XG4gICAqXG4gICAqIGNvbnN0IGNscyA9IHJlcXVpcmUoJ2Nscy1ob29rZWQnKTtcbiAgICogY29uc3QgbmFtZXNwYWNlID0gY2xzLmNyZWF0ZU5hbWVzcGFjZSgnLi4uLicpO1xuICAgKiBjb25zdCBTZXF1ZWxpemUgPSByZXF1aXJlKCdzZXF1ZWxpemUnKTtcbiAgICogU2VxdWVsaXplLnVzZUNMUyhuYW1lc3BhY2UpO1xuICAgKlxuICAgKiAvLyBOb3RlLCB0aGF0IENMUyBpcyBlbmFibGVkIGZvciBhbGwgc2VxdWVsaXplIGluc3RhbmNlcywgYW5kIGFsbCBpbnN0YW5jZXMgd2lsbCBzaGFyZSB0aGUgc2FtZSBuYW1lc3BhY2VcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnNdIFRyYW5zYWN0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMudHlwZT0nREVGRVJSRUQnXSBTZWUgYFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5UWVBFU2AgZm9yIHBvc3NpYmxlIG9wdGlvbnMuIFNxbGl0ZSBvbmx5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5pc29sYXRpb25MZXZlbF0gU2VlIGBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMU2AgZm9yIHBvc3NpYmxlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuZGVmZXJyYWJsZV0gU2V0cyB0aGUgY29uc3RyYWludHMgdG8gYmUgZGVmZXJyZWQgb3IgaW1tZWRpYXRlbHkgY2hlY2tlZC4gU2VlIGBTZXF1ZWxpemUuRGVmZXJyYWJsZWAuIFBvc3RncmVTUUwgT25seVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2F1dG9DYWxsYmFja10gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHRoZSB0cmFuc2FjdGlvbiBvYmplY3QsIGFuZCBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZS4gSWYgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQsIHRoZSB0cmFuc2FjdGlvbiBjb21taXRzOyBpZiB0aGUgcHJvbWlzZSByZWplY3RzLCB0aGUgdHJhbnNhY3Rpb24gcm9sbHMgYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHRyYW5zYWN0aW9uKG9wdGlvbnMsIGF1dG9DYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXV0b0NhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24odGhpcywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWF1dG9DYWxsYmFjaykge1xuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucHJlcGFyZUVudmlyb25tZW50KGZhbHNlKTtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBhdXRvQ2FsbGJhY2sgcHJvdmlkZWRcbiAgICByZXR1cm4gU2VxdWVsaXplLl9jbHNSdW4oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucHJlcGFyZUVudmlyb25tZW50KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dG9DYWxsYmFjayh0cmFuc2FjdGlvbik7XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5maW5pc2hlZCkge1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUgY29ubmVjdGlvbiwgZXZlbiBpZiB3ZSBkb24ndCBuZWVkIHRvIHJvbGxiYWNrXG4gICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jbGVhbnVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIwKSB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBDTFMgKENvbnRpbnVhdGlvbiBMb2NhbCBTdG9yYWdlKSB3aXRoIFNlcXVlbGl6ZS4gV2l0aCBDb250aW51YXRpb25cbiAgICogTG9jYWwgU3RvcmFnZSwgYWxsIHF1ZXJpZXMgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjYWxsYmFjayB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVjZWl2ZSB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBDTFMgbmFtZXNwYWNlIHByb3ZpZGVkIGlzIHN0b3JlZCBhcyBgU2VxdWVsaXplLl9jbHNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBucyBDTFMgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFNlcXVlbGl6ZSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgc3RhdGljIHVzZUNMUyhucykge1xuICAgIC8vIGNoZWNrIGBuc2AgaXMgdmFsaWQgQ0xTIG5hbWVzcGFjZVxuICAgIGlmICghbnMgfHwgdHlwZW9mIG5zICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbnMuYmluZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbnMucnVuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBDTFMgbmFtZXNwYWNlJyk7XG5cbiAgICAvLyBzYXZlIG5hbWVzcGFjZSBhcyBgU2VxdWVsaXplLl9jbHNgXG4gICAgdGhpcy5fY2xzID0gbnM7XG5cbiAgICAvLyByZXR1cm4gU2VxdWVsaXplIGZvciBjaGFpbmluZ1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBmdW5jdGlvbiBpbiBDTFMgY29udGV4dC5cbiAgICogSWYgbm8gQ0xTIGNvbnRleHQgaW4gdXNlLCBqdXN0IHJ1bnMgdGhlIGZ1bmN0aW9uIG5vcm1hbGx5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIHJ1blxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJuIHZhbHVlIG9mIGZ1bmN0aW9uXG4gICAqL1xuICBzdGF0aWMgX2Nsc1J1bihmbikge1xuICAgIGNvbnN0IG5zID0gU2VxdWVsaXplLl9jbHM7XG4gICAgaWYgKCFucykgcmV0dXJuIGZuKCk7XG5cbiAgICBsZXQgcmVzO1xuICAgIG5zLnJ1bihjb250ZXh0ID0+IHJlcyA9IGZuKGNvbnRleHQpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucztcblxuICAgIGNvbnN0IGxhc3QgPSBfLmxhc3QoYXJncyk7XG5cbiAgICBpZiAobGFzdCAmJiBfLmlzUGxhaW5PYmplY3QobGFzdCkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhc3QsICdsb2dnaW5nJykpIHtcbiAgICAgIG9wdGlvbnMgPSBsYXN0O1xuXG4gICAgICAvLyByZW1vdmUgb3B0aW9ucyBmcm9tIHNldCBvZiBsb2dnZWQgYXJndW1lbnRzIGlmIG9wdGlvbnMubG9nZ2luZyBpcyBlcXVhbCB0byBjb25zb2xlLmxvZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGlmIChvcHRpb25zLmxvZ2dpbmcgPT09IGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKGFyZ3MubGVuZ3RoIC0gMSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBvcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICAgIH1cblxuICAgICAgLy8gc2Vjb25kIGFyZ3VtZW50IGlzIHNxbC10aW1pbmdzLCB3aGVuIGJlbmNobWFya2luZyBvcHRpb24gZW5hYmxlZFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGlmICgodGhpcy5vcHRpb25zLmJlbmNobWFyayB8fCBvcHRpb25zLmJlbmNobWFyaykgJiYgb3B0aW9ucy5sb2dnaW5nID09PSBjb25zb2xlLmxvZykge1xuICAgICAgICBhcmdzID0gW2Ake2FyZ3NbMF19IEVsYXBzZWQgdGltZTogJHthcmdzWzFdfW1zYF07XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubG9nZ2luZyguLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgYWxsIGNvbm5lY3Rpb25zIHVzZWQgYnkgdGhpcyBzZXF1ZWxpemUgaW5zdGFuY2UsIGFuZCBmcmVlIGFsbCByZWZlcmVuY2VzIHNvIHRoZSBpbnN0YW5jZSBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqXG4gICAqIE5vcm1hbGx5IHRoaXMgaXMgZG9uZSBvbiBwcm9jZXNzIGV4aXQsIHNvIHlvdSBvbmx5IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBpZiB5b3UgYXJlIGNyZWF0aW5nIG11bHRpcGxlIGluc3RhbmNlcywgYW5kIHdhbnRcbiAgICogdG8gZ2FyYmFnZSBjb2xsZWN0IHNvbWUgb2YgdGhlbS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbG9zZSgpO1xuICB9XG5cbiAgbm9ybWFsaXplRGF0YVR5cGUoVHlwZSkge1xuICAgIGxldCB0eXBlID0gdHlwZW9mIFR5cGUgPT09ICdmdW5jdGlvbicgPyBuZXcgVHlwZSgpIDogVHlwZTtcbiAgICBjb25zdCBkaWFsZWN0VHlwZXMgPSB0aGlzLmRpYWxlY3QuRGF0YVR5cGVzIHx8IHt9O1xuXG4gICAgaWYgKGRpYWxlY3RUeXBlc1t0eXBlLmtleV0pIHtcbiAgICAgIHR5cGUgPSBkaWFsZWN0VHlwZXNbdHlwZS5rZXldLmV4dGVuZCh0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgaWYgKCF0eXBlLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUlJBWSBpcyBtaXNzaW5nIHR5cGUgZGVmaW5pdGlvbiBmb3IgaXRzIHZhbHVlcy4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaWFsZWN0VHlwZXNbdHlwZS50eXBlLmtleV0pIHtcbiAgICAgICAgdHlwZS50eXBlID0gZGlhbGVjdFR5cGVzW3R5cGUudHlwZS5rZXldLmV4dGVuZCh0eXBlLnR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgbm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHsgdHlwZTogYXR0cmlidXRlIH07XG4gICAgfVxuXG4gICAgaWYgKCFhdHRyaWJ1dGUudHlwZSkgcmV0dXJuIGF0dHJpYnV0ZTtcblxuICAgIGF0dHJpYnV0ZS50eXBlID0gdGhpcy5ub3JtYWxpemVEYXRhVHlwZShhdHRyaWJ1dGUudHlwZSk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgJiYgKFxuICAgICAgICBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID09PSBEYXRhVHlwZXMuTk9XIHx8XG4gICAgICAgICAgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9PT0gRGF0YVR5cGVzLlVVSURWMSB8fFxuICAgICAgICAgIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPT09IERhdGFUeXBlcy5VVUlEVjRcbiAgICAgICkpIHtcbiAgICAgICAgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9IG5ldyBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIC8vIFRoZSBFTlVNIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZSB0eXBlIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWx1ZXNcbiAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZS50eXBlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLm9wdGlvbnMudmFsdWVzID0gYXR0cmlidXRlLnZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXR0cmlidXRlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZXMgZm9yIEVOVU0gaGF2ZSBub3QgYmVlbiBkZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cbn1cblxuLy8gQWxpYXNlc1xuU2VxdWVsaXplLnByb3RvdHlwZS5mbiA9IFNlcXVlbGl6ZS5mbjtcblNlcXVlbGl6ZS5wcm90b3R5cGUuY29sID0gU2VxdWVsaXplLmNvbDtcblNlcXVlbGl6ZS5wcm90b3R5cGUuY2FzdCA9IFNlcXVlbGl6ZS5jYXN0O1xuU2VxdWVsaXplLnByb3RvdHlwZS5saXRlcmFsID0gU2VxdWVsaXplLmxpdGVyYWw7XG5TZXF1ZWxpemUucHJvdG90eXBlLmFuZCA9IFNlcXVlbGl6ZS5hbmQ7XG5TZXF1ZWxpemUucHJvdG90eXBlLm9yID0gU2VxdWVsaXplLm9yO1xuU2VxdWVsaXplLnByb3RvdHlwZS5qc29uID0gU2VxdWVsaXplLmpzb247XG5TZXF1ZWxpemUucHJvdG90eXBlLndoZXJlID0gU2VxdWVsaXplLndoZXJlO1xuU2VxdWVsaXplLnByb3RvdHlwZS52YWxpZGF0ZSA9IFNlcXVlbGl6ZS5wcm90b3R5cGUuYXV0aGVudGljYXRlO1xuXG4vKipcbiAqIFNlcXVlbGl6ZSB2ZXJzaW9uIG51bWJlci5cbiAqL1xuU2VxdWVsaXplLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG5TZXF1ZWxpemUub3B0aW9ucyA9IHsgaG9va3M6IHt9IH07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuU2VxdWVsaXplLlV0aWxzID0gVXRpbHM7XG5cbi8qKlxuICogT3BlcmF0b3JzIHN5bWJvbHMgdG8gYmUgdXNlZCBmb3IgcXVlcnlpbmcgZGF0YVxuICpcbiAqIEBzZWUgIHtAbGluayBPcGVyYXRvcnN9XG4gKi9cblNlcXVlbGl6ZS5PcCA9IE9wO1xuXG4vKipcbiAqIEF2YWlsYWJsZSB0YWJsZSBoaW50cyB0byBiZSB1c2VkIGZvciBxdWVyeWluZyBkYXRhIGluIG1zc3FsIGZvciB0YWJsZSBoaW50c1xuICpcbiAqIEBzZWUge0BsaW5rIFRhYmxlSGludHN9XG4gKi9cblNlcXVlbGl6ZS5UYWJsZUhpbnRzID0gVGFibGVIaW50cztcblxuLyoqXG4gKiBBdmFpbGFibGUgaW5kZXggaGludHMgdG8gYmUgdXNlZCBmb3IgcXVlcnlpbmcgZGF0YSBpbiBteXNxbCBmb3IgaW5kZXggaGludHNcbiAqXG4gKiBAc2VlIHtAbGluayBJbmRleEhpbnRzfVxuICovXG5TZXF1ZWxpemUuSW5kZXhIaW50cyA9IEluZGV4SGludHM7XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gdGhlIHNlcXVlbGl6ZSB0cmFuc2FjdGlvbiBjbGFzcy4gVXNlIHRoaXMgdG8gYWNjZXNzIGlzb2xhdGlvbkxldmVscyBhbmQgdHlwZXMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHNlZSB7QGxpbmsgVHJhbnNhY3Rpb259XG4gKiBAc2VlIHtAbGluayBTZXF1ZWxpemUudHJhbnNhY3Rpb259XG4gKi9cblNlcXVlbGl6ZS5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIFNlcXVlbGl6ZSBjb25zdHJ1Y3RvciBmcm9tIHNlcXVlbGl6ZS4gVXNlZnVsIGZvciBhY2Nlc3NpbmcgRGF0YVR5cGVzLCBFcnJvcnMgZXRjLlxuICpcbiAqIEBzZWUge0BsaW5rIFNlcXVlbGl6ZX1cbiAqL1xuU2VxdWVsaXplLnByb3RvdHlwZS5TZXF1ZWxpemUgPSBTZXF1ZWxpemU7XG5cbi8qKlxuICogQXZhaWxhYmxlIHF1ZXJ5IHR5cGVzIGZvciB1c2Ugd2l0aCBgc2VxdWVsaXplLnF1ZXJ5YFxuICpcbiAqIEBzZWUge0BsaW5rIFF1ZXJ5VHlwZXN9XG4gKi9cblNlcXVlbGl6ZS5wcm90b3R5cGUuUXVlcnlUeXBlcyA9IFNlcXVlbGl6ZS5RdWVyeVR5cGVzID0gUXVlcnlUeXBlcztcblxuLyoqXG4gKiBFeHBvc2VzIHRoZSB2YWxpZGF0b3IuanMgb2JqZWN0LCBzbyB5b3UgY2FuIGV4dGVuZCBpdCB3aXRoIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gVGhlIHZhbGlkYXRvciBpcyBleHBvc2VkIGJvdGggb24gdGhlIGluc3RhbmNlLCBhbmQgb24gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanNcbiAqL1xuU2VxdWVsaXplLnByb3RvdHlwZS5WYWxpZGF0b3IgPSBTZXF1ZWxpemUuVmFsaWRhdG9yID0gVmFsaWRhdG9yO1xuXG5TZXF1ZWxpemUuTW9kZWwgPSBNb2RlbDtcblxuU2VxdWVsaXplLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbmZvciAoY29uc3QgZGF0YVR5cGUgaW4gRGF0YVR5cGVzKSB7XG4gIFNlcXVlbGl6ZVtkYXRhVHlwZV0gPSBEYXRhVHlwZXNbZGF0YVR5cGVdO1xufVxuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIHRoZSBkZWZlcnJhYmxlIGNvbGxlY3Rpb24uIFVzZSB0aGlzIHRvIGFjY2VzcyB0aGUgZGlmZmVyZW50IGRlZmVycmFibGUgb3B0aW9ucy5cbiAqXG4gKiBAc2VlIHtAbGluayBUcmFuc2FjdGlvbi5EZWZlcnJhYmxlfVxuICogQHNlZSB7QGxpbmsgU2VxdWVsaXplI3RyYW5zYWN0aW9ufVxuICovXG5TZXF1ZWxpemUuRGVmZXJyYWJsZSA9IERlZmVycmFibGU7XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gdGhlIHNlcXVlbGl6ZSBhc3NvY2lhdGlvbiBjbGFzcy5cbiAqXG4gKiBAc2VlIHtAbGluayBBc3NvY2lhdGlvbn1cbiAqL1xuU2VxdWVsaXplLnByb3RvdHlwZS5Bc3NvY2lhdGlvbiA9IFNlcXVlbGl6ZS5Bc3NvY2lhdGlvbiA9IEFzc29jaWF0aW9uO1xuXG4vKipcbiAqIFByb3ZpZGUgYWx0ZXJuYXRpdmUgdmVyc2lvbiBvZiBgaW5mbGVjdGlvbmAgbW9kdWxlIHRvIGJlIHVzZWQgYnkgYFV0aWxzLnBsdXJhbGl6ZWAgZXRjLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBfaW5mbGVjdGlvbiAtIGBpbmZsZWN0aW9uYCBtb2R1bGVcbiAqL1xuU2VxdWVsaXplLnVzZUluZmxlY3Rpb24gPSBVdGlscy51c2VJbmZsZWN0aW9uO1xuXG4vKipcbiAqIEFsbG93IGhvb2tzIHRvIGJlIGRlZmluZWQgb24gU2VxdWVsaXplICsgb24gc2VxdWVsaXplIGluc3RhbmNlIGFzIHVuaXZlcnNhbCBob29rcyB0byBydW4gb24gYWxsIG1vZGVsc1xuICogYW5kIG9uIFNlcXVlbGl6ZS9zZXF1ZWxpemUgbWV0aG9kcyBlLmcuIFNlcXVlbGl6ZSgpLCBTZXF1ZWxpemUjZGVmaW5lKClcbiAqL1xuSG9va3MuYXBwbHlUbyhTZXF1ZWxpemUpO1xuSG9va3MuYXBwbHlUbyhTZXF1ZWxpemUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFeHBvc2UgdmFyaW91cyBlcnJvcnMgYXZhaWxhYmxlXG4gKi9cblxuLy8gZXhwb3NlIGFsaWFzIHRvIEJhc2VFcnJvclxuU2VxdWVsaXplLkVycm9yID0gc2VxdWVsaXplRXJyb3JzLkJhc2VFcnJvcjtcblxuZm9yIChjb25zdCBlcnJvciBvZiBPYmplY3Qua2V5cyhzZXF1ZWxpemVFcnJvcnMpKSB7XG4gIFNlcXVlbGl6ZVtlcnJvcl0gPSBzZXF1ZWxpemVFcnJvcnNbZXJyb3JdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcXVlbGl6ZTtcbm1vZHVsZS5leHBvcnRzLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBTZXF1ZWxpemU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIGFycmF5VG9MaXN0KGFycmF5LCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHNxbCwgdmFsLCBpKSA9PiB7XG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIHNxbCArPSAnLCAnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBzcWwgKz0gYCgke2FycmF5VG9MaXN0KHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCl9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxbCArPSBlc2NhcGUodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfSwgJycpO1xufVxuZXhwb3J0cy5hcnJheVRvTGlzdCA9IGFycmF5VG9MaXN0O1xuXG5mdW5jdGlvbiBlc2NhcGUodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KSB7XG4gIGxldCBwcmVwZW5kTiA9IGZhbHNlO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdOVUxMJztcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAvLyBTUUxpdGUgZG9lc24ndCBoYXZlIHRydWUvZmFsc2Ugc3VwcG9ydC4gTXlTUUwgYWxpYXNlcyB0cnVlL2ZhbHNlIHRvIDEvMFxuICAgIC8vIGZvciB1cy4gUG9zdGdyZXMgYWN0dWFsbHkgaGFzIGEgYm9vbGVhbiB0eXBlIHdpdGggdHJ1ZS9mYWxzZSBsaXRlcmFscyxcbiAgICAvLyBidXQgc2VxdWVsaXplIGRvZXNuJ3QgdXNlIGl0IHlldC5cbiAgICAgIGlmIChkaWFsZWN0ID09PSAnc3FsaXRlJyB8fCBkaWFsZWN0ID09PSAnbXNzcWwnKSB7XG4gICAgICAgIHJldHVybiArISF2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCEhdmFsKS50b1N0cmluZygpO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAvLyBJbiBtc3NxbCwgcHJlcGVuZCBOIHRvIGFsbCBxdW90ZWQgdmFscyB3aGljaCBhcmUgb3JpZ2luYWxseSBhIHN0cmluZyAoZm9yXG4gICAgLy8gdW5pY29kZSBjb21wYXRpYmlsaXR5KVxuICAgICAgcHJlcGVuZE4gPSBkaWFsZWN0ID09PSAnbXNzcWwnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHZhbCA9IGRhdGFUeXBlc1tkaWFsZWN0XS5EQVRFLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsLCB7IHRpbWV6b25lOiB0aW1lWm9uZSB9KTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIGlmIChkYXRhVHlwZXNbZGlhbGVjdF0uQkxPQikge1xuICAgICAgcmV0dXJuIGRhdGFUeXBlc1tkaWFsZWN0XS5CTE9CLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVR5cGVzLkJMT0IucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IHBhcnRpYWxFc2NhcGUgPSBlc2NWYWwgPT4gZXNjYXBlKGVzY1ZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCk7XG4gICAgaWYgKGRpYWxlY3QgPT09ICdwb3N0Z3JlcycgJiYgIWZvcm1hdCkge1xuICAgICAgcmV0dXJuIGRhdGFUeXBlcy5BUlJBWS5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCwgeyBlc2NhcGU6IHBhcnRpYWxFc2NhcGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvTGlzdCh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpO1xuICB9XG5cbiAgaWYgKCF2YWwucmVwbGFjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSAke2xvZ2dlci5pbnNwZWN0KHZhbCl9YCk7XG4gIH1cblxuICBpZiAoZGlhbGVjdCA9PT0gJ3Bvc3RncmVzJyB8fCBkaWFsZWN0ID09PSAnc3FsaXRlJyB8fCBkaWFsZWN0ID09PSAnbXNzcWwnKSB7XG4gICAgLy8gaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzguMi9zdGF0aWMvc3FsLXN5bnRheC1sZXhpY2FsLmh0bWwjU1FMLVNZTlRBWC1TVFJJTkdTXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNjAzNTcyLzEzMDU5OFxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csIFwiJydcIik7XG5cbiAgICBpZiAoZGlhbGVjdCA9PT0gJ3Bvc3RncmVzJykge1xuICAgICAgLy8gbnVsbCBjaGFyYWN0ZXIgaXMgbm90IGFsbG93ZWQgaW4gUG9zdGdyZXNcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXDAvZywgJ1xcXFwwJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoL1tcXDBcXG5cXHJcXGJcXHRcXFxcJ1wiXFx4MWFdL2csIHMgPT4ge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJ1xcMCc6IHJldHVybiAnXFxcXDAnO1xuICAgICAgICBjYXNlICdcXG4nOiByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgY2FzZSAnXFxyJzogcmV0dXJuICdcXFxccic7XG4gICAgICAgIGNhc2UgJ1xcYic6IHJldHVybiAnXFxcXGInO1xuICAgICAgICBjYXNlICdcXHQnOiByZXR1cm4gJ1xcXFx0JztcbiAgICAgICAgY2FzZSAnXFx4MWEnOiByZXR1cm4gJ1xcXFxaJztcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIGBcXFxcJHtzfWA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGAkeyhwcmVwZW5kTiA/IFwiTidcIiA6IFwiJ1wiKSArIHZhbH0nYDtcbn1cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuXG5mdW5jdGlvbiBmb3JtYXQoc3FsLCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0KSB7XG4gIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuXG4gIGlmICh0eXBlb2Ygc3FsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTUUwgc3RyaW5nIHByb3ZpZGVkOiAke3NxbH1gKTtcbiAgfVxuXG4gIHJldHVybiBzcWwucmVwbGFjZSgvXFw/L2csIG1hdGNoID0+IHtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlKHZhbHVlcy5zaGlmdCgpLCB0aW1lWm9uZSwgZGlhbGVjdCwgdHJ1ZSk7XG4gIH0pO1xufVxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5cbmZ1bmN0aW9uIGZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QpIHtcbiAgcmV0dXJuIHNxbC5yZXBsYWNlKC86Kyg/IVxcZCkoXFx3KykvZywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoJ3Bvc3RncmVzJyA9PT0gZGlhbGVjdCAmJiAnOjonID09PSB2YWx1ZS5zbGljZSgwLCAyKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlKHZhbHVlc1trZXldLCB0aW1lWm9uZSwgZGlhbGVjdCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTmFtZWQgcGFyYW1ldGVyIFwiJHt2YWx1ZX1cIiBoYXMgbm8gdmFsdWUgaW4gdGhlIGdpdmVuIG9iamVjdC5gKTtcbiAgfSk7XG59XG5leHBvcnRzLmZvcm1hdE5hbWVkUGFyYW1ldGVycyA9IGZvcm1hdE5hbWVkUGFyYW1ldGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlbnVtIG9mIHRhYmxlIGhpbnRzIHRvIGJlIHVzZWQgaW4gbXNzcWwgZm9yIHF1ZXJ5aW5nIHdpdGggdGFibGUgaGludHNcbiAqXG4gKiBAcHJvcGVydHkgTk9MT0NLXG4gKiBAcHJvcGVydHkgUkVBRFVOQ09NTUlUVEVEXG4gKiBAcHJvcGVydHkgVVBETE9DS1xuICogQHByb3BlcnR5IFJFUEVBVEFCTEVSRUFEXG4gKiBAcHJvcGVydHkgU0VSSUFMSVpBQkxFXG4gKiBAcHJvcGVydHkgUkVBRENPTU1JVFRFRFxuICogQHByb3BlcnR5IFRBQkxPQ0tcbiAqIEBwcm9wZXJ0eSBUQUJMT0NLWFxuICogQHByb3BlcnR5IFBBR0xPQ0tcbiAqIEBwcm9wZXJ0eSBST1dMT0NLXG4gKiBAcHJvcGVydHkgTk9XQUlUXG4gKiBAcHJvcGVydHkgUkVBRFBBU1RcbiAqIEBwcm9wZXJ0eSBYTE9DS1xuICogQHByb3BlcnR5IFNOQVBTSE9UXG4gKiBAcHJvcGVydHkgTk9FWFBBTkRcbiAqL1xuY29uc3QgVGFibGVIaW50cyA9IG1vZHVsZS5leHBvcnRzID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIE5PTE9DSzogJ05PTE9DSycsXG4gIFJFQURVTkNPTU1JVFRFRDogJ1JFQURVTkNPTU1JVFRFRCcsXG4gIFVQRExPQ0s6ICdVUERMT0NLJyxcbiAgUkVQRUFUQUJMRVJFQUQ6ICdSRVBFQVRBQkxFUkVBRCcsXG4gIFNFUklBTElaQUJMRTogJ1NFUklBTElaQUJMRScsXG4gIFJFQURDT01NSVRURUQ6ICdSRUFEQ09NTUlUVEVEJyxcbiAgVEFCTE9DSzogJ1RBQkxPQ0snLFxuICBUQUJMT0NLWDogJ1RBQkxPQ0tYJyxcbiAgUEFHTE9DSzogJ1BBR0xPQ0snLFxuICBST1dMT0NLOiAnUk9XTE9DSycsXG4gIE5PV0FJVDogJ05PV0FJVCcsXG4gIFJFQURQQVNUOiAnUkVBRFBBU1QnLFxuICBYTE9DSzogJ1hMT0NLJyxcbiAgU05BUFNIT1Q6ICdTTkFQU0hPVCcsXG4gIE5PRVhQQU5EOiAnTk9FWFBBTkQnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgaXMgdXNlZCB0byBpZGVudGlmeSBhIHJ1bm5pbmcgdHJhbnNhY3Rpb24uXG4gKiBJdCBpcyBjcmVhdGVkIGJ5IGNhbGxpbmcgYFNlcXVlbGl6ZS50cmFuc2FjdGlvbigpYC5cbiAqIFRvIHJ1biBhIHF1ZXJ5IHVuZGVyIGEgdHJhbnNhY3Rpb24sIHlvdSBzaG91bGQgcGFzcyB0aGUgdHJhbnNhY3Rpb24gaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICogQHNlZSB7QGxpbmsgU2VxdWVsaXplLnRyYW5zYWN0aW9ufVxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7U2VxdWVsaXplfSBzZXF1ZWxpemUgQSBjb25maWd1cmVkIHNlcXVlbGl6ZSBJbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlXSBTZXRzIHRoZSB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbi4gU3FsaXRlIG9ubHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlzb2xhdGlvbkxldmVsXSBTZXRzIHRoZSBpc29sYXRpb24gbGV2ZWwgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVmZXJyYWJsZV0gU2V0cyB0aGUgY29uc3RyYWludHMgdG8gYmUgZGVmZXJyZWQgb3IgaW1tZWRpYXRlbHkgY2hlY2tlZC4gUG9zdGdyZVNRTCBvbmx5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLnNhdmVwb2ludHMgPSBbXTtcbiAgICB0aGlzLl9hZnRlckNvbW1pdEhvb2tzID0gW107XG5cbiAgICAvLyBnZXQgZGlhbGVjdCBzcGVjaWZpYyB0cmFuc2FjdGlvbiBvcHRpb25zXG4gICAgY29uc3QgZ2VuZXJhdGVUcmFuc2FjdGlvbklkID0gdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5nZW5lcmF0ZVRyYW5zYWN0aW9uSWQ7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBzZXF1ZWxpemUub3B0aW9ucy50cmFuc2FjdGlvblR5cGUsXG4gICAgICBpc29sYXRpb25MZXZlbDogc2VxdWVsaXplLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIHRoaXMucGFyZW50ID0gdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uO1xuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5wYXJlbnQuaWQ7XG4gICAgICB0aGlzLnBhcmVudC5zYXZlcG9pbnRzLnB1c2godGhpcyk7XG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLmlkfS1zcC0ke3RoaXMucGFyZW50LnNhdmVwb2ludHMubGVuZ3RofWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm5hbWUgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1pdCB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gY2Fubm90IGJlIGNvbW1pdHRlZCBiZWNhdXNlIGl0IGhhcyBiZWVuIGZpbmlzaGVkIHdpdGggc3RhdGU6ICR7dGhpcy5maW5pc2hlZH1gKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkuY29tbWl0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5maW5pc2hlZCA9ICdjb21taXQnO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fYWZ0ZXJDb21taXRIb29rcykge1xuICAgICAgICBhd2FpdCBob29rLmFwcGx5KHRoaXMsIFt0aGlzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIChhYm9ydCkgdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcm9sbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gY2Fubm90IGJlIHJvbGxlZCBiYWNrIGJlY2F1c2UgaXQgaGFzIGJlZW4gZmluaXNoZWQgd2l0aCBzdGF0ZTogJHt0aGlzLmZpbmlzaGVkfWApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSByb2xsZWQgYmFjayBiZWNhdXNlIGl0IG5ldmVyIHN0YXJ0ZWQnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXNcbiAgICAgICAgLnNlcXVlbGl6ZVxuICAgICAgICAuZ2V0UXVlcnlJbnRlcmZhY2UoKVxuICAgICAgICAucm9sbGJhY2tUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGFjcXVpcmUgYSBjb25uZWN0aW9uIHRvIHVzZSBhbmQgc2V0IHRoZSBjb3JyZWN0IG9wdGlvbnMgb24gdGhlIGNvbm5lY3Rpb24uXG4gICAqIFdlIHNob3VsZCBlbnN1cmUgYWxsIG9mIHRoZSBlbnZpcm9ubWVudCB0aGF0J3Mgc2V0IHVwIGlzIGNsZWFuZWQgdXAgaW4gYGNsZWFudXAoKWAgYmVsb3cuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ0xTIERlZmF1bHRzIHRvIHRydWU6IFVzZSBDTFMgKENvbnRpbnVhdGlvbiBMb2NhbCBTdG9yYWdlKSB3aXRoIFNlcXVlbGl6ZS4gV2l0aCBDTFMsIGFsbCBxdWVyaWVzIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY2FsbGJhY2sgd2lsbCBhdXRvbWF0aWNhbGx5IHJlY2VpdmUgdGhlIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBwcmVwYXJlRW52aXJvbm1lbnQodXNlQ0xTKSB7XG4gICAgbGV0IGNvbm5lY3Rpb25Qcm9taXNlO1xuXG4gICAgaWYgKHVzZUNMUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VDTFMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29ubmVjdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5wYXJlbnQuY29ubmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjcXVpcmVPcHRpb25zID0geyB1dWlkOiB0aGlzLmlkIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIGFjcXVpcmVPcHRpb25zLnR5cGUgPSAnU0VMRUNUJztcbiAgICAgIH1cbiAgICAgIGNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbihhY3F1aXJlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbm5lY3Rpb24udXVpZCA9IHRoaXMuaWQ7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5iZWdpbigpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXREZWZlcnJhYmxlKCk7XG4gICAgfSBjYXRjaCAoc2V0dXBFcnIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucm9sbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IHNldHVwRXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuc2FmZS1maW5hbGx5XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVzZUNMUyAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLnNldCgndHJhbnNhY3Rpb24nLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgc2V0RGVmZXJyYWJsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZmVycmFibGUpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzXG4gICAgICAgIC5zZXF1ZWxpemVcbiAgICAgICAgLmdldFF1ZXJ5SW50ZXJmYWNlKClcbiAgICAgICAgLmRlZmVyQ29uc3RyYWludHModGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBiZWdpbigpIHtcbiAgICBjb25zdCBxdWVyeUludGVyZmFjZSA9IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCk7XG5cbiAgICBpZiAoIHRoaXMuc2VxdWVsaXplLmRpYWxlY3Quc3VwcG9ydHMuc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb24gKSB7XG4gICAgICBhd2FpdCBxdWVyeUludGVyZmFjZS5zdGFydFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICByZXR1cm4gcXVlcnlJbnRlcmZhY2Uuc2V0SXNvbGF0aW9uTGV2ZWwodGhpcywgdGhpcy5vcHRpb25zLmlzb2xhdGlvbkxldmVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGF3YWl0IHF1ZXJ5SW50ZXJmYWNlLnNldElzb2xhdGlvbkxldmVsKHRoaXMsIHRoaXMub3B0aW9ucy5pc29sYXRpb25MZXZlbCwgdGhpcy5vcHRpb25zKTtcblxuICAgIHJldHVybiBxdWVyeUludGVyZmFjZS5zdGFydFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBjbGVhbnVwKCkge1xuICAgIC8vIERvbid0IHJlbGVhc2UgdGhlIGNvbm5lY3Rpb24gaWYgdGhlcmUncyBhIHBhcmVudCB0cmFuc2FjdGlvbiBvclxuICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgY2xlYW5lZCB1cFxuICAgIGlmICh0aGlzLnBhcmVudCB8fCB0aGlzLmNvbm5lY3Rpb24udXVpZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB0aGlzLl9jbGVhckNscygpO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbGVhc2VDb25uZWN0aW9uKHRoaXMuY29ubmVjdGlvbik7XG4gICAgdGhpcy5jb25uZWN0aW9uLnV1aWQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIF9jbGVhckNscygpIHtcbiAgICBjb25zdCBjbHMgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzO1xuXG4gICAgaWYgKGNscykge1xuICAgICAgaWYgKGNscy5nZXQoJ3RyYW5zYWN0aW9uJykgPT09IHRoaXMpIHtcbiAgICAgICAgY2xzLnNldCgndHJhbnNhY3Rpb24nLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGEgdHJhbnNhY3Rpb24gaXMgY29tbWl0dGVkXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBjb21taXR0ZWQgdHJhbnNhY3Rpb25cbiAgICogQG5hbWUgYWZ0ZXJDb21taXRcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5UcmFuc2FjdGlvblxuICAgKi9cbiAgYWZ0ZXJDb21taXQoZm4pIHtcbiAgICBpZiAoIWZuIHx8IHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImZuXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MucHVzaChmbik7XG4gIH1cblxuICAvKipcbiAgICogVHlwZXMgY2FuIGJlIHNldCBwZXItdHJhbnNhY3Rpb24gYnkgcGFzc2luZyBgb3B0aW9ucy50eXBlYCB0byBgc2VxdWVsaXplLnRyYW5zYWN0aW9uYC5cbiAgICogRGVmYXVsdCB0byBgREVGRVJSRURgIGJ1dCB5b3UgY2FuIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHR5cGUgYnkgcGFzc2luZyBgb3B0aW9ucy50cmFuc2FjdGlvblR5cGVgIGluIGBuZXcgU2VxdWVsaXplYC5cbiAgICogU3FsaXRlIG9ubHkuXG4gICAqXG4gICAqIFBhc3MgaW4gdGhlIGRlc2lyZWQgbGV2ZWwgYXMgdGhlIGZpcnN0IGFyZ3VtZW50OlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0cnkge1xuICAgKiAgIGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbih7IHR5cGU6IFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5UWVBFUy5FWENMVVNJVkUgfSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgKiAgICAgIC8vIHlvdXIgdHJhbnNhY3Rpb25zXG4gICAqICAgfSk7XG4gICAqICAgLy8gdHJhbnNhY3Rpb24gaGFzIGJlZW4gY29tbWl0dGVkLiBEbyBzb21ldGhpbmcgYWZ0ZXIgdGhlIGNvbW1pdCBpZiByZXF1aXJlZC5cbiAgICogfSBjYXRjaChlcnIpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXJyLlxuICAgKiB9XG4gICAqXG4gICAqIEBwcm9wZXJ0eSBERUZFUlJFRFxuICAgKiBAcHJvcGVydHkgSU1NRURJQVRFXG4gICAqIEBwcm9wZXJ0eSBFWENMVVNJVkVcbiAgICovXG4gIHN0YXRpYyBnZXQgVFlQRVMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIERFRkVSUkVEOiAnREVGRVJSRUQnLFxuICAgICAgSU1NRURJQVRFOiAnSU1NRURJQVRFJyxcbiAgICAgIEVYQ0xVU0lWRTogJ0VYQ0xVU0lWRSdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIElzb2xhdGlvbiBsZXZlbHMgY2FuIGJlIHNldCBwZXItdHJhbnNhY3Rpb24gYnkgcGFzc2luZyBgb3B0aW9ucy5pc29sYXRpb25MZXZlbGAgdG8gYHNlcXVlbGl6ZS50cmFuc2FjdGlvbmAuXG4gICAqIFNlcXVlbGl6ZSB1c2VzIHRoZSBkZWZhdWx0IGlzb2xhdGlvbiBsZXZlbCBvZiB0aGUgZGF0YWJhc2UsIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBieSBwYXNzaW5nIGBvcHRpb25zLmlzb2xhdGlvbkxldmVsYCBpbiBTZXF1ZWxpemUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogUGFzcyBpbiB0aGUgZGVzaXJlZCBsZXZlbCBhcyB0aGUgZmlyc3QgYXJndW1lbnQ6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRyeSB7XG4gICAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VxdWVsaXplLnRyYW5zYWN0aW9uKHtpc29sYXRpb25MZXZlbDogU2VxdWVsaXplLlRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuU0VSSUFMSVpBQkxFfSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgKiAgICAgLy8geW91ciB0cmFuc2FjdGlvbnNcbiAgICogICB9KTtcbiAgICogICAvLyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBjb21taXR0ZWQuIERvIHNvbWV0aGluZyBhZnRlciB0aGUgY29tbWl0IGlmIHJlcXVpcmVkLlxuICAgKiB9IGNhdGNoKGVycikge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBlcnIuXG4gICAqIH1cbiAgICpcbiAgICogQHByb3BlcnR5IFJFQURfVU5DT01NSVRURURcbiAgICogQHByb3BlcnR5IFJFQURfQ09NTUlUVEVEXG4gICAqIEBwcm9wZXJ0eSBSRVBFQVRBQkxFX1JFQURcbiAgICogQHByb3BlcnR5IFNFUklBTElaQUJMRVxuICAgKi9cbiAgc3RhdGljIGdldCBJU09MQVRJT05fTEVWRUxTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBSRUFEX1VOQ09NTUlUVEVEOiAnUkVBRCBVTkNPTU1JVFRFRCcsXG4gICAgICBSRUFEX0NPTU1JVFRFRDogJ1JFQUQgQ09NTUlUVEVEJyxcbiAgICAgIFJFUEVBVEFCTEVfUkVBRDogJ1JFUEVBVEFCTEUgUkVBRCcsXG4gICAgICBTRVJJQUxJWkFCTEU6ICdTRVJJQUxJWkFCTEUnXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIG9wdGlvbnMgZm9yIHJvdyBsb2NraW5nLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGZpbmRgIGNhbGxzOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyB0MSBpcyBhIHRyYW5zYWN0aW9uXG4gICAqIE1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiAuLi4sXG4gICAqICAgdHJhbnNhY3Rpb246IHQxLFxuICAgKiAgIGxvY2s6IHQxLkxPQ0suLi5cbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlBvc3RncmVzIGFsc28gc3VwcG9ydHMgc3BlY2lmaWMgbG9ja3Mgd2hpbGUgZWFnZXIgbG9hZGluZyBieSB1c2luZyBPRjo8L2NhcHRpb24+XG4gICAqIFVzZXJNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZTogLi4uLFxuICAgKiAgIGluY2x1ZGU6IFtUYXNrTW9kZWwsIC4uLl0sXG4gICAqICAgdHJhbnNhY3Rpb246IHQxLFxuICAgKiAgIGxvY2s6IHtcbiAgICogICAgIGxldmVsOiB0MS5MT0NLLi4uLFxuICAgKiAgICAgb2Y6IFVzZXJNb2RlbFxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqICMgVXNlck1vZGVsIHdpbGwgYmUgbG9ja2VkIGJ1dCBUYXNrTW9kZWwgd29uJ3QhXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPllvdSBjYW4gYWxzbyBza2lwIGxvY2tlZCByb3dzOjwvY2FwdGlvbj5cbiAgICogLy8gdDEgaXMgYSB0cmFuc2FjdGlvblxuICAgKiBNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZTogLi4uLFxuICAgKiAgIHRyYW5zYWN0aW9uOiB0MSxcbiAgICogICBsb2NrOiB0cnVlLFxuICAgKiAgIHNraXBMb2NrZWQ6IHRydWVcbiAgICogfSk7XG4gICAqICMgVGhlIHF1ZXJ5IHdpbGwgbm93IHJldHVybiBhbnkgcm93cyB0aGF0IGFyZW4ndCBsb2NrZWQgYnkgYW5vdGhlciB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkgVVBEQVRFXG4gICAqIEBwcm9wZXJ0eSBTSEFSRVxuICAgKiBAcHJvcGVydHkgS0VZX1NIQVJFIFBvc3RncmVzIDkuMysgb25seVxuICAgKiBAcHJvcGVydHkgTk9fS0VZX1VQREFURSBQb3N0Z3JlcyA5LjMrIG9ubHlcbiAgICovXG4gIHN0YXRpYyBnZXQgTE9DSygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgVVBEQVRFOiAnVVBEQVRFJyxcbiAgICAgIFNIQVJFOiAnU0hBUkUnLFxuICAgICAgS0VZX1NIQVJFOiAnS0VZIFNIQVJFJyxcbiAgICAgIE5PX0tFWV9VUERBVEU6ICdOTyBLRVkgVVBEQVRFJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGxlYXNlIHNlZSB7QGxpbmsgVHJhbnNhY3Rpb24uTE9DS31cbiAgICovXG4gIGdldCBMT0NLKCkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvbi5MT0NLO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGEtdHlwZXMnKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoJy4vc3FsLXN0cmluZycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoL19iYXNlSXNOYXRpdmUnKTtcbmNvbnN0IHV1aWR2MSA9IHJlcXVpcmUoJ3V1aWQnKS52MTtcbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoJ3V1aWQnKS52NDtcbmNvbnN0IG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzJyk7XG5jb25zdCBvcGVyYXRvcnNTZXQgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMob3BlcmF0b3JzKSk7XG5cbmxldCBpbmZsZWN0aW9uID0gcmVxdWlyZSgnaW5mbGVjdGlvbicpO1xuXG5leHBvcnRzLmNsYXNzVG9JbnZva2FibGUgPSByZXF1aXJlKCcuL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZScpLmNsYXNzVG9JbnZva2FibGU7XG5leHBvcnRzLmpvaW5TUUxGcmFnbWVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cycpLmpvaW5TUUxGcmFnbWVudHM7XG5cbmZ1bmN0aW9uIHVzZUluZmxlY3Rpb24oX2luZmxlY3Rpb24pIHtcbiAgaW5mbGVjdGlvbiA9IF9pbmZsZWN0aW9uO1xufVxuZXhwb3J0cy51c2VJbmZsZWN0aW9uID0gdXNlSW5mbGVjdGlvbjtcblxuZnVuY3Rpb24gY2FtZWxpemVJZihzdHIsIGNvbmRpdGlvbikge1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuXG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXN1bHQgPSBjYW1lbGl6ZShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY2FtZWxpemVJZiA9IGNhbWVsaXplSWY7XG5cbmZ1bmN0aW9uIHVuZGVyc2NvcmVkSWYoc3RyLCBjb25kaXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcblxuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmVzdWx0ID0gdW5kZXJzY29yZShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5kZXJzY29yZWRJZiA9IHVuZGVyc2NvcmVkSWY7XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuLy8gU2FtZSBjb25jZXB0IGFzIF8ubWVyZ2UsIGJ1dCBkb24ndCBvdmVyd3JpdGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFzc2lnbmVkXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKGEsIGIpIHtcbiAgcmV0dXJuIF8ubWVyZ2VXaXRoKGEsIGIsIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpID0+IHtcbiAgICAvLyBJZiBpdCdzIGFuIG9iamVjdCwgbGV0IF8gaGFuZGxlIGl0IHRoaXMgdGltZSwgd2Ugd2lsbCBiZSBjYWxsZWQgYWdhaW4gZm9yIGVhY2ggcHJvcGVydHlcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvYmplY3RWYWx1ZSkgJiYgb2JqZWN0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gXy5pc05hdGl2ZSBpbmNsdWRlcyBhIGNoZWNrIGZvciBjb3JlLWpzIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgcHJlc2VudC5cbiAgICAgIC8vIERlcGVuZGluZyBvbiBfYmFzZUlzTmF0aXZlIGJ5cGFzc2VzIHRoZSBjb3JlLWpzIGNoZWNrLlxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmplY3RWYWx1ZSkgJiYgYmFzZUlzTmF0aXZlKG9iamVjdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlVmFsdWUgfHwgb2JqZWN0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWU7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMubWVyZ2VEZWZhdWx0cyA9IG1lcmdlRGVmYXVsdHM7XG5cbi8vIEFuIGFsdGVybmF0aXZlIHRvIF8ubWVyZ2UsIHdoaWNoIGRvZXNuJ3QgY2xvbmUgaXRzIGFyZ3VtZW50c1xuLy8gQ2xvbmluZyBpcyBhIGJhZCBpZGVhIGJlY2F1c2Ugb3B0aW9ucyBhcmd1bWVudHMgbWF5IGNvbnRhaW4gcmVmZXJlbmNlcyB0byBzZXF1ZWxpemVcbi8vIG1vZGVscyAtIHdoaWNoIGFnYWluIHJlZmVyZW5jZSBkYXRhYmFzZSBsaWJzIHdoaWNoIGRvbid0IGxpa2UgdG8gYmUgY2xvbmVkIChpbiBwYXJ0aWN1bGFyIHBnLW5hdGl2ZSlcbmZ1bmN0aW9uIG1lcmdlKCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICBmb3IgKGNvbnN0IG9iaiBvZiBhcmd1bWVudHMpIHtcbiAgICBfLmZvck93bihvYmosICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXJlc3VsdFtrZXldKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlLmNvbmNhdChyZXN1bHRba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcblxuZnVuY3Rpb24gc3BsaWNlU3RyKHN0ciwgaW5kZXgsIGNvdW50LCBhZGQpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBpbmRleCkgKyBhZGQgKyBzdHIuc2xpY2UoaW5kZXggKyBjb3VudCk7XG59XG5leHBvcnRzLnNwbGljZVN0ciA9IHNwbGljZVN0cjtcblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpLnJlcGxhY2UoL1stX1xcc10rKC4pPy9nLCAobWF0Y2gsIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5leHBvcnRzLmNhbWVsaXplID0gY2FtZWxpemU7XG5cbmZ1bmN0aW9uIHVuZGVyc2NvcmUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnVuZGVyc2NvcmUoc3RyKTtcbn1cbmV4cG9ydHMudW5kZXJzY29yZSA9IHVuZGVyc2NvcmU7XG5cbmZ1bmN0aW9uIHNpbmd1bGFyaXplKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi5zaW5ndWxhcml6ZShzdHIpO1xufVxuZXhwb3J0cy5zaW5ndWxhcml6ZSA9IHNpbmd1bGFyaXplO1xuXG5mdW5jdGlvbiBwbHVyYWxpemUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnBsdXJhbGl6ZShzdHIpO1xufVxuZXhwb3J0cy5wbHVyYWxpemUgPSBwbHVyYWxpemU7XG5cbmZ1bmN0aW9uIGZvcm1hdChhcnIsIGRpYWxlY3QpIHtcbiAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICAvLyBNYWtlIGEgY2xvbmUgb2YgdGhlIGFycmF5IGJlYWN1c2UgZm9ybWF0IG1vZGlmaWVzIHRoZSBwYXNzZWQgYXJnc1xuICByZXR1cm4gU3FsU3RyaW5nLmZvcm1hdChhcnJbMF0sIGFyci5zbGljZSgxKSwgdGltZVpvbmUsIGRpYWxlY3QpO1xufVxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5cbmZ1bmN0aW9uIGZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHBhcmFtZXRlcnMsIGRpYWxlY3QpIHtcbiAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICByZXR1cm4gU3FsU3RyaW5nLmZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHBhcmFtZXRlcnMsIHRpbWVab25lLCBkaWFsZWN0KTtcbn1cbmV4cG9ydHMuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzID0gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzO1xuXG5mdW5jdGlvbiBjbG9uZURlZXAob2JqLCBvbmx5UGxhaW4pIHtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICByZXR1cm4gXy5jbG9uZURlZXBXaXRoKG9iaiwgZWxlbSA9PiB7XG4gICAgLy8gRG8gbm90IHRyeSB0byBjdXN0b21pemUgY2xvbmluZyBvZiBhcnJheXMgb3IgUE9KT3NcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtKSB8fCBfLmlzUGxhaW5PYmplY3QoZWxlbSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugc3BlY2lmaWVkIHRvIGNsb25lIG9ubHkgcGxhaW4gb2JqZWN0cyAmIGFycmF5cywgd2UgaWdub3JlIGV2ZXJ5aGluZyBlbHNlXG4gICAgLy8gSW4gYW55IGNhc2UsIGRvbid0IGNsb25lIHN0dWZmIHRoYXQncyBhbiBvYmplY3QsIGJ1dCBub3QgYSBwbGFpbiBvbmUgLSBmeCBleGFtcGxlIHNlcXVlbGl6ZSBtb2RlbHMgYW5kIGluc3RhbmNlc1xuICAgIGlmIChvbmx5UGxhaW4gfHwgdHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICAvLyBQcmVzZXJ2ZSBzcGVjaWFsIGRhdGEtdHlwZXMgbGlrZSBgZm5gIGFjcm9zcyBjbG9uZXMuIF8uZ2V0KCkgaXMgdXNlZCBmb3IgY2hlY2tpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgIGlmIChlbGVtICYmIHR5cGVvZiBlbGVtLmNsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZWxlbS5jbG9uZSgpO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcblxuLyogRXhwYW5kIGFuZCBub3JtYWxpemUgZmluZGVyIG9wdGlvbnMgKi9cbmZ1bmN0aW9uIG1hcEZpbmRlck9wdGlvbnMob3B0aW9ucywgTW9kZWwpIHtcbiAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBNb2RlbC5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMuZmlsdGVyKHYgPT4gIU1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcy5oYXModikpO1xuICB9XG5cbiAgbWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCBNb2RlbCk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLm1hcEZpbmRlck9wdGlvbnMgPSBtYXBGaW5kZXJPcHRpb25zO1xuXG4vKiBVc2VkIHRvIG1hcCBmaWVsZCBuYW1lcyBpbiBhdHRyaWJ1dGVzIGFuZCB3aGVyZSBjb25kaXRpb25zICovXG5mdW5jdGlvbiBtYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIE1vZGVsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKGF0dHIgPT4ge1xuICAgICAgLy8gT2JqZWN0IGxvb2t1cHMgd2lsbCBmb3JjZSBhbnkgdmFyaWFibGUgdG8gc3RyaW5ncywgd2UgZG9uJ3Qgd2FudCB0aGF0IGZvciBzcGVjaWFsIG9iamVjdHMgZXRjXG4gICAgICBpZiAodHlwZW9mIGF0dHIgIT09ICdzdHJpbmcnKSByZXR1cm4gYXR0cjtcbiAgICAgIC8vIE1hcCBhdHRyaWJ1dGVzIHRvIGFsaWFzZWQgc3ludGF4IGF0dHJpYnV0ZXNcbiAgICAgIGlmIChNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmIGF0dHIgIT09IE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIFtNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkLCBhdHRyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMud2hlcmUgJiYgXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgb3B0aW9ucy53aGVyZSA9IG1hcFdoZXJlRmllbGROYW1lcyhvcHRpb25zLndoZXJlLCBNb2RlbCk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMubWFwT3B0aW9uRmllbGROYW1lcyA9IG1hcE9wdGlvbkZpZWxkTmFtZXM7XG5cbmZ1bmN0aW9uIG1hcFdoZXJlRmllbGROYW1lcyhhdHRyaWJ1dGVzLCBNb2RlbCkge1xuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGdldENvbXBsZXhLZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goYXR0cmlidXRlID0+IHtcbiAgICAgIGNvbnN0IHJhd0F0dHJpYnV0ZSA9IE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcblxuICAgICAgaWYgKHJhd0F0dHJpYnV0ZSAmJiByYXdBdHRyaWJ1dGUuZmllbGQgIT09IHJhd0F0dHJpYnV0ZS5maWVsZE5hbWUpIHtcbiAgICAgICAgYXR0cmlidXRlc1tyYXdBdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgICBkZWxldGUgYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXNbYXR0cmlidXRlXSlcbiAgICAgICAgJiYgIShyYXdBdHRyaWJ1dGUgJiYgKFxuICAgICAgICAgIHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkhTVE9SRVxuICAgICAgICAgIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pKSkgeyAvLyBQcmV2ZW50IHJlbmFtaW5nIG9mIEhTVE9SRSAmIEpTT04gZmllbGRzXG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IG1hcE9wdGlvbkZpZWxkTmFtZXMoe1xuICAgICAgICAgIHdoZXJlOiBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cbiAgICAgICAgfSwgTW9kZWwpLndoZXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXS5mb3JFYWNoKCh3aGVyZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHdoZXJlKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdW2luZGV4XSA9IG1hcFdoZXJlRmllbGROYW1lcyh3aGVyZSwgTW9kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuZXhwb3J0cy5tYXBXaGVyZUZpZWxkTmFtZXMgPSBtYXBXaGVyZUZpZWxkTmFtZXM7XG5cbi8qIFVzZWQgdG8gbWFwIGZpZWxkIG5hbWVzIGluIHZhbHVlcyAqL1xuZnVuY3Rpb24gbWFwVmFsdWVGaWVsZE5hbWVzKGRhdGFWYWx1ZXMsIGZpZWxkcywgTW9kZWwpIHtcbiAgY29uc3QgdmFsdWVzID0ge307XG5cbiAgZm9yIChjb25zdCBhdHRyIG9mIGZpZWxkcykge1xuICAgIGlmIChkYXRhVmFsdWVzW2F0dHJdICE9PSB1bmRlZmluZWQgJiYgIU1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoYXR0cikpIHtcbiAgICAgIC8vIEZpZWxkIG5hbWUgbWFwcGluZ1xuICAgICAgaWYgKE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJiBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyKSB7XG4gICAgICAgIHZhbHVlc1tNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSA9IGRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNbYXR0cl0gPSBkYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLm1hcFZhbHVlRmllbGROYW1lcyA9IG1hcFZhbHVlRmllbGROYW1lcztcblxuZnVuY3Rpb24gaXNDb2xTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICckJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyQnO1xufVxuZXhwb3J0cy5pc0NvbFN0cmluZyA9IGlzQ29sU3RyaW5nO1xuXG5mdW5jdGlvbiBjYW5UcmVhdEFycmF5QXNBbmQoYXJyKSB7XG4gIHJldHVybiBhcnIuc29tZShhcmcgPT4gXy5pc1BsYWluT2JqZWN0KGFyZykgfHwgYXJnIGluc3RhbmNlb2YgV2hlcmUpO1xufVxuZXhwb3J0cy5jYW5UcmVhdEFycmF5QXNBbmQgPSBjYW5UcmVhdEFycmF5QXNBbmQ7XG5cbmZ1bmN0aW9uIGNvbWJpbmVUYWJsZU5hbWVzKHRhYmxlTmFtZTEsIHRhYmxlTmFtZTIpIHtcbiAgcmV0dXJuIHRhYmxlTmFtZTEudG9Mb3dlckNhc2UoKSA8IHRhYmxlTmFtZTIudG9Mb3dlckNhc2UoKSA/IHRhYmxlTmFtZTEgKyB0YWJsZU5hbWUyIDogdGFibGVOYW1lMiArIHRhYmxlTmFtZTE7XG59XG5leHBvcnRzLmNvbWJpbmVUYWJsZU5hbWVzID0gY29tYmluZVRhYmxlTmFtZXM7XG5cbmZ1bmN0aW9uIHRvRGVmYXVsdFZhbHVlKHZhbHVlLCBkaWFsZWN0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0bXAgPSB2YWx1ZSgpO1xuICAgIGlmICh0bXAgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQUJTVFJBQ1QpIHtcbiAgICAgIHJldHVybiB0bXAudG9TcWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRtcDtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFYxKSB7XG4gICAgcmV0dXJuIHV1aWR2MSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjQpIHtcbiAgICByZXR1cm4gdXVpZHY0KCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLk5PVykge1xuICAgIHJldHVybiBub3coZGlhbGVjdCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbiAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4geyAuLi52YWx1ZSB9O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMudG9EZWZhdWx0VmFsdWUgPSB0b0RlZmF1bHRWYWx1ZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgZXhpc3RzIGFuZCBjYW4gYmUgZGVzY3JpYmVkXG4gKiBpbiBhIGRiIHNjaGVtYSB1c2luZyB0aGUgREVGQVVMVCBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtICB7Kn0gdmFsdWUgQW55IGRlZmF1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0geWVzIC8gbm8uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0VmFsdWVTY2hlbWFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gVE9ETyB0aGlzIHdpbGwgYmUgc2NoZW1hYmxlIHdoZW4gYWxsIHN1cHBvcnRlZCBkYlxuICAvLyBoYXZlIGJlZW4gbm9ybWFsaXplZCBmb3IgdGhpcyBjYXNlXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5OT1cpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWMSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlID0gZGVmYXVsdFZhbHVlU2NoZW1hYmxlO1xuXG5mdW5jdGlvbiByZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goaGFzaCwgb21pdE51bGwsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9IGhhc2g7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYWxsb3dOdWxsID0gb3B0aW9ucy5hbGxvd051bGwgfHwgW107XG5cbiAgaWYgKG9taXROdWxsKSB7XG4gICAgY29uc3QgX2hhc2ggPSB7fTtcblxuICAgIF8uZm9ySW4oaGFzaCwgKHZhbCwga2V5KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5hbGxvd051bGwuaW5jbHVkZXMoa2V5KSB8fCBrZXkuZW5kc1dpdGgoJ0lkJykgfHwgdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9oYXNoW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQgPSBfaGFzaDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaCA9IHJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaDtcblxuY29uc3QgZGlhbGVjdHMgPSBuZXcgU2V0KFsnbWFyaWFkYicsICdteXNxbCcsICdwb3N0Z3JlcycsICdzcWxpdGUnLCAnbXNzcWwnXSk7XG5cbmZ1bmN0aW9uIG5vdyhkaWFsZWN0KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xuICBpZiAoIWRpYWxlY3RzLmhhcyhkaWFsZWN0KSkge1xuICAgIGQuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIHJldHVybiBkO1xufVxuZXhwb3J0cy5ub3cgPSBub3c7XG5cbi8vIE5vdGU6IFVzZSB0aGUgYHF1b3RlSWRlbnRpZmllcigpYCBhbmQgYGVzY2FwZSgpYCBtZXRob2RzIG9uIHRoZVxuLy8gYFF1ZXJ5SW50ZXJmYWNlYCBpbnN0ZWFkIGZvciBtb3JlIHBvcnRhYmxlIGNvZGUuXG5cbmNvbnN0IFRJQ0tfQ0hBUiA9ICdgJztcbmV4cG9ydHMuVElDS19DSEFSID0gVElDS19DSEFSO1xuXG5mdW5jdGlvbiBhZGRUaWNrcyhzLCB0aWNrQ2hhcikge1xuICB0aWNrQ2hhciA9IHRpY2tDaGFyIHx8IFRJQ0tfQ0hBUjtcbiAgcmV0dXJuIHRpY2tDaGFyICsgcmVtb3ZlVGlja3MocywgdGlja0NoYXIpICsgdGlja0NoYXI7XG59XG5leHBvcnRzLmFkZFRpY2tzID0gYWRkVGlja3M7XG5cbmZ1bmN0aW9uIHJlbW92ZVRpY2tzKHMsIHRpY2tDaGFyKSB7XG4gIHRpY2tDaGFyID0gdGlja0NoYXIgfHwgVElDS19DSEFSO1xuICByZXR1cm4gcy5yZXBsYWNlKG5ldyBSZWdFeHAodGlja0NoYXIsICdnJyksICcnKTtcbn1cbmV4cG9ydHMucmVtb3ZlVGlja3MgPSByZW1vdmVUaWNrcztcblxuLyoqXG4gKiBSZWNlaXZlcyBhIHRyZWUtbGlrZSBvYmplY3QgYW5kIHJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2hpY2ggZGVwdGggaXMgMS5cbiAqXG4gKiAtIElucHV0OlxuICpcbiAqICB7XG4gKiAgICBuYW1lOiAnSm9obicsXG4gKiAgICBhZGRyZXNzOiB7XG4gKiAgICAgIHN0cmVldDogJ0Zha2UgU3QuIDEyMycsXG4gKiAgICAgIGNvb3JkaW5hdGVzOiB7XG4gKiAgICAgICAgbG9uZ2l0dWRlOiA1NS42Nzc5NjI3LFxuICogICAgICAgIGxhdGl0dWRlOiAxMi41OTY0MzEzXG4gKiAgICAgIH1cbiAqICAgIH1cbiAqICB9XG4gKlxuICogLSBPdXRwdXQ6XG4gKlxuICogIHtcbiAqICAgIG5hbWU6ICdKb2huJyxcbiAqICAgIGFkZHJlc3Muc3RyZWV0OiAnRmFrZSBTdC4gMTIzJyxcbiAqICAgIGFkZHJlc3MuY29vcmRpbmF0ZXMubGF0aXR1ZGU6IDU1LjY3Nzk2MjcsXG4gKiAgICBhZGRyZXNzLmNvb3JkaW5hdGVzLmxvbmdpdHVkZTogMTIuNTk2NDMxM1xuICogIH1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgYW4gT2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBhIGZsYXR0ZW5lZCBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5PYmplY3REZWVwKHZhbHVlKSB7XG4gIGlmICghXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBmbGF0dGVuZWRPYmogPSB7fTtcblxuICBmdW5jdGlvbiBmbGF0dGVuT2JqZWN0KG9iaiwgc3ViUGF0aCkge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgcGF0aFRvUHJvcGVydHkgPSBzdWJQYXRoID8gYCR7c3ViUGF0aH0uJHtrZXl9YCA6IGtleTtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnICYmIG9ialtrZXldICE9PSBudWxsKSB7XG4gICAgICAgIGZsYXR0ZW5PYmplY3Qob2JqW2tleV0sIHBhdGhUb1Byb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5lZE9ialtwYXRoVG9Qcm9wZXJ0eV0gPSBfLmdldChvYmosIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZE9iajtcbiAgfVxuXG4gIHJldHVybiBmbGF0dGVuT2JqZWN0KHZhbHVlLCB1bmRlZmluZWQpO1xufVxuZXhwb3J0cy5mbGF0dGVuT2JqZWN0RGVlcCA9IGZsYXR0ZW5PYmplY3REZWVwO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciByZXByZXNlbnRpbmcgU1FMIGZ1bmN0aW9ucywgYW5kIGNvbHVtbnMgdGhhdCBzaG91bGQgYmUgZXNjYXBlZC5cbiAqIFBsZWFzZSBkbyBub3QgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSwgdXNlIFNlcXVlbGl6ZS5mbiBhbmQgU2VxdWVsaXplLmNvbCBpbnN0ZWFkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNlcXVlbGl6ZU1ldGhvZCB7fVxuZXhwb3J0cy5TZXF1ZWxpemVNZXRob2QgPSBTZXF1ZWxpemVNZXRob2Q7XG5cbmNsYXNzIEZuIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoZm4sIGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRm4odGhpcy5mbiwgdGhpcy5hcmdzKTtcbiAgfVxufVxuZXhwb3J0cy5GbiA9IEZuO1xuXG5jbGFzcyBDb2wgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcihjb2wsIC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbCA9IGFyZ3M7XG4gICAgfVxuICAgIHRoaXMuY29sID0gY29sO1xuICB9XG59XG5leHBvcnRzLkNvbCA9IENvbDtcblxuY2xhc3MgQ2FzdCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKHZhbCwgdHlwZSwganNvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gICAgdGhpcy50eXBlID0gKHR5cGUgfHwgJycpLnRyaW0oKTtcbiAgICB0aGlzLmpzb24gPSBqc29uIHx8IGZhbHNlO1xuICB9XG59XG5leHBvcnRzLkNhc3QgPSBDYXN0O1xuXG5jbGFzcyBMaXRlcmFsIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgfVxufVxuZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcblxuY2xhc3MgSnNvbiBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoXy5pc09iamVjdChjb25kaXRpb25zT3JQYXRoKSkge1xuICAgICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9uc09yUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXRoID0gY29uZGl0aW9uc09yUGF0aDtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnRzLkpzb24gPSBKc29uO1xuXG5jbGFzcyBXaGVyZSBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZSwgY29tcGFyYXRvciwgbG9naWMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChsb2dpYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dpYyA9IGNvbXBhcmF0b3I7XG4gICAgICBjb21wYXJhdG9yID0gJz0nO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5sb2dpYyA9IGxvZ2ljO1xuICB9XG59XG5leHBvcnRzLldoZXJlID0gV2hlcmU7XG5cbi8vQ29sbGVjdGlvbiBvZiBoZWxwZXIgbWV0aG9kcyB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggc3ltYm9sIG9wZXJhdG9yc1xuXG4vKipcbiAqIGdldE9wZXJhdG9yc1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXk8c3ltYm9sPn0gQWxsIG9wZXJhdG9ycyBwcm9wZXJ0aWVzIG9mIG9ialxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0T3BlcmF0b3JzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopLmZpbHRlcihzID0+IG9wZXJhdG9yc1NldC5oYXMocykpO1xufVxuZXhwb3J0cy5nZXRPcGVyYXRvcnMgPSBnZXRPcGVyYXRvcnM7XG5cbi8qKlxuICogZ2V0Q29tcGxleEtleXNcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5PHN0cmluZ3xzeW1ib2w+fSBBbGwga2V5cyBpbmNsdWRpbmcgb3BlcmF0b3JzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRDb21wbGV4S2V5cyhvYmopIHtcbiAgcmV0dXJuIGdldE9wZXJhdG9ycyhvYmopLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKTtcbn1cbmV4cG9ydHMuZ2V0Q29tcGxleEtleXMgPSBnZXRDb21wbGV4S2V5cztcblxuLyoqXG4gKiBnZXRDb21wbGV4U2l6ZVxuICpcbiAqIEBwYXJhbSAge29iamVjdHxBcnJheX0gb2JqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAgICAgIExlbmd0aCBvZiBvYmplY3QgcHJvcGVydGllcyBpbmNsdWRpbmcgb3BlcmF0b3JzIGlmIG9iaiBpcyBhcnJheSByZXR1cm5zIGl0cyBsZW5ndGhcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBsZXhTaXplKG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IGdldENvbXBsZXhLZXlzKG9iaikubGVuZ3RoO1xufVxuZXhwb3J0cy5nZXRDb21wbGV4U2l6ZSA9IGdldENvbXBsZXhTaXplO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHdoZXJlIGNsYXVzZSBpcyBlbXB0eSwgZXZlbiB3aXRoIFN5bWJvbHNcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1doZXJlRW1wdHkob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiBfLmlzRW1wdHkob2JqKSAmJiBnZXRPcGVyYXRvcnMob2JqKS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzV2hlcmVFbXB0eSA9IGlzV2hlcmVFbXB0eTtcblxuLyoqXG4gKiBSZXR1cm5zIEVOVU0gbmFtZSBieSBqb2luaW5nIHRhYmxlIGFuZCBjb2x1bW4gbmFtZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVFbnVtTmFtZSh0YWJsZU5hbWUsIGNvbHVtbk5hbWUpIHtcbiAgcmV0dXJuIGBlbnVtXyR7dGFibGVOYW1lfV8ke2NvbHVtbk5hbWV9YDtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVFbnVtTmFtZSA9IGdlbmVyYXRlRW51bU5hbWU7XG5cbi8qKlxuICogUmV0dXJucyBhbiBuZXcgT2JqZWN0IHdoaWNoIGtleXMgYXJlIGNhbWVsaXplZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZU9iamVjdEtleXMob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IG5ldyBPYmplY3QoKTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbmV3T2JqW2NhbWVsaXplKGtleSldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZXhwb3J0cy5jYW1lbGl6ZU9iamVjdEtleXMgPSBjYW1lbGl6ZU9iamVjdEtleXM7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBhbmQgc3ltYm9sIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKlxuICogaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy40I2RlZmF1bHRzXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5vYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdHMob2JqZWN0LCAuLi5zb3VyY2VzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHNvdXJjZSA9IE9iamVjdChzb3VyY2UpO1xuXG4gICAgICBnZXRDb21wbGV4S2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIF8uZXEodmFsdWUsIE9iamVjdC5wcm90b3R5cGVba2V5XSkgJiZcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpXG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb2JqZWN0O1xufVxuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXl9ICBpbmRleC5maWVsZHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5kZXgubmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gdGFibGVOYW1lXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5hbWVJbmRleChpbmRleCwgdGFibGVOYW1lKSB7XG4gIGlmICh0YWJsZU5hbWUudGFibGVOYW1lKSB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluZGV4LCAnbmFtZScpKSB7XG4gICAgY29uc3QgZmllbGRzID0gaW5kZXguZmllbGRzLm1hcChcbiAgICAgIGZpZWxkID0+IHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycgPyBmaWVsZCA6IGZpZWxkLm5hbWUgfHwgZmllbGQuYXR0cmlidXRlXG4gICAgKTtcbiAgICBpbmRleC5uYW1lID0gdW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7ZmllbGRzLmpvaW4oJ18nKX1gKTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cbmV4cG9ydHMubmFtZUluZGV4ID0gbmFtZUluZGV4O1xuXG4vKipcbiAqIENoZWNrcyBpZiAyIGFycmF5cyBpbnRlcnNlY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyMVxuICogQHBhcmFtIHtBcnJheX0gYXJyMlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhhcnIxLCBhcnIyKSB7XG4gIHJldHVybiBhcnIxLnNvbWUodiA9PiBhcnIyLmluY2x1ZGVzKHYpKTtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV3JhcHMgYSBjb25zdHJ1Y3RvciB0byBub3QgbmVlZCB0aGUgYG5ld2Aga2V5d29yZCB1c2luZyBhIHByb3h5LlxuICogT25seSB1c2VkIGZvciBkYXRhIHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENsYXNzIFRoZSBjbGFzcyBpbnN0YW5jZSB0byB3cmFwIGFzIGludm9jYWJsZS5cbiAqIEByZXR1cm5zIHtQcm94eX0gV3JhcHBlZCBjbGFzcyBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsYXNzVG9JbnZva2FibGUoQ2xhc3MpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShDbGFzcywge1xuICAgIGFwcGx5KFRhcmdldCwgdGhpc0FyZywgYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoLi4uYXJncyk7XG4gICAgfSxcbiAgICBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IFRhcmdldCguLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHApIHtcbiAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMuY2xhc3NUb0ludm9rYWJsZSA9IGNsYXNzVG9JbnZva2FibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgZGVwcmVjYXRlIH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuZXhwb3J0cy5ub1Jhd0F0dHJpYnV0ZXMgPSBkZXByZWNhdGUobm9vcCwgJ1VzZSBzZXF1ZWxpemUuZm4gLyBzZXF1ZWxpemUubGl0ZXJhbCB0byBjb25zdHJ1Y3QgYXR0cmlidXRlcycsICdTRVFVRUxJWkUwMDAxJyk7XG5leHBvcnRzLm5vVHJ1ZUxvZ2dpbmcgPSBkZXByZWNhdGUobm9vcCwgJ1RoZSBsb2dnaW5nLW9wdGlvbiBzaG91bGQgYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgZmFsc2UuIERlZmF1bHQ6IGNvbnNvbGUubG9nJywgJ1NFUVVFTElaRTAwMDInKTtcbmV4cG9ydHMubm9TdHJpbmdPcGVyYXRvcnMgPSBkZXByZWNhdGUobm9vcCwgJ1N0cmluZyBiYXNlZCBvcGVyYXRvcnMgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgU3ltYm9sIGJhc2VkIG9wZXJhdG9ycyBmb3IgYmV0dGVyIHNlY3VyaXR5LCByZWFkIG1vcmUgYXQgaHR0cHM6Ly9zZXF1ZWxpemUub3JnL21hc3Rlci9tYW51YWwvcXVlcnlpbmcuaHRtbCNvcGVyYXRvcnMnLCAnU0VRVUVMSVpFMDAwMycpO1xuZXhwb3J0cy5ub0Jvb2xPcGVyYXRvckFsaWFzZXMgPSBkZXByZWNhdGUobm9vcCwgJ0EgYm9vbGVhbiB2YWx1ZSB3YXMgcGFzc2VkIHRvIG9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcy4gVGhpcyBpcyBhIG5vLW9wIHdpdGggdjUgYW5kIHNob3VsZCBiZSByZW1vdmVkLicsICdTRVFVRUxJWkUwMDA0Jyk7XG5leHBvcnRzLm5vRG91YmxlTmVzdGVkR3JvdXAgPSBkZXByZWNhdGUobm9vcCwgJ1Bhc3NpbmcgYSBkb3VibGUgbmVzdGVkIG5lc3RlZCBhcnJheSB0byBgZ3JvdXBgIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjYuJywgJ1NFUVVFTElaRTAwMDUnKTtcbmV4cG9ydHMudW5zdXBwb3J0ZWRFbmdpbmUgPSBkZXByZWNhdGUobm9vcCwgJ1RoaXMgZGF0YWJhc2UgZW5naW5lIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIHVwZGF0ZSB5b3VyIGRhdGFiYXNlIHNlcnZlci4gTW9yZSBpbmZvcm1hdGlvbiBodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9ibG9iL21haW4vRU5HSU5FLm1kJywgJ1NFUVVFTElaRTAwMDYnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZG9lc05vdFdhbnRMZWFkaW5nU3BhY2Uoc3RyKSB7XG4gIHJldHVybiAvXls7LCldLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBkb2VzTm90V2FudFRyYWlsaW5nU3BhY2Uoc3RyKSB7XG4gIHJldHVybiAvXFwoJC8udGVzdChzdHIpO1xufVxuXG4vKipcbiAqIEpvaW5zIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCBhIHNpbmdsZSBzcGFjZSBiZXR3ZWVuIHRoZW0sXG4gKiBleGNlcHQgZm9yOlxuICogXG4gKiAtIFN0cmluZ3Mgc3RhcnRpbmcgd2l0aCAnOycsICcsJyBhbmQgJyknLCB3aGljaCBkbyBub3QgZ2V0IGEgbGVhZGluZyBzcGFjZS5cbiAqIC0gU3RyaW5ncyBlbmRpbmcgd2l0aCAnKCcsIHdoaWNoIGRvIG5vdCBnZXQgYSB0cmFpbGluZyBzcGFjZS5cbiAqIFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFydHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaW5nbGVTcGFjZUpvaW5IZWxwZXIocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnJlZHVjZSgoeyBza2lwTmV4dExlYWRpbmdTcGFjZSwgcmVzdWx0IH0sIHBhcnQpID0+IHtcbiAgICBpZiAoc2tpcE5leHRMZWFkaW5nU3BhY2UgfHwgZG9lc05vdFdhbnRMZWFkaW5nU3BhY2UocGFydCkpIHtcbiAgICAgIHJlc3VsdCArPSBwYXJ0LnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGAgJHtwYXJ0LnRyaW0oKX1gO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2tpcE5leHRMZWFkaW5nU3BhY2U6IGRvZXNOb3RXYW50VHJhaWxpbmdTcGFjZShwYXJ0KSxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH0sIHtcbiAgICBza2lwTmV4dExlYWRpbmdTcGFjZTogdHJ1ZSxcbiAgICByZXN1bHQ6ICcnXG4gIH0pLnJlc3VsdDtcbn1cblxuLyoqXG4gKiBKb2lucyBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIHNwYWNlLCBhdXRvIHRyaW1taW5nIHdoZW4gbmVlZGVkLlxuICogXG4gKiBDZXJ0YWluIGVsZW1lbnRzIGRvIG5vdCBnZXQgbGVhZGluZy90cmFpbGluZyBzcGFjZXMuXG4gKiBcbiAqIEBwYXJhbSB7YW55W119IGFycmF5IFRoZSBhcnJheSB0byBiZSBqb2luZWQuIEZhbHN5IHZhbHVlcyBhcmUgc2tpcHBlZC4gSWYgYW5cbiAqIGVsZW1lbnQgaXMgYW5vdGhlciBhcnJheSwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCByZWN1cnNpdmVseSBvbiB0aGF0IGFycmF5LlxuICogT3RoZXJ3aXNlLCBpZiBhIG5vbi1zdHJpbmcsIG5vbi1mYWxzeSB2YWx1ZSBpcyBwcmVzZW50LCBhIFR5cGVFcnJvciB3aWxsIGJlIHRocm93bi5cbiAqIFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGpvaW5lZCBzdHJpbmcuXG4gKiBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGpvaW5TUUxGcmFnbWVudHMoYXJyYXkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIC8vIFNraXAgZmFsc3kgZnJhZ21lbnRzXG4gIGFycmF5ID0gYXJyYXkuZmlsdGVyKHggPT4geCk7XG5cbiAgLy8gUmVzb2x2ZSByZWN1cnNpdmUgY2FsbHNcbiAgYXJyYXkgPSBhcnJheS5tYXAoZnJhZ21lbnQgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyYWdtZW50KSkge1xuICAgICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0pO1xuXG4gIC8vIEVuc3VyZSBzdHJpbmdzXG4gIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgYXJyYXkpIHtcbiAgICBpZiAoZnJhZ21lbnQgJiYgdHlwZW9mIGZyYWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGBUcmllZCB0byBjb25zdHJ1Y3QgYSBTUUwgc3RyaW5nIHdpdGggYSBub24tc3RyaW5nLCBub24tZmFsc3kgZnJhZ21lbnQgKCR7ZnJhZ21lbnR9KS5gKTtcbiAgICAgIGVycm9yLmFyZ3MgPSBhcnJheTtcbiAgICAgIGVycm9yLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBUcmltIGZyYWdtZW50c1xuICBhcnJheSA9IGFycmF5Lm1hcCh4ID0+IHgudHJpbSgpKTtcblxuICAvLyBTa2lwIGZ1bGwtd2hpdGVzcGFjZSBmcmFnbWVudHMgKGVtcHR5IGFmdGVyIHRoZSBhYm92ZSB0cmltKVxuICBhcnJheSA9IGFycmF5LmZpbHRlcih4ID0+IHggIT09ICcnKTtcblxuICByZXR1cm4gc2luZ2xlU3BhY2VKb2luSGVscGVyKGFycmF5KTtcbn1cbmV4cG9ydHMuam9pblNRTEZyYWdtZW50cyA9IGpvaW5TUUxGcmFnbWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2VxdWVsaXplIG1vZHVsZSBmb3IgZGVidWcgYW5kIGRlcHJlY2F0aW9uIG1lc3NhZ2VzLlxuICogSXQgcmVxdWlyZSBhIGBjb250ZXh0YCBmb3Igd2hpY2ggbWVzc2FnZXMgd2lsbCBiZSBwcmludGVkLlxuICpcbiAqIEBtb2R1bGUgbG9nZ2luZ1xuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgY29udGV4dDogJ3NlcXVlbGl6ZScsXG4gICAgICBkZWJ1ZzogdHJ1ZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICB3YXJuKG1lc3NhZ2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihgKCR7dGhpcy5jb25maWcuY29udGV4dH0pIFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgfVxuXG4gIGluc3BlY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHZhbHVlLCBmYWxzZSwgMyk7XG4gIH1cblxuICBkZWJ1Z0NvbnRleHQobmFtZSkge1xuICAgIHJldHVybiBkZWJ1ZyhgJHt0aGlzLmNvbmZpZy5jb250ZXh0fToke25hbWV9YCk7XG4gIH1cbn1cblxuZXhwb3J0cy5sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB2YWxpZGF0b3IgPSBfLmNsb25lRGVlcChyZXF1aXJlKCd2YWxpZGF0b3InKSk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuY29uc3QgZXh0ZW5zaW9ucyA9IHtcbiAgZXh0ZW5kKG5hbWUsIGZuKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZuO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vdEVtcHR5KHN0cikge1xuICAgIHJldHVybiAhc3RyLm1hdGNoKC9eW1xcc1xcdFxcclxcbl0qJC8pO1xuICB9LFxuICBsZW4oc3RyLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVuZ3RoKHN0ciwgbWluLCBtYXgpO1xuICB9LFxuICBpc1VybChzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1VSTChzdHIpO1xuICB9LFxuICBpc0lQdjYoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJUChzdHIsIDYpO1xuICB9LFxuICBpc0lQdjQoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJUChzdHIsIDQpO1xuICB9LFxuICBub3RJbihzdHIsIHZhbHVlcykge1xuICAgIHJldHVybiAhdGhpcy5pc0luKHN0ciwgdmFsdWVzKTtcbiAgfSxcbiAgcmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICBzdHIgKz0gJyc7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXR0ZXJuKS5zbGljZSg4LCAtMSkgIT09ICdSZWdFeHAnKSB7XG4gICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLm1hdGNoKHBhdHRlcm4pO1xuICB9LFxuICBub3RSZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiAhdGhpcy5yZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH0sXG4gIGlzRGVjaW1hbChzdHIpIHtcbiAgICByZXR1cm4gc3RyICE9PSAnJyAmJiAhIXN0ci5tYXRjaCgvXig/Oi0/KD86WzAtOV0rKSk/KD86XFwuWzAtOV0qKT8oPzpbZUVdWystXT8oPzpbMC05XSspKT8kLyk7XG4gIH0sXG4gIG1pbihzdHIsIHZhbCkge1xuICAgIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gaXNOYU4obnVtYmVyKSB8fCBudW1iZXIgPj0gdmFsO1xuICB9LFxuICBtYXgoc3RyLCB2YWwpIHtcbiAgICBjb25zdCBudW1iZXIgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgcmV0dXJuIGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDw9IHZhbDtcbiAgfSxcbiAgbm90KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMubm90UmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9LFxuICBjb250YWlucyhzdHIsIGVsZW0pIHtcbiAgICByZXR1cm4gISFlbGVtICYmIHN0ci5pbmNsdWRlcyhlbGVtKTtcbiAgfSxcbiAgbm90Q29udGFpbnMoc3RyLCBlbGVtKSB7XG4gICAgcmV0dXJuICF0aGlzLmNvbnRhaW5zKHN0ciwgZWxlbSk7XG4gIH0sXG4gIGlzKHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9XG59O1xuZXhwb3J0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuLy8gaW5zdGFuY2UgYmFzZWQgdmFsaWRhdG9yc1xudmFsaWRhdG9yLmlzSW1tdXRhYmxlID0gZnVuY3Rpb24odmFsdWUsIHZhbGlkYXRvckFyZ3MsIGZpZWxkLCBtb2RlbEluc3RhbmNlKSB7XG4gIHJldHVybiBtb2RlbEluc3RhbmNlLmlzTmV3UmVjb3JkIHx8IG1vZGVsSW5zdGFuY2UuZGF0YVZhbHVlc1tmaWVsZF0gPT09IG1vZGVsSW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1tmaWVsZF07XG59O1xuXG4vLyBleHRyYSB2YWxpZGF0b3JzXG52YWxpZGF0b3Iubm90TnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvYmxvYi82LjIuMC92YWxpZGF0b3IuanNcbl8uZm9yRWFjaChleHRlbnNpb25zLCAoZXh0ZW5kLCBrZXkpID0+IHtcbiAgdmFsaWRhdG9yW2tleV0gPSBleHRlbmQ7XG59KTtcblxuLy8gbWFwIGlzTnVsbCB0byBpc0VtcHR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9jb21taXQvZTMzZDM4YTI2ZWUyZjk2NjZiMzE5YWRiNjdjN2ZjMGQzZGVhNzEyNVxudmFsaWRhdG9yLmlzTnVsbCA9IHZhbGlkYXRvci5pc0VtcHR5O1xuXG4vLyBpc0RhdGUgcmVtb3ZlZCBpbiA3LjAuMFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvY29tbWl0LzA5NTUwOWZjNzA3YTRkYzBlOTlmODUxMzFkZjExNzZhZDYzODlmYzlcbnZhbGlkYXRvci5pc0RhdGUgPSBmdW5jdGlvbihkYXRlU3RyaW5nKSB7XG4gIC8vIGF2b2lkIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS9cbiAgLy8gYnkgZG9pbmcgYSBwcmVsaW1pbmFyeSBjaGVjayBvbiBgZGF0ZVN0cmluZ2BcbiAgY29uc3QgcGFyc2VkID0gRGF0ZS5wYXJzZShkYXRlU3RyaW5nKTtcbiAgaWYgKGlzTmFOKHBhcnNlZCkpIHtcbiAgICAvLyBmYWlsIGlmIHdlIGNhbid0IHBhcnNlIGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIG90aGVyd2lzZSBjb252ZXJ0IHRvIElTTyA4NjAxIGFzIG1vbWVudCBwcmVmZXJzXG4gIC8vIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nL1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUocGFyc2VkKTtcbiAgcmV0dXJuIG1vbWVudChkYXRlLnRvSVNPU3RyaW5nKCkpLmlzVmFsaWQoKTtcbn07XG5cbmV4cG9ydHMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuIiwiLyoqKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBHdXN0YXZvIEhlbmtlIGFuZCBBYXJvbiBUcmVudFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICoqKiovXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcbiAgICBpZiggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAgIGRlZmluZSggXCJUb3Bvc29ydFwiLCBbXCJleHBvcnRzXCIsIFwibW9kdWxlXCJdLCBmYWN0b3J5ICk7XG4gICAgfSBlbHNlIGlmKCB0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBmYWN0b3J5KCBleHBvcnRzLCBtb2R1bGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kID0ge1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgfTtcbiAgICAgICAgZmFjdG9yeSggbW9kLmV4cG9ydHMsIG1vZCApO1xuICAgICAgICBnbG9iYWwuVG9wb3NvcnQgPSBtb2QuZXhwb3J0cztcbiAgICB9XG59KSggdGhpcywgZnVuY3Rpb24oIGV4cG9ydHMsIG1vZHVsZSApIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayggaW5zdGFuY2UsIENvbnN0cnVjdG9yICkge1xuICAgICAgICBpZiggIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBUb3Bvc29ydCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gVG9wb3NvcnQoKSB7XG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2soIHRoaXMsIFRvcG9zb3J0ICk7XG5cbiAgICAgICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuVG9wb3NvcnQgPSBUb3Bvc29ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGRlcGVuZGVuY3kgZWRnZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzaW5jZSAgIDAuMS4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9IGl0ZW0gICAgICAgICAgICAgICBBbiBkZXBlbmRlbnQgbmFtZS4gTXVzdCBiZSBhbiBzdHJpbmcgYW5kIG5vdCBlbXB0eVxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nW118U3RyaW5nfSBbZGVwc10gICAgQW4gZGVwZW5kZW5jeSBvciBhcnJheSBvZiBkZXBlbmRlbmNpZXNcbiAgICAgICAgICogQHJldHVybnMge1RvcG9zb3J0fSAgICAgICAgICAgICAgICAgIFRoZSBUb3Bvc29ydCBpbnN0YW5jZVxuICAgICAgICAgKi9cblxuICAgICAgICBUb3Bvc29ydC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCBpdGVtLCBkZXBzICkge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiIHx8ICFpdGVtICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIFwiRGVwZW5kZW50IG5hbWUgbXVzdCBiZSBnaXZlbiBhcyBhIG5vdCBlbXB0eSBzdHJpbmdcIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXBzID0gQXJyYXkuaXNBcnJheSggZGVwcyApID8gZGVwcyA6IFtkZXBzXTtcblxuICAgICAgICAgICAgaWYoIGRlcHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBfaXRlcmF0b3IgPSBkZXBzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvciApLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2kuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXAgPSBfcmVmO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCB0eXBlb2YgZGVwICE9PSBcInN0cmluZ1wiIHx8ICFkZXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCBcIkRlcGVuZGVuY3kgbmFtZSBtdXN0IGJlIGdpdmVuIGFzIGEgbm90IGVtcHR5IHN0cmluZ1wiICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzLnB1c2goIFtpdGVtLCBkZXBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzLnB1c2goIFtpdGVtXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyB0aGUgdG9wb3NvcnRpbmcgYW5kIHJldHVybiBhbiBvcmRlcmVkIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHNpbmNlICAgMC4xLjBcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ1tdfSAgVGhlIGxpc3Qgb2YgaXRlbXMgdG9wb2xvZ2ljYWxseSBzb3J0ZWQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIFRvcG9zb3J0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgICAgICAgICAvL2FjY3VtdWxhdGUgdW5pcXVlIG5vZGVzIGludG8gYSBsYXJnZSBsaXN0XG4gICAgICAgICAgICBmb3IoIHZhciBfaXRlcmF0b3IyID0gdGhpcy5lZGdlcywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yMiApLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXkyICkge1xuICAgICAgICAgICAgICAgICAgICBpZiggX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIF9pMi5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfcmVmMjtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvcjMgPSBlZGdlLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3IzICksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXkzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTMuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfcmVmMztcblxuICAgICAgICAgICAgICAgICAgICBpZiggbm9kZXMuaW5kZXhPZiggbm9kZSApID09PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pbml0aWFsaXplIHRoZSBwbGFjZW1lbnQgb2Ygbm9kZXMgaW50byB0aGUgc29ydGVkIGFycmF5IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHZhciBwbGFjZSA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy9pbml0aWFsaXplIHRoZSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHVuaXF1ZSBub2RlcyBhcnJheVxuICAgICAgICAgICAgdmFyIHNvcnRlZCA9IG5ldyBBcnJheSggbm9kZXMubGVuZ3RoICk7XG5cbiAgICAgICAgICAgIC8vZGVmaW5lIGEgdmlzaXRvciBmdW5jdGlvbiB0aGF0IHJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiB2aXNpdCggbm9kZSwgcHJlZGVjZXNzb3JzICkge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgYSBub2RlIGlzIGRlcGVuZGVudCBvZiBpdHNlbGZcbiAgICAgICAgICAgICAgICBpZiggcHJlZGVjZXNzb3JzLmxlbmd0aCAhPT0gMCAmJiBwcmVkZWNlc3NvcnMuaW5kZXhPZiggbm9kZSApICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIkN5Y2xpYyBkZXBlbmRlbmN5IGZvdW5kLiBcIiArIG5vZGUgKyBcIiBpcyBkZXBlbmRlbnQgb2YgaXRzZWxmLlxcbkRlcGVuZGVuY3kgY2hhaW46IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBwcmVkZWNlc3NvcnMuam9pbiggXCIgLT4gXCIgKSArIFwiID0+IFwiICsgbm9kZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGVzLmluZGV4T2YoIG5vZGUgKTtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIG5vZGUgc3RpbGwgZXhpc3RzLCB0cmF2ZXJzZSBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgaWYoIGluZGV4ICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvL21hcmsgdGhlIG5vZGUgYXMgZmFsc2UgdG8gZXhjbHVkZSBpdCBmcm9tIGZ1dHVyZSBpdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4XSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIGFsbCBlZGdlcyBhbmQgZm9sbG93IGRlcGVuZGVuY2llcyBvZiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvcjQgPSBfdGhpcy5lZGdlcywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yNCApLCBfaTQgPSAwLCBfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pc0FycmF5NCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k0ID49IF9pdGVyYXRvcjQubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaXRlcmF0b3I0W19pNCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2k0ID0gX2l0ZXJhdG9yNC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pNC5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaTQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gX3JlZjQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBlZGdlWzBdID09PSBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGF6aWx5IGNyZWF0ZSBhIGNvcHkgb2YgcHJlZGVjZXNzb3JzIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBjb25jYXRlbmF0ZWQgb250byBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBjb3B5IHx8IHByZWRlY2Vzc29ycy5jb25jYXQoIFtub2RlXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWN1cnNlIHRvIG5vZGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXQoIGVkZ2VbMV0sIGNvcHkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBub2RlIHRvIHRoZSBuZXh0IHBsYWNlIGluIHRoZSBzb3J0ZWQgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkWy0tcGxhY2VdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgICAgICAgICAvL2lnbm9yZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBleGNsdWRlZFxuICAgICAgICAgICAgICAgIGlmKCBub2RlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9tYXJrIHRoZSBub2RlIGFzIGZhbHNlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBmdXR1cmUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIGFsbCBlZGdlcyBhbmQgZm9sbG93IGRlcGVuZGVuY2llcyBvZiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvcjUgPSB0aGlzLmVkZ2VzLCBfaXNBcnJheTUgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3I1ICksIF9pNSA9IDAsIF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I1W1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pc0FycmF5NSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k1ID49IF9pdGVyYXRvcjUubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3I1W19pNSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pNS5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjUgPSBfaTUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gX3JlZjU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBlZGdlWzBdID09PSBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVjdXJzZSB0byBub2RlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0KCBlZGdlWzFdLCBbbm9kZV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBub2RlIHRvIHRoZSBuZXh0IHBsYWNlIGluIHRoZSBzb3J0ZWQgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkWy0tcGxhY2VdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBlZGdlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAc2luY2UgICAwLjQuMFxuICAgICAgICAgKiBAcmV0dXJucyB7VG9wb3NvcnR9ICAgICAgICAgICAgICAgICAgVGhlIFRvcG9zb3J0IGluc3RhbmNlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFRvcG9zb3J0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVG9wb3NvcnQ7XG4gICAgfSkoKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9wb3NvcnQ7XG59ICk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoICcuL2J1aWxkL3RvcG9zb3J0LmpzJyApO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0ID0gZXhwb3J0cy5zZXF1ZWxpemUgPSB2b2lkIDA7XG52YXIgc2VxdWVsaXplX3R5cGVzY3JpcHRfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemUtdHlwZXNjcmlwdFwiKTtcbnZhciBpbml0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZV8xO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zZXF1ZWxpemUgPSBuZXcgc2VxdWVsaXplX3R5cGVzY3JpcHRfMS5TZXF1ZWxpemUoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbHM6IFtfX2Rpcm5hbWUgKyAnLy4uL2RhdGFiYXNlL21vZGVsLyoqLyoubW9kZWwudHMnXSxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHByb2Nlc3MuZW52LkRCX0hPU1QsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBwcm9jZXNzLmVudi5EQl9EQVRBQkFTRSxcbiAgICAgICAgICAgICAgICAgICAgZGlhbGVjdDogJ215c3FsJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb2Nlc3MuZW52LkRCX1VTRVJOQU1FLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuREJfUEFTU1dPUkRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGV4cG9ydHMuc2VxdWVsaXplLmF1dGhlbnRpY2F0ZSgpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHBvcnRzLnNlcXVlbGl6ZS5zeW5jKHsgYWx0ZXI6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRCIENvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGNvbm5lY3QgdG8gREJcIiwgZV8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VxdWVsaXplX3R5cGVzY3JpcHRfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemUtdHlwZXNjcmlwdFwiKTtcbnZhciBVc2VyX21vZGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vVXNlci5tb2RlbFwiKSk7XG52YXIgUGV0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGV0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc2VxdWVsaXplX3R5cGVzY3JpcHRfMS5Db2x1bW5cbiAgICBdLCBQZXQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc2VxdWVsaXplX3R5cGVzY3JpcHRfMS5EZWZhdWx0KFwiRG9nXCIpLFxuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkNvbHVtblxuICAgIF0sIFBldC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkZvcmVpZ25LZXkoZnVuY3Rpb24gKCkgeyByZXR1cm4gVXNlcl9tb2RlbF8xLmRlZmF1bHQ7IH0pLFxuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkNvbHVtblxuICAgIF0sIFBldC5wcm90b3R5cGUsIFwib3duZXJJZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkJlbG9uZ3NUbyhmdW5jdGlvbiAoKSB7IHJldHVybiBVc2VyX21vZGVsXzEuZGVmYXVsdDsgfSlcbiAgICBdLCBQZXQucHJvdG90eXBlLCBcIm93bmVyXCIsIHZvaWQgMCk7XG4gICAgUGV0ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEuVGFibGUoe1xuICAgICAgICAgICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogdHJ1ZVxuICAgICAgICB9KVxuICAgIF0sIFBldCk7XG4gICAgcmV0dXJuIFBldDtcbn0oc2VxdWVsaXplX3R5cGVzY3JpcHRfMS5Nb2RlbCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGV0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEgPSByZXF1aXJlKFwic2VxdWVsaXplLXR5cGVzY3JpcHRcIik7XG52YXIgUGV0X21vZGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGV0Lm1vZGVsXCIpKTtcbnZhciBVc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVXNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkNvbHVtblxuICAgIF0sIFVzZXIucHJvdG90eXBlLCBcImZpcnN0TmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLkNvbHVtblxuICAgIF0sIFVzZXIucHJvdG90eXBlLCBcImxhc3ROYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEuSGFzTWFueShmdW5jdGlvbiAoKSB7IHJldHVybiBQZXRfbW9kZWxfMS5kZWZhdWx0OyB9KVxuICAgIF0sIFVzZXIucHJvdG90eXBlLCBcInBldHNcIiwgdm9pZCAwKTtcbiAgICBVc2VyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEuVGFibGUoe1xuICAgICAgICAgICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogdHJ1ZVxuICAgICAgICB9KVxuICAgIF0sIFVzZXIpO1xuICAgIHJldHVybiBVc2VyO1xufShzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLk1vZGVsKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBVc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGV0X21vZGVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2RhdGFiYXNlL21vZGVsL1BldC5tb2RlbFwiKSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgVXNlcjoge1xuICAgICAgICBwZXRzOiBmdW5jdGlvbiAocGFyZW50LCBhcmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlFVRVJZIFBFVFNcIik7XG4gICAgICAgICAgICByZXR1cm4gUGV0X21vZGVsXzEuZGVmYXVsdC5maW5kQWxsKHsgd2hlcmU6IHsgb3duZXJJZDogcGFyZW50LmlkIH0gfSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBRdWVyeToge1xuICAgICAgICBwZXRzOiBmdW5jdGlvbiAocGFyZW50LCBhcmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlFVRVJZIFBFVFNcIik7XG4gICAgICAgICAgICByZXR1cm4gUGV0X21vZGVsXzEuZGVmYXVsdC5maW5kQWxsKHsgd2hlcmU6IHsgb3duZXJJZDogYXJncy5vd25lcklkIH0gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBldDogZnVuY3Rpb24gKHBhcmVudCwgYXJncywgY29udGV4dCwgaW5mbykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJRVUVSWSBQRVRcIik7XG4gICAgICAgICAgICByZXR1cm4gUGV0X21vZGVsXzEuZGVmYXVsdC5maW5kT25lKHsgd2hlcmU6IHsgb3duZXJJZDogYXJncy5vd25lcklkIH0gfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIE11dGF0aW9uOiB7XG4gICAgICAgIHBldDogZnVuY3Rpb24gKHBhcmVudCwgYXJncykge1xuICAgICAgICAgICAgdmFyIHBldCA9IHsgbmFtZTogYXJncy5uYW1lLCBvd25lcklkOiBhcmdzLm93bmVySWQsIHR5cGU6IGFyZ3MudHlwZSB9O1xuICAgICAgICAgICAgcmV0dXJuIFBldF9tb2RlbF8xLmRlZmF1bHQuY3JlYXRlKHBldCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVXNlcl9tb2RlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9kYXRhYmFzZS9tb2RlbC9Vc2VyLm1vZGVsXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBRdWVyeToge1xuICAgICAgICB1c2VyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJRVUVSWSBVU0VSU1wiKTtcbiAgICAgICAgICAgIHJldHVybiBVc2VyX21vZGVsXzEuZGVmYXVsdC5maW5kQWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6IGZ1bmN0aW9uIChwYXJlbnQsIGFyZ3MsIGNvbnRleHQsIGluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUVVFUlkgVVNFUlwiKTtcbiAgICAgICAgICAgIHJldHVybiBVc2VyX21vZGVsXzEuZGVmYXVsdC5maW5kT25lKHsgd2hlcmU6IHsgaWQ6IGFyZ3MuaWQgfSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgTXV0YXRpb246IHtcbiAgICAgICAgdXNlcjogZnVuY3Rpb24gKHBhcmVudCwgYXJncykge1xuICAgICAgICAgICAgdmFyIHVzZXIgPSB7IGZpcnN0TmFtZTogYXJncy5maXJzdE5hbWUsIGxhc3ROYW1lOiBhcmdzLmxhc3ROYW1lIH07XG4gICAgICAgICAgICByZXR1cm4gVXNlcl9tb2RlbF8xLmRlZmF1bHQuY3JlYXRlKHVzZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZGFzaF8xID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbnZhciBVc2VyX3Jlc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vVXNlci5yZXNvbHZlclwiKSk7XG52YXIgUGV0X3Jlc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGV0LnJlc29sdmVyXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvZGFzaF8xLm1lcmdlKFVzZXJfcmVzb2x2ZXJfMS5kZWZhdWx0LCBQZXRfcmVzb2x2ZXJfMS5kZWZhdWx0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcG9sbG9fc2VydmVyXzEgPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlclwiKTtcbnZhciBpbmRleF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3R5cGVEZWZzL2luZGV4XCIpKTtcbnZhciBpbmRleF8yID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc29sdmVycy9pbmRleFwiKSk7XG52YXIgc2VxdWFsaXplXzEgPSByZXF1aXJlKFwiLi9jb25maWdzL3NlcXVhbGl6ZVwiKTtcbnZhciBzZXJ2ZXIgPSBuZXcgYXBvbGxvX3NlcnZlcl8xLkFwb2xsb1NlcnZlcih7IHR5cGVEZWZzOiBpbmRleF8xLmRlZmF1bHQsIHJlc29sdmVyczogaW5kZXhfMi5kZWZhdWx0IH0pO1xuc2VydmVyLmxpc3RlbigpXG4gICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHVybCA9IF9hLnVybDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2ZXIgcmVhZHkgYXQgXCIgKyB1cmwgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgc2VxdWFsaXplXzEuaW5pdCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGV0ID0gdm9pZCAwO1xudmFyIGFwb2xsb19zZXJ2ZXJfMSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyXCIpO1xuZXhwb3J0cy5QZXQgPSBhcG9sbG9fc2VydmVyXzEuZ3FsKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgdHlwZSBQZXQge1xcbiAgICAgICAgaWQ6IElEIVxcbiAgICAgICAgbmFtZTogU3RyaW5nIVxcbiAgICAgICAgb3duZXJJZDogU3RyaW5nIVxcbiAgICAgICAgb3duZXI6IFVzZXJcXG4gICAgfVxcblxcbiAgICBleHRlbmQgdHlwZSBRdWVyeSB7XFxuICAgICAgICBwZXRzOiBbUGV0IV0hXFxuICAgICAgICBwZXQ6IFBldCFcXG4gICAgfVxcblxcbiAgICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XFxuICAgICAgICBwZXQobmFtZTogU3RyaW5nISwgdHlwZTogU3RyaW5nLCBvd25lcklkOiBTdHJpbmchKTogUGV0IVxcbiAgICB9XFxuXCJdLCBbXCJcXG4gICAgdHlwZSBQZXQge1xcbiAgICAgICAgaWQ6IElEIVxcbiAgICAgICAgbmFtZTogU3RyaW5nIVxcbiAgICAgICAgb3duZXJJZDogU3RyaW5nIVxcbiAgICAgICAgb3duZXI6IFVzZXJcXG4gICAgfVxcblxcbiAgICBleHRlbmQgdHlwZSBRdWVyeSB7XFxuICAgICAgICBwZXRzOiBbUGV0IV0hXFxuICAgICAgICBwZXQ6IFBldCFcXG4gICAgfVxcblxcbiAgICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XFxuICAgICAgICBwZXQobmFtZTogU3RyaW5nISwgdHlwZTogU3RyaW5nLCBvd25lcklkOiBTdHJpbmchKTogUGV0IVxcbiAgICB9XFxuXCJdKSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVzZXIgPSB2b2lkIDA7XG52YXIgYXBvbGxvX3NlcnZlcl8xID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXJcIik7XG5leHBvcnRzLlVzZXIgPSBhcG9sbG9fc2VydmVyXzEuZ3FsKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgdHlwZSBVc2VyIHtcXG4gICAgICAgIGlkOiBJRCFcXG4gICAgICAgIGZpcnN0TmFtZTogU3RyaW5nIVxcbiAgICAgICAgbGFzdE5hbWU6IFN0cmluZyFcXG4gICAgICAgIHBldHM6IFtQZXQhXSFcXG4gICAgfVxcblxcbiAgICBleHRlbmQgdHlwZSBRdWVyeSB7XFxuICAgICAgICB1c2VyczogW1VzZXIhXSFcXG4gICAgICAgIHVzZXIoaWQ6IElEISk6IFVzZXIhXFxuICAgIH1cXG5cXG4gICAgZXh0ZW5kIHR5cGUgTXV0YXRpb24ge1xcbiAgICAgICAgdXNlcihmaXJzdE5hbWU6IFN0cmluZyEsIGxhc3ROYW1lOiBTdHJpbmchKTogVXNlciFcXG4gICAgfVxcblwiXSwgW1wiXFxuICAgIHR5cGUgVXNlciB7XFxuICAgICAgICBpZDogSUQhXFxuICAgICAgICBmaXJzdE5hbWU6IFN0cmluZyFcXG4gICAgICAgIGxhc3ROYW1lOiBTdHJpbmchXFxuICAgICAgICBwZXRzOiBbUGV0IV0hXFxuICAgIH1cXG5cXG4gICAgZXh0ZW5kIHR5cGUgUXVlcnkge1xcbiAgICAgICAgdXNlcnM6IFtVc2VyIV0hXFxuICAgICAgICB1c2VyKGlkOiBJRCEpOiBVc2VyIVxcbiAgICB9XFxuXFxuICAgIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcXG4gICAgICAgIHVzZXIoZmlyc3ROYW1lOiBTdHJpbmchLCBsYXN0TmFtZTogU3RyaW5nISk6IFVzZXIhXFxuICAgIH1cXG5cIl0pKSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcG9sbG9fc2VydmVyXzEgPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlclwiKTtcbnZhciBVc2VyXzEgPSByZXF1aXJlKFwiLi9Vc2VyXCIpO1xudmFyIFBldF90eXBlXzEgPSByZXF1aXJlKFwiLi9QZXQudHlwZVwiKTtcbnZhciBiYXNlVHlwZURlZnMgPSBhcG9sbG9fc2VydmVyXzEuZ3FsKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgdHlwZSBRdWVyeVxcbiAgICB0eXBlIE11dGF0aW9uXFxuXCJdLCBbXCJcXG4gICAgdHlwZSBRdWVyeVxcbiAgICB0eXBlIE11dGF0aW9uXFxuXCJdKSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gW2Jhc2VUeXBlRGVmcywgVXNlcl8xLlVzZXIsIFBldF90eXBlXzEuUGV0XTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdG9EYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9EYXRlXCIpKTtcblxudmFyIF90b0Zsb2F0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9GbG9hdFwiKSk7XG5cbnZhciBfdG9JbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90b0ludFwiKSk7XG5cbnZhciBfdG9Cb29sZWFuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9Cb29sZWFuXCIpKTtcblxudmFyIF9lcXVhbHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9lcXVhbHNcIikpO1xuXG52YXIgX2NvbnRhaW5zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvY29udGFpbnNcIikpO1xuXG52YXIgX21hdGNoZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9tYXRjaGVzXCIpKTtcblxudmFyIF9pc0VtYWlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNFbWFpbFwiKSk7XG5cbnZhciBfaXNVUkwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1VSTFwiKSk7XG5cbnZhciBfaXNNQUNBZGRyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNQUNBZGRyZXNzXCIpKTtcblxudmFyIF9pc0lQID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJUFwiKSk7XG5cbnZhciBfaXNJUFJhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJUFJhbmdlXCIpKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0ZRRE5cIikpO1xuXG52YXIgX2lzQm9vbGVhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQm9vbGVhblwiKSk7XG5cbnZhciBfaXNBbHBoYSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0FscGhhXCIpKTtcblxudmFyIF9pc0FscGhhbnVtZXJpYyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0FscGhhbnVtZXJpY1wiKSk7XG5cbnZhciBfaXNOdW1lcmljID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNOdW1lcmljXCIpKTtcblxudmFyIF9pc1BvcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1BvcnRcIikpO1xuXG52YXIgX2lzTG93ZXJjYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMb3dlcmNhc2VcIikpO1xuXG52YXIgX2lzVXBwZXJjYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNVcHBlcmNhc2VcIikpO1xuXG52YXIgX2lzQXNjaWkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0FzY2lpXCIpKTtcblxudmFyIF9pc0Z1bGxXaWR0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRnVsbFdpZHRoXCIpKTtcblxudmFyIF9pc0hhbGZXaWR0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSGFsZldpZHRoXCIpKTtcblxudmFyIF9pc1ZhcmlhYmxlV2lkdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1ZhcmlhYmxlV2lkdGhcIikpO1xuXG52YXIgX2lzTXVsdGlieXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNdWx0aWJ5dGVcIikpO1xuXG52YXIgX2lzU3Vycm9nYXRlUGFpciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzU3Vycm9nYXRlUGFpclwiKSk7XG5cbnZhciBfaXNJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0ludFwiKSk7XG5cbnZhciBfaXNGbG9hdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0Zsb2F0XCIpKTtcblxudmFyIF9pc0RlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0RlY2ltYWxcIikpO1xuXG52YXIgX2lzSGV4YWRlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hleGFkZWNpbWFsXCIpKTtcblxudmFyIF9pc0RpdmlzaWJsZUJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNEaXZpc2libGVCeVwiKSk7XG5cbnZhciBfaXNIZXhDb2xvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSGV4Q29sb3JcIikpO1xuXG52YXIgX2lzSVNSQyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNSQ1wiKSk7XG5cbnZhciBfaXNNRCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTUQ1XCIpKTtcblxudmFyIF9pc0hhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hhc2hcIikpO1xuXG52YXIgX2lzSldUID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNKV1RcIikpO1xuXG52YXIgX2lzSlNPTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSlNPTlwiKSk7XG5cbnZhciBfaXNFbXB0eSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRW1wdHlcIikpO1xuXG52YXIgX2lzTGVuZ3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMZW5ndGhcIikpO1xuXG52YXIgX2lzQnl0ZUxlbmd0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQnl0ZUxlbmd0aFwiKSk7XG5cbnZhciBfaXNVVUlEID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNVVUlEXCIpKTtcblxudmFyIF9pc01vbmdvSWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc01vbmdvSWRcIikpO1xuXG52YXIgX2lzQWZ0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0FmdGVyXCIpKTtcblxudmFyIF9pc0JlZm9yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQmVmb3JlXCIpKTtcblxudmFyIF9pc0luID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJblwiKSk7XG5cbnZhciBfaXNDcmVkaXRDYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNDcmVkaXRDYXJkXCIpKTtcblxudmFyIF9pc0lkZW50aXR5Q2FyZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSWRlbnRpdHlDYXJkXCIpKTtcblxudmFyIF9pc0lTSU4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTSU5cIikpO1xuXG52YXIgX2lzSVNCTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNCTlwiKSk7XG5cbnZhciBfaXNJU1NOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJU1NOXCIpKTtcblxudmFyIF9pc01vYmlsZVBob25lID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbGliL2lzTW9iaWxlUGhvbmVcIikpO1xuXG52YXIgX2lzQ3VycmVuY3kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0N1cnJlbmN5XCIpKTtcblxudmFyIF9pc0lTTyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNPODYwMVwiKSk7XG5cbnZhciBfaXNSRkMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1JGQzMzMzlcIikpO1xuXG52YXIgX2lzSVNPMzE2NjFBbHBoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNPMzE2NjFBbHBoYTJcIikpO1xuXG52YXIgX2lzSVNPMzE2NjFBbHBoYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTTzMxNjYxQWxwaGEzXCIpKTtcblxudmFyIF9pc0Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0Jhc2U2NFwiKSk7XG5cbnZhciBfaXNEYXRhVVJJID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNEYXRhVVJJXCIpKTtcblxudmFyIF9pc01hZ25ldFVSSSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTWFnbmV0VVJJXCIpKTtcblxudmFyIF9pc01pbWVUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNaW1lVHlwZVwiKSk7XG5cbnZhciBfaXNMYXRMb25nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMYXRMb25nXCIpKTtcblxudmFyIF9pc1Bvc3RhbENvZGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvaXNQb3N0YWxDb2RlXCIpKTtcblxudmFyIF9sdHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2x0cmltXCIpKTtcblxudmFyIF9ydHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3J0cmltXCIpKTtcblxudmFyIF90cmltID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdHJpbVwiKSk7XG5cbnZhciBfZXNjYXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvZXNjYXBlXCIpKTtcblxudmFyIF91bmVzY2FwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3VuZXNjYXBlXCIpKTtcblxudmFyIF9zdHJpcExvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3N0cmlwTG93XCIpKTtcblxudmFyIF93aGl0ZWxpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93aGl0ZWxpc3RcIikpO1xuXG52YXIgX2JsYWNrbGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2JsYWNrbGlzdFwiKSk7XG5cbnZhciBfaXNXaGl0ZWxpc3RlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzV2hpdGVsaXN0ZWRcIikpO1xuXG52YXIgX25vcm1hbGl6ZUVtYWlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvbm9ybWFsaXplRW1haWxcIikpO1xuXG52YXIgX3RvU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdXRpbC90b1N0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZlcnNpb24gPSAnMTAuMTEuMCc7XG52YXIgdmFsaWRhdG9yID0ge1xuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB0b0RhdGU6IF90b0RhdGUuZGVmYXVsdCxcbiAgdG9GbG9hdDogX3RvRmxvYXQuZGVmYXVsdCxcbiAgdG9JbnQ6IF90b0ludC5kZWZhdWx0LFxuICB0b0Jvb2xlYW46IF90b0Jvb2xlYW4uZGVmYXVsdCxcbiAgZXF1YWxzOiBfZXF1YWxzLmRlZmF1bHQsXG4gIGNvbnRhaW5zOiBfY29udGFpbnMuZGVmYXVsdCxcbiAgbWF0Y2hlczogX21hdGNoZXMuZGVmYXVsdCxcbiAgaXNFbWFpbDogX2lzRW1haWwuZGVmYXVsdCxcbiAgaXNVUkw6IF9pc1VSTC5kZWZhdWx0LFxuICBpc01BQ0FkZHJlc3M6IF9pc01BQ0FkZHJlc3MuZGVmYXVsdCxcbiAgaXNJUDogX2lzSVAuZGVmYXVsdCxcbiAgaXNJUFJhbmdlOiBfaXNJUFJhbmdlLmRlZmF1bHQsXG4gIGlzRlFETjogX2lzRlFETi5kZWZhdWx0LFxuICBpc0Jvb2xlYW46IF9pc0Jvb2xlYW4uZGVmYXVsdCxcbiAgaXNBbHBoYTogX2lzQWxwaGEuZGVmYXVsdCxcbiAgaXNBbHBoYUxvY2FsZXM6IF9pc0FscGhhLmxvY2FsZXMsXG4gIGlzQWxwaGFudW1lcmljOiBfaXNBbHBoYW51bWVyaWMuZGVmYXVsdCxcbiAgaXNBbHBoYW51bWVyaWNMb2NhbGVzOiBfaXNBbHBoYW51bWVyaWMubG9jYWxlcyxcbiAgaXNOdW1lcmljOiBfaXNOdW1lcmljLmRlZmF1bHQsXG4gIGlzUG9ydDogX2lzUG9ydC5kZWZhdWx0LFxuICBpc0xvd2VyY2FzZTogX2lzTG93ZXJjYXNlLmRlZmF1bHQsXG4gIGlzVXBwZXJjYXNlOiBfaXNVcHBlcmNhc2UuZGVmYXVsdCxcbiAgaXNBc2NpaTogX2lzQXNjaWkuZGVmYXVsdCxcbiAgaXNGdWxsV2lkdGg6IF9pc0Z1bGxXaWR0aC5kZWZhdWx0LFxuICBpc0hhbGZXaWR0aDogX2lzSGFsZldpZHRoLmRlZmF1bHQsXG4gIGlzVmFyaWFibGVXaWR0aDogX2lzVmFyaWFibGVXaWR0aC5kZWZhdWx0LFxuICBpc011bHRpYnl0ZTogX2lzTXVsdGlieXRlLmRlZmF1bHQsXG4gIGlzU3Vycm9nYXRlUGFpcjogX2lzU3Vycm9nYXRlUGFpci5kZWZhdWx0LFxuICBpc0ludDogX2lzSW50LmRlZmF1bHQsXG4gIGlzRmxvYXQ6IF9pc0Zsb2F0LmRlZmF1bHQsXG4gIGlzRmxvYXRMb2NhbGVzOiBfaXNGbG9hdC5sb2NhbGVzLFxuICBpc0RlY2ltYWw6IF9pc0RlY2ltYWwuZGVmYXVsdCxcbiAgaXNIZXhhZGVjaW1hbDogX2lzSGV4YWRlY2ltYWwuZGVmYXVsdCxcbiAgaXNEaXZpc2libGVCeTogX2lzRGl2aXNpYmxlQnkuZGVmYXVsdCxcbiAgaXNIZXhDb2xvcjogX2lzSGV4Q29sb3IuZGVmYXVsdCxcbiAgaXNJU1JDOiBfaXNJU1JDLmRlZmF1bHQsXG4gIGlzTUQ1OiBfaXNNRC5kZWZhdWx0LFxuICBpc0hhc2g6IF9pc0hhc2guZGVmYXVsdCxcbiAgaXNKV1Q6IF9pc0pXVC5kZWZhdWx0LFxuICBpc0pTT046IF9pc0pTT04uZGVmYXVsdCxcbiAgaXNFbXB0eTogX2lzRW1wdHkuZGVmYXVsdCxcbiAgaXNMZW5ndGg6IF9pc0xlbmd0aC5kZWZhdWx0LFxuICBpc0J5dGVMZW5ndGg6IF9pc0J5dGVMZW5ndGguZGVmYXVsdCxcbiAgaXNVVUlEOiBfaXNVVUlELmRlZmF1bHQsXG4gIGlzTW9uZ29JZDogX2lzTW9uZ29JZC5kZWZhdWx0LFxuICBpc0FmdGVyOiBfaXNBZnRlci5kZWZhdWx0LFxuICBpc0JlZm9yZTogX2lzQmVmb3JlLmRlZmF1bHQsXG4gIGlzSW46IF9pc0luLmRlZmF1bHQsXG4gIGlzQ3JlZGl0Q2FyZDogX2lzQ3JlZGl0Q2FyZC5kZWZhdWx0LFxuICBpc0lkZW50aXR5Q2FyZDogX2lzSWRlbnRpdHlDYXJkLmRlZmF1bHQsXG4gIGlzSVNJTjogX2lzSVNJTi5kZWZhdWx0LFxuICBpc0lTQk46IF9pc0lTQk4uZGVmYXVsdCxcbiAgaXNJU1NOOiBfaXNJU1NOLmRlZmF1bHQsXG4gIGlzTW9iaWxlUGhvbmU6IF9pc01vYmlsZVBob25lLmRlZmF1bHQsXG4gIGlzTW9iaWxlUGhvbmVMb2NhbGVzOiBfaXNNb2JpbGVQaG9uZS5sb2NhbGVzLFxuICBpc1Bvc3RhbENvZGU6IF9pc1Bvc3RhbENvZGUuZGVmYXVsdCxcbiAgaXNQb3N0YWxDb2RlTG9jYWxlczogX2lzUG9zdGFsQ29kZS5sb2NhbGVzLFxuICBpc0N1cnJlbmN5OiBfaXNDdXJyZW5jeS5kZWZhdWx0LFxuICBpc0lTTzg2MDE6IF9pc0lTTy5kZWZhdWx0LFxuICBpc1JGQzMzMzk6IF9pc1JGQy5kZWZhdWx0LFxuICBpc0lTTzMxNjYxQWxwaGEyOiBfaXNJU08zMTY2MUFscGhhLmRlZmF1bHQsXG4gIGlzSVNPMzE2NjFBbHBoYTM6IF9pc0lTTzMxNjYxQWxwaGEyLmRlZmF1bHQsXG4gIGlzQmFzZTY0OiBfaXNCYXNlLmRlZmF1bHQsXG4gIGlzRGF0YVVSSTogX2lzRGF0YVVSSS5kZWZhdWx0LFxuICBpc01hZ25ldFVSSTogX2lzTWFnbmV0VVJJLmRlZmF1bHQsXG4gIGlzTWltZVR5cGU6IF9pc01pbWVUeXBlLmRlZmF1bHQsXG4gIGlzTGF0TG9uZzogX2lzTGF0TG9uZy5kZWZhdWx0LFxuICBsdHJpbTogX2x0cmltLmRlZmF1bHQsXG4gIHJ0cmltOiBfcnRyaW0uZGVmYXVsdCxcbiAgdHJpbTogX3RyaW0uZGVmYXVsdCxcbiAgZXNjYXBlOiBfZXNjYXBlLmRlZmF1bHQsXG4gIHVuZXNjYXBlOiBfdW5lc2NhcGUuZGVmYXVsdCxcbiAgc3RyaXBMb3c6IF9zdHJpcExvdy5kZWZhdWx0LFxuICB3aGl0ZWxpc3Q6IF93aGl0ZWxpc3QuZGVmYXVsdCxcbiAgYmxhY2tsaXN0OiBfYmxhY2tsaXN0LmRlZmF1bHQsXG4gIGlzV2hpdGVsaXN0ZWQ6IF9pc1doaXRlbGlzdGVkLmRlZmF1bHQsXG4gIG5vcm1hbGl6ZUVtYWlsOiBfbm9ybWFsaXplRW1haWwuZGVmYXVsdCxcbiAgdG9TdHJpbmc6IF90b1N0cmluZy5kZWZhdWx0XG59O1xudmFyIF9kZWZhdWx0ID0gdmFsaWRhdG9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbW1hRGVjaW1hbCA9IGV4cG9ydHMuZG90RGVjaW1hbCA9IGV4cG9ydHMuYXJhYmljTG9jYWxlcyA9IGV4cG9ydHMuZW5nbGlzaExvY2FsZXMgPSBleHBvcnRzLmRlY2ltYWwgPSBleHBvcnRzLmFscGhhbnVtZXJpYyA9IGV4cG9ydHMuYWxwaGEgPSB2b2lkIDA7XG52YXIgYWxwaGEgPSB7XG4gICdlbi1VUyc6IC9eW0EtWl0rJC9pLFxuICAnYmctQkcnOiAvXlvQkC3Qr10rJC9pLFxuICAnY3MtQ1onOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKyQvaSxcbiAgJ2RhLURLJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdkZS1ERSc6IC9eW0EtWsOEw5bDnMOfXSskL2ksXG4gICdlbC1HUic6IC9eW86RLc+JXSskL2ksXG4gICdlcy1FUyc6IC9eW0EtWsOBw4nDjcORw5PDmsOcXSskL2ksXG4gICdmci1GUic6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSskL2ksXG4gICdpdC1JVCc6IC9eW0EtWsOAw4nDiMOMw47Dk8OSw5ldKyQvaSxcbiAgJ25iLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdubC1OTCc6IC9eW0EtWsOBw4nDi8OPw5PDlsOcw5pdKyQvaSxcbiAgJ25uLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdodS1IVSc6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAncGwtUEwnOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xbldKyQvaSxcbiAgJ3B0LVBUJzogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKyQvaSxcbiAgJ3J1LVJVJzogL15b0JAt0K/QgV0rJC9pLFxuICAnc2wtU0knOiAvXltBLVrEjMSGxJDFoMW9XSskL2ksXG4gICdzay1TSyc6IC9eW0EtWsOBxIzEjsOJw43Fh8OTxaDFpMOaw53FvcS5xZTEvcOEw5RdKyQvaSxcbiAgJ3NyLVJTQGxhdGluJzogL15bQS1axIzEhsW9xaDEkF0rJC9pLFxuICAnc3ItUlMnOiAvXlvQkC3Qr9CC0IjQidCK0IvQj10rJC9pLFxuICAnc3YtU0UnOiAvXltBLVrDhcOEw5ZdKyQvaSxcbiAgJ3RyLVRSJzogL15bQS1aw4fEnsSwxLHDlsWew5xdKyQvaSxcbiAgJ3VrLVVBJzogL15b0JAt0KnQrNCu0K/QhEnQh9KQ0ZZdKyQvaSxcbiAgJ2t1LUlRJzogL15b2KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0rJC9cbn07XG5leHBvcnRzLmFscGhhID0gYWxwaGE7XG52YXIgYWxwaGFudW1lcmljID0ge1xuICAnZW4tVVMnOiAvXlswLTlBLVpdKyQvaSxcbiAgJ2JnLUJHJzogL15bMC050JAt0K9dKyQvaSxcbiAgJ2NzLUNaJzogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSskL2ksXG4gICdkYS1ESyc6IC9eWzAtOUEtWsOGw5jDhV0rJC9pLFxuICAnZGUtREUnOiAvXlswLTlBLVrDhMOWw5zDn10rJC9pLFxuICAnZWwtR1InOiAvXlswLTnOkS3PiV0rJC9pLFxuICAnZXMtRVMnOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF0rJC9pLFxuICAnZnItRlInOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0rJC9pLFxuICAnaXQtSVQnOiAvXlswLTlBLVrDgMOJw4jDjMOOw5PDksOZXSskL2ksXG4gICdodS1IVSc6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAnbmItTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ25sLU5MJzogL15bMC05QS1aw4HDicOLw4/Dk8OWw5zDml0rJC9pLFxuICAnbm4tTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ3BsLVBMJzogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSskL2ksXG4gICdwdC1QVCc6IC9eWzAtOUEtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSskL2ksXG4gICdydS1SVSc6IC9eWzAtOdCQLdCv0IFdKyQvaSxcbiAgJ3NsLVNJJzogL15bMC05QS1axIzEhsSQxaDFvV0rJC9pLFxuICAnc2stU0snOiAvXlswLTlBLVrDgcSMxI7DicONxYfDk8WgxaTDmsOdxb3EucWUxL3DhMOUXSskL2ksXG4gICdzci1SU0BsYXRpbic6IC9eWzAtOUEtWsSMxIbFvcWgxJBdKyQvaSxcbiAgJ3NyLVJTJzogL15bMC050JAt0K/QgtCI0InQitCL0I9dKyQvaSxcbiAgJ3N2LVNFJzogL15bMC05QS1aw4XDhMOWXSskL2ksXG4gICd0ci1UUic6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSskL2ksXG4gICd1ay1VQSc6IC9eWzAtOdCQLdCp0KzQrtCv0IRJ0IfSkNGWXSskL2ksXG4gICdrdS1JUSc6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSskL1xufTtcbmV4cG9ydHMuYWxwaGFudW1lcmljID0gYWxwaGFudW1lcmljO1xudmFyIGRlY2ltYWwgPSB7XG4gICdlbi1VUyc6ICcuJyxcbiAgYXI6ICfZqydcbn07XG5leHBvcnRzLmRlY2ltYWwgPSBkZWNpbWFsO1xudmFyIGVuZ2xpc2hMb2NhbGVzID0gWydBVScsICdHQicsICdISycsICdJTicsICdOWicsICdaQScsICdaTSddO1xuZXhwb3J0cy5lbmdsaXNoTG9jYWxlcyA9IGVuZ2xpc2hMb2NhbGVzO1xuXG5mb3IgKHZhciBsb2NhbGUsIGkgPSAwOyBpIDwgZW5nbGlzaExvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgbG9jYWxlID0gXCJlbi1cIi5jb25jYXQoZW5nbGlzaExvY2FsZXNbaV0pO1xuICBhbHBoYVtsb2NhbGVdID0gYWxwaGFbJ2VuLVVTJ107XG4gIGFscGhhbnVtZXJpY1tsb2NhbGVdID0gYWxwaGFudW1lcmljWydlbi1VUyddO1xuICBkZWNpbWFsW2xvY2FsZV0gPSBkZWNpbWFsWydlbi1VUyddO1xufSAvLyBTb3VyY2U6IGh0dHA6Ly93d3cubG9jYWxlcGxhbmV0LmNvbS9qYXZhL1xuXG5cbnZhciBhcmFiaWNMb2NhbGVzID0gWydBRScsICdCSCcsICdEWicsICdFRycsICdJUScsICdKTycsICdLVycsICdMQicsICdMWScsICdNQScsICdRTScsICdRQScsICdTQScsICdTRCcsICdTWScsICdUTicsICdZRSddO1xuZXhwb3J0cy5hcmFiaWNMb2NhbGVzID0gYXJhYmljTG9jYWxlcztcblxuZm9yICh2YXIgX2xvY2FsZSwgX2kgPSAwOyBfaSA8IGFyYWJpY0xvY2FsZXMubGVuZ3RoOyBfaSsrKSB7XG4gIF9sb2NhbGUgPSBcImFyLVwiLmNvbmNhdChhcmFiaWNMb2NhbGVzW19pXSk7XG4gIGFscGhhW19sb2NhbGVdID0gYWxwaGEuYXI7XG4gIGFscGhhbnVtZXJpY1tfbG9jYWxlXSA9IGFscGhhbnVtZXJpYy5hcjtcbiAgZGVjaW1hbFtfbG9jYWxlXSA9IGRlY2ltYWwuYXI7XG59IC8vIFNvdXJjZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVjaW1hbF9tYXJrXG5cblxudmFyIGRvdERlY2ltYWwgPSBbXTtcbmV4cG9ydHMuZG90RGVjaW1hbCA9IGRvdERlY2ltYWw7XG52YXIgY29tbWFEZWNpbWFsID0gWydiZy1CRycsICdjcy1DWicsICdkYS1ESycsICdkZS1ERScsICdlbC1HUicsICdlcy1FUycsICdmci1GUicsICdpdC1JVCcsICdrdS1JUScsICdodS1IVScsICduYi1OTycsICdubi1OTycsICdubC1OTCcsICdwbC1QTCcsICdwdC1QVCcsICdydS1SVScsICdzbC1TSScsICdzci1SU0BsYXRpbicsICdzci1SUycsICdzdi1TRScsICd0ci1UUicsICd1ay1VQSddO1xuZXhwb3J0cy5jb21tYURlY2ltYWwgPSBjb21tYURlY2ltYWw7XG5cbmZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGRvdERlY2ltYWwubGVuZ3RoOyBfaTIrKykge1xuICBkZWNpbWFsW2RvdERlY2ltYWxbX2kyXV0gPSBkZWNpbWFsWydlbi1VUyddO1xufVxuXG5mb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjb21tYURlY2ltYWwubGVuZ3RoOyBfaTMrKykge1xuICBkZWNpbWFsW2NvbW1hRGVjaW1hbFtfaTNdXSA9ICcsJztcbn1cblxuYWxwaGFbJ3B0LUJSJ10gPSBhbHBoYVsncHQtUFQnXTtcbmFscGhhbnVtZXJpY1sncHQtQlInXSA9IGFscGhhbnVtZXJpY1sncHQtUFQnXTtcbmRlY2ltYWxbJ3B0LUJSJ10gPSBkZWNpbWFsWydwdC1QVCddOyAvLyBzZWUgIzg2MlxuXG5hbHBoYVsncGwtUGwnXSA9IGFscGhhWydwbC1QTCddO1xuYWxwaGFudW1lcmljWydwbC1QbCddID0gYWxwaGFudW1lcmljWydwbC1QTCddO1xuZGVjaW1hbFsncGwtUGwnXSA9IGRlY2ltYWxbJ3BsLVBMJ107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBibGFja2xpc3Q7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJsYWNrbGlzdChzdHIsIGNoYXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiW1wiLmNvbmNhdChjaGFycywgXCJdK1wiKSwgJ2cnKSwgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb250YWlucztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF90b1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC90b1N0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoKDAsIF90b1N0cmluZy5kZWZhdWx0KShlbGVtKSkgPj0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWxzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlcXVhbHMoc3RyLCBjb21wYXJpc29uKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIgPT09IGNvbXBhcmlzb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVzY2FwZTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjeDI3OycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFwvL2csICcmI3gyRjsnKS5yZXBsYWNlKC9cXFxcL2csICcmI3g1QzsnKS5yZXBsYWNlKC9gL2csICcmIzk2OycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FmdGVyO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvRGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9EYXRlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBZnRlcihzdHIpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFN0cmluZyhuZXcgRGF0ZSgpKTtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNvbXBhcmlzb24gPSAoMCwgX3RvRGF0ZS5kZWZhdWx0KShkYXRlKTtcbiAgdmFyIG9yaWdpbmFsID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICEhKG9yaWdpbmFsICYmIGNvbXBhcmlzb24gJiYgb3JpZ2luYWwgPiBjb21wYXJpc29uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYTtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9hbHBoYSA9IHJlcXVpcmUoXCIuL2FscGhhXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FscGhhKHN0cikge1xuICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZW4tVVMnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gX2FscGhhLmFscGhhKSB7XG4gICAgcmV0dXJuIF9hbHBoYS5hbHBoYVtsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKF9hbHBoYS5hbHBoYSk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYW51bWVyaWM7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBbHBoYW51bWVyaWMoc3RyKSB7XG4gIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdlbi1VUyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBfYWxwaGEuYWxwaGFudW1lcmljKSB7XG4gICAgcmV0dXJuIF9hbHBoYS5hbHBoYW51bWVyaWNbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhfYWxwaGEuYWxwaGFudW1lcmljKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FzY2lpO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgYXNjaWkgPSAvXltcXHgwMC1cXHg3Rl0rJC87XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNBc2NpaShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGFzY2lpLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCYXNlNjQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBub3RCYXNlNjQgPSAvW15BLVowLTkrXFwvPV0vaTtcblxuZnVuY3Rpb24gaXNCYXNlNjQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGlmICghbGVuIHx8IGxlbiAlIDQgIT09IDAgfHwgbm90QmFzZTY0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmaXJzdFBhZGRpbmdDaGFyID0gc3RyLmluZGV4T2YoJz0nKTtcbiAgcmV0dXJuIGZpcnN0UGFkZGluZ0NoYXIgPT09IC0xIHx8IGZpcnN0UGFkZGluZ0NoYXIgPT09IGxlbiAtIDEgfHwgZmlyc3RQYWRkaW5nQ2hhciA9PT0gbGVuIC0gMiAmJiBzdHJbbGVuIC0gMV0gPT09ICc9Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCZWZvcmU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfdG9EYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90b0RhdGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0JlZm9yZShzdHIpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFN0cmluZyhuZXcgRGF0ZSgpKTtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNvbXBhcmlzb24gPSAoMCwgX3RvRGF0ZS5kZWZhdWx0KShkYXRlKTtcbiAgdmFyIG9yaWdpbmFsID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICEhKG9yaWdpbmFsICYmIGNvbXBhcmlzb24gJiYgb3JpZ2luYWwgPCBjb21wYXJpc29uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCb29sZWFuO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBbJ3RydWUnLCAnZmFsc2UnLCAnMScsICcwJ10uaW5kZXhPZihzdHIpID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnl0ZUxlbmd0aDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5mdW5jdGlvbiBpc0J5dGVMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNCeXRlTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXG4gICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQ3JlZGl0Q2FyZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIGNyZWRpdENhcmQgPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoMjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfXw2WzI3XVswLTldezE0fSkkLztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBpc0NyZWRpdENhcmQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvWy0gXSsvZywgJycpO1xuXG4gIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGRpZ2l0O1xuICB2YXIgdG1wTnVtO1xuICB2YXIgc2hvdWxkRG91YmxlO1xuXG4gIGZvciAodmFyIGkgPSBzYW5pdGl6ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkaWdpdCA9IHNhbml0aXplZC5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcblxuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICUgMTAgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IHRtcE51bTtcbiAgICB9XG5cbiAgICBzaG91bGREb3VibGUgPSAhc2hvdWxkRG91YmxlO1xuICB9XG5cbiAgcmV0dXJuICEhKHN1bSAlIDEwID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0N1cnJlbmN5O1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3VycmVuY3lSZWdleChvcHRpb25zKSB7XG4gIHZhciBkZWNpbWFsX2RpZ2l0cyA9IFwiXFxcXGR7XCIuY29uY2F0KG9wdGlvbnMuZGlnaXRzX2FmdGVyX2RlY2ltYWxbMF0sIFwifVwiKTtcbiAgb3B0aW9ucy5kaWdpdHNfYWZ0ZXJfZGVjaW1hbC5mb3JFYWNoKGZ1bmN0aW9uIChkaWdpdCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggIT09IDApIGRlY2ltYWxfZGlnaXRzID0gXCJcIi5jb25jYXQoZGVjaW1hbF9kaWdpdHMsIFwifFxcXFxke1wiKS5jb25jYXQoZGlnaXQsIFwifVwiKTtcbiAgfSk7XG4gIHZhciBzeW1ib2wgPSBcIihcXFxcXCIuY29uY2F0KG9wdGlvbnMuc3ltYm9sLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKSwgXCIpXCIpLmNvbmNhdChvcHRpb25zLnJlcXVpcmVfc3ltYm9sID8gJycgOiAnPycpLFxuICAgICAgbmVnYXRpdmUgPSAnLT8nLFxuICAgICAgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRob3V0X3NlcCA9ICdbMS05XVxcXFxkKicsXG4gICAgICB3aG9sZV9kb2xsYXJfYW1vdW50X3dpdGhfc2VwID0gXCJbMS05XVxcXFxkezAsMn0oXFxcXFwiLmNvbmNhdChvcHRpb25zLnRob3VzYW5kc19zZXBhcmF0b3IsIFwiXFxcXGR7M30pKlwiKSxcbiAgICAgIHZhbGlkX3dob2xlX2RvbGxhcl9hbW91bnRzID0gWycwJywgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRob3V0X3NlcCwgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRoX3NlcF0sXG4gICAgICB3aG9sZV9kb2xsYXJfYW1vdW50ID0gXCIoXCIuY29uY2F0KHZhbGlkX3dob2xlX2RvbGxhcl9hbW91bnRzLmpvaW4oJ3wnKSwgXCIpP1wiKSxcbiAgICAgIGRlY2ltYWxfYW1vdW50ID0gXCIoXFxcXFwiLmNvbmNhdChvcHRpb25zLmRlY2ltYWxfc2VwYXJhdG9yLCBcIihcIikuY29uY2F0KGRlY2ltYWxfZGlnaXRzLCBcIikpXCIpLmNvbmNhdChvcHRpb25zLnJlcXVpcmVfZGVjaW1hbCA/ICcnIDogJz8nKTtcbiAgdmFyIHBhdHRlcm4gPSB3aG9sZV9kb2xsYXJfYW1vdW50ICsgKG9wdGlvbnMuYWxsb3dfZGVjaW1hbCB8fCBvcHRpb25zLnJlcXVpcmVfZGVjaW1hbCA/IGRlY2ltYWxfYW1vdW50IDogJycpOyAvLyBkZWZhdWx0IGlzIG5lZ2F0aXZlIHNpZ24gYmVmb3JlIHN5bWJvbCwgYnV0IHRoZXJlIGFyZSB0d28gb3RoZXIgb3B0aW9ucyAoYmVzaWRlcyBwYXJlbnMpXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfbmVnYXRpdmVzICYmICFvcHRpb25zLnBhcmVuc19mb3JfbmVnYXRpdmVzKSB7XG4gICAgaWYgKG9wdGlvbnMubmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHMpIHtcbiAgICAgIHBhdHRlcm4gKz0gbmVnYXRpdmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5lZ2F0aXZlX3NpZ25fYmVmb3JlX2RpZ2l0cykge1xuICAgICAgcGF0dGVybiA9IG5lZ2F0aXZlICsgcGF0dGVybjtcbiAgICB9XG4gIH0gLy8gU291dGggQWZyaWNhbiBSYW5kLCBmb3IgZXhhbXBsZSwgdXNlcyBSIDEyMyAoc3BhY2UpIGFuZCBSLTEyMyAobm8gc3BhY2UpXG5cblxuICBpZiAob3B0aW9ucy5hbGxvd19uZWdhdGl2ZV9zaWduX3BsYWNlaG9sZGVyKSB7XG4gICAgcGF0dGVybiA9IFwiKCAoPyFcXFxcLSkpP1wiLmNvbmNhdChwYXR0ZXJuKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93X3NwYWNlX2FmdGVyX3N5bWJvbCkge1xuICAgIHBhdHRlcm4gPSBcIiA/XCIuY29uY2F0KHBhdHRlcm4pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dfc3BhY2VfYWZ0ZXJfZGlnaXRzKSB7XG4gICAgcGF0dGVybiArPSAnKCAoPyEkKSk/JztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnN5bWJvbF9hZnRlcl9kaWdpdHMpIHtcbiAgICBwYXR0ZXJuICs9IHN5bWJvbDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuID0gc3ltYm9sICsgcGF0dGVybjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93X25lZ2F0aXZlcykge1xuICAgIGlmIChvcHRpb25zLnBhcmVuc19mb3JfbmVnYXRpdmVzKSB7XG4gICAgICBwYXR0ZXJuID0gXCIoXFxcXChcIi5jb25jYXQocGF0dGVybiwgXCJcXFxcKXxcIikuY29uY2F0KHBhdHRlcm4sIFwiKVwiKTtcbiAgICB9IGVsc2UgaWYgKCEob3B0aW9ucy5uZWdhdGl2ZV9zaWduX2JlZm9yZV9kaWdpdHMgfHwgb3B0aW9ucy5uZWdhdGl2ZV9zaWduX2FmdGVyX2RpZ2l0cykpIHtcbiAgICAgIHBhdHRlcm4gPSBuZWdhdGl2ZSArIHBhdHRlcm47XG4gICAgfVxuICB9IC8vIGVuc3VyZSB0aGVyZSdzIGEgZG9sbGFyIGFuZC9vciBkZWNpbWFsIGFtb3VudCwgYW5kIHRoYXRcbiAgLy8gaXQgZG9lc24ndCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgYSBuZWdhdGl2ZSBzaWduIGZvbGxvd2VkIGJ5IGEgc3BhY2VcblxuXG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/IS0/ICkoPz0uKlxcXFxkKVwiLmNvbmNhdChwYXR0ZXJuLCBcIiRcIikpO1xufVxuXG52YXIgZGVmYXVsdF9jdXJyZW5jeV9vcHRpb25zID0ge1xuICBzeW1ib2w6ICckJyxcbiAgcmVxdWlyZV9zeW1ib2w6IGZhbHNlLFxuICBhbGxvd19zcGFjZV9hZnRlcl9zeW1ib2w6IGZhbHNlLFxuICBzeW1ib2xfYWZ0ZXJfZGlnaXRzOiBmYWxzZSxcbiAgYWxsb3dfbmVnYXRpdmVzOiB0cnVlLFxuICBwYXJlbnNfZm9yX25lZ2F0aXZlczogZmFsc2UsXG4gIG5lZ2F0aXZlX3NpZ25fYmVmb3JlX2RpZ2l0czogZmFsc2UsXG4gIG5lZ2F0aXZlX3NpZ25fYWZ0ZXJfZGlnaXRzOiBmYWxzZSxcbiAgYWxsb3dfbmVnYXRpdmVfc2lnbl9wbGFjZWhvbGRlcjogZmFsc2UsXG4gIHRob3VzYW5kc19zZXBhcmF0b3I6ICcsJyxcbiAgZGVjaW1hbF9zZXBhcmF0b3I6ICcuJyxcbiAgYWxsb3dfZGVjaW1hbDogdHJ1ZSxcbiAgcmVxdWlyZV9kZWNpbWFsOiBmYWxzZSxcbiAgZGlnaXRzX2FmdGVyX2RlY2ltYWw6IFsyXSxcbiAgYWxsb3dfc3BhY2VfYWZ0ZXJfZGlnaXRzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNDdXJyZW5jeShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9jdXJyZW5jeV9vcHRpb25zKTtcbiAgcmV0dXJuIGN1cnJlbmN5UmVnZXgob3B0aW9ucykudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0RhdGFVUkk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB2YWxpZE1lZGlhVHlwZSA9IC9eW2Etel0rXFwvW2EtejAtOVxcLVxcK10rJC9pO1xudmFyIHZhbGlkQXR0cmlidXRlID0gL15bYS16XFwtXSs9W2EtejAtOVxcLV0rJC9pO1xudmFyIHZhbGlkRGF0YSA9IC9eW2EtejAtOSFcXCQmJ1xcKFxcKVxcKlxcKyw7PVxcLVxcLl9+OkBcXC9cXD8lXFxzXSokL2k7XG5cbmZ1bmN0aW9uIGlzRGF0YVVSSShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGRhdGEgPSBzdHIuc3BsaXQoJywnKTtcblxuICBpZiAoZGF0YS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBkYXRhLnNoaWZ0KCkudHJpbSgpLnNwbGl0KCc7Jyk7XG4gIHZhciBzY2hlbWVBbmRNZWRpYVR5cGUgPSBhdHRyaWJ1dGVzLnNoaWZ0KCk7XG5cbiAgaWYgKHNjaGVtZUFuZE1lZGlhVHlwZS5zdWJzdHIoMCwgNSkgIT09ICdkYXRhOicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWVkaWFUeXBlID0gc2NoZW1lQW5kTWVkaWFUeXBlLnN1YnN0cig1KTtcblxuICBpZiAobWVkaWFUeXBlICE9PSAnJyAmJiAhdmFsaWRNZWRpYVR5cGUudGVzdChtZWRpYVR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IGF0dHJpYnV0ZXMubGVuZ3RoIC0gMSAmJiBhdHRyaWJ1dGVzW2ldLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNlNjQnKSB7Ly8gb2tcbiAgICB9IGVsc2UgaWYgKCF2YWxpZEF0dHJpYnV0ZS50ZXN0KGF0dHJpYnV0ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKCF2YWxpZERhdGEudGVzdChkYXRhW19pXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEZWNpbWFsO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pbmNsdWRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9pbmNsdWRlc1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZGVjaW1hbFJlZ0V4cChvcHRpb25zKSB7XG4gIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlstK10/KFswLTldKyk/KFxcXFxcIi5jb25jYXQoX2FscGhhLmRlY2ltYWxbb3B0aW9ucy5sb2NhbGVdLCBcIlswLTlde1wiKS5jb25jYXQob3B0aW9ucy5kZWNpbWFsX2RpZ2l0cywgXCJ9KVwiKS5jb25jYXQob3B0aW9ucy5mb3JjZV9kZWNpbWFsID8gJycgOiAnPycsIFwiJFwiKSk7XG4gIHJldHVybiByZWdFeHA7XG59XG5cbnZhciBkZWZhdWx0X2RlY2ltYWxfb3B0aW9ucyA9IHtcbiAgZm9yY2VfZGVjaW1hbDogZmFsc2UsXG4gIGRlY2ltYWxfZGlnaXRzOiAnMSwnLFxuICBsb2NhbGU6ICdlbi1VUydcbn07XG52YXIgYmxhY2tsaXN0ID0gWycnLCAnLScsICcrJ107XG5cbmZ1bmN0aW9uIGlzRGVjaW1hbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9kZWNpbWFsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmxvY2FsZSBpbiBfYWxwaGEuZGVjaW1hbCkge1xuICAgIHJldHVybiAhKDAsIF9pbmNsdWRlcy5kZWZhdWx0KShibGFja2xpc3QsIHN0ci5yZXBsYWNlKC8gL2csICcnKSkgJiYgZGVjaW1hbFJlZ0V4cChvcHRpb25zKS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KG9wdGlvbnMubG9jYWxlLCBcIidcIikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0RpdmlzaWJsZUJ5O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvRmxvYXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RvRmxvYXRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0RpdmlzaWJsZUJ5KHN0ciwgbnVtKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX3RvRmxvYXQuZGVmYXVsdCkoc3RyKSAlIHBhcnNlSW50KG51bSwgMTApID09PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzQnl0ZUxlbmd0aFwiKSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0ZRRE5cIikpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSVBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9lbWFpbF9vcHRpb25zID0ge1xuICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICByZXF1aXJlX2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIGFsbG93X3V0ZjhfbG9jYWxfcGFydDogdHJ1ZSxcbiAgcmVxdWlyZV90bGQ6IHRydWVcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxudmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xudmFyIGVtYWlsVXNlclBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl0rJC9pO1xudmFyIGdtYWlsVXNlclBhcnQgPSAvXlthLXpcXGRdKyQvO1xudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG52YXIgZW1haWxVc2VyVXRmOFBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlclV0ZjggPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkqJC9pO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc0VtYWlsKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2VtYWlsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lIHx8IG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuXG4gICAgaWYgKGRpc3BsYXlfZW1haWwpIHtcbiAgICAgIHN0ciA9IGRpc3BsYXlfZW1haWxbMV07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCdAJyk7XG4gIHZhciBkb21haW4gPSBwYXJ0cy5wb3AoKTtcbiAgdmFyIHVzZXIgPSBwYXJ0cy5qb2luKCdAJyk7XG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcblxuICBpZiAob3B0aW9ucy5kb21haW5fc3BlY2lmaWNfdmFsaWRhdGlvbiAmJiAobG93ZXJfZG9tYWluID09PSAnZ21haWwuY29tJyB8fCBsb3dlcl9kb21haW4gPT09ICdnb29nbGVtYWlsLmNvbScpKSB7XG4gICAgLypcbiAgICAgIFByZXZpb3VzbHkgd2UgcmVtb3ZlZCBkb3RzIGZvciBnbWFpbCBhZGRyZXNzZXMgYmVmb3JlIHZhbGlkYXRpbmcuXG4gICAgICBUaGlzIHdhcyByZW1vdmVkIGJlY2F1c2UgaXQgYWxsb3dzIGBtdWx0aXBsZS4uZG90c0BnbWFpbC5jb21gXG4gICAgICB0byBiZSByZXBvcnRlZCBhcyB2YWxpZCwgYnV0IGl0IGlzIG5vdC5cbiAgICAgIEdtYWlsIG9ubHkgbm9ybWFsaXplcyBzaW5nbGUgZG90cywgcmVtb3ZpbmcgdGhlbSBmcm9tIGhlcmUgaXMgcG9pbnRsZXNzLFxuICAgICAgc2hvdWxkIGJlIGRvbmUgaW4gbm9ybWFsaXplRW1haWxcbiAgICAqL1xuICAgIHVzZXIgPSB1c2VyLnRvTG93ZXJDYXNlKCk7IC8vIFJlbW92aW5nIHN1Yi1hZGRyZXNzIGZyb20gdXNlcm5hbWUgYmVmb3JlIGdtYWlsIHZhbGlkYXRpb25cblxuICAgIHZhciB1c2VybmFtZSA9IHVzZXIuc3BsaXQoJysnKVswXTsgLy8gRG90cyBhcmUgbm90IGluY2x1ZGVkIGluIGdtYWlsIGxlbmd0aCByZXN0cmljdGlvblxuXG4gICAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KSh1c2VybmFtZS5yZXBsYWNlKCcuJywgJycpLCB7XG4gICAgICBtaW46IDYsXG4gICAgICBtYXg6IDMwXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX3VzZXJfcGFydHMgPSB1c2VybmFtZS5zcGxpdCgnLicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdXNlcl9wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFnbWFpbFVzZXJQYXJ0LnRlc3QoX3VzZXJfcGFydHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQpKHVzZXIsIHtcbiAgICBtYXg6IDY0XG4gIH0pIHx8ICEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KShkb21haW4sIHtcbiAgICBtYXg6IDI1NFxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0ZRRE4uZGVmYXVsdCkoZG9tYWluLCB7XG4gICAgcmVxdWlyZV90bGQ6IG9wdGlvbnMucmVxdWlyZV90bGRcbiAgfSkpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfaXBfZG9tYWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoMCwgX2lzSVAuZGVmYXVsdCkoZG9tYWluKSkge1xuICAgICAgaWYgKCFkb21haW4uc3RhcnRzV2l0aCgnWycpIHx8ICFkb21haW4uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0JyYWNrZXRkb21haW4gPSBkb21haW4uc3Vic3RyKDEsIGRvbWFpbi5sZW5ndGggLSAyKTtcblxuICAgICAgaWYgKG5vQnJhY2tldGRvbWFpbi5sZW5ndGggPT09IDAgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShub0JyYWNrZXRkb21haW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodXNlclswXSA9PT0gJ1wiJykge1xuICAgIHVzZXIgPSB1c2VyLnNsaWNlKDEsIHVzZXIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XG4gIH1cblxuICB2YXIgcGF0dGVybiA9IG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gZW1haWxVc2VyVXRmOFBhcnQgOiBlbWFpbFVzZXJQYXJ0O1xuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXNlcl9wYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBpZiAoIXBhdHRlcm4udGVzdCh1c2VyX3BhcnRzW19pXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbXB0eTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2lzX2VtcHR5X29wdGlvbnMgPSB7XG4gIGlnbm9yZV93aGl0ZXNwYWNlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNFbXB0eShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9pc19lbXB0eV9vcHRpb25zKTtcbiAgcmV0dXJuIChvcHRpb25zLmlnbm9yZV93aGl0ZXNwYWNlID8gc3RyLnRyaW0oKS5sZW5ndGggOiBzdHIubGVuZ3RoKSA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGUUROO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZnFkbl9vcHRpb25zID0ge1xuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBpc0ZRRE4oc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcbiAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcuJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0c1tpXS5sZW5ndGggPiA2Mykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfdGxkKSB7XG4gICAgdmFyIHRsZCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXHUwMGExLVxcdWZmZmZdezIsfXx4blthLXowLTktXXsyLH0pJC9pLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZGlzYWxsb3cgc3BhY2VzXG5cblxuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHBhcnQsIF9pID0gMDsgX2kgPCBwYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwYXJ0ID0gcGFydHNbX2ldO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dfdW5kZXJzY29yZXMpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xuICAgIH1cblxuICAgIGlmICghL15bYS16XFx1MDBhMS1cXHVmZmZmMC05LV0rJC9pLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcblxuXG4gICAgaWYgKC9bXFx1ZmYwMS1cXHVmZjVlXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJ0WzBdID09PSAnLScgfHwgcGFydFtwYXJ0Lmxlbmd0aCAtIDFdID09PSAnLScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGbG9hdDtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9hbHBoYSA9IHJlcXVpcmUoXCIuL2FscGhhXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0Zsb2F0KHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGZsb2F0ID0gbmV3IFJlZ0V4cChcIl4oPzpbLStdKT8oPzpbMC05XSspPyg/OlxcXFxcIi5jb25jYXQob3B0aW9ucy5sb2NhbGUgPyBfYWxwaGEuZGVjaW1hbFtvcHRpb25zLmxvY2FsZV0gOiAnLicsIFwiWzAtOV0qKT8oPzpbZUVdW1xcXFwrXFxcXC1dPyg/OlswLTldKykpPyRcIikpO1xuXG4gIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gJy4nIHx8IHN0ciA9PT0gJy0nIHx8IHN0ciA9PT0gJysnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgnLCcsICcuJykpO1xuICByZXR1cm4gZmxvYXQudGVzdChzdHIpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWluJykgfHwgdmFsdWUgPj0gb3B0aW9ucy5taW4pICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWF4JykgfHwgdmFsdWUgPD0gb3B0aW9ucy5tYXgpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbHQnKSB8fCB2YWx1ZSA8IG9wdGlvbnMubHQpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZ3QnKSB8fCB2YWx1ZSA+IG9wdGlvbnMuZ3QpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKF9hbHBoYS5kZWNpbWFsKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Z1bGxXaWR0aDtcbmV4cG9ydHMuZnVsbFdpZHRoID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVsbFdpZHRoID0gL1teXFx1MDAyMC1cXHUwMDdFXFx1RkY2MS1cXHVGRjlGXFx1RkZBMC1cXHVGRkRDXFx1RkZFOC1cXHVGRkVFMC05YS16QS1aXS87XG5leHBvcnRzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblxuZnVuY3Rpb24gaXNGdWxsV2lkdGgoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBmdWxsV2lkdGgudGVzdChzdHIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNIYWxmV2lkdGg7XG5leHBvcnRzLmhhbGZXaWR0aCA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGhhbGZXaWR0aCA9IC9bXFx1MDAyMC1cXHUwMDdFXFx1RkY2MS1cXHVGRjlGXFx1RkZBMC1cXHVGRkRDXFx1RkZFOC1cXHVGRkVFMC05YS16QS1aXS87XG5leHBvcnRzLmhhbGZXaWR0aCA9IGhhbGZXaWR0aDtcblxuZnVuY3Rpb24gaXNIYWxmV2lkdGgoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBoYWxmV2lkdGgudGVzdChzdHIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNIYXNoO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbGVuZ3RocyA9IHtcbiAgbWQ1OiAzMixcbiAgbWQ0OiAzMixcbiAgc2hhMTogNDAsXG4gIHNoYTI1NjogNjQsXG4gIHNoYTM4NDogOTYsXG4gIHNoYTUxMjogMTI4LFxuICByaXBlbWQxMjg6IDMyLFxuICByaXBlbWQxNjA6IDQwLFxuICB0aWdlcjEyODogMzIsXG4gIHRpZ2VyMTYwOiA0MCxcbiAgdGlnZXIxOTI6IDQ4LFxuICBjcmMzMjogOCxcbiAgY3JjMzJiOiA4XG59O1xuXG5mdW5jdGlvbiBpc0hhc2goc3RyLCBhbGdvcml0aG0pIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGhhc2ggPSBuZXcgUmVnRXhwKFwiXlthLWYwLTlde1wiLmNvbmNhdChsZW5ndGhzW2FsZ29yaXRobV0sIFwifSRcIikpO1xuICByZXR1cm4gaGFzaC50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSGV4Q29sb3I7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoZXhjb2xvciA9IC9eIz8oWzAtOUEtRl17M318WzAtOUEtRl17Nn0pJC9pO1xuXG5mdW5jdGlvbiBpc0hleENvbG9yKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gaGV4Y29sb3IudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0hleGFkZWNpbWFsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaGV4YWRlY2ltYWwgPSAvXlswLTlBLUZdKyQvaTtcblxuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGhleGFkZWNpbWFsLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlwdjRNYXliZSA9IC9eKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KSQvO1xudmFyIGlwdjZCbG9jayA9IC9eWzAtOUEtRl17MSw0fSQvaTtcblxuZnVuY3Rpb24gaXNJUChzdHIpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuXG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBpc0lQKHN0ciwgNCkgfHwgaXNJUChzdHIsIDYpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc2Jykge1xuICAgIHZhciBibG9ja3MgPSBzdHIuc3BsaXQoJzonKTtcbiAgICB2YXIgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuICAgIC8vIEF0IGxlYXN0IHNvbWUgT1MgYWNjZXB0IHRoZSBsYXN0IDMyIGJpdHMgb2YgYW4gSVB2NiBhZGRyZXNzXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgIC8vIHRoYXQgJzo6ZmZmZjphLmIuYy5kJyBpcyB2YWxpZCBmb3IgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMsXG4gICAgLy8gYW5kICc6OmEuYi5jLmQnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhbHNvIHZhbGlkLlxuXG4gICAgdmFyIGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA9IGlzSVAoYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXSwgNCk7XG4gICAgdmFyIGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgIGlmIChibG9ja3MubGVuZ3RoID4gZXhwZWN0ZWROdW1iZXJPZkJsb2Nrcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuXG5cbiAgICBpZiAoc3RyID09PSAnOjonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHRlc3QgZm9yIGEgOjogd2hpY2ggY2FuIG5vdCBiZSBhdCB0aGUgc3RyaW5nIHN0YXJ0L2VuZFxuICAgICAgLy8gc2luY2UgdGhvc2UgY2FzZXMgaGF2ZSBiZWVuIGhhbmRsZWQgYWJvdmVcbiAgICAgIGlmIChibG9ja3NbaV0gPT09ICcnICYmIGkgPiAwICYmIGkgPCBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtdWx0aXBsZSA6OiBpbiBhZGRyZXNzXG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIHsvLyBpdCBoYXMgYmVlbiBjaGVja2VkIGJlZm9yZSB0aGF0IHRoZSBsYXN0XG4gICAgICAgIC8vIGJsb2NrIGlzIGEgdmFsaWQgSVB2NCBhZGRyZXNzXG4gICAgICB9IGVsc2UgaWYgKCFpcHY2QmxvY2sudGVzdChibG9ja3NbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja3MubGVuZ3RoID09PSBleHBlY3RlZE51bWJlck9mQmxvY2tzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lQUmFuZ2U7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNJUFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdWJuZXRNYXliZSA9IC9eXFxkezEsMn0kLztcblxuZnVuY3Rpb24gaXNJUFJhbmdlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTsgLy8gcGFydHNbMF0gLT4gaXAsIHBhcnRzWzFdIC0+IHN1Ym5ldFxuXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXN1Ym5ldE1heWJlLnRlc3QocGFydHNbMV0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIERpc2FsbG93IHByZWNlZGluZyAwIGkuZS4gMDEsIDAyLCAuLi5cblxuXG4gIGlmIChwYXJ0c1sxXS5sZW5ndGggPiAxICYmIHBhcnRzWzFdLnN0YXJ0c1dpdGgoJzAnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2lzSVAuZGVmYXVsdCkocGFydHNbMF0sIDQpICYmIHBhcnRzWzFdIDw9IDMyICYmIHBhcnRzWzFdID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNCTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzYm4xME1heWJlID0gL14oPzpbMC05XXs5fVh8WzAtOV17MTB9KSQvO1xudmFyIGlzYm4xM01heWJlID0gL14oPzpbMC05XXsxM30pJC87XG52YXIgZmFjdG9yID0gWzEsIDNdO1xuXG5mdW5jdGlvbiBpc0lTQk4oc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcblxuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gaXNJU0JOKHN0ciwgMTApIHx8IGlzSVNCTihzdHIsIDEzKTtcbiAgfVxuXG4gIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvW1xccy1dKy9nLCAnJyk7XG4gIHZhciBjaGVja3N1bSA9IDA7XG4gIHZhciBpO1xuXG4gIGlmICh2ZXJzaW9uID09PSAnMTAnKSB7XG4gICAgaWYgKCFpc2JuMTBNYXliZS50ZXN0KHNhbml0aXplZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBjaGVja3N1bSArPSAoaSArIDEpICogc2FuaXRpemVkLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICBpZiAoc2FuaXRpemVkLmNoYXJBdCg5KSA9PT0gJ1gnKSB7XG4gICAgICBjaGVja3N1bSArPSAxMCAqIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja3N1bSArPSAxMCAqIHNhbml0aXplZC5jaGFyQXQoOSk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrc3VtICUgMTEgPT09IDApIHtcbiAgICAgIHJldHVybiAhIXNhbml0aXplZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzEzJykge1xuICAgIGlmICghaXNibjEzTWF5YmUudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgIGNoZWNrc3VtICs9IGZhY3RvcltpICUgMl0gKiBzYW5pdGl6ZWQuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIGlmIChzYW5pdGl6ZWQuY2hhckF0KDEyKSAtICgxMCAtIGNoZWNrc3VtICUgMTApICUgMTAgPT09IDApIHtcbiAgICAgIHJldHVybiAhIXNhbml0aXplZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNJTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzaW4gPSAvXltBLVpdezJ9WzAtOUEtWl17OX1bMC05XSQvO1xuXG5mdW5jdGlvbiBpc0lTSU4oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKCFpc2luLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGVja3N1bVN0ciA9IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNoYXJhY3RlciwgMzYpO1xuICB9KTtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBkaWdpdDtcbiAgdmFyIHRtcE51bTtcbiAgdmFyIHNob3VsZERvdWJsZSA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IGNoZWNrc3VtU3RyLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGlnaXQgPSBjaGVja3N1bVN0ci5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcblxuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuXG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAxKSwgMTApID09PSAoMTAwMDAgLSBzdW0pICUgMTA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPMzE2NjFBbHBoYTI7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaW5jbHVkZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvaW5jbHVkZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTFfYWxwaGEtMlxudmFyIHZhbGlkSVNPMzE2NjFBbHBoYTJDb3VudHJpZXNDb2RlcyA9IFsnQUQnLCAnQUUnLCAnQUYnLCAnQUcnLCAnQUknLCAnQUwnLCAnQU0nLCAnQU8nLCAnQVEnLCAnQVInLCAnQVMnLCAnQVQnLCAnQVUnLCAnQVcnLCAnQVgnLCAnQVonLCAnQkEnLCAnQkInLCAnQkQnLCAnQkUnLCAnQkYnLCAnQkcnLCAnQkgnLCAnQkknLCAnQkonLCAnQkwnLCAnQk0nLCAnQk4nLCAnQk8nLCAnQlEnLCAnQlInLCAnQlMnLCAnQlQnLCAnQlYnLCAnQlcnLCAnQlknLCAnQlonLCAnQ0EnLCAnQ0MnLCAnQ0QnLCAnQ0YnLCAnQ0cnLCAnQ0gnLCAnQ0knLCAnQ0snLCAnQ0wnLCAnQ00nLCAnQ04nLCAnQ08nLCAnQ1InLCAnQ1UnLCAnQ1YnLCAnQ1cnLCAnQ1gnLCAnQ1knLCAnQ1onLCAnREUnLCAnREonLCAnREsnLCAnRE0nLCAnRE8nLCAnRFonLCAnRUMnLCAnRUUnLCAnRUcnLCAnRUgnLCAnRVInLCAnRVMnLCAnRVQnLCAnRkknLCAnRkonLCAnRksnLCAnRk0nLCAnRk8nLCAnRlInLCAnR0EnLCAnR0InLCAnR0QnLCAnR0UnLCAnR0YnLCAnR0cnLCAnR0gnLCAnR0knLCAnR0wnLCAnR00nLCAnR04nLCAnR1AnLCAnR1EnLCAnR1InLCAnR1MnLCAnR1QnLCAnR1UnLCAnR1cnLCAnR1knLCAnSEsnLCAnSE0nLCAnSE4nLCAnSFInLCAnSFQnLCAnSFUnLCAnSUQnLCAnSUUnLCAnSUwnLCAnSU0nLCAnSU4nLCAnSU8nLCAnSVEnLCAnSVInLCAnSVMnLCAnSVQnLCAnSkUnLCAnSk0nLCAnSk8nLCAnSlAnLCAnS0UnLCAnS0cnLCAnS0gnLCAnS0knLCAnS00nLCAnS04nLCAnS1AnLCAnS1InLCAnS1cnLCAnS1knLCAnS1onLCAnTEEnLCAnTEInLCAnTEMnLCAnTEknLCAnTEsnLCAnTFInLCAnTFMnLCAnTFQnLCAnTFUnLCAnTFYnLCAnTFknLCAnTUEnLCAnTUMnLCAnTUQnLCAnTUUnLCAnTUYnLCAnTUcnLCAnTUgnLCAnTUsnLCAnTUwnLCAnTU0nLCAnTU4nLCAnTU8nLCAnTVAnLCAnTVEnLCAnTVInLCAnTVMnLCAnTVQnLCAnTVUnLCAnTVYnLCAnTVcnLCAnTVgnLCAnTVknLCAnTVonLCAnTkEnLCAnTkMnLCAnTkUnLCAnTkYnLCAnTkcnLCAnTkknLCAnTkwnLCAnTk8nLCAnTlAnLCAnTlInLCAnTlUnLCAnTlonLCAnT00nLCAnUEEnLCAnUEUnLCAnUEYnLCAnUEcnLCAnUEgnLCAnUEsnLCAnUEwnLCAnUE0nLCAnUE4nLCAnUFInLCAnUFMnLCAnUFQnLCAnUFcnLCAnUFknLCAnUUEnLCAnUkUnLCAnUk8nLCAnUlMnLCAnUlUnLCAnUlcnLCAnU0EnLCAnU0InLCAnU0MnLCAnU0QnLCAnU0UnLCAnU0cnLCAnU0gnLCAnU0knLCAnU0onLCAnU0snLCAnU0wnLCAnU00nLCAnU04nLCAnU08nLCAnU1InLCAnU1MnLCAnU1QnLCAnU1YnLCAnU1gnLCAnU1knLCAnU1onLCAnVEMnLCAnVEQnLCAnVEYnLCAnVEcnLCAnVEgnLCAnVEonLCAnVEsnLCAnVEwnLCAnVE0nLCAnVE4nLCAnVE8nLCAnVFInLCAnVFQnLCAnVFYnLCAnVFcnLCAnVFonLCAnVUEnLCAnVUcnLCAnVU0nLCAnVVMnLCAnVVknLCAnVVonLCAnVkEnLCAnVkMnLCAnVkUnLCAnVkcnLCAnVkknLCAnVk4nLCAnVlUnLCAnV0YnLCAnV1MnLCAnWUUnLCAnWVQnLCAnWkEnLCAnWk0nLCAnWlcnXTtcblxuZnVuY3Rpb24gaXNJU08zMTY2MUFscGhhMihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICgwLCBfaW5jbHVkZXMuZGVmYXVsdCkodmFsaWRJU08zMTY2MUFscGhhMkNvdW50cmllc0NvZGVzLCBzdHIudG9VcHBlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPMzE2NjFBbHBoYTM7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaW5jbHVkZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvaW5jbHVkZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTFfYWxwaGEtM1xudmFyIHZhbGlkSVNPMzE2NjFBbHBoYTNDb3VudHJpZXNDb2RlcyA9IFsnQUZHJywgJ0FMQScsICdBTEInLCAnRFpBJywgJ0FTTScsICdBTkQnLCAnQUdPJywgJ0FJQScsICdBVEEnLCAnQVRHJywgJ0FSRycsICdBUk0nLCAnQUJXJywgJ0FVUycsICdBVVQnLCAnQVpFJywgJ0JIUycsICdCSFInLCAnQkdEJywgJ0JSQicsICdCTFInLCAnQkVMJywgJ0JMWicsICdCRU4nLCAnQk1VJywgJ0JUTicsICdCT0wnLCAnQkVTJywgJ0JJSCcsICdCV0EnLCAnQlZUJywgJ0JSQScsICdJT1QnLCAnQlJOJywgJ0JHUicsICdCRkEnLCAnQkRJJywgJ0tITScsICdDTVInLCAnQ0FOJywgJ0NQVicsICdDWU0nLCAnQ0FGJywgJ1RDRCcsICdDSEwnLCAnQ0hOJywgJ0NYUicsICdDQ0snLCAnQ09MJywgJ0NPTScsICdDT0cnLCAnQ09EJywgJ0NPSycsICdDUkknLCAnQ0lWJywgJ0hSVicsICdDVUInLCAnQ1VXJywgJ0NZUCcsICdDWkUnLCAnRE5LJywgJ0RKSScsICdETUEnLCAnRE9NJywgJ0VDVScsICdFR1knLCAnU0xWJywgJ0dOUScsICdFUkknLCAnRVNUJywgJ0VUSCcsICdGTEsnLCAnRlJPJywgJ0ZKSScsICdGSU4nLCAnRlJBJywgJ0dVRicsICdQWUYnLCAnQVRGJywgJ0dBQicsICdHTUInLCAnR0VPJywgJ0RFVScsICdHSEEnLCAnR0lCJywgJ0dSQycsICdHUkwnLCAnR1JEJywgJ0dMUCcsICdHVU0nLCAnR1RNJywgJ0dHWScsICdHSU4nLCAnR05CJywgJ0dVWScsICdIVEknLCAnSE1EJywgJ1ZBVCcsICdITkQnLCAnSEtHJywgJ0hVTicsICdJU0wnLCAnSU5EJywgJ0lETicsICdJUk4nLCAnSVJRJywgJ0lSTCcsICdJTU4nLCAnSVNSJywgJ0lUQScsICdKQU0nLCAnSlBOJywgJ0pFWScsICdKT1InLCAnS0FaJywgJ0tFTicsICdLSVInLCAnUFJLJywgJ0tPUicsICdLV1QnLCAnS0daJywgJ0xBTycsICdMVkEnLCAnTEJOJywgJ0xTTycsICdMQlInLCAnTEJZJywgJ0xJRScsICdMVFUnLCAnTFVYJywgJ01BQycsICdNS0QnLCAnTURHJywgJ01XSScsICdNWVMnLCAnTURWJywgJ01MSScsICdNTFQnLCAnTUhMJywgJ01UUScsICdNUlQnLCAnTVVTJywgJ01ZVCcsICdNRVgnLCAnRlNNJywgJ01EQScsICdNQ08nLCAnTU5HJywgJ01ORScsICdNU1InLCAnTUFSJywgJ01PWicsICdNTVInLCAnTkFNJywgJ05SVScsICdOUEwnLCAnTkxEJywgJ05DTCcsICdOWkwnLCAnTklDJywgJ05FUicsICdOR0EnLCAnTklVJywgJ05GSycsICdNTlAnLCAnTk9SJywgJ09NTicsICdQQUsnLCAnUExXJywgJ1BTRScsICdQQU4nLCAnUE5HJywgJ1BSWScsICdQRVInLCAnUEhMJywgJ1BDTicsICdQT0wnLCAnUFJUJywgJ1BSSScsICdRQVQnLCAnUkVVJywgJ1JPVScsICdSVVMnLCAnUldBJywgJ0JMTScsICdTSE4nLCAnS05BJywgJ0xDQScsICdNQUYnLCAnU1BNJywgJ1ZDVCcsICdXU00nLCAnU01SJywgJ1NUUCcsICdTQVUnLCAnU0VOJywgJ1NSQicsICdTWUMnLCAnU0xFJywgJ1NHUCcsICdTWE0nLCAnU1ZLJywgJ1NWTicsICdTTEInLCAnU09NJywgJ1pBRicsICdTR1MnLCAnU1NEJywgJ0VTUCcsICdMS0EnLCAnU0ROJywgJ1NVUicsICdTSk0nLCAnU1daJywgJ1NXRScsICdDSEUnLCAnU1lSJywgJ1RXTicsICdUSksnLCAnVFpBJywgJ1RIQScsICdUTFMnLCAnVEdPJywgJ1RLTCcsICdUT04nLCAnVFRPJywgJ1RVTicsICdUVVInLCAnVEtNJywgJ1RDQScsICdUVVYnLCAnVUdBJywgJ1VLUicsICdBUkUnLCAnR0JSJywgJ1VTQScsICdVTUknLCAnVVJZJywgJ1VaQicsICdWVVQnLCAnVkVOJywgJ1ZOTScsICdWR0InLCAnVklSJywgJ1dMRicsICdFU0gnLCAnWUVNJywgJ1pNQicsICdaV0UnXTtcblxuZnVuY3Rpb24gaXNJU08zMTY2MUFscGhhMyhzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICgwLCBfaW5jbHVkZXMuZGVmYXVsdCkodmFsaWRJU08zMTY2MUFscGhhM0NvdW50cmllc0NvZGVzLCBzdHIudG9VcHBlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPODYwMTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLy8gZnJvbSBodHRwOi8vZ29vLmdsLzBlakhIV1xudmFyIGlzbzg2MDEgPSAvXihbXFwrLV0/XFxkezR9KD8hXFxkezJ9XFxiKSkoKC0/KSgoMFsxLTldfDFbMC0yXSkoXFwzKFsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoWzAtNF1cXGR8NVswLTNdKSgtP1sxLTddKT98KDAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18MyhbMC01XVxcZHw2WzEtNl0pKSkoW1RcXHNdKCgoWzAxXVxcZHwyWzAtM10pKCg6PylbMC01XVxcZCk/fDI0Oj8wMCkoW1xcLixdXFxkKyg/ITopKT8pPyhcXDE3WzAtNV1cXGQoW1xcLixdXFxkKyk/KT8oW3paXXwoW1xcKy1dKShbMDFdXFxkfDJbMC0zXSk6PyhbMC01XVxcZCk/KT8pPyk/JC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIGlzVmFsaWREYXRlID0gZnVuY3Rpb24gaXNWYWxpZERhdGUoc3RyKSB7XG4gIC8vIHN0ciBtdXN0IGhhdmUgcGFzc2VkIHRoZSBJU084NjAxIGNoZWNrXG4gIC8vIHRoaXMgY2hlY2sgaXMgbWVhbnQgdG8gY2F0Y2ggaW52YWxpZCBkYXRlc1xuICAvLyBsaWtlIDIwMDktMDItMzFcbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG9yZGluYWwgZGF0ZXNcbiAgdmFyIG9yZGluYWxNYXRjaCA9IHN0ci5tYXRjaCgvXihcXGR7NH0pLT8oXFxkezN9KShbIFRdezF9XFwuKnwkKS8pO1xuXG4gIGlmIChvcmRpbmFsTWF0Y2gpIHtcbiAgICB2YXIgb1llYXIgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzFdKTtcbiAgICB2YXIgb0RheSA9IE51bWJlcihvcmRpbmFsTWF0Y2hbMl0pOyAvLyBpZiBpcyBsZWFwIHllYXJcblxuICAgIGlmIChvWWVhciAlIDQgPT09IDAgJiYgb1llYXIgJSAxMDAgIT09IDApIHJldHVybiBvRGF5IDw9IDM2NjtcbiAgICByZXR1cm4gb0RheSA8PSAzNjU7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goLyhcXGR7NH0pLT8oXFxkezAsMn0pLT8oXFxkKikvKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHllYXIgPSBtYXRjaFsxXTtcbiAgdmFyIG1vbnRoID0gbWF0Y2hbMl07XG4gIHZhciBkYXkgPSBtYXRjaFszXTtcbiAgdmFyIG1vbnRoU3RyaW5nID0gbW9udGggPyBcIjBcIi5jb25jYXQobW9udGgpLnNsaWNlKC0yKSA6IG1vbnRoO1xuICB2YXIgZGF5U3RyaW5nID0gZGF5ID8gXCIwXCIuY29uY2F0KGRheSkuc2xpY2UoLTIpIDogZGF5OyAvLyBjcmVhdGUgYSBkYXRlIG9iamVjdCBhbmQgY29tcGFyZVxuXG4gIHZhciBkID0gbmV3IERhdGUoXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aFN0cmluZyB8fCAnMDEnLCBcIi1cIikuY29uY2F0KGRheVN0cmluZyB8fCAnMDEnKSk7XG4gIGlmIChpc05hTihkLmdldFVUQ0Z1bGxZZWFyKCkpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKG1vbnRoICYmIGRheSkge1xuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZC5nZXRVVENNb250aCgpICsgMSA9PT0gbW9udGggJiYgZC5nZXRVVENEYXRlKCkgPT09IGRheTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNJU084NjAxKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgY2hlY2sgPSBpc284NjAxLnRlc3Qoc3RyKTtcbiAgaWYgKCFvcHRpb25zKSByZXR1cm4gY2hlY2s7XG4gIGlmIChjaGVjayAmJiBvcHRpb25zLnN0cmljdCkgcmV0dXJuIGlzVmFsaWREYXRlKHN0cik7XG4gIHJldHVybiBjaGVjaztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJU1JDO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBzZWUgaHR0cDovL2lzcmMuaWZwaS5vcmcvZW4vaXNyYy1zdGFuZGFyZC9jb2RlLXN5bnRheFxudmFyIGlzcmMgPSAvXltBLVpdezJ9WzAtOUEtWl17M31cXGR7Mn1cXGR7NX0kLztcblxuZnVuY3Rpb24gaXNJU1JDKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gaXNyYy50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNTTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzc24gPSAnXlxcXFxkezR9LT9cXFxcZHszfVtcXFxcZFhdJCc7XG5cbmZ1bmN0aW9uIGlzSVNTTihzdHIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgdGVzdElzc24gPSBpc3NuO1xuICB0ZXN0SXNzbiA9IG9wdGlvbnMucmVxdWlyZV9oeXBoZW4gPyB0ZXN0SXNzbi5yZXBsYWNlKCc/JywgJycpIDogdGVzdElzc247XG4gIHRlc3RJc3NuID0gb3B0aW9ucy5jYXNlX3NlbnNpdGl2ZSA/IG5ldyBSZWdFeHAodGVzdElzc24pIDogbmV3IFJlZ0V4cCh0ZXN0SXNzbiwgJ2knKTtcblxuICBpZiAoIXRlc3RJc3NuLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkaWdpdHMgPSBzdHIucmVwbGFjZSgnLScsICcnKS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgY2hlY2tzdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgIGNoZWNrc3VtICs9IChkaWdpdCA9PT0gJ1gnID8gMTAgOiArZGlnaXQpICogKDggLSBpKTtcbiAgfVxuXG4gIHJldHVybiBjaGVja3N1bSAlIDExID09PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lkZW50aXR5Q2FyZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZhbGlkYXRvcnMgPSB7XG4gIEVTOiBmdW5jdGlvbiBFUyhzdHIpIHtcbiAgICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICAgIHZhciBETkkgPSAvXlswLTlYLVpdWzAtOV17N31bVFJXQUdNWUZQRFhCTkpaU1FWSExDS0VdJC87XG4gICAgdmFyIGNoYXJzVmFsdWUgPSB7XG4gICAgICBYOiAwLFxuICAgICAgWTogMSxcbiAgICAgIFo6IDJcbiAgICB9O1xuICAgIHZhciBjb250cm9sRGlnaXRzID0gWydUJywgJ1InLCAnVycsICdBJywgJ0cnLCAnTScsICdZJywgJ0YnLCAnUCcsICdEJywgJ1gnLCAnQicsICdOJywgJ0onLCAnWicsICdTJywgJ1EnLCAnVicsICdIJywgJ0wnLCAnQycsICdLJywgJ0UnXTsgLy8gc2FuaXRpemUgdXNlciBpbnB1dFxuXG4gICAgdmFyIHNhbml0aXplZCA9IHN0ci50cmltKCkudG9VcHBlckNhc2UoKTsgLy8gdmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlXG5cbiAgICBpZiAoIUROSS50ZXN0KHNhbml0aXplZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHZhbGlkYXRlIHRoZSBjb250cm9sIGRpZ2l0XG5cblxuICAgIHZhciBudW1iZXIgPSBzYW5pdGl6ZWQuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL1tYLFksWl0vZywgZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgIHJldHVybiBjaGFyc1ZhbHVlW2NoYXJdO1xuICAgIH0pO1xuICAgIHJldHVybiBzYW5pdGl6ZWQuZW5kc1dpdGgoY29udHJvbERpZ2l0c1tudW1iZXIgJSAyM10pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc0lkZW50aXR5Q2FyZChzdHIpIHtcbiAgdmFyIGxvY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FueSc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiB2YWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnNbbG9jYWxlXShzdHIpO1xuICB9IGVsc2UgaWYgKGxvY2FsZSA9PT0gJ2FueScpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsaWRhdG9ycykge1xuICAgICAgaWYgKHZhbGlkYXRvcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gdmFsaWRhdG9yc1trZXldO1xuXG4gICAgICAgIGlmICh2YWxpZGF0b3Ioc3RyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfdG9TdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvdG9TdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc0luKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgaTtcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKGkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgYXJyYXlbaV0gPSAoMCwgX3RvU3RyaW5nLmRlZmF1bHQpKG9wdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheS5pbmRleE9mKHN0cikgPj0gMDtcbiAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRpb25zLmhhc093blByb3BlcnR5KHN0cik7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaW5kZXhPZihzdHIpID49IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW50O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaW50ID0gL14oPzpbLStdPyg/OjB8WzEtOV1bMC05XSopKSQvO1xudmFyIGludExlYWRpbmdaZXJvZXMgPSAvXlstK10/WzAtOV0rJC87XG5cbmZ1bmN0aW9uIGlzSW50KHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gR2V0IHRoZSByZWdleCB0byB1c2UgZm9yIHRlc3RpbmcsIGJhc2VkIG9uIHdoZXRoZXJcbiAgLy8gbGVhZGluZyB6ZXJvZXMgYXJlIGFsbG93ZWQgb3Igbm90LlxuXG4gIHZhciByZWdleCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2FsbG93X2xlYWRpbmdfemVyb2VzJykgJiYgIW9wdGlvbnMuYWxsb3dfbGVhZGluZ196ZXJvZXMgPyBpbnQgOiBpbnRMZWFkaW5nWmVyb2VzOyAvLyBDaGVjayBtaW4vbWF4L2x0L2d0XG5cbiAgdmFyIG1pbkNoZWNrUGFzc2VkID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21pbicpIHx8IHN0ciA+PSBvcHRpb25zLm1pbjtcbiAgdmFyIG1heENoZWNrUGFzc2VkID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21heCcpIHx8IHN0ciA8PSBvcHRpb25zLm1heDtcbiAgdmFyIGx0Q2hlY2tQYXNzZWQgPSAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbHQnKSB8fCBzdHIgPCBvcHRpb25zLmx0O1xuICB2YXIgZ3RDaGVja1Bhc3NlZCA9ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdndCcpIHx8IHN0ciA+IG9wdGlvbnMuZ3Q7XG4gIHJldHVybiByZWdleC50ZXN0KHN0cikgJiYgbWluQ2hlY2tQYXNzZWQgJiYgbWF4Q2hlY2tQYXNzZWQgJiYgbHRDaGVja1Bhc3NlZCAmJiBndENoZWNrUGFzc2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0pTT047XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGlzSlNPTihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICB0cnkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gICAgcmV0dXJuICEhb2JqICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNKV1Q7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBqd3QgPSAvXihbQS1aYS16MC05XFwtX34rXFwvXStbPV17MCwyfSlcXC4oW0EtWmEtejAtOVxcLV9+K1xcL10rWz1dezAsMn0pKD86XFwuKFtBLVphLXowLTlcXC1ffitcXC9dK1s9XXswLDJ9KSk/JC87XG5cbmZ1bmN0aW9uIGlzSldUKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gand0LnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBsYXQgPSAvXlxcKD9bKy1dPyg5MChcXC4wKyk/fFsxLThdP1xcZChcXC5cXGQrKT8pJC87XG52YXIgbG9uZyA9IC9eXFxzP1srLV0/KDE4MChcXC4wKyk/fDFbMC03XVxcZChcXC5cXGQrKT98XFxkezEsMn0oXFwuXFxkKyk/KVxcKT8kLztcblxuZnVuY3Rpb24gX2RlZmF1bHQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIGlmICghc3RyLmluY2x1ZGVzKCcsJykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHBhaXIgPSBzdHIuc3BsaXQoJywnKTtcbiAgcmV0dXJuIGxhdC50ZXN0KHBhaXJbMF0pICYmIGxvbmcudGVzdChwYWlyWzFdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuZnVuY3Rpb24gaXNMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgdmFyIHN1cnJvZ2F0ZVBhaXJzID0gc3RyLm1hdGNoKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2cpIHx8IFtdO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aCAtIHN1cnJvZ2F0ZVBhaXJzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbiA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IGxlbiA8PSBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0xvd2VyY2FzZTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNMb3dlcmNhc2Uoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIgPT09IHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01BQ0FkZHJlc3M7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtYWNBZGRyZXNzID0gL14oWzAtOWEtZkEtRl1bMC05YS1mQS1GXTopezV9KFswLTlhLWZBLUZdWzAtOWEtZkEtRl0pJC87XG52YXIgbWFjQWRkcmVzc05vQ29sb25zID0gL14oWzAtOWEtZkEtRl0pezEyfSQvO1xuXG5mdW5jdGlvbiBpc01BQ0FkZHJlc3Moc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19jb2xvbnMpIHtcbiAgICByZXR1cm4gbWFjQWRkcmVzc05vQ29sb25zLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHJldHVybiBtYWNBZGRyZXNzLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNRDU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtZDUgPSAvXlthLWYwLTldezMyfSQvO1xuXG5mdW5jdGlvbiBpc01ENShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIG1kNS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTWFnbmV0VVJJO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbWFnbmV0VVJJID0gL15tYWduZXQ6XFw/eHQ9dXJuOlthLXowLTldKzpbYS16MC05XXszMiw0MH0mZG49LismdHI9LiskL2k7XG5cbmZ1bmN0aW9uIGlzTWFnbmV0VVJJKHVybCkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KSh1cmwpO1xuICByZXR1cm4gbWFnbmV0VVJJLnRlc3QodXJsLnRyaW0oKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTWltZVR5cGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qXG4gIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgc3RyaW5nIG1hdGNoZXMgdG8gYSBjb3JyZWN0IE1lZGlhIHR5cGUgZm9ybWF0IChNSU1FIHR5cGUpXG5cbiAgVGhpcyBmdW5jdGlvbiBvbmx5IGNoZWNrcyBpcyB0aGUgc3RyaW5nIGZvcm1hdCBmb2xsb3dzIHRoZVxuICBldGFibGlzaGVkIHJ1bGVzIGJ5IHRoZSBhY2NvcmRpbmcgUkZDIHNwZWNpZmljYXRpb25zLlxuICBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzICdjaGFyc2V0JyBpbiB0ZXh0dWFsIG1lZGlhIHR5cGVzXG4gIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY1NykuXG5cbiAgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayBhZ2FpbnN0IGFsbCB0aGUgbWVkaWEgdHlwZXMgbGlzdGVkXG4gIGJ5IHRoZSBJQU5BIChodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9tZWRpYS10eXBlcy54aHRtbClcbiAgYmVjYXVzZSBvZiBsaWdodG5lc3MgcHVycG9zZXMgOiBpdCB3b3VsZCByZXF1aXJlIHRvIGluY2x1ZGVcbiAgYWxsIHRoZXNlIE1JTUUgdHlwZXMgaW4gdGhpcyBsaWJyYWlyeSwgd2hpY2ggd291bGQgd2VpZ2ggaXRcbiAgc2lnbmlmaWNhbnRseS4gVGhpcyBraW5kIG9mIGVmZm9ydCBtYXliZSBpcyBub3Qgd29ydGggZm9yIHRoZSB1c2UgdGhhdFxuICB0aGlzIGZ1bmN0aW9uIGhhcyBpbiB0aGlzIGVudGlyZSBsaWJyYWlyeS5cblxuICBNb3JlIGluZm9ybWF0aW9ucyBpbiB0aGUgUkZDIHNwZWNpZmljYXRpb25zIDpcbiAgLSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0NVxuICAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMDQ2XG4gIC0gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi0zLjEuMS4xXG4gIC0gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi0zLjEuMS41XG4qL1xuLy8gTWF0Y2ggc2ltcGxlIE1JTUUgdHlwZXNcbi8vIE5CIDpcbi8vICAgU3VidHlwZSBsZW5ndGggbXVzdCBub3QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLlxuLy8gICBUaGlzIHJ1bGUgZG9lcyBub3QgY29tcGx5IHRvIHRoZSBSRkMgc3BlY3MgKHdoYXQgaXMgdGhlIG1heCBsZW5ndGggPykuXG52YXIgbWltZVR5cGVTaW1wbGUgPSAvXihhcHBsaWNhdGlvbnxhdWRpb3xmb250fGltYWdlfG1lc3NhZ2V8bW9kZWx8bXVsdGlwYXJ0fHRleHR8dmlkZW8pXFwvW2EtekEtWjAtOVxcLlxcLVxcK117MSwxMDB9JC9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbi8vIEhhbmRsZSBcImNoYXJzZXRcIiBpbiBcInRleHQvKlwiXG5cbnZhciBtaW1lVHlwZVRleHQgPSAvXnRleHRcXC9bYS16QS1aMC05XFwuXFwtXFwrXXsxLDEwMH07XFxzP2NoYXJzZXQ9KFwiW2EtekEtWjAtOVxcLlxcLVxcK1xcc117MCw3MH1cInxbYS16QS1aMC05XFwuXFwtXFwrXXswLDcwfSkoXFxzP1xcKFthLXpBLVowLTlcXC5cXC1cXCtcXHNdezEsMjB9XFwpKT8kL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuLy8gSGFuZGxlIFwiYm91bmRhcnlcIiBpbiBcIm11bHRpcGFydC8qXCJcblxudmFyIG1pbWVUeXBlTXVsdGlwYXJ0ID0gL15tdWx0aXBhcnRcXC9bYS16QS1aMC05XFwuXFwtXFwrXXsxLDEwMH0oO1xccz8oYm91bmRhcnl8Y2hhcnNldCk9KFwiW2EtekEtWjAtOVxcLlxcLVxcK1xcc117MCw3MH1cInxbYS16QS1aMC05XFwuXFwtXFwrXXswLDcwfSkoXFxzP1xcKFthLXpBLVowLTlcXC5cXC1cXCtcXHNdezEsMjB9XFwpKT8pezAsMn0kL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXG5mdW5jdGlvbiBpc01pbWVUeXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gbWltZVR5cGVTaW1wbGUudGVzdChzdHIpIHx8IG1pbWVUeXBlVGV4dC50ZXN0KHN0cikgfHwgbWltZVR5cGVNdWx0aXBhcnQudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01vYmlsZVBob25lO1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgcGhvbmVzID0ge1xuICAnYXItQUUnOiAvXigoXFwrPzk3MSl8MCk/NVswMjQ1NjhdXFxkezd9JC8sXG4gICdhci1EWic6IC9eKFxcKz8yMTN8MCkoNXw2fDcpXFxkezh9JC8sXG4gICdhci1FRyc6IC9eKChcXCs/MjApfDApPzFbMDEyXVxcZHs4fSQvLFxuICAnYXItSVEnOiAvXihcXCs/OTY0fDApPzdbMC05XVxcZHs4fSQvLFxuICAnYXItSk8nOiAvXihcXCs/OTYyfDApPzdbNzg5XVxcZHs3fSQvLFxuICAnYXItS1cnOiAvXihcXCs/OTY1KVs1NjldXFxkezd9JC8sXG4gICdhci1TQSc6IC9eKCE/KFxcKz85NjYpfDApPzVcXGR7OH0kLyxcbiAgJ2FyLVNZJzogL14oIT8oXFwrPzk2Myl8MCk/OVxcZHs4fSQvLFxuICAnYXItVE4nOiAvXihcXCs/MjE2KT9bMjQ1OV1cXGR7N30kLyxcbiAgJ2JlLUJZJzogL14oXFwrPzM3NSk/KDI0fDI1fDI5fDMzfDQ0KVxcZHs3fSQvLFxuICAnYmctQkcnOiAvXihcXCs/MzU5fDApPzhbNzg5XVxcZHs3fSQvLFxuICAnYm4tQkQnOiAvXFwrPyg4OCk/MD8xWzM1Njc4OV1bMC05XXs4fVxcYi8sXG4gICdjcy1DWic6IC9eKFxcKz80MjApPyA/WzEtOV1bMC05XXsyfSA/WzAtOV17M30gP1swLTldezN9JC8sXG4gICdkYS1ESyc6IC9eKFxcKz80NSk/XFxzP1xcZHsyfVxccz9cXGR7Mn1cXHM/XFxkezJ9XFxzP1xcZHsyfSQvLFxuICAnZGUtREUnOiAvXihcXCs0OSk/MD8xKDVbMC0yNS05XVxcZHw2KFsyM118MFxcZD8pfDcoWzAtNTctOV18NlxcZCkpXFxkezd9JC8sXG4gICdlbC1HUic6IC9eKFxcKz8zMHwwKT8oNjlcXGR7OH0pJC8sXG4gICdlbi1BVSc6IC9eKFxcKz82MXwwKTRcXGR7OH0kLyxcbiAgJ2VuLUdCJzogL14oXFwrPzQ0fDApN1xcZHs5fSQvLFxuICAnZW4tR0gnOiAvXihcXCsyMzN8MCkoMjB8NTB8MjR8NTR8Mjd8NTd8MjZ8NTZ8MjN8MjgpXFxkezd9JC8sXG4gICdlbi1ISyc6IC9eKFxcKz84NTJcXC0/KT9bNDU2Nzg5XVxcZHszfVxcLT9cXGR7NH0kLyxcbiAgJ2VuLUlFJzogL14oXFwrPzM1M3wwKThbMzU2Nzg5XVxcZHs3fSQvLFxuICAnZW4tSU4nOiAvXihcXCs/OTF8MCk/WzY3ODldXFxkezl9JC8sXG4gICdlbi1LRSc6IC9eKFxcKz8yNTR8MCk/WzddXFxkezh9JC8sXG4gICdlbi1NVSc6IC9eKFxcKz8yMzB8MCk/XFxkezh9JC8sXG4gICdlbi1ORyc6IC9eKFxcKz8yMzR8MCk/Wzc4OV1cXGR7OX0kLyxcbiAgJ2VuLU5aJzogL14oXFwrPzY0fDApWzI4XVxcZHs3LDl9JC8sXG4gICdlbi1QSyc6IC9eKChcXCs5Mil8KDAwOTIpKS17MCwxfVxcZHszfS17MCwxfVxcZHs3fSR8XlxcZHsxMX0kfF5cXGR7NH0tXFxkezd9JC8sXG4gICdlbi1SVyc6IC9eKFxcKz8yNTB8MCk/WzddXFxkezh9JC8sXG4gICdlbi1TRyc6IC9eKFxcKzY1KT9bODldXFxkezd9JC8sXG4gICdlbi1UWic6IC9eKFxcKz8yNTV8MCk/WzY3XVxcZHs4fSQvLFxuICAnZW4tVUcnOiAvXihcXCs/MjU2fDApP1s3XVxcZHs4fSQvLFxuICAnZW4tVVMnOiAvXigoXFwrMXwxKT8oIHwtKT8pPyhcXChbMi05XVswLTldezJ9XFwpfFsyLTldWzAtOV17Mn0pKCB8LSk/KFsyLTldWzAtOV17Mn0oIHwtKT9bMC05XXs0fSkkLyxcbiAgJ2VuLVpBJzogL14oXFwrPzI3fDApXFxkezl9JC8sXG4gICdlbi1aTSc6IC9eKFxcKz8yNik/MDlbNTY3XVxcZHs3fSQvLFxuICAnZXMtRVMnOiAvXihcXCs/MzQpPyg2XFxkezF9fDdbMTIzNF0pXFxkezd9JC8sXG4gICdlcy1NWCc6IC9eKFxcKz81Mik/KDF8MDEpP1xcZHsxMCwxMX0kLyxcbiAgJ2VzLVVZJzogL14oXFwrNTk4fDApOVsxLTldW1xcZF17Nn0kLyxcbiAgJ2V0LUVFJzogL14oXFwrPzM3Mik/XFxzPyg1fDhbMS00XSlcXHM/KFswLTldXFxzPyl7Niw3fSQvLFxuICAnZmEtSVInOiAvXihcXCs/OThbXFwtXFxzXT98MCk5WzAtMzldXFxkW1xcLVxcc10/XFxkezN9W1xcLVxcc10/XFxkezR9JC8sXG4gICdmaS1GSSc6IC9eKFxcKz8zNTh8MClcXHM/KDQoMHwxfDJ8NHw1fDYpP3w1MClcXHM/KFxcZFxccz8pezQsOH1cXGQkLyxcbiAgJ2ZvLUZPJzogL14oXFwrPzI5OCk/XFxzP1xcZHsyfVxccz9cXGR7Mn1cXHM/XFxkezJ9JC8sXG4gICdmci1GUic6IC9eKFxcKz8zM3wwKVs2N11cXGR7OH0kLyxcbiAgJ2hlLUlMJzogL14oXFwrOTcyfDApKFsyMzQ4OV18NVswMTIzNDU2ODldfDc3KVsxLTldXFxkezZ9JC8sXG4gICdodS1IVSc6IC9eKFxcKz8zNikoMjB8MzB8NzApXFxkezd9JC8sXG4gICdpZC1JRCc6IC9eKFxcKz82MnwwKTgoMVsxMjM0NTY3ODldfDJbMTIzOF18M1sxMjM4XXw1WzEyMzU2Nzg5XXw3Wzc4XXw5WzU2Nzg5XXw4WzEyMzQ1Njc4OV0pKFtcXHM/fFxcZF17NSwxMX0pJC8sXG4gICdpdC1JVCc6IC9eKFxcKz8zOSk/XFxzPzNcXGR7Mn0gP1xcZHs2LDd9JC8sXG4gICdqYS1KUCc6IC9eKFxcKz84MXwwKVs3ODldMFsgXFwtXT9bMS05XVxcZHsyfVsgXFwtXT9cXGR7NX0kLyxcbiAgJ2trLUtaJzogL14oXFwrPzd8OCk/N1xcZHs5fSQvLFxuICAna2wtR0wnOiAvXihcXCs/Mjk5KT9cXHM/XFxkezJ9XFxzP1xcZHsyfVxccz9cXGR7Mn0kLyxcbiAgJ2tvLUtSJzogL14oKFxcKz84MilbIFxcLV0/KT8wPzEoWzB8MXw2fDd8OHw5XXsxfSlbIFxcLV0/XFxkezMsNH1bIFxcLV0/XFxkezR9JC8sXG4gICdsdC1MVCc6IC9eKFxcKzM3MHw4KVxcZHs4fSQvLFxuICAnbXMtTVknOiAvXihcXCs/Nj8wMSl7MX0oKFswMTQ1XXsxfShcXC18XFxzKT9cXGR7Nyw4fSl8KFsyMzY3ODldezF9KFxcc3xcXC0pP1xcZHs3fSkpJC8sXG4gICduYi1OTyc6IC9eKFxcKz80Nyk/WzQ5XVxcZHs3fSQvLFxuICAnbmwtQkUnOiAvXihcXCs/MzJ8MCk0P1xcZHs4fSQvLFxuICAnbm4tTk8nOiAvXihcXCs/NDcpP1s0OV1cXGR7N30kLyxcbiAgJ3BsLVBMJzogL14oXFwrPzQ4KT8gP1s1LThdXFxkID9cXGR7M30gP1xcZHsyfSA/XFxkezJ9JC8sXG4gICdwdC1CUic6IC8oPz1eKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtP1xcZHs0fVxcLT9cXGR7NH0kKSheKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtP1s2LTldezF9XFxkezN9XFwtP1xcZHs0fSQpfCheKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtPzlbNi05XXsxfVxcZHszfVxcLT9cXGR7NH0kKS8sXG4gICdwdC1QVCc6IC9eKFxcKz8zNTEpPzlbMTIzNl1cXGR7N30kLyxcbiAgJ3JvLVJPJzogL14oXFwrPzQ/MClcXHM/N1xcZHsyfShcXC98XFxzfFxcLnxcXC0pP1xcZHszfShcXHN8XFwufFxcLSk/XFxkezN9JC8sXG4gICdydS1SVSc6IC9eKFxcKz83fDgpPzlcXGR7OX0kLyxcbiAgJ3NsLVNJJzogL14oXFwrMzg2XFxzP3wwKShcXGR7MX1cXHM/XFxkezN9XFxzP1xcZHsyfVxccz9cXGR7Mn18XFxkezJ9XFxzP1xcZHszfVxccz9cXGR7M30pJC8sXG4gICdzay1TSyc6IC9eKFxcKz80MjEpPyA/WzEtOV1bMC05XXsyfSA/WzAtOV17M30gP1swLTldezN9JC8sXG4gICdzci1SUyc6IC9eKFxcKzM4MTZ8MDYpWy0gXFxkXXs1LDl9JC8sXG4gICdzdi1TRSc6IC9eKFxcKz80NnwwKVtcXHNcXC1dPzdbXFxzXFwtXT9bMDIzNjldKFtcXHNcXC1dP1xcZCl7N30kLyxcbiAgJ3RoLVRIJzogL14oXFwrNjZ8NjZ8MClcXGR7OX0kLyxcbiAgJ3RyLVRSJzogL14oXFwrPzkwfDApPzVcXGR7OX0kLyxcbiAgJ3VrLVVBJzogL14oXFwrPzM4fDgpPzBcXGR7OX0kLyxcbiAgJ3ZpLVZOJzogL14oXFwrPzg0fDApKCgzKFsyLTldKSl8KDUoWzY4OV0pKXwoNyhbMHw2LTldKSl8KDgoWzEtNV0pKXwoOShbMC05XSkpKShbMC05XXs3fSkkLyxcbiAgJ3poLUNOJzogL14oKFxcK3wwMCk4Nik/MShbMzU4XVswLTldfDRbNTc5XXw2Nnw3WzAxMzU2NzhdfDlbODldKVswLTldezh9JC8sXG4gICd6aC1UVyc6IC9eKFxcKz84ODZcXC0/fDApPzlcXGR7OH0kL1xufTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLy8gYWxpYXNlc1xuXG5waG9uZXNbJ2VuLUNBJ10gPSBwaG9uZXNbJ2VuLVVTJ107XG5waG9uZXNbJ2ZyLUJFJ10gPSBwaG9uZXNbJ25sLUJFJ107XG5waG9uZXNbJ3poLUhLJ10gPSBwaG9uZXNbJ2VuLUhLJ107XG5cbmZ1bmN0aW9uIGlzTW9iaWxlUGhvbmUoc3RyLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdE1vZGUgJiYgIXN0ci5zdGFydHNXaXRoKCcrJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbGUpKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChwaG9uZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgcGhvbmUgPSBwaG9uZXNba2V5XTtcblxuICAgICAgICBpZiAocGhvbmUudGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvY2FsZSBpbiBwaG9uZXMpIHtcbiAgICByZXR1cm4gcGhvbmVzW2xvY2FsZV0udGVzdChzdHIpOyAvLyBhbGlhcyBmYWxzZXkgbG9jYWxlIGFzICdhbnknXG4gIH0gZWxzZSBpZiAoIWxvY2FsZSB8fCBsb2NhbGUgPT09ICdhbnknKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHBob25lcykge1xuICAgICAgaWYgKHBob25lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBwaG9uZSA9IHBob25lc1trZXldO1xuXG4gICAgICAgIGlmIChwaG9uZS50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKHBob25lcyk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNb25nb0lkO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2lzSGV4YWRlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSGV4YWRlY2ltYWxcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc01vbmdvSWQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX2lzSGV4YWRlY2ltYWwuZGVmYXVsdCkoc3RyKSAmJiBzdHIubGVuZ3RoID09PSAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNdWx0aWJ5dGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbnZhciBtdWx0aWJ5dGUgPSAvW15cXHgwMC1cXHg3Rl0vO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmZ1bmN0aW9uIGlzTXVsdGlieXRlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gbXVsdGlieXRlLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOdW1lcmljO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbnVtZXJpYyA9IC9eWystXT8oWzAtOV0qWy5dKT9bMC05XSskLztcbnZhciBudW1lcmljTm9TeW1ib2xzID0gL15bMC05XSskLztcblxuZnVuY3Rpb24gaXNOdW1lcmljKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fc3ltYm9scykge1xuICAgIHJldHVybiBudW1lcmljTm9TeW1ib2xzLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHJldHVybiBudW1lcmljLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQb3J0O1xuXG52YXIgX2lzSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0ludFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzUG9ydChzdHIpIHtcbiAgcmV0dXJuICgwLCBfaXNJbnQuZGVmYXVsdCkoc3RyLCB7XG4gICAgbWluOiAwLFxuICAgIG1heDogNjU1MzVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBjb21tb24gcGF0dGVybnNcbnZhciB0aHJlZURpZ2l0ID0gL15cXGR7M30kLztcbnZhciBmb3VyRGlnaXQgPSAvXlxcZHs0fSQvO1xudmFyIGZpdmVEaWdpdCA9IC9eXFxkezV9JC87XG52YXIgc2l4RGlnaXQgPSAvXlxcZHs2fSQvO1xudmFyIHBhdHRlcm5zID0ge1xuICBBRDogL15BRFxcZHszfSQvLFxuICBBVDogZm91ckRpZ2l0LFxuICBBVTogZm91ckRpZ2l0LFxuICBCRTogZm91ckRpZ2l0LFxuICBCRzogZm91ckRpZ2l0LFxuICBDQTogL15bQUJDRUdISktMTU5QUlNUVlhZXVxcZFtBQkNFR0hKLU5QUlNUVi1aXVtcXHNcXC1dP1xcZFtBQkNFR0hKLU5QUlNUVi1aXVxcZCQvaSxcbiAgQ0g6IGZvdXJEaWdpdCxcbiAgQ1o6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBERTogZml2ZURpZ2l0LFxuICBESzogZm91ckRpZ2l0LFxuICBEWjogZml2ZURpZ2l0LFxuICBFRTogZml2ZURpZ2l0LFxuICBFUzogZml2ZURpZ2l0LFxuICBGSTogZml2ZURpZ2l0LFxuICBGUjogL15cXGR7Mn1cXHM/XFxkezN9JC8sXG4gIEdCOiAvXihnaXJcXHM/MGFhfFthLXpdezEsMn1cXGRbXFxkYS16XT9cXHM/KFxcZFthLXpdezJ9KT8pJC9pLFxuICBHUjogL15cXGR7M31cXHM/XFxkezJ9JC8sXG4gIEhSOiAvXihbMS01XVxcZHs0fSQpLyxcbiAgSFU6IGZvdXJEaWdpdCxcbiAgSUw6IGZpdmVEaWdpdCxcbiAgSU46IHNpeERpZ2l0LFxuICBJUzogdGhyZWVEaWdpdCxcbiAgSVQ6IGZpdmVEaWdpdCxcbiAgSlA6IC9eXFxkezN9XFwtXFxkezR9JC8sXG4gIEtFOiBmaXZlRGlnaXQsXG4gIExJOiAvXig5NDhbNS05XXw5NDlbMC03XSkkLyxcbiAgTFQ6IC9eTFRcXC1cXGR7NX0kLyxcbiAgTFU6IGZvdXJEaWdpdCxcbiAgTFY6IC9eTFZcXC1cXGR7NH0kLyxcbiAgTVg6IGZpdmVEaWdpdCxcbiAgTkw6IC9eXFxkezR9XFxzP1thLXpdezJ9JC9pLFxuICBOTzogZm91ckRpZ2l0LFxuICBQTDogL15cXGR7Mn1cXC1cXGR7M30kLyxcbiAgUFQ6IC9eXFxkezR9XFwtXFxkezN9PyQvLFxuICBSTzogc2l4RGlnaXQsXG4gIFJVOiBzaXhEaWdpdCxcbiAgU0E6IGZpdmVEaWdpdCxcbiAgU0U6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBTSTogZm91ckRpZ2l0LFxuICBTSzogL15cXGR7M31cXHM/XFxkezJ9JC8sXG4gIFROOiBmb3VyRGlnaXQsXG4gIFRXOiAvXlxcZHszfShcXGR7Mn0pPyQvLFxuICBVQTogZml2ZURpZ2l0LFxuICBVUzogL15cXGR7NX0oLVxcZHs0fSk/JC8sXG4gIFpBOiBmb3VyRGlnaXQsXG4gIFpNOiBmaXZlRGlnaXRcbn07XG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKHBhdHRlcm5zKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHN0ciwgbG9jYWxlKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBwYXR0ZXJucykge1xuICAgIHJldHVybiBwYXR0ZXJuc1tsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfSBlbHNlIGlmIChsb2NhbGUgPT09ICdhbnknKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHBhdHRlcm5zKSB7XG4gICAgICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2tleV07XG5cbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUkZDMzMzOTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogQmFzZWQgb24gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjYgKi9cbnZhciBkYXRlRnVsbFllYXIgPSAvWzAtOV17NH0vO1xudmFyIGRhdGVNb250aCA9IC8oMFsxLTldfDFbMC0yXSkvO1xudmFyIGRhdGVNRGF5ID0gLyhbMTJdXFxkfDBbMS05XXwzWzAxXSkvO1xudmFyIHRpbWVIb3VyID0gLyhbMDFdWzAtOV18MlswLTNdKS87XG52YXIgdGltZU1pbnV0ZSA9IC9bMC01XVswLTldLztcbnZhciB0aW1lU2Vjb25kID0gLyhbMC01XVswLTldfDYwKS87XG52YXIgdGltZVNlY0ZyYWMgPSAvKFxcLlswLTldKyk/LztcbnZhciB0aW1lTnVtT2Zmc2V0ID0gbmV3IFJlZ0V4cChcIlstK11cIi5jb25jYXQodGltZUhvdXIuc291cmNlLCBcIjpcIikuY29uY2F0KHRpbWVNaW51dGUuc291cmNlKSk7XG52YXIgdGltZU9mZnNldCA9IG5ldyBSZWdFeHAoXCIoW3paXXxcIi5jb25jYXQodGltZU51bU9mZnNldC5zb3VyY2UsIFwiKVwiKSk7XG52YXIgcGFydGlhbFRpbWUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHRpbWVIb3VyLnNvdXJjZSwgXCI6XCIpLmNvbmNhdCh0aW1lTWludXRlLnNvdXJjZSwgXCI6XCIpLmNvbmNhdCh0aW1lU2Vjb25kLnNvdXJjZSkuY29uY2F0KHRpbWVTZWNGcmFjLnNvdXJjZSkpO1xudmFyIGZ1bGxEYXRlID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChkYXRlRnVsbFllYXIuc291cmNlLCBcIi1cIikuY29uY2F0KGRhdGVNb250aC5zb3VyY2UsIFwiLVwiKS5jb25jYXQoZGF0ZU1EYXkuc291cmNlKSk7XG52YXIgZnVsbFRpbWUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHBhcnRpYWxUaW1lLnNvdXJjZSkuY29uY2F0KHRpbWVPZmZzZXQuc291cmNlKSk7XG52YXIgcmZjMzMzOSA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoZnVsbERhdGUuc291cmNlLCBcIlsgdFRdXCIpLmNvbmNhdChmdWxsVGltZS5zb3VyY2UpKTtcblxuZnVuY3Rpb24gaXNSRkMzMzM5KHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gcmZjMzMzOS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzU3Vycm9nYXRlUGFpcjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cnJvZ2F0ZVBhaXIgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS87XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN1cnJvZ2F0ZVBhaXIudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VSTDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzRlFETlwiKSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNJUFwiKSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWVyZ2VcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF91cmxfb3B0aW9ucyA9IHtcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJ10sXG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICByZXF1aXJlX3Byb3RvY29sOiBmYWxzZSxcbiAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICByZXF1aXJlX3ZhbGlkX3Byb3RvY29sOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gIGFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHM6IGZhbHNlXG59O1xudmFyIHdyYXBwZWRfaXB2NiA9IC9eXFxbKFteXFxdXSspXFxdKD86OihbMC05XSspKT8kLztcblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG5cbiAgICBpZiAoaG9zdCA9PT0gbWF0Y2ggfHwgaXNSZWdFeHAobWF0Y2gpICYmIG1hdGNoLnRlc3QoaG9zdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVUkwodXJsLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHVybCk7XG5cbiAgaWYgKCF1cmwgfHwgdXJsLmxlbmd0aCA+PSAyMDgzIHx8IC9bXFxzPD5dLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodXJsLmluZGV4T2YoJ21haWx0bzonKSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfdXJsX29wdGlvbnMpO1xuICB2YXIgcHJvdG9jb2wsIGF1dGgsIGhvc3QsIGhvc3RuYW1lLCBwb3J0LCBwb3J0X3N0ciwgc3BsaXQsIGlwdjY7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcjJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc/Jyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc6Ly8nKTtcblxuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIHByb3RvY29sID0gc3BsaXQuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZV92YWxpZF9wcm90b2NvbCAmJiBvcHRpb25zLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX3Byb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJscykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNwbGl0WzBdID0gdXJsLnN1YnN0cigyKTtcbiAgfVxuXG4gIHVybCA9IHNwbGl0LmpvaW4oJzovLycpO1xuXG4gIGlmICh1cmwgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcblxuICBpZiAodXJsID09PSAnJyAmJiAhb3B0aW9ucy5yZXF1aXJlX2hvc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCdAJyk7XG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhbGxvd19hdXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXV0aCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgICBpZiAoYXV0aC5pbmRleE9mKCc6JykgPj0gMCAmJiBhdXRoLnNwbGl0KCc6JykubGVuZ3RoID4gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xuICBwb3J0X3N0ciA9IG51bGw7XG4gIGlwdjYgPSBudWxsO1xuICB2YXIgaXB2Nl9tYXRjaCA9IGhvc3RuYW1lLm1hdGNoKHdyYXBwZWRfaXB2Nik7XG5cbiAgaWYgKGlwdjZfbWF0Y2gpIHtcbiAgICBob3N0ID0gJyc7XG4gICAgaXB2NiA9IGlwdjZfbWF0Y2hbMV07XG4gICAgcG9ydF9zdHIgPSBpcHY2X21hdGNoWzJdIHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBob3N0bmFtZS5zcGxpdCgnOicpO1xuICAgIGhvc3QgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKHNwbGl0Lmxlbmd0aCkge1xuICAgICAgcG9ydF9zdHIgPSBzcGxpdC5qb2luKCc6Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcnRfc3RyICE9PSBudWxsKSB7XG4gICAgcG9ydCA9IHBhcnNlSW50KHBvcnRfc3RyLCAxMCk7XG5cbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChwb3J0X3N0cikgfHwgcG9ydCA8PSAwIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0lQLmRlZmF1bHQpKGhvc3QpICYmICEoMCwgX2lzRlFETi5kZWZhdWx0KShob3N0LCBvcHRpb25zKSAmJiAoIWlwdjYgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShpcHY2LCA2KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBob3N0ID0gaG9zdCB8fCBpcHY2O1xuXG4gIGlmIChvcHRpb25zLmhvc3Rfd2hpdGVsaXN0ICYmICFjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X3doaXRlbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ob3N0X2JsYWNrbGlzdCAmJiBjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X2JsYWNrbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVVUlEO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXVpZCA9IHtcbiAgMzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS0zWzAtOUEtRl17M30tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pLFxuICA0OiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTRbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gIDU6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNVswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSxcbiAgYWxsOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaVxufTtcblxuZnVuY3Rpb24gaXNVVUlEKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FsbCc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBwYXR0ZXJuID0gdXVpZFt2ZXJzaW9uXTtcbiAgcmV0dXJuIHBhdHRlcm4gJiYgcGF0dGVybi50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVXBwZXJjYXNlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1VwcGVyY2FzZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ciA9PT0gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFyaWFibGVXaWR0aDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pc0Z1bGxXaWR0aCA9IHJlcXVpcmUoXCIuL2lzRnVsbFdpZHRoXCIpO1xuXG52YXIgX2lzSGFsZldpZHRoID0gcmVxdWlyZShcIi4vaXNIYWxmV2lkdGhcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVXaWR0aChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIF9pc0Z1bGxXaWR0aC5mdWxsV2lkdGgudGVzdChzdHIpICYmIF9pc0hhbGZXaWR0aC5oYWxmV2lkdGgudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1doaXRlbGlzdGVkO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1doaXRlbGlzdGVkKHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGNoYXJzLmluZGV4T2Yoc3RyW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbHRyaW07XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGx0cmltKHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHBhdHRlcm4gPSBjaGFycyA/IG5ldyBSZWdFeHAoXCJeW1wiLmNvbmNhdChjaGFycywgXCJdK1wiKSwgJ2cnKSA6IC9eXFxzKy9nO1xuICByZXR1cm4gc3RyLnJlcGxhY2UocGF0dGVybiwgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaGVzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBtYXRjaGVzKHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXR0ZXJuKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm4udGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBub3JtYWxpemVFbWFpbDtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X25vcm1hbGl6ZV9lbWFpbF9vcHRpb25zID0ge1xuICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXBwbHkgdG8gYWxsIGVtYWlsIGFkZHJlc3Nlc1xuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzLlxuICAvLyBQbGVhc2Ugbm90ZSB0aGlzIG1heSB2aW9sYXRlIFJGQyA1MzIxIGFzIHBlciBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85ODA4MzMyLzE5MjAyNCkuXG4gIC8vIFRoZSBkb21haW4gaXMgYWx3YXlzIGxvd2VyY2FzZWQsIGFzIHBlciBSRkMgMTAzNVxuICBhbGxfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBUaGUgZm9sbG93aW5nIGNvbnZlcnNpb25zIGFyZSBzcGVjaWZpYyB0byBHTWFpbFxuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBHTWFpbCBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICBnbWFpbF9sb3dlcmNhc2U6IHRydWUsXG4gIC8vIFJlbW92ZXMgZG90cyBmcm9tIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzLCBhcyB0aGF0J3MgaWdub3JlZCBieSBHTWFpbFxuICBnbWFpbF9yZW1vdmVfZG90czogdHJ1ZSxcbiAgLy8gUmVtb3ZlcyB0aGUgc3ViYWRkcmVzcyAoZS5nLiBcIitmb29cIikgZnJvbSB0aGUgZW1haWwgYWRkcmVzc1xuICBnbWFpbF9yZW1vdmVfc3ViYWRkcmVzczogdHJ1ZSxcbiAgLy8gQ29udmVyc3RzIHRoZSBnb29nbGVtYWlsLmNvbSBkb21haW4gdG8gZ21haWwuY29tXG4gIGdtYWlsX2NvbnZlcnRfZ29vZ2xlbWFpbGRvdGNvbTogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gT3V0bG9vay5jb20gLyBXaW5kb3dzIExpdmUgLyBIb3RtYWlsXG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIE91dGxvb2suY29tIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIG91dGxvb2tkb3Rjb21fbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBSZW1vdmVzIHRoZSBzdWJhZGRyZXNzIChlLmcuIFwiK2Zvb1wiKSBmcm9tIHRoZSBlbWFpbCBhZGRyZXNzXG4gIG91dGxvb2tkb3Rjb21fcmVtb3ZlX3N1YmFkZHJlc3M6IHRydWUsXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29udmVyc2lvbnMgYXJlIHNwZWNpZmljIHRvIFlhaG9vXG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIFlhaG9vIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIHlhaG9vX2xvd2VyY2FzZTogdHJ1ZSxcbiAgLy8gUmVtb3ZlcyB0aGUgc3ViYWRkcmVzcyAoZS5nLiBcIi1mb29cIikgZnJvbSB0aGUgZW1haWwgYWRkcmVzc1xuICB5YWhvb19yZW1vdmVfc3ViYWRkcmVzczogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gWWFuZGV4XG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIFlhbmRleCBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICB5YW5kZXhfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBUaGUgZm9sbG93aW5nIGNvbnZlcnNpb25zIGFyZSBzcGVjaWZpYyB0byBpQ2xvdWRcbiAgLy8gTG93ZXJjYXNlcyB0aGUgbG9jYWwgcGFydCBvZiB0aGUgaUNsb3VkIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIGljbG91ZF9sb3dlcmNhc2U6IHRydWUsXG4gIC8vIFJlbW92ZXMgdGhlIHN1YmFkZHJlc3MgKGUuZy4gXCIrZm9vXCIpIGZyb20gdGhlIGVtYWlsIGFkZHJlc3NcbiAgaWNsb3VkX3JlbW92ZV9zdWJhZGRyZXNzOiB0cnVlXG59OyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBpQ2xvdWRcblxudmFyIGljbG91ZF9kb21haW5zID0gWydpY2xvdWQuY29tJywgJ21lLmNvbSddOyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBPdXRsb29rLmNvbSBhbmQgaXRzIHByZWRlY2Vzc29yc1xuLy8gVGhpcyBsaXN0IGlzIGxpa2VseSBpbmNvbXBsZXRlLlxuLy8gUGFydGlhbCByZWZlcmVuY2U6XG4vLyBodHRwczovL2Jsb2dzLm9mZmljZS5jb20vMjAxMy8wNC8xNy9vdXRsb29rLWNvbS1nZXRzLXR3by1zdGVwLXZlcmlmaWNhdGlvbi1zaWduLWluLWJ5LWFsaWFzLWFuZC1uZXctaW50ZXJuYXRpb25hbC1kb21haW5zL1xuXG52YXIgb3V0bG9va2RvdGNvbV9kb21haW5zID0gWydob3RtYWlsLmF0JywgJ2hvdG1haWwuYmUnLCAnaG90bWFpbC5jYScsICdob3RtYWlsLmNsJywgJ2hvdG1haWwuY28uaWwnLCAnaG90bWFpbC5jby5ueicsICdob3RtYWlsLmNvLnRoJywgJ2hvdG1haWwuY28udWsnLCAnaG90bWFpbC5jb20nLCAnaG90bWFpbC5jb20uYXInLCAnaG90bWFpbC5jb20uYXUnLCAnaG90bWFpbC5jb20uYnInLCAnaG90bWFpbC5jb20uZ3InLCAnaG90bWFpbC5jb20ubXgnLCAnaG90bWFpbC5jb20ucGUnLCAnaG90bWFpbC5jb20udHInLCAnaG90bWFpbC5jb20udm4nLCAnaG90bWFpbC5jeicsICdob3RtYWlsLmRlJywgJ2hvdG1haWwuZGsnLCAnaG90bWFpbC5lcycsICdob3RtYWlsLmZyJywgJ2hvdG1haWwuaHUnLCAnaG90bWFpbC5pZCcsICdob3RtYWlsLmllJywgJ2hvdG1haWwuaW4nLCAnaG90bWFpbC5pdCcsICdob3RtYWlsLmpwJywgJ2hvdG1haWwua3InLCAnaG90bWFpbC5sdicsICdob3RtYWlsLm15JywgJ2hvdG1haWwucGgnLCAnaG90bWFpbC5wdCcsICdob3RtYWlsLnNhJywgJ2hvdG1haWwuc2cnLCAnaG90bWFpbC5zaycsICdsaXZlLmJlJywgJ2xpdmUuY28udWsnLCAnbGl2ZS5jb20nLCAnbGl2ZS5jb20uYXInLCAnbGl2ZS5jb20ubXgnLCAnbGl2ZS5kZScsICdsaXZlLmVzJywgJ2xpdmUuZXUnLCAnbGl2ZS5mcicsICdsaXZlLml0JywgJ2xpdmUubmwnLCAnbXNuLmNvbScsICdvdXRsb29rLmF0JywgJ291dGxvb2suYmUnLCAnb3V0bG9vay5jbCcsICdvdXRsb29rLmNvLmlsJywgJ291dGxvb2suY28ubnonLCAnb3V0bG9vay5jby50aCcsICdvdXRsb29rLmNvbScsICdvdXRsb29rLmNvbS5hcicsICdvdXRsb29rLmNvbS5hdScsICdvdXRsb29rLmNvbS5icicsICdvdXRsb29rLmNvbS5ncicsICdvdXRsb29rLmNvbS5wZScsICdvdXRsb29rLmNvbS50cicsICdvdXRsb29rLmNvbS52bicsICdvdXRsb29rLmN6JywgJ291dGxvb2suZGUnLCAnb3V0bG9vay5kaycsICdvdXRsb29rLmVzJywgJ291dGxvb2suZnInLCAnb3V0bG9vay5odScsICdvdXRsb29rLmlkJywgJ291dGxvb2suaWUnLCAnb3V0bG9vay5pbicsICdvdXRsb29rLml0JywgJ291dGxvb2suanAnLCAnb3V0bG9vay5rcicsICdvdXRsb29rLmx2JywgJ291dGxvb2subXknLCAnb3V0bG9vay5waCcsICdvdXRsb29rLnB0JywgJ291dGxvb2suc2EnLCAnb3V0bG9vay5zZycsICdvdXRsb29rLnNrJywgJ3Bhc3Nwb3J0LmNvbSddOyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBZYWhvbyBNYWlsXG4vLyBUaGlzIGxpc3QgaXMgbGlrZWx5IGluY29tcGxldGVcblxudmFyIHlhaG9vX2RvbWFpbnMgPSBbJ3JvY2tldG1haWwuY29tJywgJ3lhaG9vLmNhJywgJ3lhaG9vLmNvLnVrJywgJ3lhaG9vLmNvbScsICd5YWhvby5kZScsICd5YWhvby5mcicsICd5YWhvby5pbicsICd5YWhvby5pdCcsICd5bWFpbC5jb20nXTsgLy8gTGlzdCBvZiBkb21haW5zIHVzZWQgYnkgeWFuZGV4LnJ1XG5cbnZhciB5YW5kZXhfZG9tYWlucyA9IFsneWFuZGV4LnJ1JywgJ3lhbmRleC51YScsICd5YW5kZXgua3onLCAneWFuZGV4LmNvbScsICd5YW5kZXguYnknLCAneWEucnUnXTsgLy8gcmVwbGFjZSBzaW5nbGUgZG90cywgYnV0IG5vdCBtdWx0aXBsZSBjb25zZWN1dGl2ZSBkb3RzXG5cbmZ1bmN0aW9uIGRvdHNSZXBsYWNlcihtYXRjaCkge1xuICBpZiAobWF0Y2gubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRW1haWwoZW1haWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9ub3JtYWxpemVfZW1haWxfb3B0aW9ucyk7XG4gIHZhciByYXdfcGFydHMgPSBlbWFpbC5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcmF3X3BhcnRzLnBvcCgpO1xuICB2YXIgdXNlciA9IHJhd19wYXJ0cy5qb2luKCdAJyk7XG4gIHZhciBwYXJ0cyA9IFt1c2VyLCBkb21haW5dOyAvLyBUaGUgZG9tYWluIGlzIGFsd2F5cyBsb3dlcmNhc2VkLCBhcyBpdCdzIGNhc2UtaW5zZW5zaXRpdmUgcGVyIFJGQyAxMDM1XG5cbiAgcGFydHNbMV0gPSBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChwYXJ0c1sxXSA9PT0gJ2dtYWlsLmNvbScgfHwgcGFydHNbMV0gPT09ICdnb29nbGVtYWlsLmNvbScpIHtcbiAgICAvLyBBZGRyZXNzIGlzIEdNYWlsXG4gICAgaWYgKG9wdGlvbnMuZ21haWxfcmVtb3ZlX3N1YmFkZHJlc3MpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0uc3BsaXQoJysnKVswXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5nbWFpbF9yZW1vdmVfZG90cykge1xuICAgICAgLy8gdGhpcyBkb2VzIG5vdCByZXBsYWNlIGNvbnNlY3V0aXZlIGRvdHMgbGlrZSBleGFtcGxlLi5lbWFpbEBnbWFpbC5jb21cbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZSgvXFwuKy9nLCBkb3RzUmVwbGFjZXIpO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLmdtYWlsX2xvd2VyY2FzZSkge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHBhcnRzWzFdID0gb3B0aW9ucy5nbWFpbF9jb252ZXJ0X2dvb2dsZW1haWxkb3Rjb20gPyAnZ21haWwuY29tJyA6IHBhcnRzWzFdO1xuICB9IGVsc2UgaWYgKGljbG91ZF9kb21haW5zLmluZGV4T2YocGFydHNbMV0pID49IDApIHtcbiAgICAvLyBBZGRyZXNzIGlzIGlDbG91ZFxuICAgIGlmIChvcHRpb25zLmljbG91ZF9yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5zcGxpdCgnKycpWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLmljbG91ZF9sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3V0bG9va2RvdGNvbV9kb21haW5zLmluZGV4T2YocGFydHNbMV0pID49IDApIHtcbiAgICAvLyBBZGRyZXNzIGlzIE91dGxvb2suY29tXG4gICAgaWYgKG9wdGlvbnMub3V0bG9va2RvdGNvbV9yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5zcGxpdCgnKycpWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLm91dGxvb2tkb3Rjb21fbG93ZXJjYXNlKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHlhaG9vX2RvbWFpbnMuaW5kZXhPZihwYXJ0c1sxXSkgPj0gMCkge1xuICAgIC8vIEFkZHJlc3MgaXMgWWFob29cbiAgICBpZiAob3B0aW9ucy55YWhvb19yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBwYXJ0c1swXS5zcGxpdCgnLScpO1xuICAgICAgcGFydHNbMF0gPSBjb21wb25lbnRzLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzLnNsaWNlKDAsIC0xKS5qb2luKCctJykgOiBjb21wb25lbnRzWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLnlhaG9vX2xvd2VyY2FzZSkge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5YW5kZXhfZG9tYWlucy5pbmRleE9mKHBhcnRzWzFdKSA+PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLnlhbmRleF9sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBwYXJ0c1sxXSA9ICd5YW5kZXgucnUnOyAvLyBhbGwgeWFuZGV4IGRvbWFpbnMgYXJlIGVxdWFsLCAxc3QgcHJlZmZlcmVkXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxfbG93ZXJjYXNlKSB7XG4gICAgLy8gQW55IG90aGVyIGFkZHJlc3NcbiAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignQCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBydHJpbTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcnRyaW0oc3RyLCBjaGFycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGF0dGVybiA9IGNoYXJzID8gbmV3IFJlZ0V4cChcIltcIi5jb25jYXQoY2hhcnMsIFwiXVwiKSkgOiAvXFxzLztcbiAgdmFyIGlkeCA9IHN0ci5sZW5ndGggLSAxO1xuXG4gIGZvciAoOyBpZHggPj0gMCAmJiBwYXR0ZXJuLnRlc3Qoc3RyW2lkeF0pOyBpZHgtLSkge1xuICAgIDtcbiAgfVxuXG4gIHJldHVybiBpZHggPCBzdHIubGVuZ3RoID8gc3RyLnN1YnN0cigwLCBpZHggKyAxKSA6IHN0cjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaXBMb3c7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYmxhY2tsaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ibGFja2xpc3RcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdHJpcExvdyhzdHIsIGtlZXBfbmV3X2xpbmVzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBjaGFycyA9IGtlZXBfbmV3X2xpbmVzID8gJ1xcXFx4MDAtXFxcXHgwOVxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3RicgOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3Ric7XG4gIHJldHVybiAoMCwgX2JsYWNrbGlzdC5kZWZhdWx0KShzdHIsIGNoYXJzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9Cb29sZWFuO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0Jvb2xlYW4oc3RyLCBzdHJpY3QpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAoc3RyaWN0KSB7XG4gICAgcmV0dXJuIHN0ciA9PT0gJzEnIHx8IHN0ciA9PT0gJ3RydWUnO1xuICB9XG5cbiAgcmV0dXJuIHN0ciAhPT0gJzAnICYmIHN0ciAhPT0gJ2ZhbHNlJyAmJiBzdHIgIT09ICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0RhdGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvRGF0ZShkYXRlKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKGRhdGUpO1xuICBkYXRlID0gRGF0ZS5wYXJzZShkYXRlKTtcbiAgcmV0dXJuICFpc05hTihkYXRlKSA/IG5ldyBEYXRlKGRhdGUpIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9GbG9hdDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9GbG9hdChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9JbnQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvSW50KHN0ciwgcmFkaXgpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgcmFkaXggfHwgMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xuXG52YXIgX3J0cmltID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ydHJpbVwiKSk7XG5cbnZhciBfbHRyaW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2x0cmltXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdHJpbShzdHIsIGNoYXJzKSB7XG4gIHJldHVybiAoMCwgX3J0cmltLmRlZmF1bHQpKCgwLCBfbHRyaW0uZGVmYXVsdCkoc3RyLCBjaGFycyksIGNoYXJzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5lc2NhcGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyZhbXA7L2csICcmJykucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpLnJlcGxhY2UoLyYjeDI3Oy9nLCBcIidcIikucmVwbGFjZSgvJmx0Oy9nLCAnPCcpLnJlcGxhY2UoLyZndDsvZywgJz4nKS5yZXBsYWNlKC8mI3gyRjsvZywgJy8nKS5yZXBsYWNlKC8mI3g1QzsvZywgJ1xcXFwnKS5yZXBsYWNlKC8mIzk2Oy9nLCAnYCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnRTdHJpbmc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICB2YXIgaW52YWxpZFR5cGU7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgIGludmFsaWRUeXBlID0gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhbGlkVHlwZSA9IF90eXBlb2YoaW5wdXQpO1xuXG4gICAgICBpZiAoaW52YWxpZFR5cGUgPT09ICdvYmplY3QnICYmIGlucHV0LmNvbnN0cnVjdG9yICYmIGlucHV0LmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCduYW1lJykpIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBcImEgXCIuY29uY2F0KGludmFsaWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCBcIi5jb25jYXQoaW52YWxpZFR5cGUsIFwiLlwiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGFyclZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IGFyclZhbDtcbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpbmNsdWRlcztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWVyZ2U7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b1N0cmluZztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdG9TdHJpbmcoaW5wdXQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0JyAmJiBpbnB1dCAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCBpc05hTihpbnB1dCkgJiYgIWlucHV0Lmxlbmd0aCkge1xuICAgIGlucHV0ID0gJyc7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2hpdGVsaXN0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB3aGl0ZWxpc3Qoc3RyLCBjaGFycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlteXCIuY29uY2F0KGNoYXJzLCBcIl0rXCIpLCAnZycpLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XG5cdHZhciB1bmFjY2VwdGVkTW9kdWxlcyA9IHVwZGF0ZWRNb2R1bGVzLmZpbHRlcihmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRyZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xuXHR9KTtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblxuXHRpZiAodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuXHRcdGxvZyhcblx0XHRcdFwid2FybmluZ1wiLFxuXHRcdFx0XCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IChUaGV5IHdvdWxkIG5lZWQgYSBmdWxsIHJlbG9hZCEpXCJcblx0XHQpO1xuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBOb3RoaW5nIGhvdCB1cGRhdGVkLlwiKTtcblx0fSBlbHNlIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcblx0XHRyZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJzdHJpbmdcIiAmJiBtb2R1bGVJZC5pbmRleE9mKFwiIVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gbW9kdWxlSWQuc3BsaXQoXCIhXCIpO1xuXHRcdFx0XHRsb2cuZ3JvdXBDb2xsYXBzZWQoXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBwYXJ0cy5wb3AoKSk7XG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHRcdFx0bG9nLmdyb3VwRW5kKFwiaW5mb1wiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIgbnVtYmVySWRzID0gcmVuZXdlZE1vZHVsZXMuZXZlcnkoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xuXHRcdH0pO1xuXHRcdGlmIChudW1iZXJJZHMpXG5cdFx0XHRsb2coXG5cdFx0XHRcdFwiaW5mb1wiLFxuXHRcdFx0XHQnW0hNUl0gQ29uc2lkZXIgdXNpbmcgdGhlIG9wdGltaXphdGlvbi5tb2R1bGVJZHM6IFwibmFtZWRcIiBmb3IgbW9kdWxlIG5hbWVzLidcblx0XHRcdCk7XG5cdH1cbn07XG4iLCJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8qZ2xvYmFscyBfX3Jlc291cmNlUXVlcnkgKi9cbmlmIChtb2R1bGUuaG90KSB7XG5cdHZhciBob3RQb2xsSW50ZXJ2YWwgPSArX19yZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSB8fCAxMCAqIDYwICogMTAwMDtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblxuXHR2YXIgY2hlY2tGb3JVcGRhdGUgPSBmdW5jdGlvbiBjaGVja0ZvclVwZGF0ZShmcm9tVXBkYXRlKSB7XG5cdFx0aWYgKG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XG5cdFx0XHRtb2R1bGUuaG90XG5cdFx0XHRcdC5jaGVjayh0cnVlKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMpIHtcblx0XHRcdFx0XHRpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbVVwZGF0ZSkgbG9nKFwiaW5mb1wiLCBcIltITVJdIFVwZGF0ZSBhcHBsaWVkLlwiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVxdWlyZShcIi4vbG9nLWFwcGx5LXJlc3VsdFwiKSh1cGRhdGVkTW9kdWxlcywgdXBkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRcdGNoZWNrRm9yVXBkYXRlKHRydWUpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdHZhciBzdGF0dXMgPSBtb2R1bGUuaG90LnN0YXR1cygpO1xuXHRcdFx0XHRcdGlmIChbXCJhYm9ydFwiLCBcImZhaWxcIl0uaW5kZXhPZihzdGF0dXMpID49IDApIHtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLlwiKTtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBZb3UgbmVlZCB0byByZXN0YXJ0IHRoZSBhcHBsaWNhdGlvbiFcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBVcGRhdGUgZmFpbGVkOiBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblx0c2V0SW50ZXJ2YWwoY2hlY2tGb3JVcGRhdGUsIGhvdFBvbGxJbnRlcnZhbCk7XG59IGVsc2Uge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQmluYXJ5UmVhZGVyO1xyXG5cclxuZnVuY3Rpb24gQmluYXJ5UmVhZGVyKGJ1ZmZlciwgaXNCaWdFbmRpYW4pIHtcclxuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICB0aGlzLmlzQmlnRW5kaWFuID0gaXNCaWdFbmRpYW4gfHwgZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9yZWFkKHJlYWRMRSwgcmVhZEJFLCBzaXplKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNCaWdFbmRpYW4pXHJcbiAgICAgICAgICAgIHZhbHVlID0gcmVhZEJFLmNhbGwodGhpcy5idWZmZXIsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsdWUgPSByZWFkTEUuY2FsbCh0aGlzLmJ1ZmZlciwgdGhpcy5wb3NpdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufVxyXG5cclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDggPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCwgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDgsIDEpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50MTYgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUsIDIpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50MzIgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUsIDQpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCwgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCwgMSk7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZEludDE2ID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSwgMik7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZEludDMyID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSwgNCk7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZEZsb2F0ID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSwgNCk7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZERvdWJsZSA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFLCBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSwgOCk7XHJcblxyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmV4dEJ5dGUsXHJcbiAgICAgICAgcmVzdWx0ID0gMCxcclxuICAgICAgICBieXRlc1JlYWQgPSAwO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICBuZXh0Qnl0ZSA9IHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24gKyBieXRlc1JlYWRdO1xyXG4gICAgICAgIHJlc3VsdCArPSAobmV4dEJ5dGUgJiAweDdGKSA8PCAoNyAqIGJ5dGVzUmVhZCk7XHJcbiAgICAgICAgYnl0ZXNSZWFkKys7XHJcbiAgICB9IHdoaWxlIChuZXh0Qnl0ZSA+PSAweDgwKTtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVdyaXRlcjtcclxuXHJcbmZ1bmN0aW9uIEJpbmFyeVdyaXRlcihzaXplLCBhbGxvd1Jlc2l6ZSkge1xyXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKHNpemUpO1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICB0aGlzLmFsbG93UmVzaXplID0gYWxsb3dSZXNpemU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF93cml0ZSh3cml0ZSwgc2l6ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZVNpemUoc2l6ZSk7XHJcblxyXG4gICAgICAgIHdyaXRlLmNhbGwodGhpcy5idWZmZXIsIHZhbHVlLCB0aGlzLnBvc2l0aW9uLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplO1xyXG4gICAgfTtcclxufVxyXG5cclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlSW50OCA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCwgMSk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFLCAyKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUsIDgpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFLCA4KTtcclxuXHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICB0aGlzLmVuc3VyZVNpemUoYnVmZmVyLmxlbmd0aCk7XHJcblxyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5idWZmZXIsIHRoaXMucG9zaXRpb24sIDAsIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgdGhpcy5wb3NpdGlvbiArPSBidWZmZXIubGVuZ3RoO1xyXG59O1xyXG5cclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVZhckludCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIGxlbmd0aCA9IDE7XHJcblxyXG4gICAgd2hpbGUgKCh2YWx1ZSAmIDB4RkZGRkZGODApICE9PSAwKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KCh2YWx1ZSAmIDB4N0YpIHwgMHg4MCk7XHJcbiAgICAgICAgdmFsdWUgPj4+PSA3O1xyXG4gICAgICAgIGxlbmd0aCsrO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSAmIDB4N0YpO1xyXG5cclxuICAgIHJldHVybiBsZW5ndGg7XHJcbn07XHJcblxyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLmVuc3VyZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IHRoaXMucG9zaXRpb24gKyBzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNpemUpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMucG9zaXRpb24gKyBzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIuY29weSh0ZW1wQnVmZmVyLCAwLCAwLCB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRlbXBCdWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEdlb21ldHJ5O1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBMaW5lU3RyaW5nID0gcmVxdWlyZSgnLi9saW5lc3RyaW5nJyk7XHJcbnZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9wb2x5Z29uJyk7XHJcbnZhciBNdWx0aVBvaW50ID0gcmVxdWlyZSgnLi9tdWx0aXBvaW50Jyk7XHJcbnZhciBNdWx0aUxpbmVTdHJpbmcgPSByZXF1aXJlKCcuL211bHRpbGluZXN0cmluZycpO1xyXG52YXIgTXVsdGlQb2x5Z29uID0gcmVxdWlyZSgnLi9tdWx0aXBvbHlnb24nKTtcclxudmFyIEdlb21ldHJ5Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZ2VvbWV0cnljb2xsZWN0aW9uJyk7XHJcbnZhciBCaW5hcnlSZWFkZXIgPSByZXF1aXJlKCcuL2JpbmFyeXJlYWRlcicpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxudmFyIFdrdFBhcnNlciA9IHJlcXVpcmUoJy4vd2t0cGFyc2VyJyk7XHJcbnZhciBaaWdaYWcgPSByZXF1aXJlKCcuL3ppZ3phZy5qcycpO1xyXG5cclxuZnVuY3Rpb24gR2VvbWV0cnkoKSB7XHJcbiAgICB0aGlzLnNyaWQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhhc1ogPSBmYWxzZTtcclxuICAgIHRoaXMuaGFzTSA9IGZhbHNlO1xyXG59XHJcblxyXG5HZW9tZXRyeS5wYXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFdrdFBhcnNlcilcclxuICAgICAgICByZXR1cm4gR2VvbWV0cnkuX3BhcnNlV2t0KHZhbHVlKTtcclxuICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBCaW5hcnlSZWFkZXIpXHJcbiAgICAgICAgcmV0dXJuIEdlb21ldHJ5Ll9wYXJzZVdrYih2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlcicpO1xyXG59O1xyXG5cclxuR2VvbWV0cnkuX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgd2t0UGFyc2VyLFxyXG4gICAgICAgIHNyaWQ7XHJcblxyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgV2t0UGFyc2VyKVxyXG4gICAgICAgIHdrdFBhcnNlciA9IHZhbHVlO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHdrdFBhcnNlciA9IG5ldyBXa3RQYXJzZXIodmFsdWUpO1xyXG5cclxuICAgIHZhciBtYXRjaCA9IHdrdFBhcnNlci5tYXRjaFJlZ2V4KFsvXlNSSUQ9KFxcZCspOy9dKTtcclxuICAgIGlmIChtYXRjaClcclxuICAgICAgICBzcmlkID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0gd2t0UGFyc2VyLm1hdGNoVHlwZSgpO1xyXG4gICAgdmFyIGRpbWVuc2lvbiA9IHdrdFBhcnNlci5tYXRjaERpbWVuc2lvbigpO1xyXG5cclxuICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgIHNyaWQ6IHNyaWQsXHJcbiAgICAgICAgaGFzWjogZGltZW5zaW9uLmhhc1osXHJcbiAgICAgICAgaGFzTTogZGltZW5zaW9uLmhhc01cclxuICAgIH07XHJcblxyXG4gICAgc3dpdGNoIChnZW9tZXRyeVR5cGUpIHtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5Qb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Ll9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0LkxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lU3RyaW5nLl9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0LlBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBQb2x5Z29uLl9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0Lk11bHRpUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvaW50Ll9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0Lk11bHRpTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpTGluZVN0cmluZy5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5NdWx0aVBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvbHlnb24uX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuR2VvbWV0cnlDb2xsZWN0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR2VvbWV0cnkuX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJlbnRPcHRpb25zKSB7XHJcbiAgICB2YXIgYmluYXJ5UmVhZGVyLFxyXG4gICAgICAgIHdrYlR5cGUsXHJcbiAgICAgICAgZ2VvbWV0cnlUeXBlLFxyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnlSZWFkZXIpXHJcbiAgICAgICAgYmluYXJ5UmVhZGVyID0gdmFsdWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgYmluYXJ5UmVhZGVyID0gbmV3IEJpbmFyeVJlYWRlcih2YWx1ZSk7XHJcblxyXG4gICAgYmluYXJ5UmVhZGVyLmlzQmlnRW5kaWFuID0gIWJpbmFyeVJlYWRlci5yZWFkSW50OCgpO1xyXG5cclxuICAgIHdrYlR5cGUgPSBiaW5hcnlSZWFkZXIucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIG9wdGlvbnMuaGFzU3JpZCA9ICh3a2JUeXBlICYgMHgyMDAwMDAwMCkgPT09IDB4MjAwMDAwMDA7XHJcbiAgICBvcHRpb25zLmlzRXdrYiA9ICh3a2JUeXBlICYgMHgyMDAwMDAwMCkgfHwgKHdrYlR5cGUgJiAweDQwMDAwMDAwKSB8fCAod2tiVHlwZSAmIDB4ODAwMDAwMDApO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc1NyaWQpXHJcbiAgICAgICAgb3B0aW9ucy5zcmlkID0gYmluYXJ5UmVhZGVyLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBvcHRpb25zLmhhc1ogPSBmYWxzZTtcclxuICAgIG9wdGlvbnMuaGFzTSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5pc0V3a2IgJiYgKCFwYXJlbnRPcHRpb25zIHx8ICFwYXJlbnRPcHRpb25zLmlzRXdrYikpIHtcclxuICAgICAgICBpZiAod2tiVHlwZSA+PSAxMDAwICYmIHdrYlR5cGUgPCAyMDAwKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzWiA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9IHdrYlR5cGUgLSAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3a2JUeXBlID49IDIwMDAgJiYgd2tiVHlwZSA8IDMwMDApIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNNID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlID0gd2tiVHlwZSAtIDIwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHdrYlR5cGUgPj0gMzAwMCAmJiB3a2JUeXBlIDwgNDAwMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmhhc1ogPSB0cnVlO1xyXG4gICAgICAgICAgICBvcHRpb25zLmhhc00gPSB0cnVlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSB3a2JUeXBlIC0gMzAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9IHdrYlR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHdrYlR5cGUgJiAweDgwMDAwMDAwKVxyXG4gICAgICAgICAgICBvcHRpb25zLmhhc1ogPSB0cnVlO1xyXG4gICAgICAgIGlmICh3a2JUeXBlICYgMHg0MDAwMDAwMClcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNNID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnlUeXBlID0gd2tiVHlwZSAmIDB4RjtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLlBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIExpbmVTdHJpbmcuX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIFBvbHlnb24uX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlQb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9pbnQuX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlMaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9seWdvbi5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5HZW9tZXRyeUNvbGxlY3Rpb246XHJcbiAgICAgICAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW9tZXRyeVR5cGUgJyArIGdlb21ldHJ5VHlwZSArICcgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR2VvbWV0cnkucGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgYmluYXJ5UmVhZGVyLFxyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnlSZWFkZXIpXHJcbiAgICAgICAgYmluYXJ5UmVhZGVyID0gdmFsdWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgYmluYXJ5UmVhZGVyID0gbmV3IEJpbmFyeVJlYWRlcih2YWx1ZSk7XHJcblxyXG4gICAgdmFyIHR5cGUgPSBiaW5hcnlSZWFkZXIucmVhZFVJbnQ4KCk7XHJcbiAgICB2YXIgbWV0YWRhdGFIZWFkZXIgPSBiaW5hcnlSZWFkZXIucmVhZFVJbnQ4KCk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHR5cGUgJiAweDBGO1xyXG4gICAgb3B0aW9ucy5wcmVjaXNpb24gPSBaaWdaYWcuZGVjb2RlKHR5cGUgPj4gNCk7XHJcbiAgICBvcHRpb25zLnByZWNpc2lvbkZhY3RvciA9IE1hdGgucG93KDEwLCBvcHRpb25zLnByZWNpc2lvbik7XHJcblxyXG4gICAgb3B0aW9ucy5oYXNCb3VuZGluZ0JveCA9IG1ldGFkYXRhSGVhZGVyID4+IDAgJiAxO1xyXG4gICAgb3B0aW9ucy5oYXNTaXplQXR0cmlidXRlID0gbWV0YWRhdGFIZWFkZXIgPj4gMSAmIDE7XHJcbiAgICBvcHRpb25zLmhhc0lkTGlzdCA9IG1ldGFkYXRhSGVhZGVyID4+IDIgJiAxO1xyXG4gICAgb3B0aW9ucy5oYXNFeHRlbmRlZFByZWNpc2lvbiA9IG1ldGFkYXRhSGVhZGVyID4+IDMgJiAxO1xyXG4gICAgb3B0aW9ucy5pc0VtcHR5ID0gbWV0YWRhdGFIZWFkZXIgPj4gNCAmIDE7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzRXh0ZW5kZWRQcmVjaXNpb24pIHtcclxuICAgICAgICB2YXIgZXh0ZW5kZWRQcmVjaXNpb24gPSBiaW5hcnlSZWFkZXIucmVhZFVJbnQ4KCk7XHJcbiAgICAgICAgb3B0aW9ucy5oYXNaID0gKGV4dGVuZGVkUHJlY2lzaW9uICYgMHgwMSkgPT09IDB4MDE7XHJcbiAgICAgICAgb3B0aW9ucy5oYXNNID0gKGV4dGVuZGVkUHJlY2lzaW9uICYgMHgwMikgPT09IDB4MDI7XHJcblxyXG4gICAgICAgIG9wdGlvbnMuelByZWNpc2lvbiA9IFppZ1phZy5kZWNvZGUoKGV4dGVuZGVkUHJlY2lzaW9uICYgMHgxQykgPj4gMik7XHJcbiAgICAgICAgb3B0aW9ucy56UHJlY2lzaW9uRmFjdG9yID0gTWF0aC5wb3coMTAsIG9wdGlvbnMuelByZWNpc2lvbik7XHJcblxyXG4gICAgICAgIG9wdGlvbnMubVByZWNpc2lvbiA9IFppZ1phZy5kZWNvZGUoKGV4dGVuZGVkUHJlY2lzaW9uICYgMHhFMCkgPj4gNSk7XHJcbiAgICAgICAgb3B0aW9ucy5tUHJlY2lzaW9uRmFjdG9yID0gTWF0aC5wb3coMTAsIG9wdGlvbnMubVByZWNpc2lvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvcHRpb25zLmhhc1ogPSBmYWxzZTtcclxuICAgICAgICBvcHRpb25zLmhhc00gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNTaXplQXR0cmlidXRlKVxyXG4gICAgICAgIGJpbmFyeVJlYWRlci5yZWFkVmFySW50KCk7XHJcbiAgICBpZiAob3B0aW9ucy5oYXNCb3VuZGluZ0JveCkge1xyXG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gMjtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzWilcclxuICAgICAgICAgICAgZGltZW5zaW9ucysrO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc00pXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnMrKztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgYmluYXJ5UmVhZGVyLnJlYWRWYXJJbnQoKTtcclxuICAgICAgICAgICAgYmluYXJ5UmVhZGVyLnJlYWRWYXJJbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChnZW9tZXRyeVR5cGUpIHtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5Qb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Ll9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5MaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTGluZVN0cmluZy5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIFBvbHlnb24uX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvaW50Ll9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aUxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aUxpbmVTdHJpbmcuX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9seWdvbi5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuR2VvbWV0cnlDb2xsZWN0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5VHlwZSAnICsgZ2VvbWV0cnlUeXBlICsgJyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBHZW9tZXRyeS5fcGFyc2VHZW9KU09OKHZhbHVlKTtcclxufTtcclxuXHJcbkdlb21ldHJ5Ll9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUsIGlzU3ViR2VvbWV0cnkpIHtcclxuICAgIHZhciBnZW9tZXRyeTtcclxuXHJcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uUG9pbnQ6XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gUG9pbnQuX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5MaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IExpbmVTdHJpbmcuX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5Qb2x5Z29uOlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IFBvbHlnb24uX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5NdWx0aVBvaW50OlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IE11bHRpUG9pbnQuX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5NdWx0aUxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gTXVsdGlMaW5lU3RyaW5nLl9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uTXVsdGlQb2x5Z29uOlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IE11bHRpUG9seWdvbi5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLkdlb21ldHJ5Q29sbGVjdGlvbjpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBHZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2VvbWV0cnlUeXBlICcgKyB2YWx1ZS50eXBlICsgJyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZhbHVlLmNycyAmJiB2YWx1ZS5jcnMudHlwZSAmJiB2YWx1ZS5jcnMudHlwZSA9PT0gJ25hbWUnICYmIHZhbHVlLmNycy5wcm9wZXJ0aWVzICYmIHZhbHVlLmNycy5wcm9wZXJ0aWVzLm5hbWUpIHtcclxuICAgICAgICB2YXIgY3JzID0gdmFsdWUuY3JzLnByb3BlcnRpZXMubmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGNycy5pbmRleE9mKCdFUFNHOicpID09PSAwKVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5zcmlkID0gcGFyc2VJbnQoY3JzLnN1YnN0cmluZyg1KSk7XHJcbiAgICAgICAgZWxzZSBpZiAoY3JzLmluZGV4T2YoJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjonKSA9PT0gMClcclxuICAgICAgICAgICAgZ2VvbWV0cnkuc3JpZCA9IHBhcnNlSW50KGNycy5zdWJzdHJpbmcoMjIpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3JzOiAnICsgY3JzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc1N1Ykdlb21ldHJ5KSB7XHJcbiAgICAgICAgZ2VvbWV0cnkuc3JpZCA9IDQzMjY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLnRvRXdrdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAnU1JJRD0nICsgdGhpcy5zcmlkICsgJzsnICsgdGhpcy50b1drdCgpO1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLnRvRXdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBld2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkgKyA0KTtcclxuICAgIHZhciB3a2IgPSB0aGlzLnRvV2tiKCk7XHJcblxyXG4gICAgZXdrYi53cml0ZUludDgoMSk7XHJcbiAgICBld2tiLndyaXRlVUludDMyTEUoKHdrYi5zbGljZSgxLCA1KS5yZWFkVUludDMyTEUoMCkgfCAweDIwMDAwMDAwKSA+Pj4gMCwgdHJ1ZSk7XHJcbiAgICBld2tiLndyaXRlVUludDMyTEUodGhpcy5zcmlkKTtcclxuXHJcbiAgICBld2tiLndyaXRlQnVmZmVyKHdrYi5zbGljZSg1KSk7XHJcblxyXG4gICAgcmV0dXJuIGV3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLl9nZXRXa3RUeXBlID0gZnVuY3Rpb24gKHdrdFR5cGUsIGlzRW1wdHkpIHtcclxuICAgIHZhciB3a3QgPSB3a3RUeXBlO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1ogJiYgdGhpcy5oYXNNKVxyXG4gICAgICAgIHdrdCArPSAnIFpNICc7XHJcbiAgICBlbHNlIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgd2t0ICs9ICcgWiAnO1xyXG4gICAgZWxzZSBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIHdrdCArPSAnIE0gJztcclxuXHJcbiAgICBpZiAoaXNFbXB0eSAmJiAhdGhpcy5oYXNaICYmICF0aGlzLmhhc00pXHJcbiAgICAgICAgd2t0ICs9ICcgJztcclxuXHJcbiAgICBpZiAoaXNFbXB0eSlcclxuICAgICAgICB3a3QgKz0gJ0VNUFRZJztcclxuXHJcbiAgICByZXR1cm4gd2t0O1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLl9nZXRXa3RDb29yZGluYXRlID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwb2ludC54ICsgJyAnICsgcG9pbnQueTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIGNvb3JkaW5hdGVzICs9ICcgJyArIHBvaW50Lno7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIGNvb3JkaW5hdGVzICs9ICcgJyArIHBvaW50Lm07XHJcblxyXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLl93cml0ZVdrYlR5cGUgPSBmdW5jdGlvbiAod2tiLCBnZW9tZXRyeVR5cGUsIHBhcmVudE9wdGlvbnMpIHtcclxuICAgIHZhciBkaW1lbnNpb25UeXBlID0gMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRoaXMuc3JpZCA9PT0gJ3VuZGVmaW5lZCcgJiYgKCFwYXJlbnRPcHRpb25zIHx8IHR5cGVvZiBwYXJlbnRPcHRpb25zLnNyaWQgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1ogJiYgdGhpcy5oYXNNKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25UeXBlICs9IDMwMDA7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25UeXBlICs9IDEwMDA7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25UeXBlICs9IDIwMDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25UeXBlIHw9IDB4ODAwMDAwMDA7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICAgICAgZGltZW5zaW9uVHlwZSB8PSAweDQwMDAwMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKChkaW1lbnNpb25UeXBlICsgZ2VvbWV0cnlUeXBlKSA+Pj4gMCwgdHJ1ZSk7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uID0gZnVuY3Rpb24gKHh5UHJlY2lzaW9uLCB6UHJlY2lzaW9uLCBtUHJlY2lzaW9uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHh5OiB4eVByZWNpc2lvbixcclxuICAgICAgICB6OiB6UHJlY2lzaW9uLFxyXG4gICAgICAgIG06IG1QcmVjaXNpb24sXHJcbiAgICAgICAgeHlGYWN0b3I6IE1hdGgucG93KDEwLCB4eVByZWNpc2lvbiksXHJcbiAgICAgICAgekZhY3RvcjogTWF0aC5wb3coMTAsIHpQcmVjaXNpb24pLFxyXG4gICAgICAgIG1GYWN0b3I6IE1hdGgucG93KDEwLCBtUHJlY2lzaW9uKVxyXG4gICAgfTtcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS5fd3JpdGVUd2tiSGVhZGVyID0gZnVuY3Rpb24gKHR3a2IsIGdlb21ldHJ5VHlwZSwgcHJlY2lzaW9uLCBpc0VtcHR5KSB7XHJcbiAgICB2YXIgdHlwZSA9IChaaWdaYWcuZW5jb2RlKHByZWNpc2lvbi54eSkgPDwgNCkgKyBnZW9tZXRyeVR5cGU7XHJcbiAgICB2YXIgbWV0YWRhdGFIZWFkZXIgPSAodGhpcy5oYXNaIHx8IHRoaXMuaGFzTSkgPDwgMztcclxuICAgIG1ldGFkYXRhSGVhZGVyICs9IGlzRW1wdHkgPDwgNDtcclxuXHJcbiAgICB0d2tiLndyaXRlVUludDgodHlwZSk7XHJcbiAgICB0d2tiLndyaXRlVUludDgobWV0YWRhdGFIZWFkZXIpO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1ogfHwgdGhpcy5oYXNNKSB7XHJcbiAgICAgICAgdmFyIGV4dGVuZGVkUHJlY2lzaW9uID0gMDtcclxuICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICBleHRlbmRlZFByZWNpc2lvbiB8PSAweDE7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICAgICAgZXh0ZW5kZWRQcmVjaXNpb24gfD0gMHgyO1xyXG5cclxuICAgICAgICB0d2tiLndyaXRlVUludDgoZXh0ZW5kZWRQcmVjaXNpb24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IHt9O1xyXG5cclxuICAgIGlmICh0aGlzLnNyaWQpIHtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG9ydENycykge1xyXG4gICAgICAgICAgICAgICAgZ2VvSlNPTi5jcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25hbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0VQU0c6JyArIHRoaXMuc3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5sb25nQ3JzKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9KU09OLmNycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OicgKyB0aGlzLnNyaWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEdlb21ldHJ5Q29sbGVjdGlvbjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIGlmICh0aGlzLmdlb21ldHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMuZ2VvbWV0cmllc1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMuZ2VvbWV0cmllc1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKEdlb21ldHJ5Q29sbGVjdGlvbiwgR2VvbWV0cnkpO1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLlogPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgc3JpZCkge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgc3JpZCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLk0gPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgc3JpZCkge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgc3JpZCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLlpNID0gZnVuY3Rpb24gKGdlb21ldHJpZXMsIHNyaWQpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHNyaWQpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSB0cnVlO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMucHVzaChHZW9tZXRyeS5wYXJzZSh2YWx1ZSkpO1xyXG4gICAgfSB3aGlsZSAodmFsdWUuaXNNYXRjaChbJywnXSkpO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5Q291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeUNvdW50OyBpKyspXHJcbiAgICAgICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMucHVzaChHZW9tZXRyeS5wYXJzZSh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeUNvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnlDb3VudDsgaSsrKVxyXG4gICAgICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLnB1c2goR2VvbWV0cnkucGFyc2VUd2tiKHZhbHVlKSk7XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5wdXNoKEdlb21ldHJ5Ll9wYXJzZUdlb0pTT04odmFsdWUuZ2VvbWV0cmllc1tpXSwgdHJ1ZSkpO1xyXG5cclxuICAgIGlmIChnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggPiAwKVxyXG4gICAgICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXNbMF0uaGFzWjtcclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmdlb21ldHJpZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5HZW9tZXRyeUNvbGxlY3Rpb24sIHRydWUpO1xyXG5cclxuICAgIHZhciB3a3QgPSB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5HZW9tZXRyeUNvbGxlY3Rpb24sIGZhbHNlKSArICcoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a3QgKz0gdGhpcy5nZW9tZXRyaWVzW2ldLnRvV2t0KCkgKyAnLCc7XHJcblxyXG4gICAgd2t0ID0gd2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIHdrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIHdrdDtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLkdlb21ldHJ5Q29sbGVjdGlvbik7XHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a2Iud3JpdGVCdWZmZXIodGhpcy5nZW9tZXRyaWVzW2ldLnRvV2tiKHsgc3JpZDogdGhpcy5zcmlkIH0pKTtcclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLmdlb21ldHJpZXMubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuR2VvbWV0cnlDb2xsZWN0aW9uLCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLmdlb21ldHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB0d2tiLndyaXRlQnVmZmVyKHRoaXMuZ2VvbWV0cmllc1tpXS50b1R3a2IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzaXplID0gMSArIDQgKyA0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHNpemUgKz0gdGhpcy5nZW9tZXRyaWVzW2ldLl9nZXRXa2JTaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uR2VvbWV0cnlDb2xsZWN0aW9uO1xyXG4gICAgZ2VvSlNPTi5nZW9tZXRyaWVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZ2VvSlNPTi5nZW9tZXRyaWVzLnB1c2godGhpcy5nZW9tZXRyaWVzW2ldLnRvR2VvSlNPTigpKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBMaW5lU3RyaW5nO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIExpbmVTdHJpbmcocG9pbnRzLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLnBvaW50c1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMucG9pbnRzWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoTGluZVN0cmluZywgR2VvbWV0cnkpO1xyXG5cclxuTGluZVN0cmluZy5aID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhwb2ludHMsIHNyaWQpO1xyXG4gICAgbGluZVN0cmluZy5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5NID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhwb2ludHMsIHNyaWQpO1xyXG4gICAgbGluZVN0cmluZy5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5aTSA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcocG9pbnRzLCBzcmlkKTtcclxuICAgIGxpbmVTdHJpbmcuaGFzWiA9IHRydWU7XHJcbiAgICBsaW5lU3RyaW5nLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLl9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZygpO1xyXG4gICAgbGluZVN0cmluZy5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgbGluZVN0cmluZy5wb2ludHMucHVzaC5hcHBseShsaW5lU3RyaW5nLnBvaW50cywgdmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoKTtcclxuICAgIGxpbmVTdHJpbmcuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIGxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgcG9pbnRDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkrKylcclxuICAgICAgICBsaW5lU3RyaW5nLnBvaW50cy5wdXNoKFBvaW50Ll9yZWFkV2tiUG9pbnQodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZygpO1xyXG4gICAgbGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgb3B0aW9ucy5oYXNaID8gMCA6IHVuZGVmaW5lZCwgb3B0aW9ucy5oYXNNID8gMCA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgcG9pbnRDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkrKylcclxuICAgICAgICBsaW5lU3RyaW5nLnBvaW50cy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLl9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoKTtcclxuXHJcbiAgICBpZiAodmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoID4gMClcclxuICAgICAgICBsaW5lU3RyaW5nLmhhc1ogPSB2YWx1ZS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgbGluZVN0cmluZy5wb2ludHMucHVzaChQb2ludC5fcmVhZEdlb0pTT05Qb2ludCh2YWx1ZS5jb29yZGluYXRlc1tpXSkpO1xyXG5cclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5MaW5lU3RyaW5nLCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTGluZVN0cmluZywgZmFsc2UpICsgdGhpcy5fdG9Jbm5lcldrdCgpO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUuX3RvSW5uZXJXa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaW5uZXJXa3QgPSAnKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBpbm5lcldrdCArPSB0aGlzLl9nZXRXa3RDb29yZGluYXRlKHRoaXMucG9pbnRzW2ldKSArICcsJztcclxuXHJcbiAgICBpbm5lcldrdCA9IGlubmVyV2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIGlubmVyV2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gaW5uZXJXa3Q7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uIChwYXJlbnRPcHRpb25zKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLkxpbmVTdHJpbmcsIHBhcmVudE9wdGlvbnMpO1xyXG4gICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5wb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHRoaXMucG9pbnRzW2ldLl93cml0ZVdrYlBvaW50KHdrYik7XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLkxpbmVTdHJpbmcsIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMucG9pbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVTaXplID0gMTY7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG5cclxuICAgIHJldHVybiAxICsgNCArIDQgKyAodGhpcy5wb2ludHMubGVuZ3RoICogY29vcmRpbmF0ZVNpemUpO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5MaW5lU3RyaW5nO1xyXG4gICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2goW3RoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnksIHRoaXMucG9pbnRzW2ldLnpdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaChbdGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IE11bHRpTGluZVN0cmluZztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIExpbmVTdHJpbmcgPSByZXF1aXJlKCcuL2xpbmVzdHJpbmcnKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5saW5lU3RyaW5ncyA9IGxpbmVTdHJpbmdzIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMubGluZVN0cmluZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMubGluZVN0cmluZ3NbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLmxpbmVTdHJpbmdzWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoTXVsdGlMaW5lU3RyaW5nLCBHZW9tZXRyeSk7XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuWiA9IGZ1bmN0aW9uIChsaW5lU3RyaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHNyaWQpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5NID0gZnVuY3Rpb24gKGxpbmVTdHJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgc3JpZCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLlpNID0gZnVuY3Rpb24gKGxpbmVTdHJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgc3JpZCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IHRydWU7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5nLmxpbmVTdHJpbmdzLnB1c2gobmV3IExpbmVTdHJpbmcodmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSkpO1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcbiAgICB9IHdoaWxlICh2YWx1ZS5pc01hdGNoKFsnLCddKSk7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgbGluZVN0cmluZ0NvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVN0cmluZ0NvdW50OyBpKyspXHJcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5nLmxpbmVTdHJpbmdzLnB1c2goR2VvbWV0cnkucGFyc2UodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxuXHJcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCBvcHRpb25zLmhhc1ogPyAwIDogdW5kZWZpbmVkLCBvcHRpb25zLmhhc00gPyAwIDogdW5kZWZpbmVkKTtcclxuICAgIHZhciBsaW5lU3RyaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU3RyaW5nQ291bnQ7IGkrKykge1xyXG4gICAgICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoKTtcclxuICAgICAgICBsaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICAgICAgbGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludENvdW50OyBqKyspXHJcbiAgICAgICAgICAgIGxpbmVTdHJpbmcucG9pbnRzLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5nLmxpbmVTdHJpbmdzLnB1c2gobGluZVN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZygpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGggPiAwICYmIHZhbHVlLmNvb3JkaW5hdGVzWzBdLmxlbmd0aCA+IDApXHJcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSB2YWx1ZS5jb29yZGluYXRlc1swXVswXS5sZW5ndGggPiAyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5nLmxpbmVTdHJpbmdzLnB1c2goTGluZVN0cmluZy5fcGFyc2VHZW9KU09OKHsgY29vcmRpbmF0ZXM6IHZhbHVlLmNvb3JkaW5hdGVzW2ldIH0pKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlMaW5lU3RyaW5nLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgd2t0ID0gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlMaW5lU3RyaW5nLCBmYWxzZSkgKyAnKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrdCArPSB0aGlzLmxpbmVTdHJpbmdzW2ldLl90b0lubmVyV2t0KCkgKyAnLCc7XHJcblxyXG4gICAgd2t0ID0gd2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIHdrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIHdrdDtcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLk11bHRpTGluZVN0cmluZyk7XHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrYi53cml0ZUJ1ZmZlcih0aGlzLmxpbmVTdHJpbmdzW2ldLnRvV2tiKHsgc3JpZDogdGhpcy5zcmlkIH0pKTtcclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLk11bHRpTGluZVN0cmluZywgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5saW5lU3RyaW5ncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lU3RyaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMubGluZVN0cmluZ3NbaV0ucG9pbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubGluZVN0cmluZ3NbaV0ucG9pbnRzLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RyaW5nc1tpXS5wb2ludHNbal0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2l6ZSA9IDEgKyA0ICsgNDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgc2l6ZSArPSB0aGlzLmxpbmVTdHJpbmdzW2ldLl9nZXRXa2JTaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uTXVsdGlMaW5lU3RyaW5nO1xyXG4gICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lU3RyaW5ncy5sZW5ndGg7IGkrKylcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2godGhpcy5saW5lU3RyaW5nc1tpXS50b0dlb0pTT04oKS5jb29yZGluYXRlcyk7XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gTXVsdGlQb2ludDtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBNdWx0aVBvaW50KHBvaW50cywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cdFxyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLnBvaW50c1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMucG9pbnRzWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoTXVsdGlQb2ludCwgR2VvbWV0cnkpO1xyXG5cclxuTXVsdGlQb2ludC5aID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludChwb2ludHMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2ludC5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5NID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludChwb2ludHMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2ludC5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5aTSA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQocG9pbnRzLCBzcmlkKTtcclxuICAgIG11bHRpUG9pbnQuaGFzWiA9IHRydWU7XHJcbiAgICBtdWx0aVBvaW50Lmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50Ll9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludCgpO1xyXG4gICAgbXVsdGlQb2ludC5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlQb2ludC5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2ludC5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgbXVsdGlQb2ludC5wb2ludHMucHVzaC5hcHBseShtdWx0aVBvaW50LnBvaW50cywgdmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQoKTtcclxuICAgIG11bHRpUG9pbnQuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpUG9pbnQuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9pbnQuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgcG9pbnRDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkrKylcclxuICAgICAgICBtdWx0aVBvaW50LnBvaW50cy5wdXNoKEdlb21ldHJ5LnBhcnNlKHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50Ll9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQoKTtcclxuICAgIG11bHRpUG9pbnQuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9pbnQuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG5cclxuICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIG9wdGlvbnMuaGFzWiA/IDAgOiB1bmRlZmluZWQsIG9wdGlvbnMuaGFzTSA/IDAgOiB1bmRlZmluZWQpO1xyXG4gICAgdmFyIHBvaW50Q291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspXHJcbiAgICAgICAgbXVsdGlQb2ludC5wb2ludHMucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KCk7XHJcblxyXG4gICAgaWYgKHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgbXVsdGlQb2ludC5oYXNaID0gdmFsdWUuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIG11bHRpUG9pbnQucG9pbnRzLnB1c2goUG9pbnQuX3BhcnNlR2VvSlNPTih7IGNvb3JkaW5hdGVzOiB2YWx1ZS5jb29yZGluYXRlc1tpXSB9KSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpUG9pbnQsIHRydWUpO1xyXG5cclxuICAgIHZhciB3a3QgPSB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aVBvaW50LCBmYWxzZSkgKyAnKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a3QgKz0gdGhpcy5fZ2V0V2t0Q29vcmRpbmF0ZSh0aGlzLnBvaW50c1tpXSkgKyAnLCc7XHJcblxyXG4gICAgd2t0ID0gd2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIHdrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIHdrdDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5NdWx0aVBvaW50KTtcclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMucG9pbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a2Iud3JpdGVCdWZmZXIodGhpcy5wb2ludHNbaV0udG9Xa2IoeyBzcmlkOiB0aGlzLnNyaWQgfSkpO1xyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLnBvaW50cy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5NdWx0aVBvaW50LCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLnBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLnBvaW50c1tpXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb29yZGluYXRlU2l6ZSA9IDE2O1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuXHJcbiAgICBjb29yZGluYXRlU2l6ZSArPSA1O1xyXG5cclxuICAgIHJldHVybiAxICsgNCArIDQgKyAodGhpcy5wb2ludHMubGVuZ3RoICogY29vcmRpbmF0ZVNpemUpO1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5NdWx0aVBvaW50O1xyXG4gICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKHRoaXMucG9pbnRzW2ldLnRvR2VvSlNPTigpLmNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aVBvbHlnb247XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9wb2x5Z29uJyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlQb2x5Z29uKHBvbHlnb25zLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucG9seWdvbnMgPSBwb2x5Z29ucyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIGlmICh0aGlzLnBvbHlnb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLnBvbHlnb25zWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5wb2x5Z29uc1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKE11bHRpUG9seWdvbiwgR2VvbWV0cnkpO1xyXG5cclxuTXVsdGlQb2x5Z29uLlogPSBmdW5jdGlvbiAocG9seWdvbnMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25zLCBzcmlkKTtcclxuICAgIG11bHRpUG9seWdvbi5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uTSA9IGZ1bmN0aW9uIChwb2x5Z29ucywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5aTSA9IGZ1bmN0aW9uIChwb2x5Z29ucywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc1ogPSB0cnVlO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKCk7XHJcbiAgICBtdWx0aVBvbHlnb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpUG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgICAgICB2YXIgZXh0ZXJpb3JSaW5nID0gW107XHJcbiAgICAgICAgdmFyIGludGVyaW9yUmluZ3MgPSBbXTtcclxuXHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgICAgIGV4dGVyaW9yUmluZy5wdXNoLmFwcGx5KGV4dGVyaW9yUmluZywgdmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHZhbHVlLmlzTWF0Y2goWycsJ10pKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgICAgICAgICAgaW50ZXJpb3JSaW5ncy5wdXNoKHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgICAgICAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbXVsdGlQb2x5Z29uLnBvbHlnb25zLnB1c2gobmV3IFBvbHlnb24oZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzKSk7XHJcblxyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgfSB3aGlsZSAodmFsdWUuaXNNYXRjaChbJywnXSkpO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKCk7XHJcbiAgICBtdWx0aVBvbHlnb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpUG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIHBvbHlnb25Db3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25Db3VudDsgaSsrKVxyXG4gICAgICAgIG11bHRpUG9seWdvbi5wb2x5Z29ucy5wdXNoKEdlb21ldHJ5LnBhcnNlKHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbigpO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgb3B0aW9ucy5oYXNaID8gMCA6IHVuZGVmaW5lZCwgb3B0aW9ucy5oYXNNID8gMCA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgcG9seWdvbkNvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbkNvdW50OyBpKyspIHtcclxuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICAgICAgcG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgICAgIHBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICAgICAgdmFyIHJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuICAgICAgICB2YXIgZXh0ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXh0ZXJpb3JSaW5nQ291bnQ7IGorKylcclxuICAgICAgICAgICAgcG9seWdvbi5leHRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgcmluZ0NvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGludGVyaW9yUmluZyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbnRlcmlvclJpbmdDb3VudDsgaysrKVxyXG4gICAgICAgICAgICAgICAgaW50ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICAgICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5ncy5wdXNoKGludGVyaW9yUmluZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtdWx0aVBvbHlnb24ucG9seWdvbnMucHVzaChwb2x5Z29uKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLl9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKCk7XHJcblxyXG4gICAgaWYgKHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDAgJiYgdmFsdWUuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMCAmJiB2YWx1ZS5jb29yZGluYXRlc1swXVswXS5sZW5ndGggPiAwKVxyXG4gICAgICAgIG11bHRpUG9seWdvbi5oYXNaID0gdmFsdWUuY29vcmRpbmF0ZXNbMF1bMF1bMF0ubGVuZ3RoID4gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIG11bHRpUG9seWdvbi5wb2x5Z29ucy5wdXNoKFBvbHlnb24uX3BhcnNlR2VvSlNPTih7IGNvb3JkaW5hdGVzOiB2YWx1ZS5jb29yZGluYXRlc1tpXSB9KSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5wb2x5Z29ucy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpUG9seWdvbiwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHdrdCA9IHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpUG9seWdvbiwgZmFsc2UpICsgJygnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2x5Z29ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a3QgKz0gdGhpcy5wb2x5Z29uc1tpXS5fdG9Jbm5lcldrdCgpICsgJywnO1xyXG5cclxuICAgIHdrdCA9IHdrdC5zbGljZSgwLCAtMSk7XHJcbiAgICB3a3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiB3a3Q7XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24ucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5NdWx0aVBvbHlnb24pO1xyXG4gICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5wb2x5Z29ucy5sZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2x5Z29ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a2Iud3JpdGVCdWZmZXIodGhpcy5wb2x5Z29uc1tpXS50b1drYih7IHNyaWQ6IHRoaXMuc3JpZCB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24ucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5wb2x5Z29ucy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5NdWx0aVBvbHlnb24sIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMucG9seWdvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5wb2x5Z29ucy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHdrYi53cml0ZVZhckludCgxICsgdGhpcy5wb2x5Z29uc1tpXS5pbnRlcmlvclJpbmdzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMucG9seWdvbnNbaV0uZXh0ZXJpb3JSaW5nLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMucG9seWdvbnNbaV0uZXh0ZXJpb3JSaW5nLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uc1tpXS5leHRlcmlvclJpbmdbal0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5wb2x5Z29uc1tpXS5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMucG9seWdvbnNbaV0uaW50ZXJpb3JSaW5nc1tqXS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5wb2x5Z29uc1tpXS5pbnRlcmlvclJpbmdzW2pdLmxlbmd0aDsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbnNbaV0uaW50ZXJpb3JSaW5nc1tqXVtrXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24ucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNpemUgPSAxICsgNCArIDQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvbHlnb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHNpemUgKz0gdGhpcy5wb2x5Z29uc1tpXS5fZ2V0V2tiU2l6ZSgpO1xyXG5cclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLk11bHRpUG9seWdvbjtcclxuICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKHRoaXMucG9seWdvbnNbaV0udG9HZW9KU09OKCkuY29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcbnZhciBaaWdaYWcgPSByZXF1aXJlKCcuL3ppZ3phZy5qcycpO1xyXG5cclxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgeiwgbSwgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMueiA9IHo7XHJcbiAgICB0aGlzLm0gPSBtO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgdGhpcy5oYXNaID0gdHlwZW9mIHRoaXMueiAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB0aGlzLmhhc00gPSB0eXBlb2YgdGhpcy5tICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhQb2ludCwgR2VvbWV0cnkpO1xyXG5cclxuUG9pbnQuWiA9IGZ1bmN0aW9uICh4LCB5LCB6LCBzcmlkKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSwgeiwgdW5kZWZpbmVkLCBzcmlkKTtcclxuICAgIHBvaW50Lmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuTSA9IGZ1bmN0aW9uICh4LCB5LCBtLCBzcmlkKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSwgdW5kZWZpbmVkLCBtLCBzcmlkKTtcclxuICAgIHBvaW50Lmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuWk0gPSBmdW5jdGlvbiAoeCwgeSwgeiwgbSwgc3JpZCkge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHksIHosIG0sIHNyaWQpO1xyXG4gICAgcG9pbnQuaGFzWiA9IHRydWU7XHJcbiAgICBwb2ludC5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50Ll9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KCk7XHJcbiAgICBwb2ludC5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgcG9pbnQuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIHBvaW50Lmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gcG9pbnQ7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgIHZhciBjb29yZGluYXRlID0gdmFsdWUubWF0Y2hDb29yZGluYXRlKG9wdGlvbnMpO1xyXG5cclxuICAgIHBvaW50LnggPSBjb29yZGluYXRlLng7XHJcbiAgICBwb2ludC55ID0gY29vcmRpbmF0ZS55O1xyXG4gICAgcG9pbnQueiA9IGNvb3JkaW5hdGUuejtcclxuICAgIHBvaW50Lm0gPSBjb29yZGluYXRlLm07XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2ludCA9IFBvaW50Ll9yZWFkV2tiUG9pbnQodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgcG9pbnQuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50Ll9yZWFkV2tiUG9pbnQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQodmFsdWUucmVhZERvdWJsZSgpLCB2YWx1ZS5yZWFkRG91YmxlKCksXHJcbiAgICAgICAgb3B0aW9ucy5oYXNaID8gdmFsdWUucmVhZERvdWJsZSgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIG9wdGlvbnMuaGFzTSA/IHZhbHVlLnJlYWREb3VibGUoKSA6IHVuZGVmaW5lZCk7XHJcbn07XHJcblxyXG5Qb2ludC5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoKTtcclxuICAgIHBvaW50Lmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBwb2ludC5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG5cclxuICAgIHBvaW50LnggPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnByZWNpc2lvbkZhY3RvcjtcclxuICAgIHBvaW50LnkgPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnByZWNpc2lvbkZhY3RvcjtcclxuICAgIHBvaW50LnogPSBvcHRpb25zLmhhc1ogPyBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnpQcmVjaXNpb25GYWN0b3IgOiB1bmRlZmluZWQ7XHJcbiAgICBwb2ludC5tID0gb3B0aW9ucy5oYXNNID8gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5tUHJlY2lzaW9uRmFjdG9yIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50Ll9yZWFkVHdrYlBvaW50ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSB7XHJcbiAgICBwcmV2aW91c1BvaW50LnggKz0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5wcmVjaXNpb25GYWN0b3I7XHJcbiAgICBwcmV2aW91c1BvaW50LnkgKz0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5wcmVjaXNpb25GYWN0b3I7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzWilcclxuICAgICAgICBwcmV2aW91c1BvaW50LnogKz0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy56UHJlY2lzaW9uRmFjdG9yO1xyXG4gICAgaWYgKG9wdGlvbnMuaGFzTSlcclxuICAgICAgICBwcmV2aW91c1BvaW50Lm0gKz0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5tUHJlY2lzaW9uRmFjdG9yO1xyXG5cclxuICAgIHJldHVybiBuZXcgUG9pbnQocHJldmlvdXNQb2ludC54LCBwcmV2aW91c1BvaW50LnksIHByZXZpb3VzUG9pbnQueiwgcHJldmlvdXNQb2ludC5tKTtcclxufTtcclxuXHJcblBvaW50Ll9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBQb2ludC5fcmVhZEdlb0pTT05Qb2ludCh2YWx1ZS5jb29yZGluYXRlcyk7XHJcbn07XHJcblxyXG5Qb2ludC5fcmVhZEdlb0pTT05Qb2ludCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xyXG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCk7XHJcblxyXG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0sIGNvb3JkaW5hdGVzWzJdKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFBvaW50KGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMueSA9PT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgdGhpcy56ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5tID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuUG9pbnQsIHRydWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5Qb2ludCwgZmFsc2UpICsgJygnICsgdGhpcy5fZ2V0V2t0Q29vcmRpbmF0ZSh0aGlzKSArICcpJztcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uIChwYXJlbnRPcHRpb25zKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuUG9pbnQsIHBhcmVudE9wdGlvbnMpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy54ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy55ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHdrYi53cml0ZURvdWJsZUxFKE5hTik7XHJcbiAgICAgICAgd2tiLndyaXRlRG91YmxlTEUoTmFOKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgd2tiLndyaXRlRG91YmxlTEUoTmFOKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgICAgICB3a2Iud3JpdGVEb3VibGVMRShOYU4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXa2JQb2ludCh3a2IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLl93cml0ZVdrYlBvaW50ID0gZnVuY3Rpb24gKHdrYikge1xyXG4gICAgd2tiLndyaXRlRG91YmxlTEUodGhpcy54KTtcclxuICAgIHdrYi53cml0ZURvdWJsZUxFKHRoaXMueSk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICB3a2Iud3JpdGVEb3VibGVMRSh0aGlzLnopO1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICB3a2Iud3JpdGVEb3VibGVMRSh0aGlzLm0pO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMueSA9PT0gJ3VuZGVmaW5lZCc7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5Qb2ludCwgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAoIWlzRW1wdHkpXHJcbiAgICAgICAgdGhpcy5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBuZXcgUG9pbnQoMCwgMCwgMCwgMCkpO1xyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5fd3JpdGVUd2tiUG9pbnQgPSBmdW5jdGlvbiAodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KSB7XHJcbiAgICB2YXIgeCA9IHRoaXMueCAqIHByZWNpc2lvbi54eUZhY3RvcjtcclxuICAgIHZhciB5ID0gdGhpcy55ICogcHJlY2lzaW9uLnh5RmFjdG9yO1xyXG4gICAgdmFyIHogPSB0aGlzLnogKiBwcmVjaXNpb24uekZhY3RvcjtcclxuICAgIHZhciBtID0gdGhpcy5tICogcHJlY2lzaW9uLm1GYWN0b3I7XHJcblxyXG4gICAgdHdrYi53cml0ZVZhckludChaaWdaYWcuZW5jb2RlKHggLSBwcmV2aW91c1BvaW50LngpKTtcclxuICAgIHR3a2Iud3JpdGVWYXJJbnQoWmlnWmFnLmVuY29kZSh5IC0gcHJldmlvdXNQb2ludC55KSk7XHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQoWmlnWmFnLmVuY29kZSh6IC0gcHJldmlvdXNQb2ludC56KSk7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQoWmlnWmFnLmVuY29kZShtIC0gcHJldmlvdXNQb2ludC5tKSk7XHJcblxyXG4gICAgcHJldmlvdXNQb2ludC54ID0geDtcclxuICAgIHByZXZpb3VzUG9pbnQueSA9IHk7XHJcbiAgICBwcmV2aW91c1BvaW50LnogPSB6O1xyXG4gICAgcHJldmlvdXNQb2ludC5tID0gbTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzaXplID0gMSArIDQgKyA4ICsgODtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIHNpemUgKz0gODtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgc2l6ZSArPSA4O1xyXG5cclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uUG9pbnQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnogIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFt0aGlzLngsIHRoaXMueV07XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBQb2x5Z29uKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IGV4dGVyaW9yUmluZyB8fCBbXTtcclxuICAgIHRoaXMuaW50ZXJpb3JSaW5ncyA9IGludGVyaW9yUmluZ3MgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMuZXh0ZXJpb3JSaW5nWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5leHRlcmlvclJpbmdbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhQb2x5Z29uLCBHZW9tZXRyeSk7XHJcblxyXG5Qb2x5Z29uLlogPSBmdW5jdGlvbiAoZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCk7XHJcbiAgICBwb2x5Z29uLmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLk0gPSBmdW5jdGlvbiAoZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCk7XHJcbiAgICBwb2x5Z29uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLlpNID0gZnVuY3Rpb24gKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbihleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpO1xyXG4gICAgcG9seWdvbi5oYXNaID0gdHJ1ZTtcclxuICAgIHBvbHlnb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICBwb2x5Z29uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBwb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBwb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgcG9seWdvbi5leHRlcmlvclJpbmcucHVzaC5hcHBseShwb2x5Z29uLmV4dGVyaW9yUmluZywgdmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHdoaWxlICh2YWx1ZS5pc01hdGNoKFsnLCddKSkge1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3MucHVzaCh2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLl9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbigpO1xyXG4gICAgcG9seWdvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgcG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgcG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciByaW5nQ291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgaWYgKHJpbmdDb3VudCA+IDApIHtcclxuICAgICAgICB2YXIgZXh0ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZXJpb3JSaW5nQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgcG9seWdvbi5leHRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFdrYlBvaW50KHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByaW5nQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJpb3JSaW5nID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGludGVyaW9yUmluZ0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICBpbnRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFdrYlBvaW50KHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3MucHVzaChpbnRlcmlvclJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbigpO1xyXG4gICAgcG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgcG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgb3B0aW9ucy5oYXNaID8gMCA6IHVuZGVmaW5lZCwgb3B0aW9ucy5oYXNNID8gMCA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgcmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG4gICAgdmFyIGV4dGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZXJpb3JSaW5nQ291bnQ7IGkrKylcclxuICAgICAgICBwb2x5Z29uLmV4dGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgZm9yIChpID0gMTsgaSA8IHJpbmdDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGludGVyaW9yUmluZyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW50ZXJpb3JSaW5nQ291bnQ7IGorKylcclxuICAgICAgICAgICAgaW50ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzLnB1c2goaW50ZXJpb3JSaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbigpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGggPiAwICYmIHZhbHVlLmNvb3JkaW5hdGVzWzBdLmxlbmd0aCA+IDApXHJcbiAgICAgICAgcG9seWdvbi5oYXNaID0gdmFsdWUuY29vcmRpbmF0ZXNbMF1bMF0ubGVuZ3RoID4gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPiAwKVxyXG4gICAgICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3MucHVzaChbXSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqICA8IHZhbHVlLmNvb3JkaW5hdGVzW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5leHRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZEdlb0pTT05Qb2ludCh2YWx1ZS5jb29yZGluYXRlc1tpXVtqXSkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3NbaSAtIDFdLnB1c2goUG9pbnQuX3JlYWRHZW9KU09OUG9pbnQodmFsdWUuY29vcmRpbmF0ZXNbaV1bal0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LlBvbHlnb24sIHRydWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5Qb2x5Z29uLCBmYWxzZSkgKyB0aGlzLl90b0lubmVyV2t0KCk7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS5fdG9Jbm5lcldrdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbm5lcldrdCA9ICcoKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICBpbm5lcldrdCArPSB0aGlzLl9nZXRXa3RDb29yZGluYXRlKHRoaXMuZXh0ZXJpb3JSaW5nW2ldKSArICcsJztcclxuXHJcbiAgICBpbm5lcldrdCA9IGlubmVyV2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIGlubmVyV2t0ICs9ICcpJztcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaW5uZXJXa3QgKz0gJywoJztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaW5uZXJXa3QgKz0gdGhpcy5fZ2V0V2t0Q29vcmRpbmF0ZSh0aGlzLmludGVyaW9yUmluZ3NbaV1bal0pICsgJywnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5uZXJXa3QgPSBpbm5lcldrdC5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgaW5uZXJXa3QgKz0gJyknO1xyXG4gICAgfVxyXG5cclxuICAgIGlubmVyV2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gaW5uZXJXa3Q7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uIChwYXJlbnRPcHRpb25zKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLlBvbHlnb24sIHBhcmVudE9wdGlvbnMpO1xyXG5cclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgd2tiLndyaXRlVUludDMyTEUoMSArIHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGgpO1xyXG4gICAgICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3a2Iud3JpdGVVSW50MzJMRSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHRoaXMuZXh0ZXJpb3JSaW5nW2ldLl93cml0ZVdrYlBvaW50KHdrYik7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmlvclJpbmdzW2ldW2pdLl93cml0ZVdrYlBvaW50KHdrYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLlBvbHlnb24sIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KDEgKyB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLmV4dGVyaW9yUmluZ1tpXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyaW9yUmluZ3NbaV1bal0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVTaXplID0gMTY7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG5cclxuICAgIHZhciBzaXplID0gMSArIDQgKyA0O1xyXG5cclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPiAwKVxyXG4gICAgICAgIHNpemUgKz0gNCArICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggKiBjb29yZGluYXRlU2l6ZSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgc2l6ZSArPSA0ICsgKHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGggKiBjb29yZGluYXRlU2l6ZSk7XHJcblxyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLlBvbHlnb247XHJcbiAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgZXh0ZXJpb3JSaW5nID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRlcmlvclJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgICAgIGV4dGVyaW9yUmluZy5wdXNoKFt0aGlzLmV4dGVyaW9yUmluZ1tpXS54LCB0aGlzLmV4dGVyaW9yUmluZ1tpXS55LCB0aGlzLmV4dGVyaW9yUmluZ1tpXS56XSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGV4dGVyaW9yUmluZy5wdXNoKFt0aGlzLmV4dGVyaW9yUmluZ1tpXS54LCB0aGlzLmV4dGVyaW9yUmluZ1tpXS55XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2goZXh0ZXJpb3JSaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBpbnRlcmlvclJpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmludGVyaW9yUmluZ3Nbal0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgICAgIGludGVyaW9yUmluZy5wdXNoKFt0aGlzLmludGVyaW9yUmluZ3Nbal1ba10ueCwgdGhpcy5pbnRlcmlvclJpbmdzW2pdW2tdLnksIHRoaXMuaW50ZXJpb3JSaW5nc1tqXVtrXS56XSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGludGVyaW9yUmluZy5wdXNoKFt0aGlzLmludGVyaW9yUmluZ3Nbal1ba10ueCwgdGhpcy5pbnRlcmlvclJpbmdzW2pdW2tdLnldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaChpbnRlcmlvclJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHdrdDoge1xyXG4gICAgICAgIFBvaW50OiAnUE9JTlQnLFxyXG4gICAgICAgIExpbmVTdHJpbmc6ICdMSU5FU1RSSU5HJyxcclxuICAgICAgICBQb2x5Z29uOiAnUE9MWUdPTicsXHJcbiAgICAgICAgTXVsdGlQb2ludDogJ01VTFRJUE9JTlQnLFxyXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogJ01VTFRJTElORVNUUklORycsXHJcbiAgICAgICAgTXVsdGlQb2x5Z29uOiAnTVVMVElQT0xZR09OJyxcclxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246ICdHRU9NRVRSWUNPTExFQ1RJT04nXHJcbiAgICB9LFxyXG4gICAgd2tiOiB7XHJcbiAgICAgICAgUG9pbnQ6IDEsXHJcbiAgICAgICAgTGluZVN0cmluZzogMixcclxuICAgICAgICBQb2x5Z29uOiAzLFxyXG4gICAgICAgIE11bHRpUG9pbnQ6IDQsXHJcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiA1LFxyXG4gICAgICAgIE11bHRpUG9seWdvbjogNixcclxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246IDdcclxuICAgIH0sXHJcbiAgICBnZW9KU09OOiB7XHJcbiAgICAgICAgUG9pbnQ6ICdQb2ludCcsXHJcbiAgICAgICAgTGluZVN0cmluZzogJ0xpbmVTdHJpbmcnLFxyXG4gICAgICAgIFBvbHlnb246ICdQb2x5Z29uJyxcclxuICAgICAgICBNdWx0aVBvaW50OiAnTXVsdGlQb2ludCcsXHJcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiAnTXVsdGlMaW5lU3RyaW5nJyxcclxuICAgICAgICBNdWx0aVBvbHlnb246ICdNdWx0aVBvbHlnb24nLFxyXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuICAgIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBXa3RQYXJzZXI7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxuXHJcbmZ1bmN0aW9uIFdrdFBhcnNlcih2YWx1ZSkge1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbn1cclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICB0aGlzLnNraXBXaGl0ZXNwYWNlcygpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuc3Vic3RyaW5nKHRoaXMucG9zaXRpb24pLmluZGV4T2YodG9rZW5zW2ldKSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHRva2Vuc1tpXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaFJlZ2V4ID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgdGhpcy5za2lwV2hpdGVzcGFjZXMoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHRoaXMudmFsdWUuc3Vic3RyaW5nKHRoaXMucG9zaXRpb24pLm1hdGNoKHRva2Vuc1tpXSk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUuaXNNYXRjaCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgIHRoaXMuc2tpcFdoaXRlc3BhY2VzKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5wb3NpdGlvbikuaW5kZXhPZih0b2tlbnNbaV0pID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gdG9rZW5zW2ldLmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2hUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHRoaXMubWF0Y2goW1R5cGVzLndrdC5Qb2ludCwgVHlwZXMud2t0LkxpbmVTdHJpbmcsIFR5cGVzLndrdC5Qb2x5Z29uLCBUeXBlcy53a3QuTXVsdGlQb2ludCxcclxuICAgIFR5cGVzLndrdC5NdWx0aUxpbmVTdHJpbmcsIFR5cGVzLndrdC5NdWx0aVBvbHlnb24sIFR5cGVzLndrdC5HZW9tZXRyeUNvbGxlY3Rpb25dKTtcclxuXHJcbiAgICBpZiAoIWdlb21ldHJ5VHlwZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGdlb21ldHJ5IHR5cGUnKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnlUeXBlO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaERpbWVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLm1hdGNoKFsnWk0nLCAnWicsICdNJ10pO1xyXG5cclxuICAgIHN3aXRjaCAoZGltZW5zaW9uKSB7XHJcbiAgICAgICAgY2FzZSAnWk0nOiByZXR1cm4geyBoYXNaOiB0cnVlLCBoYXNNOiB0cnVlIH07XHJcbiAgICAgICAgY2FzZSAnWic6IHJldHVybiB7IGhhc1o6IHRydWUsIGhhc006IGZhbHNlIH07XHJcbiAgICAgICAgY2FzZSAnTSc6IHJldHVybiB7IGhhc1o6IGZhbHNlLCBoYXNNOiB0cnVlIH07XHJcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHsgaGFzWjogZmFsc2UsIGhhc006IGZhbHNlIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLmV4cGVjdEdyb3VwU3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNNYXRjaChbJygnXSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBncm91cCBzdGFydCcpO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5leHBlY3RHcm91cEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5pc01hdGNoKFsnKSddKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGdyb3VwIGVuZCcpO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaENvb3JkaW5hdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIG1hdGNoO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc1ogJiYgb3B0aW9ucy5oYXNNKVxyXG4gICAgICAgIG1hdGNoID0gdGhpcy5tYXRjaFJlZ2V4KFsvXihcXFMqKVxccysoXFxTKilcXHMrKFxcUyopXFxzKyhbXlxccywpXSopL10pO1xyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5oYXNaIHx8IG9wdGlvbnMuaGFzTSlcclxuICAgICAgICBtYXRjaCA9IHRoaXMubWF0Y2hSZWdleChbL14oXFxTKilcXHMrKFxcUyopXFxzKyhbXlxccywpXSopL10pO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIG1hdGNoID0gdGhpcy5tYXRjaFJlZ2V4KFsvXihcXFMqKVxccysoW15cXHMsKV0qKS9dKTtcclxuXHJcbiAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29vcmRpbmF0ZXMnKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNaICYmIG9wdGlvbnMuaGFzTSlcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBhcnNlRmxvYXQobWF0Y2hbMV0pLCBwYXJzZUZsb2F0KG1hdGNoWzJdKSwgcGFyc2VGbG9hdChtYXRjaFszXSksIHBhcnNlRmxvYXQobWF0Y2hbNF0pKTtcclxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaGFzWilcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBhcnNlRmxvYXQobWF0Y2hbMV0pLCBwYXJzZUZsb2F0KG1hdGNoWzJdKSwgcGFyc2VGbG9hdChtYXRjaFszXSkpO1xyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5oYXNNKVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocGFyc2VGbG9hdChtYXRjaFsxXSksIHBhcnNlRmxvYXQobWF0Y2hbMl0pLCB1bmRlZmluZWQsIHBhcnNlRmxvYXQobWF0Y2hbM10pKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBhcnNlRmxvYXQobWF0Y2hbMV0pLCBwYXJzZUZsb2F0KG1hdGNoWzJdKSk7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHZhciBzdGFydHNXaXRoQnJhY2tldCA9IHRoaXMuaXNNYXRjaChbJygnXSk7XHJcblxyXG4gICAgICAgIGNvb3JkaW5hdGVzLnB1c2godGhpcy5tYXRjaENvb3JkaW5hdGUob3B0aW9ucykpO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnRzV2l0aEJyYWNrZXQpXHJcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0R3JvdXBFbmQoKTtcclxuICAgIH0gd2hpbGUgKHRoaXMuaXNNYXRjaChbJywnXSkpO1xyXG5cclxuICAgIHJldHVybiBjb29yZGluYXRlcztcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUuc2tpcFdoaXRlc3BhY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgd2hpbGUgKHRoaXMucG9zaXRpb24gPCB0aGlzLnZhbHVlLmxlbmd0aCAmJiB0aGlzLnZhbHVlW3RoaXMucG9zaXRpb25dID09PSAnICcpXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xyXG59O1xyXG4iLCJleHBvcnRzLlR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG5leHBvcnRzLkdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG5leHBvcnRzLlBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG5leHBvcnRzLkxpbmVTdHJpbmcgPSByZXF1aXJlKCcuL2xpbmVzdHJpbmcnKTtcclxuZXhwb3J0cy5Qb2x5Z29uID0gcmVxdWlyZSgnLi9wb2x5Z29uJyk7XHJcbmV4cG9ydHMuTXVsdGlQb2ludCA9IHJlcXVpcmUoJy4vbXVsdGlwb2ludCcpO1xyXG5leHBvcnRzLk11bHRpTGluZVN0cmluZyA9IHJlcXVpcmUoJy4vbXVsdGlsaW5lc3RyaW5nJyk7XHJcbmV4cG9ydHMuTXVsdGlQb2x5Z29uID0gcmVxdWlyZSgnLi9tdWx0aXBvbHlnb24nKTtcclxuZXhwb3J0cy5HZW9tZXRyeUNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2dlb21ldHJ5Y29sbGVjdGlvbicpOyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIDw8IDEpIF4gKHZhbHVlID4+IDMxKTtcclxuICAgIH0sXHJcbiAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgPj4gMSkgXiAoLSh2YWx1ZSAmIDEpKTtcclxuICAgIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlclwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRlYnVnXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ2xvYlwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibG9kYXNoXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJsb2Rhc2gvX2Jhc2VJc05hdGl2ZVwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibHJ1LWNhY2hlXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtb21lbnRcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dWlkXCIpOzsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGNhY2hlZE1vZHVsZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBjYWNoZWRNb2R1bGUuZXJyb3I7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdHRyeSB7XG5cdFx0dmFyIGV4ZWNPcHRpb25zID0geyBpZDogbW9kdWxlSWQsIG1vZHVsZTogbW9kdWxlLCBmYWN0b3J5OiBfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXSwgcmVxdWlyZTogX193ZWJwYWNrX3JlcXVpcmVfXyB9O1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uaS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHsgaGFuZGxlcihleGVjT3B0aW9ucyk7IH0pO1xuXHRcdG1vZHVsZSA9IGV4ZWNPcHRpb25zLm1vZHVsZTtcblx0XHRleGVjT3B0aW9ucy5mYWN0b3J5LmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGV4ZWNPcHRpb25zLnJlcXVpcmUpO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRtb2R1bGUuZXJyb3IgPSBlO1xuXHRcdHRocm93IGU7XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4vLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fO1xuXG4vLyBleHBvc2UgdGhlIG1vZHVsZSBleGVjdXRpb24gaW50ZXJjZXB0b3Jcbl9fd2VicGFja19yZXF1aXJlX18uaSA9IFtdO1xuXG4iLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCIxYzZhYmIwM2E4ZjRhZmZiNGE2ZFwiKSIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgY3VycmVudE1vZHVsZURhdGEgPSB7fTtcbnZhciBpbnN0YWxsZWRNb2R1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jO1xuXG4vLyBtb2R1bGUgYW5kIHJlcXVpcmUgY3JlYXRpb25cbnZhciBjdXJyZW50Q2hpbGRNb2R1bGU7XG52YXIgY3VycmVudFBhcmVudHMgPSBbXTtcblxuLy8gc3RhdHVzXG52YXIgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzID0gW107XG52YXIgY3VycmVudFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4vLyB3aGlsZSBkb3dubG9hZGluZ1xudmFyIGJsb2NraW5nUHJvbWlzZXM7XG5cbi8vIFRoZSB1cGRhdGUgaW5mb1xudmFyIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzO1xudmFyIHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckQgPSBjdXJyZW50TW9kdWxlRGF0YTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5pLnB1c2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0dmFyIG1vZHVsZSA9IG9wdGlvbnMubW9kdWxlO1xuXHR2YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUob3B0aW9ucy5yZXF1aXJlLCBvcHRpb25zLmlkKTtcblx0bW9kdWxlLmhvdCA9IGNyZWF0ZU1vZHVsZUhvdE9iamVjdChvcHRpb25zLmlkLCBtb2R1bGUpO1xuXHRtb2R1bGUucGFyZW50cyA9IGN1cnJlbnRQYXJlbnRzO1xuXHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0b3B0aW9ucy5yZXF1aXJlID0gcmVxdWlyZTtcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1ySSA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1aXJlKHJlcXVpcmUsIG1vZHVsZUlkKSB7XG5cdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuXHRpZiAoIW1lKSByZXR1cm4gcmVxdWlyZTtcblx0dmFyIGZuID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRpZiAobWUuaG90LmFjdGl2ZSkge1xuXHRcdFx0aWYgKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0pIHtcblx0XHRcdFx0dmFyIHBhcmVudHMgPSBpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHM7XG5cdFx0XHRcdGlmIChwYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuXHRcdFx0XHRcdHBhcmVudHMucHVzaChtb2R1bGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcblx0XHRcdFx0Y3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcblx0XHRcdH1cblx0XHRcdGlmIChtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpID09PSAtMSkge1xuXHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICtcblx0XHRcdFx0XHRyZXF1ZXN0ICtcblx0XHRcdFx0XHRcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgK1xuXHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHQpO1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVpcmUocmVxdWVzdCk7XG5cdH07XG5cdHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiByZXF1aXJlW25hbWVdO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJlcXVpcmVbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRmb3IgKHZhciBuYW1lIGluIHJlcXVpcmUpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcXVpcmUsIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcihuYW1lKSk7XG5cdFx0fVxuXHR9XG5cdGZuLmUgPSBmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdHJldHVybiB0cmFja0Jsb2NraW5nUHJvbWlzZShyZXF1aXJlLmUoY2h1bmtJZCkpO1xuXHR9O1xuXHRyZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUhvdE9iamVjdChtb2R1bGVJZCwgbWUpIHtcblx0dmFyIGhvdCA9IHtcblx0XHQvLyBwcml2YXRlIHN0dWZmXG5cdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcblx0XHRfYWNjZXB0ZWRFcnJvckhhbmRsZXJzOiB7fSxcblx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuXHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuXHRcdF9zZWxmSW52YWxpZGF0ZWQ6IGZhbHNlLFxuXHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuXHRcdF9tYWluOiBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBtb2R1bGVJZDtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xuXHRcdH0sXG5cblx0XHQvLyBNb2R1bGUgQVBJXG5cdFx0YWN0aXZlOiB0cnVlLFxuXHRcdGFjY2VwdDogZnVuY3Rpb24gKGRlcCwgY2FsbGJhY2ssIGVycm9ySGFuZGxlcikge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBbaV1dID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0aG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwXSA9IGVycm9ySGFuZGxlcjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlY2xpbmU6IGZ1bmN0aW9uIChkZXApIHtcblx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XG5cdFx0XHRlbHNlIGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XG5cdFx0fSxcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fc2VsZkludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdHN3aXRjaCAoY3VycmVudFN0YXR1cykge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c2V0U3RhdHVzKFwicmVhZHlcIik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyZWFkeVwiOlxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0XHRjYXNlIFwiY2hlY2tcIjpcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VcIjpcblx0XHRcdFx0Y2FzZSBcImFwcGx5XCI6XG5cdFx0XHRcdFx0KHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyB8fCBbXSkucHVzaChcblx0XHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBpZ25vcmUgcmVxdWVzdHMgaW4gZXJyb3Igc3RhdGVzXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIE1hbmFnZW1lbnQgQVBJXG5cdFx0Y2hlY2s6IGhvdENoZWNrLFxuXHRcdGFwcGx5OiBob3RBcHBseSxcblx0XHRzdGF0dXM6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRpZiAoIWwpIHJldHVybiBjdXJyZW50U3RhdHVzO1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0dmFyIGlkeCA9IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xuXHRcdFx0aWYgKGlkeCA+PSAwKSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblxuXHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuXHRcdGRhdGE6IGN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuXHR9O1xuXHRjdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG5cdHJldHVybiBob3Q7XG59XG5cbmZ1bmN0aW9uIHNldFN0YXR1cyhuZXdTdGF0dXMpIHtcblx0Y3VycmVudFN0YXR1cyA9IG5ld1N0YXR1cztcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXG5cdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0XHRibG9ja2luZ1Byb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdFx0XHR3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNldFN0YXR1cyhcInJlYWR5XCIpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0YmxvY2tpbmdQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKSB7XG5cdGlmIChibG9ja2luZ1Byb21pc2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZuKCk7XG5cdHZhciBibG9ja2VyID0gYmxvY2tpbmdQcm9taXNlcztcblx0YmxvY2tpbmdQcm9taXNlcyA9IFtdO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoYmxvY2tlcikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5T25VcGRhdGUpIHtcblx0aWYgKGN1cnJlbnRTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG5cdH1cblx0c2V0U3RhdHVzKFwiY2hlY2tcIik7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0oKS50aGVuKGZ1bmN0aW9uICh1cGRhdGUpIHtcblx0XHRpZiAoIXVwZGF0ZSkge1xuXHRcdFx0c2V0U3RhdHVzKGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCkgPyBcInJlYWR5XCIgOiBcImlkbGVcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRzZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuXG5cdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0YmxvY2tpbmdQcm9taXNlcyA9IFtdO1xuXHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXG5cdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMpLnJlZHVjZShmdW5jdGlvbiAoXG5cdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRrZXlcblx0XHRcdCkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckNba2V5XShcblx0XHRcdFx0XHR1cGRhdGUuYyxcblx0XHRcdFx0XHR1cGRhdGUucixcblx0XHRcdFx0XHR1cGRhdGUubSxcblx0XHRcdFx0XHRwcm9taXNlcyxcblx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyxcblx0XHRcdFx0XHR1cGRhdGVkTW9kdWxlc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdFx0XHR9LFxuXHRcdFx0W10pXG5cdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChhcHBseU9uVXBkYXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0U3RhdHVzKFwicmVhZHlcIik7XG5cblx0XHRcdFx0XHRyZXR1cm4gdXBkYXRlZE1vZHVsZXM7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKTtcblxuXHR2YXIgcmVzdWx0cyA9IGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdHJldHVybiBoYW5kbGVyKG9wdGlvbnMpO1xuXHR9KTtcblx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSB1bmRlZmluZWQ7XG5cblx0dmFyIGVycm9ycyA9IHJlc3VsdHNcblx0XHQubWFwKGZ1bmN0aW9uIChyKSB7XG5cdFx0XHRyZXR1cm4gci5lcnJvcjtcblx0XHR9KVxuXHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG5cdFx0c2V0U3RhdHVzKFwiYWJvcnRcIik7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgZXJyb3JzWzBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG5cdHNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG5cblx0cmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRpZiAocmVzdWx0LmRpc3Bvc2UpIHJlc3VsdC5kaXNwb3NlKCk7XG5cdH0pO1xuXG5cdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2Vcblx0c2V0U3RhdHVzKFwiYXBwbHlcIik7XG5cblx0dmFyIGVycm9yO1xuXHR2YXIgcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG5cdH07XG5cblx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuXHRyZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdGlmIChyZXN1bHQuYXBwbHkpIHtcblx0XHRcdHZhciBtb2R1bGVzID0gcmVzdWx0LmFwcGx5KHJlcG9ydEVycm9yKTtcblx0XHRcdGlmIChtb2R1bGVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKG1vZHVsZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxuXHRpZiAoZXJyb3IpIHtcblx0XHRzZXRTdGF0dXMoXCJmYWlsXCIpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcykge1xuXHRcdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGxpc3QpIHtcblx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRpZiAobGlzdC5pbmRleE9mKG1vZHVsZUlkKSA8IDApIGxpc3QucHVzaChtb2R1bGVJZCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH0pO1xuXHR9XG5cblx0c2V0U3RhdHVzKFwiaWRsZVwiKTtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xufVxuXG5mdW5jdGlvbiBhcHBseUludmFsaWRhdGVkTW9kdWxlcygpIHtcblx0aWYgKHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcykge1xuXHRcdGlmICghY3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMpIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGNodW5rc1xuLy8gXCIxXCIgbWVhbnMgXCJsb2FkZWRcIiwgb3RoZXJ3aXNlIG5vdCBsb2FkZWQgeWV0XG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcIm1haW5cIjogMVxufTtcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBubyBjaHVuayBpbnN0YWxsIGZ1bmN0aW9uIG5lZWRlZFxuXG4vLyBubyBjaHVuayBsb2FkaW5nXG5cbi8vIG5vIGV4dGVybmFsIGluc3RhbGwgY2h1bmtcblxuZnVuY3Rpb24gbG9hZFVwZGF0ZUNodW5rKGNodW5rSWQsIHVwZGF0ZWRNb2R1bGVzTGlzdCkge1xuXHR2YXIgdXBkYXRlID0gcmVxdWlyZShcIi4vXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpKTtcblx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gdXBkYXRlLm1vZHVsZXM7XG5cdHZhciBydW50aW1lID0gdXBkYXRlLnJ1bnRpbWU7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gdXBkYXRlZE1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8odXBkYXRlZE1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSB1cGRhdGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHRpZih1cGRhdGVkTW9kdWxlc0xpc3QpIHVwZGF0ZWRNb2R1bGVzTGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgY3VycmVudFVwZGF0ZVJ1bnRpbWUucHVzaChydW50aW1lKTtcbn1cblxudmFyIGN1cnJlbnRVcGRhdGVDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZTtcbnZhciBjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcztcbnZhciBjdXJyZW50VXBkYXRlUnVudGltZTtcbmZ1bmN0aW9uIGFwcGx5SGFuZGxlcihvcHRpb25zKSB7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmYucmVxdWlyZUhtcjtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKHVwZGF0ZU1vZHVsZUlkKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG5cdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cblx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2hhaW46IFtpZF0sXG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuXHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuXHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFtb2R1bGUgfHxcblx0XHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCAmJiAhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkKVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbcGFyZW50SWRdO1xuXHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG5cdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcblx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcblx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRpZDogcGFyZW50SWRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcblx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcblx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuXHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gYltpXTtcblx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcblx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuXHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuXHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG5cdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUobW9kdWxlKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyBtb2R1bGUuaWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcblx0XHQpO1xuXHR9O1xuXG5cdGZvciAodmFyIG1vZHVsZUlkIGluIGN1cnJlbnRVcGRhdGUpIHtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdFx0dmFyIG5ld01vZHVsZUZhY3RvcnkgPSBjdXJyZW50VXBkYXRlW21vZHVsZUlkXTtcblx0XHRcdC8qKiBAdHlwZSB7VE9ET30gKi9cblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAobmV3TW9kdWxlRmFjdG9yeSkge1xuXHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHMobW9kdWxlSWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8qKiBAdHlwZSB7RXJyb3J8ZmFsc2V9ICovXG5cdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcblx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcblx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xuXHRcdFx0aWYgKHJlc3VsdC5jaGFpbikge1xuXHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIGluIFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyZW50SWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vblVuYWNjZXB0ZWQpIG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uQWNjZXB0ZWQpIG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRpc3Bvc2VkKSBvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWJvcnRFcnJvcikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGVycm9yOiBhYm9ydEVycm9yXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9BcHBseSkge1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IG5ld01vZHVsZUZhY3Rvcnk7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG5cdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQoXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSxcblx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb0Rpc3Bvc2UpIHtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjdXJyZW50VXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cblx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBvdXRkYXRlZE1vZHVsZUlkID0gb3V0ZGF0ZWRNb2R1bGVzW2pdO1xuXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0aWYgKFxuXHRcdFx0bW9kdWxlICYmXG5cdFx0XHRtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgJiZcblx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcblx0XHRcdGFwcGxpZWRVcGRhdGVbb3V0ZGF0ZWRNb2R1bGVJZF0gIT09IHdhcm5VbmV4cGVjdGVkUmVxdWlyZSAmJlxuXHRcdFx0Ly8gd2hlbiBjYWxsZWQgaW52YWxpZGF0ZSBzZWxmLWFjY2VwdGluZyBpcyBub3QgcG9zc2libGVcblx0XHRcdCFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWRcblx0XHQpIHtcblx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcblx0XHRcdFx0bW9kdWxlOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRyZXF1aXJlOiBtb2R1bGUuaG90Ll9yZXF1aXJlU2VsZixcblx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSB1bmRlZmluZWQ7XG5cblx0XHRcdHZhciBpZHg7XG5cdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcblx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG5cdFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkaXNwb3NlSGFuZGxlcnNbal0uY2FsbChudWxsLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckRbbW9kdWxlSWRdID0gZGF0YTtcblxuXHRcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuXHRcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuXHRcdFx0XHRkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuXHRcdFx0XHRcdGlmICghY2hpbGQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG5cdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuXHRcdFx0dmFyIGRlcGVuZGVuY3k7XG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0bW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcHBseTogZnVuY3Rpb24gKHJlcG9ydEVycm9yKSB7XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcblx0XHRcdGZvciAodmFyIHVwZGF0ZU1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhhcHBsaWVkVXBkYXRlLCB1cGRhdGVNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bdXBkYXRlTW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVt1cGRhdGVNb2R1bGVJZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcnVuIG5ldyBydW50aW1lIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudFVwZGF0ZVJ1bnRpbWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWVbaV0oX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFjY2VwdENhbGxiYWNrID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlciA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoYWNjZXB0Q2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoYWNjZXB0Q2FsbGJhY2spICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goYWNjZXB0Q2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnMucHVzaChlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcy5wdXNoKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGNhbGxiYWNrcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrc1trXS5jYWxsKG51bGwsIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvckhhbmRsZXJzW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnNba10oZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba11cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgbyA9IDA7IG8gPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBvKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbb107XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGl0ZW0ucmVxdWlyZShtb2R1bGVJZCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH1cblx0fTtcbn1cbl9fd2VicGFja19yZXF1aXJlX18uaG1ySS5yZXF1aXJlID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBhcHBseUhhbmRsZXJzKSB7XG5cdGlmICghY3VycmVudFVwZGF0ZSkge1xuXHRcdGN1cnJlbnRVcGRhdGUgPSB7fTtcblx0XHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gW107XG5cdFx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdH1cblx0aWYgKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdO1xuXHR9XG59O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJDLnJlcXVpcmUgPSBmdW5jdGlvbiAoXG5cdGNodW5rSWRzLFxuXHRyZW1vdmVkQ2h1bmtzLFxuXHRyZW1vdmVkTW9kdWxlcyxcblx0cHJvbWlzZXMsXG5cdGFwcGx5SGFuZGxlcnMsXG5cdHVwZGF0ZWRNb2R1bGVzTGlzdFxuKSB7XG5cdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0ge307XG5cdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gcmVtb3ZlZENodW5rcztcblx0Y3VycmVudFVwZGF0ZSA9IHJlbW92ZWRNb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcblx0XHRvYmpba2V5XSA9IGZhbHNlO1xuXHRcdHJldHVybiBvYmo7XG5cdH0sIHt9KTtcblx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0Y2h1bmtJZHMuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdGlmIChcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mLnJlcXVpcmVIbXIgPSBmdW5jdGlvbiAoY2h1bmtJZCwgcHJvbWlzZXMpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rcyAmJlxuXHRcdFx0XHQhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGVDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0XHQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkpO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHJlcXVpcmUoXCIuL1wiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGKCkpO1xuXHR9KS5jYXRjaChmdW5jdGlvbihlcnIpIHsgaWYoZXJyLmNvZGUgIT09IFwiTU9EVUxFX05PVF9GT1VORFwiKSB0aHJvdyBlcnI7IH0pO1xufSIsIi8vIG1vZHVsZSBjYWNoZSBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvcG9sbC5qcz8xMDAwXCIpO1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvc2VydmVyLnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==